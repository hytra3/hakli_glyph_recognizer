<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Symbol Recognizer</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // OpenCV ready flag and callback - must be defined before OpenCV loads
        let isOpenCvReady = false;
        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('✅ OpenCV.js is ready');
        }
    </script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        .detection-box {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
        .canvas-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }
        .draggable-item {
            transition: transform 0.2s ease;
        }
        .draggable-item.dragging {
            transform: scale(1.05);
            z-index: 1000;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        function HakliSymbolRecognizer() {
            // State management
            const [image, setImage] = useState(null);
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [chartLoadStatus, setChartLoadStatus] = useState('not-loaded');
            const [loadedSymbolImages, setLoadedSymbolImages] = useState({});
            const [manualDetectionMode, setManualDetectionMode] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawStart, setDrawStart] = useState(null);
            const [drawCurrent, setDrawCurrent] = useState(null);
            const [activeDetections, setActiveDetections] = useState(new Set());
            
            // Validation and action recording
            const [validations, setValidations] = useState({});
            const [corrections, setCorrections] = useState({});
            const [actionHistory, setActionHistory] = useState([]);
            const [maxHistorySize] = useState(50);
            
            // Drag and drop state
            const [draggedIndex, setDraggedIndex] = useState(null);
            const [dragOverIndex, setDragOverIndex] = useState(null);

            // Refs
            const imageRef = useRef(null);
            const canvasRef = useRef(null);
            const fileInputRef = useRef(null);
            const imageContainerRef = useRef(null);

            // Action recording system
            const recordAction = useCallback((actionType, actionData) => {
                const action = {
                    type: actionType,
                    data: actionData,
                    timestamp: new Date().toISOString(),
                    id: Date.now()
                };

                setActionHistory(prev => {
                    const newHistory = [...prev, action];
                    return newHistory.slice(-maxHistorySize);
                });

                console.log('Action recorded:', action);
            }, [maxHistorySize]);

            // Enhanced undo system
            const undoLastAction = useCallback(() => {
                if (actionHistory.length === 0) return;

                const lastAction = actionHistory[actionHistory.length - 1];
                console.log('Undoing action:', lastAction);

                switch (lastAction.type) {
                    case 'delete_detection':
                        setRecognitionResults(prev => {
                            const newResults = [...prev];
                            newResults.splice(lastAction.data.index, 0, lastAction.data.detection);
                            return newResults;
                        });
                        break;
                    case 'manual_detection':
                        setRecognitionResults(prev => prev.filter((_, index) => index !== lastAction.data.detectionIndex));
                        break;
                    case 'correction':
                        setRecognitionResults(prev => prev.map((result, index) => {
                            if (index === lastAction.data.detectionIndex) {
                                return lastAction.data.originalDetection;
                            }
                            return result;
                        }));
                        setCorrections(prev => {
                            const newCorrections = { ...prev };
                            delete newCorrections[lastAction.data.detectionIndex];
                            return newCorrections;
                        });
                        break;
                    case 'validation':
                        setValidations(prev => {
                            const newValidations = { ...prev };
                            delete newValidations[lastAction.data.detectionIndex];
                            return newValidations;
                        });
                        break;
                    case 'reorder':
                        setRecognitionResults(prev => {
                            const newResults = [...prev];
                            const [item] = newResults.splice(lastAction.data.newIndex, 1);
                            newResults.splice(lastAction.data.originalIndex, 0, item);
                            return newResults;
                        });
                        break;
                }

                setActionHistory(prev => prev.slice(0, -1));
            }, [actionHistory]);

            // Validation and correction functions
            const validateDetection = useCallback((detectionIndex, isCorrect) => {
                recordAction('validation', {
                    detectionIndex: detectionIndex,
                    isCorrect: isCorrect,
                    detectionData: recognitionResults[detectionIndex]
                });

                setValidations(prev => ({
                    ...prev,
                    [detectionIndex]: {
                        isCorrect: isCorrect,
                        timestamp: new Date().toISOString(),
                        detectionData: recognitionResults[detectionIndex]
                    }
                }));
                
                console.log(`Detection ${detectionIndex + 1} marked as ${isCorrect ? 'correct' : 'incorrect'}`);
            }, [recognitionResults, recordAction]);

            const correctDetection = useCallback((detectionIndex, newSymbolId) => {
                const originalDetection = recognitionResults[detectionIndex];
                const newSymbol = equivalenceChart.symbols.find(s => s.id === newSymbolId);
                
                if (!newSymbol) return;

                recordAction('correction', {
                    detectionIndex: detectionIndex,
                    originalDetection: originalDetection,
                    newSymbol: newSymbol
                });

                setRecognitionResults(prev => prev.map((result, index) => {
                    if (index === detectionIndex) {
                        return {
                            ...result,
                            symbol: newSymbol,
                            confidence: 1.0,
                            matchType: 'manual_correction'
                        };
                    }
                    return result;
                }));

                setCorrections(prev => ({
                    ...prev,
                    [detectionIndex]: {
                        originalSymbol: originalDetection.symbol,
                        newSymbol: newSymbol,
                        timestamp: new Date().toISOString()
                    }
                }));

                console.log(`Detection ${detectionIndex + 1} corrected to ${newSymbol.name}`);
            }, [recognitionResults, equivalenceChart, recordAction]);

            const deleteDetection = useCallback((detectionIndex) => {
                recordAction('delete_detection', {
                    index: detectionIndex,
                    detection: recognitionResults[detectionIndex]
                });

                setRecognitionResults(prev => {
                    const newResults = [...prev];
                    newResults.splice(detectionIndex, 1);
                    return newResults;
                });
            }, [recognitionResults, recordAction]);

            const toggleWordBoundary = useCallback((detectionIndex) => {
                setRecognitionResults(prev => prev.map((result, index) => {
                    if (index === detectionIndex) {
                        return {
                            ...result,
                            wordBoundary: !result.wordBoundary
                        };
                    }
                    return result;
                }));
            }, []);

            // GitHub URL converter
            const convertToGitHubUrl = useCallback((githubUrl) => {
                if (!githubUrl) return null;
                
                // If it's already a full URL, handle accordingly
                if (githubUrl.startsWith('http')) {
                    if (githubUrl.includes('github.com') && githubUrl.includes('/blob/')) {
                        return githubUrl.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                    }
                    return githubUrl;
                }
                
                // If it's a relative path, convert to full GitHub raw URL
                if (typeof githubUrl === 'string' && githubUrl.length > 0) {
                    const baseUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/';
                    // Remove leading slash if present
                    const cleanPath = githubUrl.startsWith('/') ? githubUrl.substring(1) : githubUrl;
                    return baseUrl + cleanPath;
                }
                
                return null;
            }, []);

            // Manual reload chart function for the button
            const reloadChart = useCallback(() => {
                setChartLoadStatus('not-loaded');
            }, []);

            // Auto-load chart on component mount
            useEffect(() => {
                if (chartLoadStatus === 'not-loaded') {
                    const loadChartFromGitHub = async () => {
                        console.log('🔄 Starting to load chart from GitHub...');
                        setChartLoadStatus('loading');
                        
                        const githubJsonUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/Hakli_symbols.JSON';
                        
                        try {
                            console.log('📡 Fetching JSON from:', githubJsonUrl);
                            const response = await fetch(githubJsonUrl);
                            
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            
                            const chartData = await response.json();
                            
                            console.log('✅ Chart loaded successfully:', {
                                totalSymbols: chartData.symbols?.length || 0,
                                categories: chartData.categories?.length || 0
                            });
                            
                            setEquivalenceChart(chartData);
                            
                            // Load symbol images directly here
                            console.log('🖼️ Loading symbol images...');
                            console.log('📋 Chart structure:', {
                                totalSymbols: chartData.symbols?.length,
                                firstSymbol: chartData.symbols?.[0],
                                symbolKeys: chartData.symbols?.[0] ? Object.keys(chartData.symbols[0]) : 'No symbols'
                            });
                            
                            const imageCache = {};
                            let successCount = 0;
                            let failCount = 0;
                            let skipCount = 0;
                            
                            for (const symbol of chartData.symbols) {
                                console.log(`🔍 Processing symbol: ${symbol.name}`, {
                                    id: symbol.id,
                                    hasImages: !!symbol.images,
                                    hasPrimary: !!symbol.images?.primary,
                                    primary: symbol.images?.primary,
                                    hasVariants: !!symbol.images?.variants?.length,
                                    variants: symbol.images?.variants,
                                    hasExamples: !!symbol.images?.examples?.length,
                                    examples: symbol.images?.examples
                                });

                                try {
                                    // Load primary image
                                    if (symbol.images?.primary) {
                                        const fullUrl = convertToGitHubUrl(symbol.images.primary);
                                        console.log(`Trying to load primary image for ${symbol.name}:`, fullUrl);
                                        if (fullUrl && fullUrl !== symbol.images.primary) {
                                            try {
                                                const img = new Image();
                                                img.crossOrigin = 'anonymous';
                                                await new Promise((resolve, reject) => {
                                                    const timeout = setTimeout(() => {
                                                        reject(new Error('Image load timeout'));
                                                    }, 10000);
                                                    
                                                    img.onload = () => {
                                                        clearTimeout(timeout);
                                                        imageCache[symbol.id] = img;
                                                        successCount++;
                                                        console.log(`✅ Loaded primary image for ${symbol.name}`);
                                                        resolve();
                                                    };
                                                    img.onerror = (e) => {
                                                        clearTimeout(timeout);
                                                        failCount++;
                                                        console.warn(`❌ Failed to load primary image for ${symbol.name}:`, e);
                                                        reject(e);
                                                    };
                                                    img.src = fullUrl;
                                                });
                                            } catch (e) {
                                                console.warn(`Failed to load primary image for ${symbol.name}:`, e);
                                                failCount++;
                                            }
                                        } else {
                                            console.log(`⏭️ Skipping primary image for ${symbol.name} - invalid URL`);
                                            skipCount++;
                                        }
                                    } else {
                                        console.log(`⏭️ No primary image for ${symbol.name}`);
                                        skipCount++;
                                    }

                                    // Load variant images
                                    if (symbol.images?.variants && Array.isArray(symbol.images.variants)) {
                                        for (let i = 0; i < symbol.images.variants.length; i++) {
                                            try {
                                                const fullUrl = convertToGitHubUrl(symbol.images.variants[i]);
                                                console.log(`Trying to load variant ${i} for ${symbol.name}:`, fullUrl);
                                                if (fullUrl && fullUrl !== symbol.images.variants[i]) {
                                                    const img = new Image();
                                                    img.crossOrigin = 'anonymous';
                                                    await new Promise((resolve, reject) => {
                                                        const timeout = setTimeout(() => {
                                                            reject(new Error('Image load timeout'));
                                                        }, 10000);
                                                        
                                                        img.onload = () => {
                                                            clearTimeout(timeout);
                                                            imageCache[`${symbol.id}_variant_${i}`] = img;
                                                            successCount++;
                                                            console.log(`✅ Loaded variant ${i} for ${symbol.name}`);
                                                            resolve();
                                                        };
                                                        img.onerror = (e) => {
                                                            clearTimeout(timeout);
                                                            failCount++;
                                                            console.warn(`❌ Failed to load variant ${i} for ${symbol.name}:`, e);
                                                            reject(e);
                                                        };
                                                        img.src = fullUrl;
                                                    });
                                                } else {
                                                    console.log(`⏭️ Skipping variant ${i} for ${symbol.name} - invalid URL`);
                                                    skipCount++;
                                                }
                                            } catch (e) {
                                                console.warn(`Failed to load variant ${i} for ${symbol.name}:`, e);
                                                failCount++;
                                            }
                                        }
                                    }

                                    // Load example images
                                    if (symbol.images?.examples && Array.isArray(symbol.images.examples)) {
                                        for (let i = 0; i < symbol.images.examples.length; i++) {
                                            try {
                                                const fullUrl = convertToGitHubUrl(symbol.images.examples[i]);
                                                console.log(`Trying to load example ${i} for ${symbol.name}:`, fullUrl);
                                                if (fullUrl && fullUrl !== symbol.images.examples[i]) {
                                                    const img = new Image();
                                                    img.crossOrigin = 'anonymous';
                                                    await new Promise((resolve, reject) => {
                                                        const timeout = setTimeout(() => {
                                                            reject(new Error('Image load timeout'));
                                                        }, 10000);
                                                        
                                                        img.onload = () => {
                                                            clearTimeout(timeout);
                                                            imageCache[`${symbol.id}_example_${i}`] = img;
                                                            successCount++;
                                                            console.log(`✅ Loaded example ${i} for ${symbol.name}`);
                                                            resolve();
                                                        };
                                                        img.onerror = (e) => {
                                                            clearTimeout(timeout);
                                                            failCount++;
                                                            console.warn(`❌ Failed to load example ${i} for ${symbol.name}:`, e);
                                                            reject(e);
                                                        };
                                                        img.src = fullUrl;
                                                    });
                                                } else {
                                                    console.log(`⏭️ Skipping example ${i} for ${symbol.name} - invalid URL`);
                                                    skipCount++;
                                                }
                                            } catch (e) {
                                                console.warn(`Failed to load example ${i} for ${symbol.name}:`, e);
                                                failCount++;
                                            }
                                        }
                                    }
                                } catch (error) {
                                    console.warn(`Error processing images for symbol ${symbol.name}:`, error);
                                    failCount++;
                                }
                            }
                            
                            console.log(`🖼️ Image loading complete: ${successCount} successful, ${failCount} failed, ${skipCount} skipped`);
                            setLoadedSymbolImages(imageCache);
                            
                            setChartLoadStatus('loaded');
                            
                        } catch (error) {
                            console.error('❌ Error loading chart from GitHub:', error);
                            setChartLoadStatus('error');
                        }
                    };
                    
                    loadChartFromGitHub();
                }
            }, [chartLoadStatus, convertToGitHubUrl]);

            // File upload handler
            const handleFileUpload = useCallback((event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setImage(e.target.result);
                        setRecognitionResults([]);
                        setValidations({});
                        setCorrections({});
                        setActionHistory([]);
                    };
                    reader.readAsDataURL(file);
                }
            }, []);

            // Symbol isolation using OpenCV contour detection
            const isolateSymbols = useCallback((inputImage) => {
                if (!isOpenCvReady) {
                    console.error('OpenCV is not ready for symbol isolation');
                    return [];
                }

                try {
                    const src = cv.imread(inputImage);
                    const gray = new cv.Mat();
                    const binary = new cv.Mat();
                    const morphKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
                    const processed = new cv.Mat();

                    // Convert to grayscale
                    if (src.channels() > 1) {
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    } else {
                        gray = src.clone();
                    }

                    // Apply adaptive thresholding
                    cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

                    // Apply morphological operations to clean up
                    cv.morphologyEx(binary, processed, cv.MORPH_CLOSE, morphKernel);

                    // Find contours
                    const contours = new cv.MatVector();
                    const hierarchy = new cv.Mat();
                    cv.findContours(processed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    const isolatedRegions = [];
                    const minArea = 100;  // Minimum area for a symbol
                    const maxArea = 10000;  // Maximum area for a symbol
                    const minAspectRatio = 0.2;  // Minimum width/height ratio
                    const maxAspectRatio = 5.0;  // Maximum width/height ratio

                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const boundingRect = cv.boundingRect(contour);
                        const area = boundingRect.width * boundingRect.height;
                        const aspectRatio = boundingRect.width / boundingRect.height;

                        // Filter by size and aspect ratio
                        if (area >= minArea && area <= maxArea && 
                            aspectRatio >= minAspectRatio && aspectRatio <= maxAspectRatio) {
                            
                            // Add some padding around the detected region
                            const padding = 5;
                            const paddedRect = {
                                x: Math.max(0, boundingRect.x - padding),
                                y: Math.max(0, boundingRect.y - padding),
                                width: Math.min(src.cols - boundingRect.x + padding, boundingRect.width + 2 * padding),
                                height: Math.min(src.rows - boundingRect.y + padding, boundingRect.height + 2 * padding)
                            };

                            isolatedRegions.push({
                                bounds: paddedRect,
                                area: area,
                                aspectRatio: aspectRatio
                            });
                        }
                    }

                    // Sort regions left-to-right for proper reading order
                    isolatedRegions.sort((a, b) => a.bounds.x - b.bounds.x);

                    // Cleanup
                    src.delete();
                    gray.delete();
                    binary.delete();
                    morphKernel.delete();
                    processed.delete();
                    contours.delete();
                    hierarchy.delete();

                    console.log(`🔍 Symbol isolation found ${isolatedRegions.length} potential symbol regions`);
                    return isolatedRegions;

                } catch (error) {
                    console.error('Symbol isolation error:', error);
                    return [];
                }
            }, []);

            // State for isolated symbols and selection
            const [isolatedSymbols, setIsolatedSymbols] = useState([]);
            const [selectedRegions, setSelectedRegions] = useState(new Set());
            const [showRegionBoundaries, setShowRegionBoundaries] = useState(true);
            // Region management functions
            const toggleRegionSelection = useCallback((regionIndex) => {
                setSelectedRegions(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(regionIndex)) {
                        newSet.delete(regionIndex);
                    } else {
                        newSet.add(regionIndex);
                    }
                    return newSet;
                });
            }, []);

            const mergeSelectedRegions = useCallback(() => {
                if (selectedRegions.size < 2) {
                    console.log('Need at least 2 regions selected to merge');
                    return;
                }

                const selectedIndices = Array.from(selectedRegions).sort((a, b) => a - b);
                const regionsToMerge = selectedIndices.map(i => isolatedSymbols[i]);

                // Calculate bounding box that encompasses all selected regions
                const minX = Math.min(...regionsToMerge.map(r => r.bounds.x));
                const minY = Math.min(...regionsToMerge.map(r => r.bounds.y));
                const maxX = Math.max(...regionsToMerge.map(r => r.bounds.x + r.bounds.width));
                const maxY = Math.max(...regionsToMerge.map(r => r.bounds.y + r.bounds.height));

                const mergedRegion = {
                    bounds: {
                        x: minX,
                        y: minY,
                        width: maxX - minX,
                        height: maxY - minY
                    },
                    area: (maxX - minX) * (maxY - minY),
                    aspectRatio: (maxX - minX) / (maxY - minY),
                    merged: true,
                    originalRegions: selectedIndices.length
                };

                // Create new array with merged region
                const newIsolatedSymbols = [];
                let mergedAdded = false;

                for (let i = 0; i < isolatedSymbols.length; i++) {
                    if (selectedRegions.has(i)) {
                        // Add merged region only once (at first selected index position)
                        if (!mergedAdded) {
                            newIsolatedSymbols.push(mergedRegion);
                            mergedAdded = true;
                        }
                        // Skip other selected regions
                    } else {
                        newIsolatedSymbols.push(isolatedSymbols[i]);
                    }
                }

                setIsolatedSymbols(newIsolatedSymbols);
                setSelectedRegions(new Set()); // Clear selection
                console.log(`Merged ${selectedIndices.length} regions into one`);
            }, [selectedRegions, isolatedSymbols]);

            const deleteSelectedRegions = useCallback(() => {
                if (selectedRegions.size === 0) {
                    console.log('No regions selected to delete');
                    return;
                }

                const newIsolatedSymbols = isolatedSymbols.filter((_, index) => !selectedRegions.has(index));
                setIsolatedSymbols(newIsolatedSymbols);
                setSelectedRegions(new Set()); // Clear selection
                console.log(`Deleted ${selectedRegions.size} regions`);
            }, [selectedRegions, isolatedSymbols]);

            const clearRegionSelection = useCallback(() => {
                setSelectedRegions(new Set());
            }, []);
                if (!isOpenCvReady) {
                    console.error('OpenCV is not ready');
                    return [];
                }

                try {
                    const src = cv.imread(inputImage);
                    const templ = cv.imread(templateImage);
                    const dst = new cv.Mat();

                    cv.matchTemplate(src, templ, dst, cv.TM_CCOEFF_NORMED);

                    const result = cv.minMaxLoc(dst);
                    const matches = [];

                    if (result.maxVal >= threshold) {
                        // Original template match position
                        const originalMatch = {
                            confidence: result.maxVal,
                            position: {
                                x: result.maxLoc.x,
                                y: result.maxLoc.y,
                                width: templ.cols,
                                height: templ.rows
                            }
                        };

                        // Try to refine the bounding box by finding the actual content bounds
                        try {
                            // Extract the matched region
                            const matchedRegion = src.roi(new cv.Rect(
                                result.maxLoc.x, 
                                result.maxLoc.y, 
                                templ.cols, 
                                templ.rows
                            ));

                            // Convert to grayscale if needed
                            let gray = new cv.Mat();
                            if (matchedRegion.channels() > 1) {
                                cv.cvtColor(matchedRegion, gray, cv.COLOR_RGBA2GRAY);
                            } else {
                                gray = matchedRegion.clone();
                            }

                            // Apply threshold to find the actual content
                            let binary = new cv.Mat();
                            cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

                            // Find contours to get tight bounds
                            let contours = new cv.MatVector();
                            let hierarchy = new cv.Mat();
                            cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                            if (contours.size() > 0) {
                                // Find the bounding rect of all contours
                                let allPoints = [];
                                for (let i = 0; i < contours.size(); i++) {
                                    const contour = contours.get(i);
                                    for (let j = 0; j < contour.data32S.length; j += 2) {
                                        allPoints.push({
                                            x: contour.data32S[j],
                                            y: contour.data32S[j + 1]
                                        });
                                    }
                                }

                                if (allPoints.length > 0) {
                                    const minX = Math.min(...allPoints.map(p => p.x));
                                    const maxX = Math.max(...allPoints.map(p => p.x));
                                    const minY = Math.min(...allPoints.map(p => p.y));
                                    const maxY = Math.max(...allPoints.map(p => p.y));

                                    const contentWidth = maxX - minX;
                                    const contentHeight = maxY - minY;

                                    // Only use refined bounds if they're reasonable (not too small)
                                    if (contentWidth > 10 && contentHeight > 10 && 
                                        contentWidth < templ.cols && contentHeight < templ.rows) {
                                        
                                        const padding = 5; // Small padding around content
                                        matches.push({
                                            confidence: result.maxVal,
                                            position: {
                                                x: result.maxLoc.x + Math.max(0, minX - padding),
                                                y: result.maxLoc.y + Math.max(0, minY - padding),
                                                width: Math.min(templ.cols, contentWidth + padding * 2),
                                                height: Math.min(templ.rows, contentHeight + padding * 2)
                                            }
                                        });
                                    } else {
                                        // Fall back to original bounds if refinement doesn't look good
                                        matches.push(originalMatch);
                                    }
                                } else {
                                    matches.push(originalMatch);
                                }
                            } else {
                                matches.push(originalMatch);
                            }

                            // Clean up
                            matchedRegion.delete();
                            gray.delete();
                            binary.delete();
                            contours.delete();
                            hierarchy.delete();

                        } catch (refinementError) {
                            console.warn('Could not refine bounding box, using original:', refinementError);
                            matches.push(originalMatch);
                        }
                    }

                    src.delete();
                    templ.delete();
                    dst.delete();

                    return matches;
                } catch (error) {
                    console.error('Template matching error:', error);
                    return [];
                }
            }, []);

            // Recognition function with symbol isolation
            const recognizeSymbols = useCallback(async () => {
                if (!image || !equivalenceChart || !isOpenCvReady) {
                    console.log('Missing requirements:', { 
                        hasImage: !!image, 
                        hasChart: !!equivalenceChart,
                        openCvReady: isOpenCvReady 
                    });
                    return;
                }

                setIsProcessing(true);
                setRecognitionResults([]);

                try {
                    // Create temporary image element for OpenCV
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        // Step 1: Isolate symbols first
                        console.log('🔍 Starting symbol isolation...');
                        const isolated = isolateSymbols(tempImg);
                        setIsolatedSymbols(isolated);

                        if (isolated.length === 0) {
                            console.log('⚠️ No symbol regions found during isolation');
                            setIsProcessing(false);
                            return;
                        }

                        // Step 2: Template match each isolated region
                        const results = [];
                        let totalAttempts = 0;

                        console.log(`🎯 Template matching ${isolated.length} isolated regions against ${equivalenceChart.symbols.length} symbols...`);

                        // Process each isolated region
                        for (let regionIndex = 0; regionIndex < isolated.length; regionIndex++) {
                            const region = isolated[regionIndex];
                            let bestMatch = null;

                            // Try to match this region against all symbols
                            for (const symbol of equivalenceChart.symbols) {
                                // Check primary image
                                if (loadedSymbolImages[symbol.id]) {
                                    totalAttempts++;
                                    const matches = performTemplateMatchingOnRegion(tempImg, loadedSymbolImages[symbol.id], region, 0.6);
                                    
                                    matches.forEach(match => {
                                        if (!bestMatch || match.confidence > bestMatch.confidence) {
                                            bestMatch = {
                                                symbol: symbol,
                                                confidence: match.confidence * 1.0, // Primary image weight
                                                position: region.bounds, // Use isolated region bounds
                                                matchType: 'primary',
                                                regionIndex: regionIndex
                                            };
                                        }
                                    });
                                }

                                // Check variant images
                                if (symbol.images?.variants) {
                                    for (let i = 0; i < symbol.images.variants.length; i++) {
                                        const variantKey = `${symbol.id}_variant_${i}`;
                                        if (loadedSymbolImages[variantKey]) {
                                            totalAttempts++;
                                            const matches = performTemplateMatchingOnRegion(tempImg, loadedSymbolImages[variantKey], region, 0.6);
                                            
                                            matches.forEach(match => {
                                                const weightedConfidence = match.confidence * 0.9; // Variant weight
                                                if (!bestMatch || weightedConfidence > bestMatch.confidence) {
                                                    bestMatch = {
                                                        symbol: symbol,
                                                        confidence: weightedConfidence,
                                                        position: region.bounds,
                                                        matchType: 'variant',
                                                        variantIndex: i,
                                                        regionIndex: regionIndex
                                                    };
                                                }
                                            });
                                        }
                                    }
                                }

                                // Check example images
                                if (symbol.images?.examples) {
                                    for (let i = 0; i < symbol.images.examples.length; i++) {
                                        const exampleKey = `${symbol.id}_example_${i}`;
                                        if (loadedSymbolImages[exampleKey]) {
                                            totalAttempts++;
                                            const matches = performTemplateMatchingOnRegion(tempImg, loadedSymbolImages[exampleKey], region, 0.6);
                                            
                                            matches.forEach(match => {
                                                const weightedConfidence = match.confidence * 0.8; // Example weight
                                                if (!bestMatch || weightedConfidence > bestMatch.confidence) {
                                                    bestMatch = {
                                                        symbol: symbol,
                                                        confidence: weightedConfidence,
                                                        position: region.bounds,
                                                        matchType: 'example',
                                                        exampleIndex: i,
                                                        regionIndex: regionIndex
                                                    };
                                                }
                                            });
                                        }
                                    }
                                }
                            }

                            // Add the best match for this region (if any)
                            if (bestMatch && bestMatch.confidence > 0.5) {
                                results.push(bestMatch);
                            }
                        }

                        console.log(`🎯 Recognition complete: ${results.length} symbols matched from ${isolated.length} isolated regions (${totalAttempts} template matching attempts)`);
                        
                        setRecognitionResults(results);
                        setIsProcessing(false);
                    };

                    tempImg.src = image;

                } catch (error) {
                    console.error('Recognition error:', error);
                    setIsProcessing(false);
                }
            }, [image, equivalenceChart, loadedSymbolImages, isolateSymbols]);

            // Template matching for a specific region
            const performTemplateMatchingOnRegion = useCallback((inputImage, templateImage, region, threshold = 0.7) => {
                if (!isOpenCvReady) return [];

                try {
                    const src = cv.imread(inputImage);
                    
                    // Extract the isolated region
                    const regionMat = src.roi(new cv.Rect(
                        region.bounds.x,
                        region.bounds.y,
                        region.bounds.width,
                        region.bounds.height
                    ));
                    
                    const templ = cv.imread(templateImage);
                    const dst = new cv.Mat();

                    // Only proceed if template is smaller than region
                    if (templ.cols <= regionMat.cols && templ.rows <= regionMat.rows) {
                        cv.matchTemplate(regionMat, templ, dst, cv.TM_CCOEFF_NORMED);
                        const result = cv.minMaxLoc(dst);

                        const matches = [];
                        if (result.maxVal >= threshold) {
                            matches.push({
                                confidence: result.maxVal,
                                position: region.bounds // Use the isolated region bounds
                            });
                        }

                        dst.delete();
                    }

                    src.delete();
                    regionMat.delete();
                    templ.delete();

                    return [];
                } catch (error) {
                    console.error('Region template matching error:', error);
                    return [];
                }
            }, []);

            // Manual detection functions
            const handleCanvasMouseDown = useCallback((event) => {
                if (!manualDetectionMode || !imageRef.current) return;

                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                setIsDrawing(true);
                setDrawStart({ x, y });
                setDrawCurrent({ x, y });

                event.preventDefault();
            }, [manualDetectionMode]);

            const handleCanvasMouseMove = useCallback((event) => {
                if (!isDrawing || !manualDetectionMode) return;

                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                setDrawCurrent({ x, y });
                event.preventDefault();
            }, [isDrawing, manualDetectionMode]);

            const handleCanvasMouseUp = useCallback((event) => {
                if (!isDrawing || !drawStart || !manualDetectionMode) return;

                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const endPoint = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };

                const distance = Math.sqrt(Math.pow(endPoint.x - drawStart.x, 2) + Math.pow(endPoint.y - drawStart.y, 2));
                if (distance > 10) {
                    createManualDetection(drawStart, endPoint);
                } else {
                    console.log('Manual selection too small, ignoring');
                }

                setIsDrawing(false);
                setDrawStart(null);
                setDrawCurrent(null);
                event.preventDefault();
            }, [isDrawing, drawStart, manualDetectionMode]);

            const createManualDetection = useCallback((startPoint, endPoint) => {
                if (!imageRef.current || !equivalenceChart) return;

                const img = imageRef.current;
                const container = imageContainerRef.current;
                const containerRect = container.getBoundingClientRect();
                const imgRect = img.getBoundingClientRect();
                const offsetX = imgRect.left - containerRect.left;
                const offsetY = imgRect.top - containerRect.top;
                const scaleX = img.offsetWidth / img.naturalWidth;
                const scaleY = img.offsetHeight / img.naturalHeight;
                const imageX1 = (startPoint.x - offsetX) / scaleX;
                const imageY1 = (startPoint.y - offsetY) / scaleY;
                const imageX2 = (endPoint.x - offsetX) / scaleX;
                const imageY2 = (endPoint.y - offsetY) / scaleY;
                const x = Math.min(imageX1, imageX2);
                const y = Math.min(imageY1, imageY2);
                const width = Math.abs(imageX2 - imageX1);
                const height = Math.abs(imageY2 - imageY1);

                if (width < 10 || height < 10) {
                    console.log('Manual selection too small, ignoring');
                    return;
                }

                // Simple manual detection - just add with first available symbol for now
                const manualDetection = {
                    symbol: equivalenceChart.symbols[0] || { id: 'manual', name: 'Manual Selection', arabic: 'ا' },
                    confidence: 0.8,
                    position: { x: Math.round(x), y: Math.round(y), width: Math.round(width), height: Math.round(height) },
                    matchType: 'manual',
                    detectionIndex: recognitionResults.length
                };

                recordAction('manual_detection', {
                    detectionIndex: recognitionResults.length,
                    detection: manualDetection
                });

                setRecognitionResults(prev => [...prev, manualDetection]);
                console.log('Manual detection added:', manualDetection);
            }, [equivalenceChart, recognitionResults.length, recordAction]);

            // Drag and drop handlers
            const handleDragStart = useCallback((e, index) => {
                setDraggedIndex(index);
                e.dataTransfer.effectAllowed = 'move';
            }, []);

            const handleDragOver = useCallback((e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                setDragOverIndex(index);
            }, []);

            const handleDragLeave = useCallback(() => {
                setDragOverIndex(null);
            }, []);

            const handleDrop = useCallback((e, dropIndex) => {
                e.preventDefault();
                
                if (draggedIndex === null || draggedIndex === dropIndex) {
                    setDraggedIndex(null);
                    setDragOverIndex(null);
                    return;
                }

                recordAction('reorder', {
                    originalIndex: draggedIndex,
                    newIndex: dropIndex
                });

                setRecognitionResults(prev => {
                    const newResults = [...prev];
                    const [draggedItem] = newResults.splice(draggedIndex, 1);
                    newResults.splice(dropIndex, 0, draggedItem);
                    return newResults;
                });

                setDraggedIndex(null);
                setDragOverIndex(null);
            }, [draggedIndex, recordAction]);

            // Rendering the component
            return (
                <div className="max-w-6xl mx-auto p-6 bg-white">
                    <div className="mb-8">
                        <h1 className="text-3xl font-bold text-gray-900 mb-2">Hakli Symbol Recognizer</h1>
                        <p className="text-gray-600">based on Ahmad Al Jallad (2025) The Decipherment of the Dhofari Script</p>
                    </div>

                    {/* Chart Status */}
                    <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                        <div className="flex items-center justify-between">
                            <div>
                                <h3 className="font-semibold text-gray-900">Equivalence Chart Status</h3>
                                <div className="flex items-center gap-2 mt-1">
                                    {chartLoadStatus === 'loading' && (
                                        <span className="text-blue-600">🔄 Loading chart from GitHub...</span>
                                    )}
                                    {chartLoadStatus === 'loaded' && equivalenceChart && (
                                        <>
                                            <span className="text-green-600">✅ Chart loaded</span>
                                            <span className="text-sm text-gray-500">
                                                ({equivalenceChart.symbols?.length || 0} symbols, {Object.keys(loadedSymbolImages).length} images)
                                            </span>
                                        </>
                                    )}
                                    {chartLoadStatus === 'error' && (
                                        <span className="text-red-600">❌ Error loading chart</span>
                                    )}
                                </div>
                            </div>
                            <button
                                onClick={reloadChart}
                                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                                disabled={chartLoadStatus === 'loading'}
                            >
                                Reload Chart
                            </button>
                        </div>
                    </div>

                    {/* File Upload */}
                    <div className="mb-6">
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept="image/*"
                            onChange={handleFileUpload}
                            className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                        />
                    </div>

                    {/* Action Controls */}
                    {image && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <div className="flex flex-wrap gap-3 items-center">
                                <button
                                    onClick={recognizeSymbols}
                                    disabled={isProcessing || !equivalenceChart}
                                    className="px-6 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                >
                                    {isProcessing ? 'Processing...' : 'Recognize Symbols'}
                                </button>

                                <button
                                    onClick={() => setManualDetectionMode(!manualDetectionMode)}
                                    className={`px-4 py-2 rounded border ${manualDetectionMode 
                                        ? 'bg-orange-500 text-white' 
                                        : 'bg-white text-gray-700 border-gray-300'}`}
                                >
                                    Manual Selection: {manualDetectionMode ? 'ON' : 'OFF'}
                                </button>

                                <button
                                    onClick={undoLastAction}
                                    disabled={actionHistory.length === 0}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                >
                                    Undo ({actionHistory.length})
                                </button>

                                <div className="text-sm text-gray-600">
                                    {recognitionResults.length} detections • {Object.keys(validations).length} validated • {Object.keys(corrections).length} corrected
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Image Display with Detections */}
                    {image && (
                        <div className="mb-6">
                            <div className="canvas-container relative" ref={imageContainerRef}>
                                <img
                                    ref={imageRef}
                                    src={image}
                                    alt="Uploaded inscription"
                                    className="max-w-full h-auto border border-gray-300 rounded"
                                    onLoad={() => console.log('Image loaded for processing')}
                                />
                                <canvas
                                    ref={canvasRef}
                                    className="absolute top-0 left-0 pointer-events-auto"
                                    style={{
                                        width: imageRef.current?.offsetWidth || 0,
                                        height: imageRef.current?.offsetHeight || 0
                                    }}
                                    onMouseDown={handleCanvasMouseDown}
                                    onMouseMove={handleCanvasMouseMove}
                                    onMouseUp={handleCanvasMouseUp}
                                />
                                
                                {/* Region boundary overlays */}
                                {showRegionBoundaries && isolatedSymbols.map((region, idx) => {
                                    if (!imageRef.current) return null;

                                    const img = imageRef.current;
                                    const scaleX = img.offsetWidth / img.naturalWidth;
                                    const scaleY = img.offsetHeight / img.naturalHeight;

                                    const boxStyle = {
                                        left: region.bounds.x * scaleX,
                                        top: region.bounds.y * scaleY,
                                        width: region.bounds.width * scaleX,
                                        height: region.bounds.height * scaleY,
                                    };

                                    let borderColor = 'border-blue-400';
                                    let bgColor = 'bg-blue-100';
                                    
                                    if (selectedRegions.has(idx)) {
                                        borderColor = 'border-orange-500';
                                        bgColor = 'bg-orange-100';
                                    }
                                    
                                    if (region.merged) {
                                        borderColor = 'border-purple-500';
                                        bgColor = 'bg-purple-100';
                                    }

                                    return (
                                        <div
                                            key={`region-${idx}`}
                                            className={`detection-box border-2 ${borderColor} ${bgColor} bg-opacity-20 cursor-pointer hover:bg-opacity-40`}
                                            style={boxStyle}
                                            onClick={() => toggleRegionSelection(idx)}
                                            title={`Region ${idx + 1} - Click to select/deselect`}
                                        >
                                            <div className="absolute -top-6 left-0 text-xs bg-white px-1 rounded shadow border">
                                                R{idx + 1}{region.merged && ` (${region.originalRegions} merged)`}
                                            </div>
                                        </div>
                                    );
                                })}
                                
                                {/* Detection overlays */}
                                {recognitionResults.map((result, idx) => {
                                    if (!imageRef.current) return null;

                                    const img = imageRef.current;
                                    const scaleX = img.offsetWidth / img.naturalWidth;
                                    const scaleY = img.offsetHeight / img.naturalHeight;

                                    const boxStyle = {
                                        left: result.position.x * scaleX,
                                        top: result.position.y * scaleY,
                                        width: result.position.width * scaleX,
                                        height: result.position.height * scaleY,
                                    };

                                    let borderColor = 'border-green-500';
                                    if (result.matchType === 'variant') borderColor = 'border-purple-500 border-dashed';
                                    else if (result.matchType === 'example') borderColor = 'border-blue-500 border-dotted';
                                    else if (result.matchType === 'manual') borderColor = 'border-orange-500';

                                    if (validations[idx]?.isCorrect === false) borderColor = 'border-red-500 border-2';
                                    else if (validations[idx]?.isCorrect === true) borderColor = 'border-green-600 border-2';
                                    if (corrections[idx]) borderColor = 'border-amber-500 border-2';

                                    return (
                                        <div
                                            key={idx}
                                            className={`detection-box border-2 ${borderColor} ${
                                                activeDetections.has(idx) ? 'bg-blue-100 bg-opacity-30' : ''
                                            }`}
                                            style={boxStyle}
                                        >
                                            <div className="absolute -top-6 left-0 text-xs bg-white px-1 rounded shadow">
                                                #{idx + 1}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                                            {/* Region Management Controls */}
                        {isolatedSymbols.length > 0 && (
                            <div className="mb-4 p-3 bg-gray-50 rounded-lg">
                                <div className="flex flex-wrap gap-3 items-center mb-3">
                                    <label className="flex items-center gap-2">
                                        <input
                                            type="checkbox"
                                            checked={showRegionBoundaries}
                                            onChange={(e) => setShowRegionBoundaries(e.target.checked)}
                                            className="rounded"
                                        />
                                        <span className="text-sm">Show Region Boundaries</span>
                                    </label>
                                    
                                    <button
                                        onClick={mergeSelectedRegions}
                                        disabled={selectedRegions.size < 2}
                                        className="px-3 py-1 text-sm bg-purple-500 text-white rounded hover:bg-purple-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        Merge Selected ({selectedRegions.size})
                                    </button>
                                    
                                    <button
                                        onClick={deleteSelectedRegions}
                                        disabled={selectedRegions.size === 0}
                                        className="px-3 py-1 text-sm bg-red-500 text-white rounded hover:bg-red-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        Delete Selected ({selectedRegions.size})
                                    </button>
                                    
                                    <button
                                        onClick={clearRegionSelection}
                                        disabled={selectedRegions.size === 0}
                                        className="px-3 py-1 text-sm bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        Clear Selection
                                    </button>
                                </div>
                                
                                {selectedRegions.size > 0 && (
                                    <div className="text-sm text-gray-600">
                                        Selected regions: {Array.from(selectedRegions).sort((a, b) => a - b).map(i => `R${i + 1}`).join(', ')}
                                    </div>
                                )}
                            </div>
                        )}

                        {/* Isolated Symbols Debug Panel */}
                        {isolatedSymbols.length > 0 && (
                            <div className="space-y-4">
                                <h3 className="text-lg font-medium text-gray-900">
                                    Isolated Symbol Regions ({isolatedSymbols.length})
                                </h3>
                                
                                <div className="p-4 bg-blue-50 rounded-lg">
                                    <p className="text-sm text-gray-700 mb-3">
                                        OpenCV found these potential symbol regions before template matching:
                                    </p>
                                    
                                    <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-2">
                                        {isolatedSymbols.map((region, idx) => (
                                            <div 
                                                key={idx} 
                                                className={`text-center cursor-pointer rounded p-1 ${
                                                    selectedRegions.has(idx) 
                                                        ? 'bg-orange-200 border-2 border-orange-400' 
                                                        : region.merged
                                                            ? 'bg-purple-100 border border-purple-300'
                                                            : 'bg-white border border-gray-300'
                                                }`}
                                                onClick={() => toggleRegionSelection(idx)}
                                                title={`Click to ${selectedRegions.has(idx) ? 'deselect' : 'select'} region ${idx + 1}`}
                                            >
                                                <div className="w-16 h-16 bg-white border border-gray-300 rounded mb-1 flex items-center justify-center">
                                                    {imageRef.current && (() => {
                                                        try {
                                                            const canvas = document.createElement('canvas');
                                                            const ctx = canvas.getContext('2d');
                                                            canvas.width = region.bounds.width;
                                                            canvas.height = region.bounds.height;
                                                            
                                                            ctx.drawImage(
                                                                imageRef.current,
                                                                region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height,
                                                                0, 0, region.bounds.width, region.bounds.height
                                                            );
                                                            
                                                            return (
                                                                <img 
                                                                    src={canvas.toDataURL()} 
                                                                    alt={`Region ${idx + 1}`}
                                                                    className="max-w-full max-h-full object-contain"
                                                                />
                                                            );
                                                        } catch (e) {
                                                            return <span className="text-xs text-gray-400">#{idx + 1}</span>;
                                                        }
                                                    })()}
                                                </div>
                                                <div className="text-xs text-gray-600">
                                                    <div className={`font-medium ${selectedRegions.has(idx) ? 'text-orange-700' : ''}`}>
                                                        #{idx + 1}{region.merged ? ` (${region.originalRegions}M)` : ''}
                                                    </div>
                                                    <div>{region.bounds.width}×{region.bounds.height}</div>
                                                    <div>Area: {region.area}</div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Recognition Results */}
                    {recognitionResults.length > 0 && (
                        <div className="space-y-6">
                            <div className="flex items-center justify-between">
                                <h3 className="text-xl font-semibold text-gray-900">
                                    Recognition Results ({recognitionResults.length})
                                </h3>
                            </div>

                            {/* Active Selection Summary */}
                            {activeDetections.size > 0 && (
                                <div className="p-3 bg-blue-50 border border-blue-200 rounded-lg">
                                    <div className="flex items-center justify-between">
                                        <div>
                                            <span className="font-medium text-blue-800">
                                                Active Selection ({activeDetections.size}):
                                            </span>
                                            <span className="ml-2 text-blue-700">
                                                {Array.from(activeDetections)
                                                    .sort((a, b) => a - b)
                                                    .map(i => recognitionResults[i]?.symbol.name || `#${i+1}`)
                                                    .join(', ')}
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            )}

                            <div className="mb-4 p-3 bg-gray-50 rounded-lg">
                                <h4 className="font-medium text-gray-800 mb-2 text-sm">Visual Legend:</h4>
                                <div className="space-y-2 text-xs">
                                    <div className="flex gap-4">
                                        <div className="flex items-center gap-2">
                                            <div className="w-4 h-3 border-2 border-green-500"></div>
                                            <span>Primary Match</span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <div className="w-4 h-3 border-2 border-purple-500 border-dashed"></div>
                                            <span>Variant Match</span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <div className="w-4 h-3 border-2 border-amber-500"></div>
                                            <span>Combined Symbol</span>
                                        </div>
                                    </div>
                                    <div className="flex gap-4">
                                        <div className="flex items-center gap-2">
                                            <div className="w-4 h-3 border-2 border-blue-500 border-dotted"></div>
                                            <span>Example Match</span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <div className="w-4 h-3 border-2 border-orange-500"></div>
                                            <span>Manual Selection</span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <div className="w-4 h-3 border-2 border-red-500"></div>
                                            <span>Marked Incorrect</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            {/* Individual Matches */}
                            <div className="space-y-3">
                                <h4 className="font-medium text-gray-800">Individual Matches:</h4>
                                
                                {recognitionResults.map((result, idx) => (
                                    <div
                                        key={idx}
                                        className={`draggable-item p-4 border rounded-lg cursor-move ${
                                            draggedIndex === idx ? 'dragging' : ''
                                        } ${dragOverIndex === idx ? 'border-blue-400 bg-blue-50' : 'border-gray-200'} ${
                                            activeDetections.has(idx) ? 'bg-blue-50 border-blue-300' : 'bg-white'
                                        }`}
                                        draggable
                                        onDragStart={(e) => handleDragStart(e, idx)}
                                        onDragOver={(e) => handleDragOver(e, idx)}
                                        onDragLeave={handleDragLeave}
                                        onDrop={(e) => handleDrop(e, idx)}
                                    >
                                        <div className="flex items-start gap-4">
                                            <div className="flex-shrink-0">
                                                <div className="w-12 h-12 bg-gray-100 border rounded flex-shrink-0">
                                                    {(() => {
                                                        if (!imageRef.current) return null;
                                                        const debugCanvas = document.createElement('canvas');
                                                        const debugCtx = debugCanvas.getContext('2d');
                                                        debugCanvas.width = result.position.width;
                                                        debugCanvas.height = result.position.height;
                                                        
                                                        debugCtx.drawImage(
                                                            imageRef.current,
                                                            result.position.x, result.position.y, result.position.width, result.position.height,
                                                            0, 0, result.position.width, result.position.height
                                                        );
                                                        
                                                        const debugDataUrl = debugCanvas.toDataURL();
                                                        return (
                                                            <img 
                                                                src={debugDataUrl} 
                                                                alt="Symbol crop" 
                                                                className="w-full h-full object-contain rounded"
                                                            />
                                                        );
                                                    })()}
                                                </div>
                                            </div>

                                            <div className="flex-grow">
                                                <div className="flex items-center gap-2 mb-2">
                                                    <span className="font-medium text-gray-900">
                                                        #{idx + 1}: {result.symbol.name}
                                                    </span>
                                                    
                                                    <span className="text-2xl">{result.symbol.arabic}</span>
                                                    
                                                    <span className="text-sm text-gray-500">
                                                        ({result.symbol.transliteration})
                                                    </span>
                                                    
                                                    {result.matchType === 'variant' && (
                                                        <span className="text-xs bg-purple-100 text-purple-800 px-2 py-1 rounded">
                                                            Variant {result.variantIndex}
                                                        </span>
                                                    )}
                                                    {result.matchType === 'example' && (
                                                        <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
                                                            Example {result.exampleIndex}
                                                        </span>
                                                    )}
                                                    {result.matchType === 'manual' && (
                                                        <span className="text-xs bg-orange-100 text-orange-800 px-2 py-1 rounded">
                                                            Manual
                                                        </span>
                                                    )}
                                                    {corrections[idx] && (
                                                        <span className="text-xs bg-amber-100 text-amber-800 px-2 py-1 rounded">
                                                            Corrected
                                                        </span>
                                                    )}
                                                </div>

                                                <div className="text-sm text-gray-600 mb-2">
                                                    <div className="flex gap-4">
                                                        <span>Confidence: {(result.confidence * 100).toFixed(1)}%</span>
                                                        <span>Position: ({result.position.x}, {result.position.y})</span>
                                                        <span>Size: {result.position.width} × {result.position.height}</span>
                                                    </div>
                                                </div>

                                                {/* Validation Status */}
                                                {validations[idx] && (
                                                    <div className={`text-sm mb-2 ${
                                                        validations[idx].isCorrect ? 'text-green-600' : 'text-red-600'
                                                    }`}>
                                                        ✓ Marked as {validations[idx].isCorrect ? 'correct' : 'incorrect'}
                                                        <span className="text-gray-500 ml-2">
                                                            {new Date(validations[idx].timestamp).toLocaleTimeString()}
                                                        </span>
                                                    </div>
                                                )}

                                                {/* Action Buttons */}
                                                <div className="flex flex-wrap gap-2">
                                                    <button
                                                        onClick={() => validateDetection(idx, true)}
                                                        className={`px-3 py-1 text-xs rounded ${
                                                            validations[idx]?.isCorrect === true
                                                                ? 'bg-green-600 text-white'
                                                                : 'bg-green-100 text-green-800 hover:bg-green-200'
                                                        }`}
                                                    >
                                                        ✓ Correct
                                                    </button>
                                                    
                                                    <button
                                                        onClick={() => validateDetection(idx, false)}
                                                        className={`px-3 py-1 text-xs rounded ${
                                                            validations[idx]?.isCorrect === false
                                                                ? 'bg-red-600 text-white'
                                                                : 'bg-red-100 text-red-800 hover:bg-red-200'
                                                        }`}
                                                    >
                                                        ✗ Incorrect
                                                    </button>
                                                    
                                                    <button
                                                        onClick={() => toggleWordBoundary(idx)}
                                                        className={`px-3 py-1 text-xs rounded ${
                                                            result.wordBoundary
                                                                ? 'bg-blue-600 text-white'
                                                                : 'bg-gray-100 text-gray-800 hover:bg-gray-200'
                                                        }`}
                                                    >
                                                        Word Boundary
                                                    </button>
                                                    
                                                    <button
                                                        onClick={() => deleteDetection(idx)}
                                                        className="px-3 py-1 text-xs bg-red-100 text-red-800 rounded hover:bg-red-200"
                                                    >
                                                        Delete
                                                    </button>

                                                    {equivalenceChart && (
                                                        <select
                                                            onChange={(e) => correctDetection(idx, e.target.value)}
                                                            value=""
                                                            className="px-2 py-1 text-xs border border-gray-300 rounded"
                                                        >
                                                            <option value="">Correct to...</option>
                                                            {equivalenceChart.symbols.map(symbol => (
                                                                <option key={symbol.id} value={symbol.id}>
                                                                    {symbol.name} ({symbol.arabic})
                                                                </option>
                                                            ))}
                                                        </select>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>

                            {/* Reading Order Display */}
                            {recognitionResults.length > 0 && (
                                <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                                    <h4 className="font-medium text-gray-800 mb-3">Reading Order:</h4>
                                    <div className="flex flex-wrap items-center gap-2">
                                        {recognitionResults.map((result, idx) => (
                                            <React.Fragment key={idx}>
                                                <div
                                                    className={`flex items-center gap-2 px-3 py-2 rounded border ${
                                                        validations[idx]?.isCorrect === false 
                                                            ? 'bg-red-50 border-red-200' 
                                                            : validations[idx]?.isCorrect === true
                                                                ? 'bg-green-50 border-green-200'
                                                                : corrections[idx]
                                                                    ? 'bg-amber-50 border-amber-200'
                                                                    : 'bg-white border-gray-200'
                                                    }`}
                                                >
                                                    <span className="text-xs text-gray-500">#{idx + 1}</span>
                                                    <span className="text-lg">{result.symbol.arabic}</span>
                                                    <span className="text-sm text-gray-600">
                                                        {result.symbol.transliteration}
                                                    </span>
                                                </div>
                                                {result.wordBoundary && idx < recognitionResults.length - 1 && (
                                                    <div className="text-gray-400 font-bold">|</div>
                                                )}
                                            </React.Fragment>
                                        ))}
                                    </div>
                                    
                                    {/* Combined Reading */}
                                    <div className="mt-4 p-3 bg-white rounded border">
                                        <div className="font-medium text-gray-700 mb-2">Combined Reading:</div>
                                        <div className="text-2xl text-right mb-2">
                                            {recognitionResults.map(result => result.symbol.arabic).join('')}
                                        </div>
                                        <div className="text-sm text-gray-600">
                                            {recognitionResults.map(result => result.symbol.transliteration).join('-')}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* Action History */}
                            {actionHistory.length > 0 && (
                                <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                                    <h4 className="font-medium text-gray-800 mb-3">Recent Actions:</h4>
                                    <div className="space-y-1 max-h-32 overflow-y-auto text-sm">
                                        {actionHistory.slice(-10).reverse().map((action, idx) => (
                                            <div key={action.id} className="flex justify-between text-gray-600">
                                                <span>
                                                    {action.type.replace('_', ' ').toUpperCase()}: 
                                                    {action.type === 'validation' && ` Detection ${action.data.detectionIndex + 1} marked ${action.data.isCorrect ? 'correct' : 'incorrect'}`}
                                                    {action.type === 'correction' && ` Detection ${action.data.detectionIndex + 1} corrected to ${action.data.newSymbol.name}`}
                                                    {action.type === 'delete_detection' && ` Detection ${action.data.index + 1} deleted`}
                                                    {action.type === 'manual_detection' && ` Manual detection added`}
                                                    {action.type === 'reorder' && ` Moved detection ${action.data.originalIndex + 1} to position ${action.data.newIndex + 1}`}
                                                </span>
                                                <span className="text-xs">
                                                    {new Date(action.timestamp).toLocaleTimeString()}
                                                </span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {/* OpenCV Status */}
                    <div className="mt-8 p-4 bg-gray-50 rounded-lg">
                        <div className="text-sm text-gray-600">
                            <div className="flex items-center gap-2">
                                <span className={`w-2 h-2 rounded-full ${isOpenCvReady ? 'bg-green-500' : 'bg-red-500'}`}></span>
                                OpenCV Status: {isOpenCvReady ? 'Ready' : 'Loading...'}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<HakliSymbolRecognizer />);
    </script>
</body>
</html>