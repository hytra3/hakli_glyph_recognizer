<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Glyph Recognizer</title>
    <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useCallback, useEffect } = React;

        const Eye = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                <circle cx="12" cy="12" r="3"/>
            </svg>
        );

        const Upload = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                <polyline points="7,10 12,15 17,10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
        );

        const Zap = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"/>
            </svg>
        );

        const Camera = () => (
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M23 19a2 2 0 01-2 2H3a2 2 0 01-2-2V8a2 2 0 012-2h4l2-3h6l2 3h4a2 2 0 012 2z"/>
                <circle cx="12" cy="13" r="4"/>
            </svg>
        );

        const HakliSymbolRecognizer = () => {
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [uploadedImage, setUploadedImage] = useState(null);
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [chartLoadStatus, setChartLoadStatus] = useState('ready');
            const [loadedSymbolImages, setLoadedSymbolImages] = useState({});
            const [isOpenCVReady, setIsOpenCVReady] = useState(false);
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [isolatedSymbolsDebug, setIsolatedSymbolsDebug] = useState([]);
            const [processingSettings, setProcessingSettings] = useState({
                contrastThreshold: 127,
                minSymbolSize: 15,
                maxSymbolSize: 200,
                detectionSensitivity: 0.4,
                variantMatching: true
            });
            
            const canvasRef = useRef(null);
            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);

            // Format inscription with word boundaries
            const formatInscriptionWithBoundaries = (results) => {
                const sortedResults = results.sort((a, b) => a.position.x - b.position.x);
                const parts = [];
                
                sortedResults.forEach((result, index) => {
                    if (index === 0 || wordBoundaries.has(index)) {
                        if (parts.length > 0) parts.push(' | ');
                    }
                    parts.push(result.symbol.name);
                    if (index < sortedResults.length - 1 && !wordBoundaries.has(index + 1)) {
                        parts.push('-');
                    }
                });
                
                return parts.join('');
            };

            // Format Arabic with word boundaries
            const formatArabicWithBoundaries = (results) => {
                const sortedResults = results.sort((a, b) => a.position.x - b.position.x);
                const parts = [];
                
                sortedResults.forEach((result, index) => {
                    if (index === 0 || wordBoundaries.has(index)) {
                        if (parts.length > 0) parts.push(' ');
                    }
                    parts.push(result.symbol.arabic || result.symbol.name);
                });
                
                return parts.join('');
            };

            // Toggle word boundary before a symbol
            const toggleWordBoundary = (symbolIndex) => {
                setWordBoundaries(prev => {
                    const newBoundaries = new Set(prev);
                    if (newBoundaries.has(symbolIndex)) {
                        newBoundaries.delete(symbolIndex);
                    } else {
                        newBoundaries.add(symbolIndex);
                    }
                    return newBoundaries;
                });
            };

            // Check if OpenCV is ready
            useEffect(() => {
                const checkOpenCV = () => {
                    if (typeof cv !== 'undefined' && cv.Mat) {
                        console.log('OpenCV.js loaded successfully');
                        setIsOpenCVReady(true);
                    } else {
                        console.log('Waiting for OpenCV.js...');
                        setTimeout(checkOpenCV, 100);
                    }
                };
                checkOpenCV();
            }, []);

            // Convert relative paths to full GitHub URLs
            const convertToGitHubUrl = useCallback((relativePath) => {
                if (!relativePath) return null;
                if (relativePath.startsWith('http')) return relativePath;
                
                const baseUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/';
                const fullUrl = baseUrl + relativePath;
                return fullUrl;
            }, []);

            // Load symbol images from URLs
            const loadSymbolImages = useCallback(async (symbols) => {
                const imageCache = {};
                
                for (const symbol of symbols) {
                    try {
                        if (symbol.images) {
                            // Load primary image
                            if (symbol.images.primary) {
                                try {
                                    const fullUrl = convertToGitHubUrl(symbol.images.primary);
                                    if (fullUrl) {
                                        const img = new Image();
                                        img.crossOrigin = 'anonymous';
                                        await new Promise((resolve, reject) => {
                                            img.onload = () => {
                                                imageCache[`${symbol.id}_primary`] = img;
                                                resolve();
                                            };
                                            img.onerror = reject;
                                            img.src = fullUrl;
                                        });
                                    }
                                } catch (e) {
                                    console.warn(`Failed to load primary image for ${symbol.name}:`, e);
                                }
                            }

                            // Load variant images
                            if (symbol.images.variants && Array.isArray(symbol.images.variants)) {
                                for (let i = 0; i < symbol.images.variants.length; i++) {
                                    try {
                                        const fullUrl = convertToGitHubUrl(symbol.images.variants[i]);
                                        if (fullUrl) {
                                            const img = new Image();
                                            img.crossOrigin = 'anonymous';
                                            await new Promise((resolve, reject) => {
                                                img.onload = () => {
                                                    imageCache[`${symbol.id}_variant_${i}`] = img;
                                                    resolve();
                                                };
                                                img.onerror = reject;
                                                img.src = fullUrl;
                                            });
                                        }
                                    } catch (e) {
                                        console.warn(`Failed to load variant ${i} for ${symbol.name}:`, e);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.warn(`Error processing images for symbol ${symbol.name}:`, error);
                    }
                }
                
                return imageCache;
            }, [convertToGitHubUrl]);

            // Symbol isolation using OpenCV contour detection
            const isolateSymbols = useCallback((imageElement) => {
                if (!isOpenCVReady || !imageElement) {
                    console.warn('OpenCV not ready or no image');
                    return [];
                }

                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = imageElement.naturalWidth;
                    canvas.height = imageElement.naturalHeight;
                    ctx.drawImage(imageElement, 0, 0);

                    const src = cv.imread(canvas);
                    const gray = new cv.Mat();
                    const binary = new cv.Mat();
                    const morphKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                    const contours = new cv.MatVector();
                    const hierarchy = new cv.Mat();

                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
                    cv.morphologyEx(binary, binary, cv.MORPH_CLOSE, morphKernel);
                    cv.morphologyEx(binary, binary, cv.MORPH_OPEN, morphKernel);
                    cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    const isolatedSymbols = [];
                    const minArea = processingSettings.minSymbolSize * processingSettings.minSymbolSize;
                    const maxArea = processingSettings.maxSymbolSize * processingSettings.maxSymbolSize;

                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const boundingRect = cv.boundingRect(contour);
                        const area = cv.contourArea(contour);

                        if (area > minArea && area < maxArea) {
                            const aspectRatio = boundingRect.width / boundingRect.height;
                            
                            if (aspectRatio > 0.2 && aspectRatio < 5.0) {
                                const padding = 5;
                                const x = Math.max(0, boundingRect.x - padding);
                                const y = Math.max(0, boundingRect.y - padding);
                                const width = Math.min(src.cols - x, boundingRect.width + 2 * padding);
                                const height = Math.min(src.rows - y, boundingRect.height + 2 * padding);

                                isolatedSymbols.push({
                                    x: x,
                                    y: y,
                                    width: width,
                                    height: height,
                                    area: area,
                                    contour: contour.clone()
                                });
                            }
                        }
                        contour.delete();
                    }

                    src.delete();
                    gray.delete();
                    binary.delete();
                    morphKernel.delete();
                    contours.delete();
                    hierarchy.delete();

                    isolatedSymbols.sort((a, b) => a.x - b.x);
                    console.log(`Isolated ${isolatedSymbols.length} potential symbols`);
                    
                    // Create debug images of isolated symbols
                    const debugSymbols = isolatedSymbols.map((symbol, index) => {
                        const debugCanvas = document.createElement('canvas');
                        const debugCtx = debugCanvas.getContext('2d');
                        debugCanvas.width = symbol.width;
                        debugCanvas.height = symbol.height;
                        
                        debugCtx.drawImage(
                            canvas, 
                            symbol.x, symbol.y, symbol.width, symbol.height,
                            0, 0, symbol.width, symbol.height
                        );
                        
                        return {
                            id: index,
                            dataUrl: debugCanvas.toDataURL(),
                            bounds: symbol,
                            area: symbol.area
                        };
                    });
                    
                    setIsolatedSymbolsDebug(debugSymbols);
                    return isolatedSymbols;

                } catch (error) {
                    console.error('Error in symbol isolation:', error);
                    return [];
                }
            }, [isOpenCVReady, processingSettings]);

            const loadChart = useCallback(() => {
                const loadChartInternal = async () => {
                    setChartLoadStatus('loading');
                    
                    const githubJsonUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/Hakli_symbols.JSON';
                    
                    try {
                        console.log('Fetching JSON from:', githubJsonUrl);
                        const response = await fetch(githubJsonUrl);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const chartData = await response.json();
                        console.log('JSON loaded successfully');
                        
                        const processedChart = {
                            symbols: chartData.symbols.map(symbol => ({
                                ...symbol,
                                confidence_weights: {
                                    primary: 1.0,
                                    variants: 0.9
                                }
                            }))
                        };
                        
                        setEquivalenceChart(processedChart);
                        setChartLoadStatus('loaded');
                        
                        console.log('Loading symbol images...');
                        const imageCache = await loadSymbolImages(processedChart.symbols);
                        console.log('Image loading complete. Loaded count:', Object.keys(imageCache).length);
                        setLoadedSymbolImages(imageCache);
                        
                    } catch (error) {
                        console.error('Error loading chart from GitHub:', error);
                        setChartLoadStatus('error');
                    }
                };
                
                loadChartInternal();
            }, [loadSymbolImages]);

            // Auto-load chart on startup
            useEffect(() => {
                loadChart();
            }, [loadChart]);

            // Handle image upload
            const handleImageUpload = useCallback((event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setUploadedImage(e.target.result);
                        
                        // Clear all previous analysis data
                        setRecognitionResults([]);
                        setActiveDetections(new Set());
                        setWordBoundaries(new Set());
                        setCorrections({});
                        setValidations({});
                        setActionHistory([]);
                        setIsolatedSymbolsDebug([]);
                        
                        // Reset manual selection mode if active
                        setManualSelectionMode(false);
                        setIsDrawing(false);
                        setDrawStart(null);
                        setDrawCurrent(null);
                        
                        console.log('New image loaded - all previous data cleared');
                    };
                    reader.readAsDataURL(file);
                }
            }, []);

            // Template matching function for isolated symbols
            const templateMatchIsolated = useCallback((isolatedSymbol, templateImg) => {
                if (!isOpenCVReady || !templateImg) return null;

                try {
                    if (templateImg.width === 0 || templateImg.height === 0) {
                        console.warn('Template image has invalid dimensions');
                        return null;
                    }

                    const symbolCanvas = document.createElement('canvas');
                    const symbolCtx = symbolCanvas.getContext('2d');
                    symbolCanvas.width = isolatedSymbol.width;
                    symbolCanvas.height = isolatedSymbol.height;
                    
                    symbolCtx.drawImage(
                        imageRef.current,
                        isolatedSymbol.x, isolatedSymbol.y, isolatedSymbol.width, isolatedSymbol.height,
                        0, 0, isolatedSymbol.width, isolatedSymbol.height
                    );

                    const symbolMat = cv.imread(symbolCanvas);
                    const templateCanvas = document.createElement('canvas');
                    const templateCtx = templateCanvas.getContext('2d');
                    templateCanvas.width = templateImg.width;
                    templateCanvas.height = templateImg.height;
                    templateCtx.drawImage(templateImg, 0, 0);
                    const templateMat = cv.imread(templateCanvas);

                    const result = new cv.Mat();
                    const resizedTemplate = new cv.Mat();
                    const symbolSize = new cv.Size(isolatedSymbol.width, isolatedSymbol.height);
                    cv.resize(templateMat, resizedTemplate, symbolSize);

                    const symbolGray = new cv.Mat();
                    const templateGray = new cv.Mat();
                    cv.cvtColor(symbolMat, symbolGray, cv.COLOR_RGBA2GRAY);
                    cv.cvtColor(resizedTemplate, templateGray, cv.COLOR_RGBA2GRAY);

                    cv.matchTemplate(symbolGray, templateGray, result, cv.TM_CCOEFF_NORMED);
                    
                    const minMaxLoc = cv.minMaxLoc(result);
                    const confidence = minMaxLoc.maxVal;

                    symbolMat.delete();
                    templateMat.delete();
                    resizedTemplate.delete();
                    symbolGray.delete();
                    templateGray.delete();
                    result.delete();

                    return {
                        confidence: confidence,
                        position: {
                            x: isolatedSymbol.x,
                            y: isolatedSymbol.y,
                            width: isolatedSymbol.width,
                            height: isolatedSymbol.height
                        }
                    };

                } catch (error) {
                    console.error('Template matching error:', error.message || error);
                    return null;
                }
            }, [isOpenCVReady]);

            // Enhanced symbol detection with isolation
            const detectSymbols = useCallback(async () => {
                if (!uploadedImage || !equivalenceChart || !imageRef.current) {
                    console.log('Missing requirements for detection');
                    return;
                }
                
                setIsProcessing(true);
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                console.log('Starting symbol isolation...');
                const isolatedSymbols = isolateSymbols(imageRef.current);
                
                if (isolatedSymbols.length === 0) {
                    console.warn('No symbols isolated');
                    setIsProcessing(false);
                    return;
                }

                console.log(`Found ${isolatedSymbols.length} isolated symbols, now matching...`);
                console.log(`Available symbol images: ${Object.keys(loadedSymbolImages).length}`);
                
                const detectionResults = [];
                let matchAttempts = 0;
                let successfulMatches = 0;
                
                for (let i = 0; i < isolatedSymbols.length; i++) {
                    const isolatedSymbol = isolatedSymbols[i];
                    let bestMatch = null;
                    
                    console.log(`Testing isolated symbol #${i + 1} (${isolatedSymbol.width}x${isolatedSymbol.height}, area: ${isolatedSymbol.area.toFixed(0)})`);
                    
                    for (const symbol of equivalenceChart.symbols) {
                        const primaryImg = loadedSymbolImages[`${symbol.id}_primary`];
                        if (primaryImg) {
                            matchAttempts++;
                            const match = templateMatchIsolated(isolatedSymbol, primaryImg);
                            const confidence = match ? match.confidence : 0;
                            
                            if (match && confidence > processingSettings.detectionSensitivity) {
                                console.log(`${symbol.name} (primary): ${confidence.toFixed(4)}`);
                                if (!bestMatch || confidence > bestMatch.confidence) {
                                    bestMatch = {
                                        ...match,
                                        symbol: symbol,
                                        matchType: 'primary',
                                        confidence: confidence
                                    };
                                }
                            }
                        }
                        
                        if (processingSettings.variantMatching && symbol.images.variants) {
                            symbol.images.variants.forEach((variantPath, index) => {
                                const variantImg = loadedSymbolImages[`${symbol.id}_variant_${index}`];
                                if (variantImg) {
                                    matchAttempts++;
                                    const match = templateMatchIsolated(isolatedSymbol, variantImg);
                                    const confidence = match ? match.confidence : 0;
                                    const threshold = processingSettings.detectionSensitivity * 0.9;
                                    
                                    if (match && confidence > threshold) {
                                        console.log(`${symbol.name} (variant ${index + 1}): ${confidence.toFixed(4)}`);
                                        const weightedConfidence = confidence * 0.9;
                                        if (!bestMatch || weightedConfidence > bestMatch.confidence) {
                                            bestMatch = {
                                                ...match,
                                                symbol: symbol,
                                                matchType: 'variant',
                                                variantIndex: index,
                                                confidence: weightedConfidence
                                            };
                                        }
                                    }
                                }
                            });
                        }
                    }
                    
                    if (bestMatch) {
                        successfulMatches++;
                        detectionResults.push({
                            symbol: bestMatch.symbol,
                            confidence: Math.min(0.95, bestMatch.confidence),
                            position: bestMatch.position,
                            matchDetails: {
                                type: bestMatch.matchType,
                                variantIndex: bestMatch.variantIndex,
                                scale: 1.0,
                                isolatedIndex: i
                            },
                            matchType: bestMatch.matchType,
                            variantIndex: bestMatch.variantIndex
                        });
                    }
                }
                
                // Clean up contours
                isolatedSymbols.forEach(symbol => {
                    if (symbol.contour) {
                        symbol.contour.delete();
                    }
                });
                
                console.log(`Detection complete: ${detectionResults.length} symbols matched out of ${isolatedSymbols.length} isolated`);
                console.log(`Total match attempts: ${matchAttempts}, Successful matches: ${successfulMatches}`);
                
                setRecognitionResults(detectionResults);
                setIsProcessing(false);
            }, [uploadedImage, equivalenceChart, loadedSymbolImages, processingSettings, isolateSymbols, templateMatchIsolated, isOpenCVReady]);

            const [activeDetections, setActiveDetections] = useState(new Set());
            const [combineMode, setCombineMode] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawStart, setDrawStart] = useState(null);
            const [drawCurrent, setDrawCurrent] = useState(null);
            const [manualSelectionMode, setManualSelectionMode] = useState(false);
            const [corrections, setCorrections] = useState({});
            const [validations, setValidations] = useState({});
            const [showCorrectionModal, setShowCorrectionModal] = useState(false);
            const [correctionTarget, setCorrectionTarget] = useState(null);
            const [correctionSymbolId, setCorrectionSymbolId] = useState('');
            const [correctionConfidence, setCorrectionConfidence] = useState(0.9);
            const [showSymbolDropdown, setShowSymbolDropdown] = useState(false);
            const [renderKey, setRenderKey] = useState(0);
            const [actionHistory, setActionHistory] = useState([]);
            const [maxHistorySize] = useState(20);

            // Toggle detection active state
            const toggleDetectionActive = useCallback((index) => {
                setActiveDetections(prev => {
                    const newActive = new Set(prev);
                    if (newActive.has(index)) {
                        newActive.delete(index);
                    } else {
                        newActive.add(index);
                    }
                    return newActive;
                });
            }, []);

            // Clear all active selections
            const clearActiveSelections = useCallback(() => {
                setActiveDetections(new Set());
                setCombineMode(false);
            }, []);

            // Mouse event handlers for manual selection
            const handleMouseDown = useCallback((event) => {
                if (!manualSelectionMode) return;
                
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const startPoint = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
                
                setIsDrawing(true);
                setDrawStart(startPoint);
                setDrawCurrent(startPoint);
                event.preventDefault();
            }, [manualSelectionMode]);

            const handleMouseMove = useCallback((event) => {
                if (!manualSelectionMode || !isDrawing || !drawStart) return;
                
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const currentPoint = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
                
                setDrawCurrent(currentPoint);
                event.preventDefault();
            }, [manualSelectionMode, isDrawing, drawStart]);

            const handleMouseUp = useCallback((event) => {
                if (!manualSelectionMode || !isDrawing || !drawStart) return;
                
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const endPoint = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
                
                // Only create detection if we've dragged a reasonable distance
                const distance = Math.sqrt(
                    Math.pow(endPoint.x - drawStart.x, 2) + 
                    Math.pow(endPoint.y - drawStart.y, 2)
                );
                
                if (distance > 10) {
                    createManualDetection(drawStart, endPoint);
                } else {
                    // Reset if drag was too small
                    setManualSelectionMode(false);
                    setIsDrawing(false);
                    setDrawStart(null);
                    setDrawCurrent(null);
                }
                
                event.preventDefault();
            }, [manualSelectionMode, isDrawing, drawStart, createManualDetection]);

            // Validation and correction functions
            const validateDetection = useCallback((detectionIndex, isCorrect) => {
                recordAction('validation', {
                    detectionIndex: detectionIndex,
                    isCorrect: isCorrect,
                    detectionData: recognitionResults[detectionIndex]
                });

                setValidations(prev => ({
                    ...prev,
                    [detectionIndex]: {
                        isCorrect: isCorrect,
                        timestamp: new Date().toISOString(),
                        detectionData: recognitionResults[detectionIndex]
                    }
                }));
                
                console.log(`Detection ${detectionIndex + 1} marked as ${isCorrect ? 'correct' : 'incorrect'}`);
            }, [recognitionResults, recordAction]);

            const openCorrectionModal = useCallback((detectionIndex) => {
                setCorrectionTarget(detectionIndex);
                setCorrectionSymbolId('');
                setCorrectionConfidence(0.9);
                setShowSymbolDropdown(false);
                setShowCorrectionModal(true);
            }, []);

            const submitCorrection = useCallback((detectionIndex, correctSymbolId, confidence = 0.9) => {
                console.log('Submitting correction:', { detectionIndex, correctSymbolId, confidence });
                console.log('Available symbols:', equivalenceChart?.symbols?.map(s => ({ id: s.id, name: s.name })) || 'No symbols loaded');
                
                const correctSymbol = equivalenceChart?.symbols.find(s => s.id === correctSymbolId);
                if (!correctSymbol) {
                    console.error('Correct symbol not found:', correctSymbolId);
                    console.error('Available symbol IDs:', equivalenceChart?.symbols?.map(s => s.id) || 'No symbols');
                    alert(`Symbol with ID "${correctSymbolId}" not found in database. Please try reloading the chart.`);
                    return;
                }

                console.log('Found correct symbol:', correctSymbol);

                const originalDetection = recognitionResults[detectionIndex];

                // Record action for undo
                recordAction('correction', {
                    detectionIndex: detectionIndex,
                    originalDetection: originalDetection,
                    correctedSymbol: correctSymbol,
                    userConfidence: confidence
                });

                setCorrections(prev => ({
                    ...prev,
                    [detectionIndex]: {
                        originalDetection: originalDetection,
                        correctedSymbol: correctSymbol,
                        userConfidence: confidence,
                        timestamp: new Date().toISOString()
                    }
                }));

                // Update the detection result with corrected symbol
                setRecognitionResults(prev => 
                    prev.map((result, index) => {
                        if (index === detectionIndex) {
                            return {
                                ...result,
                                symbol: correctSymbol,
                                confidence: confidence,
                                matchType: 'corrected',
                                matchDetails: {
                                    ...result.matchDetails,
                                    userCorrected: true,
                                    originalSymbol: result.symbol
                                }
                            };
                        }
                        return result;
                    })
                );

                console.log(`Detection ${detectionIndex + 1} corrected to: ${correctSymbol.name}`);
                setShowCorrectionModal(false);
                setCorrectionTarget(null);
                setCorrectionSymbolId('');
                setCorrectionConfidence(0.9);
                setShowSymbolDropdown(false);
                
                // Force complete re-render
                console.log('Forcing complete re-render after correction');
                setRenderKey(prev => prev + 1);
            }, [recognitionResults, equivalenceChart, recordAction]);

            const addAsTemplate = useCallback(async (detectionIndex) => {
                const detection = recognitionResults[detectionIndex];
                if (!detection || !imageRef.current) return;

                // Extract the detection region as a new template image
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = detection.position.width;
                canvas.height = detection.position.height;
                
                ctx.drawImage(
                    imageRef.current,
                    detection.position.x, detection.position.y, detection.position.width, detection.position.height,
                    0, 0, detection.position.width, detection.position.height
                );

                const templateDataUrl = canvas.toDataURL();
                console.log(`Template created for ${detection.symbol.name}:`, templateDataUrl.substring(0, 50) + '...');

                // Here you would normally upload to your GitHub repository
                // For now, we'll store locally and show in console
                const templateData = {
                    symbolId: detection.symbol.id,
                    symbolName: detection.symbol.name,
                    imageData: templateDataUrl,
                    source: 'user_validation',
                    timestamp: new Date().toISOString(),
                    position: detection.position,
                    originalConfidence: detection.confidence
                };

                // Add to validations as a template contribution
                setValidations(prev => ({
                    ...prev,
                    [`template_${detectionIndex}`]: {
                        type: 'template_contribution',
                        templateData: templateData,
                        timestamp: new Date().toISOString()
                    }
                }));

                console.log('Template added to learning database:', templateData);
                alert(`Template for "${detection.symbol.name}" added to learning database!`);
            }, [recognitionResults]);

            const exportLearningData = useCallback(() => {
                const learningData = {
                    corrections: corrections,
                    validations: validations,
                    exportDate: new Date().toISOString(),
                    totalCorrections: Object.keys(corrections).length,
                    totalValidations: Object.keys(validations).length,
                    symbolStats: {}
                };

                // Calculate statistics
                Object.values(corrections).forEach(correction => {
                    const symbolName = correction.correctedSymbol.name;
                    if (!learningData.symbolStats[symbolName]) {
                        learningData.symbolStats[symbolName] = { corrections: 0, validations: 0 };
                    }
                    learningData.symbolStats[symbolName].corrections++;
                });

                Object.values(validations).forEach(validation => {
                    if (validation.detectionData) {
                        const symbolName = validation.detectionData.symbol.name;
                        if (!learningData.symbolStats[symbolName]) {
                            learningData.symbolStats[symbolName] = { corrections: 0, validations: 0 };
                        }
                        learningData.symbolStats[symbolName].validations++;
                    }
                });

                const blob = new Blob([JSON.stringify(learningData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_learning_data_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('Learning data exported:', learningData);
            }, [corrections, validations]);

            // Action history and undo system
            const recordAction = useCallback((actionType, actionData) => {
                const action = {
                    type: actionType,
                    data: actionData,
                    timestamp: new Date().toISOString(),
                    id: Date.now()
                };

                setActionHistory(prev => {
                    const newHistory = [...prev, action];
                    // Keep only the last maxHistorySize actions
                    return newHistory.slice(-maxHistorySize);
                });

                console.log('Action recorded:', action);
            }, [maxHistorySize]);

            const undoLastAction = useCallback(() => {
                if (actionHistory.length === 0) return;

                const lastAction = actionHistory[actionHistory.length - 1];
                console.log('Undoing action:', lastAction);

                switch (lastAction.type) {
                    case 'delete_detection':
                        // Restore deleted detection
                        setRecognitionResults(prev => {
                            const newResults = [...prev];
                            newResults.splice(lastAction.data.index, 0, lastAction.data.detection);
                            return newResults;
                        });
                        break;

                    case 'combine_detections':
                        // Restore original detections, remove combined one
                        setRecognitionResults(prev => {
                            const withoutCombined = prev.filter((_, index) => index !== lastAction.data.combinedIndex);
                            return [...withoutCombined, ...lastAction.data.originalDetections];
                        });
                        break;

                    case 'manual_detection':
                        // Remove manual detection
                        setRecognitionResults(prev => prev.filter((_, index) => index !== lastAction.data.detectionIndex));
                        break;

                    case 'correction':
                        // Restore original detection
                        setRecognitionResults(prev => 
                            prev.map((result, index) => {
                                if (index === lastAction.data.detectionIndex) {
                                    return lastAction.data.originalDetection;
                                }
                                return result;
                            })
                        );
                        // Remove from corrections
                        setCorrections(prev => {
                            const newCorrections = { ...prev };
                            delete newCorrections[lastAction.data.detectionIndex];
                            return newCorrections;
                        });
                        break;

                    case 'validation':
                        // Remove validation
                        setValidations(prev => {
                            const newValidations = { ...prev };
                            delete newValidations[lastAction.data.detectionIndex];
                            return newValidations;
                        });
                        break;

                    case 'reanalysis':
                        // Restore original combined detection
                        setRecognitionResults(prev => 
                            prev.map((result, index) => {
                                if (index === lastAction.data.detectionIndex) {
                                    return lastAction.data.originalDetection;
                                }
                                return result;
                            })
                        );
                        break;

                    default:
                        console.warn('Unknown action type for undo:', lastAction.type);
                        return;
                }

                // Remove the action from history
                setActionHistory(prev => prev.slice(0, -1));
                console.log('Action undone:', lastAction.type);
            }, [actionHistory]);

            // Delete a specific detection result
            const deleteDetection = useCallback((indexToDelete) => {
                const detectionToDelete = recognitionResults[indexToDelete];
                
                // Record action for undo
                recordAction('delete_detection', {
                    index: indexToDelete,
                    detection: detectionToDelete
                });

                setRecognitionResults(prev => prev.filter((_, index) => index !== indexToDelete));
                
                // Remove from active selections
                setActiveDetections(prev => {
                    const newActive = new Set();
                    prev.forEach(activeIndex => {
                        if (activeIndex < indexToDelete) {
                            newActive.add(activeIndex);
                        } else if (activeIndex > indexToDelete) {
                            newActive.add(activeIndex - 1);
                        }
                    });
                    return newActive;
                });
                
                // Also remove any word boundaries that referenced deleted items
                setWordBoundaries(prev => {
                    const newBoundaries = new Set();
                    prev.forEach(boundaryIndex => {
                        if (boundaryIndex < indexToDelete) {
                            newBoundaries.add(boundaryIndex);
                        } else if (boundaryIndex > indexToDelete) {
                            newBoundaries.add(boundaryIndex - 1);
                        }
                    });
                    return newBoundaries;
                });
            }, [recognitionResults, recordAction]);

            // Re-analyze a combined symbol using template matching
            const reanalyzeCombinedSymbol = useCallback(async (combinedIndex) => {
                const combinedResult = recognitionResults[combinedIndex];
                if (combinedResult.matchType !== 'combined' || !equivalenceChart || !imageRef.current) return;

                console.log('Re-analyzing combined symbol:', combinedResult.symbol.name);

                // Extract the combined region from the image
                const combinedSymbol = {
                    x: combinedResult.position.x,
                    y: combinedResult.position.y,
                    width: combinedResult.position.width,
                    height: combinedResult.position.height,
                    area: combinedResult.position.width * combinedResult.position.height
                };

                let bestMatch = null;
                let matchAttempts = 0;

                // Test against all symbols in the database
                for (const symbol of equivalenceChart.symbols) {
                    const primaryImg = loadedSymbolImages[`${symbol.id}_primary`];
                    if (primaryImg) {
                        matchAttempts++;
                        const match = templateMatchIsolated(combinedSymbol, primaryImg);
                        const confidence = match ? match.confidence : 0;
                        
                        if (match && confidence > processingSettings.detectionSensitivity) {
                            console.log(`Re-analysis: ${symbol.name} (primary): ${confidence.toFixed(4)}`);
                            if (!bestMatch || confidence > bestMatch.confidence) {
                                bestMatch = {
                                    ...match,
                                    symbol: symbol,
                                    matchType: 'primary',
                                    confidence: confidence
                                };
                            }
                        }
                    }
                    
                    // Test variants if enabled
                    if (processingSettings.variantMatching && symbol.images.variants) {
                        symbol.images.variants.forEach((variantPath, index) => {
                            const variantImg = loadedSymbolImages[`${symbol.id}_variant_${index}`];
                            if (variantImg) {
                                matchAttempts++;
                                const match = templateMatchIsolated(combinedSymbol, variantImg);
                                const confidence = match ? match.confidence : 0;
                                const threshold = processingSettings.detectionSensitivity * 0.9;
                                
                                if (match && confidence > threshold) {
                                    console.log(`Re-analysis: ${symbol.name} (variant ${index + 1}): ${confidence.toFixed(4)}`);
                                    const weightedConfidence = confidence * 0.9;
                                    if (!bestMatch || weightedConfidence > bestMatch.confidence) {
                                        bestMatch = {
                                            ...match,
                                            symbol: symbol,
                                            matchType: 'variant',
                                            variantIndex: index,
                                            confidence: weightedConfidence
                                        };
                                    }
                                }
                            }
                        });
                    }
                }

                if (bestMatch) {
                    // Update the combined symbol with new analysis
                    setRecognitionResults(prev => 
                        prev.map((result, index) => {
                            if (index === combinedIndex) {
                                return {
                                    symbol: bestMatch.symbol,
                                    confidence: Math.min(0.95, bestMatch.confidence),
                                    position: result.position, // Keep original position
                                    matchDetails: {
                                        type: bestMatch.matchType,
                                        variantIndex: bestMatch.variantIndex,
                                        scale: 1.0,
                                        reanalyzed: true
                                    },
                                    matchType: bestMatch.matchType,
                                    variantIndex: bestMatch.variantIndex
                                };
                            }
                            return result;
                        })
                    );
                    console.log(`Re-analysis complete: Found ${bestMatch.symbol.name} with ${(bestMatch.confidence * 100).toFixed(0)}% confidence`);
                } else {
                    console.log('Re-analysis: No better match found');
                }
            }, [recognitionResults, equivalenceChart, loadedSymbolImages, processingSettings, templateMatchIsolated]);

            // Combine selected detections
            const combineDetections = useCallback(() => {
                const activeIndices = Array.from(activeDetections).sort((a, b) => a - b);
                if (activeIndices.length < 2) return;

                // Store original detections for undo
                const selectedResults = activeIndices.map(i => recognitionResults[i]);

                // Find bounding box that encompasses all selected detections
                const minX = Math.min(...selectedResults.map(r => r.position.x));
                const minY = Math.min(...selectedResults.map(r => r.position.y));
                const maxX = Math.max(...selectedResults.map(r => r.position.x + r.position.width));
                const maxY = Math.max(...selectedResults.map(r => r.position.y + r.position.height));

                // Create combined detection using the first selected as base
                const baseResult = selectedResults[0];
                const combinedResult = {
                    ...baseResult,
                    position: {
                        x: minX,
                        y: minY,
                        width: maxX - minX,
                        height: maxY - minY
                    },
                    symbol: {
                        ...baseResult.symbol,
                        name: selectedResults.map(r => r.symbol.name).join('+'),
                        arabic: selectedResults.map(r => r.symbol.arabic || r.symbol.name).join('')
                    },
                    confidence: selectedResults.reduce((sum, r) => sum + r.confidence, 0) / selectedResults.length,
                    matchType: 'combined'
                };

                // Remove individual detections and add combined one
                const newResults = recognitionResults.filter((_, index) => !activeIndices.includes(index));
                const combinedIndex = newResults.length; // Index where combined detection will be added
                newResults.push(combinedResult);

                // Record action for undo
                recordAction('combine_detections', {
                    originalDetections: selectedResults,
                    combinedResult: combinedResult,
                    combinedIndex: combinedIndex,
                    originalIndices: activeIndices
                });

                setRecognitionResults(newResults);

                // Clear active selections
                setActiveDetections(new Set());
                setCombineMode(false);
            }, [activeDetections, recognitionResults, recordAction]);

            // Manual selection functions
            const startManualSelection = useCallback(() => {
                setManualSelectionMode(true);
                setActiveDetections(new Set());
                console.log('Manual selection mode activated');
            }, []);

            const cancelManualSelection = useCallback(() => {
                setManualSelectionMode(false);
                setIsDrawing(false);
                setDrawStart(null);
                setDrawCurrent(null);
                console.log('Manual selection mode cancelled');
            }, []);

            // Create manual detection from drawn rectangle
            const createManualDetection = useCallback(async (startPoint, endPoint) => {
                if (!imageRef.current || !equivalenceChart) return;

                const img = imageRef.current;
                const container = imageContainerRef.current;
                const containerRect = container.getBoundingClientRect();
                const imgRect = img.getBoundingClientRect();
                
                const offsetX = imgRect.left - containerRect.left;
                const offsetY = imgRect.top - containerRect.top;
                const scaleX = img.offsetWidth / img.naturalWidth;
                const scaleY = img.offsetHeight / img.naturalHeight;

                // Convert screen coordinates to image coordinates
                const imageX1 = (startPoint.x - offsetX) / scaleX;
                const imageY1 = (startPoint.y - offsetY) / scaleY;
                const imageX2 = (endPoint.x - offsetX) / scaleX;
                const imageY2 = (endPoint.y - offsetY) / scaleY;

                // Calculate bounding box
                const x = Math.min(imageX1, imageX2);
                const y = Math.min(imageY1, imageY2);
                const width = Math.abs(imageX2 - imageX1);
                const height = Math.abs(imageY2 - imageY1);

                // Minimum size check
                if (width < 10 || height < 10) {
                    console.log('Manual selection too small, ignoring');
                    return;
                }

                // Check for overlaps with existing detections
                let hasOverlap = false;
                const newRect = { x, y, width, height };
                
                recognitionResults.forEach((result, index) => {
                    const existingRect = result.position;
                    
                    // Calculate overlap
                    const overlapX = Math.max(0, Math.min(newRect.x + newRect.width, existingRect.x + existingRect.width) - Math.max(newRect.x, existingRect.x));
                    const overlapY = Math.max(0, Math.min(newRect.y + newRect.height, existingRect.y + existingRect.height) - Math.max(newRect.y, existingRect.y));
                    const overlapArea = overlapX * overlapY;
                    const overlapPercentage = overlapArea / (newRect.width * newRect.height);
                    
                    if (overlapPercentage > 0.3) { // More than 30% overlap
                        hasOverlap = true;
                        console.log(`Manual selection overlaps ${overlapPercentage.toFixed(2)*100}% with existing detection #${index + 1} (${result.symbol.name})`);
                    }
                });

                if (hasOverlap) {
                    if (!confirm('This selection overlaps with existing detections. Continue anyway?')) {
                        setManualSelectionMode(false);
                        setIsDrawing(false);
                        setDrawStart(null);
                        setDrawCurrent(null);
                        return;
                    }
                }

                console.log(`Creating manual selection: ${x.toFixed(0)},${y.toFixed(0)} ${width.toFixed(0)}x${height.toFixed(0)}`);

                // Create isolated symbol object for template matching
                const manualSymbol = {
                    x: Math.round(x),
                    y: Math.round(y),
                    width: Math.round(width),
                    height: Math.round(height),
                    area: width * height
                };

                let bestMatch = null;
                let matchAttempts = 0;
                
                console.log(`Manual selection testing ${equivalenceChart?.symbols?.length || 0} symbols...`);

                // Run template matching on manual selection with lower threshold
                const manualThreshold = processingSettings.detectionSensitivity * 0.5; // Lower threshold for manual selections
                console.log(`Using manual threshold: ${manualThreshold}`);

                for (const symbol of equivalenceChart.symbols) {
                    const primaryImg = loadedSymbolImages[`${symbol.id}_primary`];
                    if (primaryImg) {
                        matchAttempts++;
                        const match = templateMatchIsolated(manualSymbol, primaryImg);
                        const confidence = match ? match.confidence : 0;
                        
                        console.log(`Manual test: ${symbol.name} (primary): ${confidence.toFixed(4)} vs threshold ${manualThreshold.toFixed(3)}`);
                        
                        if (match && confidence > manualThreshold) {
                            console.log(`Manual match found: ${symbol.name} (primary): ${confidence.toFixed(4)} `);
                            if (!bestMatch || confidence > bestMatch.confidence) {
                                bestMatch = {
                                    ...match,
                                    symbol: symbol,
                                    matchType: 'primary',
                                    confidence: confidence
                                };
                            }
                        }
                    }
                    
                    // Test variants
                    if (processingSettings.variantMatching && symbol.images.variants) {
                        symbol.images.variants.forEach((variantPath, index) => {
                            const variantImg = loadedSymbolImages[`${symbol.id}_variant_${index}`];
                            if (variantImg) {
                                matchAttempts++;
                                const match = templateMatchIsolated(manualSymbol, variantImg);
                                const confidence = match ? match.confidence : 0;
                                const variantThreshold = manualThreshold * 0.9;
                                
                                console.log(`Manual test: ${symbol.name} (variant ${index + 1}): ${confidence.toFixed(4)} vs threshold ${variantThreshold.toFixed(3)}`);
                                
                                if (match && confidence > variantThreshold) {
                                    console.log(`Manual variant match found: ${symbol.name} (variant ${index + 1}): ${confidence.toFixed(4)} `);
                                    const weightedConfidence = confidence * 0.9;
                                    if (!bestMatch || weightedConfidence > bestMatch.confidence) {
                                        bestMatch = {
                                            ...match,
                                            symbol: symbol,
                                            matchType: 'variant',
                                            variantIndex: index,
                                            confidence: weightedConfidence
                                        };
                                    }
                                }
                            }
                        });
                    }
                }

                console.log(`Manual selection: ${matchAttempts} template tests completed`);

                if (bestMatch) {
                    console.log(`Best manual match: ${bestMatch.symbol.name} with confidence ${bestMatch.confidence.toFixed(4)}`);
                    
                    // Add manual detection to results
                    const manualDetection = {
                        symbol: bestMatch.symbol,
                        confidence: Math.min(0.95, bestMatch.confidence),
                        position: {
                            x: manualSymbol.x,
                            y: manualSymbol.y,
                            width: manualSymbol.width,
                            height: manualSymbol.height
                        },
                        matchDetails: {
                            type: bestMatch.matchType,
                            variantIndex: bestMatch.variantIndex,
                            scale: 1.0,
                            manual: true
                        },
                        matchType: bestMatch.matchType,
                        variantIndex: bestMatch.variantIndex
                    };

                    const newIndex = recognitionResults.length;

                    // Record action for undo
                    recordAction('manual_detection', {
                        detectionIndex: newIndex,
                        detection: manualDetection,
                        selectionBounds: { startPoint, endPoint }
                    });

                    setRecognitionResults(prev => [...prev, manualDetection]);
                    console.log(`Manual detection added: ${bestMatch.symbol.name} (${(bestMatch.confidence * 100).toFixed(0)}%)`);
                    
                    alert(`Manual selection successful: ${bestMatch.symbol.name} (${(bestMatch.confidence * 100).toFixed(0)}% confidence)`);
                } else {
                    console.log('Manual selection: No match found above threshold');
                    console.log(`Threshold was: ${manualThreshold}`);
                    alert('Manual selection: No symbol match found above threshold. Try adjusting the sensitivity or selecting a clearer region.');
                }

                // Reset manual selection mode
                setManualSelectionMode(false);
                setIsDrawing(false);
                setDrawStart(null);
                setDrawCurrent(null);
            }, [equivalenceChart, loadedSymbolImages, processingSettings, templateMatchIsolated, recognitionResults, recordAction]);

            // ENHANCED: Detection results drawing with active selection system
            const drawDetectionResults = useCallback(() => {
                if (!canvasRef.current || !imageRef.current || !imageContainerRef.current || recognitionResults.length === 0) {
                    return;
                }
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;
                const container = imageContainerRef.current;
                
                // Wait for image to be fully loaded and rendered
                if (img.naturalWidth === 0 || img.naturalHeight === 0 || img.offsetWidth === 0 || img.offsetHeight === 0) {
                    setTimeout(drawDetectionResults, 100);
                    return;
                }

                // Get the bounding rectangles to calculate precise positioning
                const containerRect = container.getBoundingClientRect();
                const imgRect = img.getBoundingClientRect();
                
                // Calculate the actual offset of the image within its container
                const offsetX = imgRect.left - containerRect.left;
                const offsetY = imgRect.top - containerRect.top;
                
                // Set canvas size to exactly match the container
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
                canvas.style.width = container.offsetWidth + 'px';
                canvas.style.height = container.offsetHeight + 'px';
                
                // Position canvas to overlay the container perfectly
                canvas.style.left = '0px';
                canvas.style.top = '0px';
                
                // Calculate scaling factors from natural image size to displayed size
                const scaleX = img.offsetWidth / img.naturalWidth;
                const scaleY = img.offsetHeight / img.naturalHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                console.log('Drawing detection boxes with active selection system:', {
                    imageNatural: `${img.naturalWidth}x${img.naturalHeight}`,
                    imageDisplay: `${img.offsetWidth}x${img.offsetHeight}`,
                    containerSize: `${container.offsetWidth}x${container.offsetHeight}`,
                    imageOffset: `${offsetX.toFixed(1)}, ${offsetY.toFixed(1)}`,
                    scale: `${scaleX.toFixed(3)}x${scaleY.toFixed(3)}`,
                    results: recognitionResults.length,
                    active: activeDetections.size
                });
                
                recognitionResults.forEach((result, index) => {
                    const { position, matchType, symbol } = result;
                    const isActive = activeDetections.has(index);
                    
                    // Apply scaling and offset transformations
                    const x = (position.x * scaleX) + offsetX;
                    const y = (position.y * scaleY) + offsetY;
                    const width = position.width * scaleX;
                    const height = position.height * scaleY;
                    
                    // Style based on match type and active state
                    let color = '#10b981'; // green for primary
                    let lineWidth = 2;
                    
                    if (matchType === 'variant') {
                        ctx.setLineDash([4, 4]);
                        color = '#8b5cf6'; // purple for variants
                    } else if (matchType === 'combined') {
                        color = '#f59e0b'; // amber for combined
                    } else {
                        ctx.setLineDash([]);
                    }
                    
                    // Active state styling
                    if (isActive) {
                        lineWidth = 3;
                        // Add pulsing effect with double border
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 5;
                        ctx.strokeRect(x - 1, y - 1, width + 2, height + 2);
                    }
                    
                    // Draw the main bounding box
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                    ctx.strokeRect(x, y, width, height);
                    ctx.setLineDash([]);
                    
                    // Add semi-transparent fill for active boxes
                    if (isActive) {
                        ctx.fillStyle = color + '20';
                        ctx.fillRect(x, y, width, height);
                    }
                    
                    // Add Arabic character inside the box (centered)
                    const character = symbol.arabic || symbol.name;
                    const labelText = character.length > 3 ? symbol.name.charAt(0) : character;
                    
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Center the text in the box
                    const centerX = x + width / 2;
                    const centerY = y + height / 2;
                    
                    // Draw text with slight background for visibility
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.strokeText(labelText, centerX, centerY);
                    ctx.fillText(labelText, centerX, centerY);
                    
                    // Show action buttons only for active boxes
                    if (isActive) {
                        const buttonSize = 16;
                        const buttonSpacing = 18;
                        let buttonX = x + width + 5;
                        const buttonY = y;
                        
                        // Delete button
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.9)'; // red
                        ctx.fillRect(buttonX, buttonY, buttonSize, buttonSize);
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(buttonX + 3, buttonY + 3);
                        ctx.lineTo(buttonX + buttonSize - 3, buttonY + buttonSize - 3);
                        ctx.moveTo(buttonX + buttonSize - 3, buttonY + 3);
                        ctx.lineTo(buttonX + 3, buttonY + buttonSize - 3);
                        ctx.stroke();
                        
                        // Re-analyze button for combined symbols
                        if (matchType === 'combined') {
                            buttonX += buttonSpacing;
                            ctx.fillStyle = 'rgba(16, 185, 129, 0.9)'; // green
                            ctx.fillRect(buttonX, buttonY, buttonSize, buttonSize);
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 10px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('R', buttonX + buttonSize/2, buttonY + buttonSize/2 + 1);
                        }
                        
                        // Combine button (only show if multiple active or in combine mode)
                        if (activeDetections.size > 1 || combineMode) {
                            buttonX += buttonSpacing;
                            ctx.fillStyle = 'rgba(59, 130, 246, 0.9)'; // blue
                            ctx.fillRect(buttonX, buttonY, buttonSize, buttonSize);
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 12px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('+', buttonX + buttonSize/2, buttonY + buttonSize/2 + 1);
                        }
                    }
                    
                    // Add confidence indicator in bottom-left corner (only for active boxes)
                    if (isActive) {
                        const confidenceText = `${(result.confidence * 100).toFixed(0)}%`;
                        ctx.font = '10px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        const confTextWidth = ctx.measureText(confidenceText).width + 4;
                        ctx.fillRect(x + 2, y + height - 14, confTextWidth, 12);
                        ctx.fillStyle = 'white';
                        ctx.fillText(confidenceText, x + 4, y + height - 4);
                    }
                });
                
                // Draw manual selection rectangle if in drawing mode
                if (manualSelectionMode && isDrawing && drawStart && drawCurrent) {
                    const startX = Math.min(drawStart.x, drawCurrent.x);
                    const startY = Math.min(drawStart.y, drawCurrent.y);
                    const rectWidth = Math.abs(drawCurrent.x - drawStart.x);
                    const rectHeight = Math.abs(drawCurrent.y - drawStart.y);
                    
                    // Draw selection rectangle
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = '#3b82f6'; // blue
                    ctx.lineWidth = 2;
                    ctx.strokeRect(startX, startY, rectWidth, rectHeight);
                    
                    // Add semi-transparent fill
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                    ctx.fillRect(startX, startY, rectWidth, rectHeight);
                    
                    ctx.setLineDash([]);
                }
                
                // Reset text alignment
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
                ctx.font = 'bold 14px Arial';
            }, [recognitionResults, activeDetections, combineMode, manualSelectionMode, isDrawing, drawStart, drawCurrent]);

            // Handle canvas clicks for active selection and actions (only when NOT in manual mode)
            const handleCanvasClick = useCallback((event) => {
                if (manualSelectionMode) return; // Don't handle clicks in manual mode
                
                if (!canvasRef.current || !imageRef.current || !imageContainerRef.current || recognitionResults.length === 0) {
                    return;
                }
                
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;
                
                const img = imageRef.current;
                const container = imageContainerRef.current;
                const containerRect = container.getBoundingClientRect();
                const imgRect = img.getBoundingClientRect();
                
                const offsetX = imgRect.left - containerRect.left;
                const offsetY = imgRect.top - containerRect.top;
                const scaleX = img.offsetWidth / img.naturalWidth;
                const scaleY = img.offsetHeight / img.naturalHeight;
                
                // Check clicks on action buttons first (for active detections)
                for (let index = 0; index < recognitionResults.length; index++) {
                    if (!activeDetections.has(index)) continue;
                    
                    const result = recognitionResults[index];
                    const { position, matchType } = result;
                    
                    const x = (position.x * scaleX) + offsetX;
                    const y = (position.y * scaleY) + offsetY;
                    const width = position.width * scaleX;
                    
                    const buttonSize = 16;
                    const buttonSpacing = 18;
                    let buttonX = x + width + 5;
                    const buttonY = y;
                    
                    // Delete button
                    if (clickX >= buttonX && clickX <= buttonX + buttonSize && 
                        clickY >= buttonY && clickY <= buttonY + buttonSize) {
                        deleteDetection(index);
                        return;
                    }
                    
                    // Re-analyze button (for combined symbols)
                    if (matchType === 'combined') {
                        buttonX += buttonSpacing;
                        if (clickX >= buttonX && clickX <= buttonX + buttonSize && 
                            clickY >= buttonY && clickY <= buttonY + buttonSize) {
                            reanalyzeCombinedSymbol(index);
                            return;
                        }
                    }
                    
                    // Combine button (if available)
                    if (activeDetections.size > 1 || combineMode) {
                        buttonX += buttonSpacing;
                        if (clickX >= buttonX && clickX <= buttonX + buttonSize && 
                            clickY >= buttonY && clickY <= buttonY + buttonSize) {
                            if (activeDetections.size > 1) {
                                combineDetections();
                            }
                            return;
                        }
                    }
                }
                
                // Check clicks on detection boxes to toggle active state
                // Allow multiple boxes to be selected even if they overlap
                let clickedAny = false;
                for (let index = 0; index < recognitionResults.length; index++) {
                    const result = recognitionResults[index];
                    const { position } = result;
                    
                    const x = (position.x * scaleX) + offsetX;
                    const y = (position.y * scaleY) + offsetY;
                    const width = position.width * scaleX;
                    const height = position.height * scaleY;
                    
                    // Check if click is within detection box bounds
                    if (clickX >= x && clickX <= x + width && 
                        clickY >= y && clickY <= y + height) {
                        toggleDetectionActive(index);
                        clickedAny = true;
                        // Don't return here - allow clicking on overlapping boxes
                        break; // But only select the first (topmost) one
                    }
                }
                
                // Click outside any detection - clear selections only if no box was clicked
                if (!clickedAny) {
                    clearActiveSelections();
                }
            }, [manualSelectionMode, recognitionResults, activeDetections, combineMode, deleteDetection, combineDetections, toggleDetectionActive, clearActiveSelections, reanalyzeCombinedSymbol]);

            // Trigger drawing when results change or manual mode changes
            useEffect(() => {
                if (uploadedImage && (recognitionResults.length > 0 || manualSelectionMode)) {
                    const timer = setTimeout(drawDetectionResults, 300);
                    return () => clearTimeout(timer);
                }
            }, [uploadedImage, recognitionResults, drawDetectionResults, manualSelectionMode]);

            // Force thumbnail updates when corrections change
            useEffect(() => {
                if (Object.keys(corrections).length > 0) {
                    console.log('Corrections updated, forcing thumbnail refresh:', corrections);
                    setRenderKey(prev => prev + 1);
                }
            }, [corrections]);

            // Redraw during manual selection
            useEffect(() => {
                if (manualSelectionMode && (isDrawing || drawStart || drawCurrent)) {
                    drawDetectionResults();
                }
            }, [manualSelectionMode, isDrawing, drawStart, drawCurrent, drawDetectionResults]);

            // Redraw on window resize
            useEffect(() => {
                const handleResize = () => {
                    if (recognitionResults.length > 0) {
                        setTimeout(drawDetectionResults, 100);
                    }
                };
                
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [recognitionResults, drawDetectionResults]);

            return (
                <div className="max-w-6xl mx-auto p-4 bg-gray-50 min-h-screen">
                    <div className="bg-white rounded-lg shadow-lg p-6">
                        <h1 className="text-3xl font-bold text-gray-800 mb-4 flex items-center gap-3">
                            <Eye />
                            Hakli Glyph Recognizer
                            <span className="text-sm font-normal text-gray-500 ml-2">based on Ahmad Al-Jallad (2025), The Decipherment of the Dhofari Script</span>
                        </h1>
                        
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <div className="space-y-4">
                                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                    <h3 className="font-semibold text-blue-800 mb-2">Chart Status</h3>
                                    <button
                                        onClick={loadChart}
                                        className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
                                        disabled={chartLoadStatus === 'loading'}
                                    >
                                        {chartLoadStatus === 'loading' ? 'Loading...' : 'Reload Chart'}
                                    </button>
                                    
                                    {equivalenceChart && (
                                        <div className="mt-3 text-sm text-green-600">
                                            Loaded {equivalenceChart.symbols?.length || 0} symbols, {Object.keys(loadedSymbolImages).length} images
                                        </div>
                                    )}
                                    
                                    {!isOpenCVReady && (
                                        <div className="mt-3 text-sm text-orange-600">
                                            Loading OpenCV.js...
                                        </div>
                                    )}
                                </div>

                                <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
                                    <h3 className="font-semibold text-gray-800 mb-2">Detection Settings</h3>
                                    <div className="space-y-2">
                                        <div>
                                            <label className="text-sm">Sensitivity: {processingSettings.detectionSensitivity}</label>
                                            <input
                                                type="range"
                                                min="0.1"
                                                max="0.9"
                                                step="0.1"
                                                value={processingSettings.detectionSensitivity}
                                                onChange={(e) => setProcessingSettings(prev => ({
                                                    ...prev,
                                                    detectionSensitivity: parseFloat(e.target.value)
                                                }))}
                                                className="w-full"
                                            />
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <input
                                                type="checkbox"
                                                id="variantMatching"
                                                checked={processingSettings.variantMatching}
                                                onChange={(e) => setProcessingSettings(prev => ({
                                                    ...prev,
                                                    variantMatching: e.target.checked
                                                }))}
                                            />
                                            <label htmlFor="variantMatching" className="text-sm">Include variants</label>
                                        </div>
                                    </div>
                                </div>

                                <div className="space-y-3">
                                    <label className="block text-sm font-medium">Upload Inscription Image</label>
                                    <div className="flex items-center justify-center w-full">
                                        <label className="flex flex-col items-center justify-center w-full h-24 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100">
                                            <div className="flex flex-col items-center justify-center pt-3 pb-3">
                                                <Upload />
                                                <p className="text-xs text-gray-500 mt-1">Click to upload</p>
                                            </div>
                                            <input
                                                type="file"
                                                className="hidden"
                                                accept="image/*"
                                                onChange={handleImageUpload}
                                            />
                                        </label>
                                    </div>
                                </div>

                                <button
                                    onClick={detectSymbols}
                                    disabled={!uploadedImage || !equivalenceChart || isProcessing || !isOpenCVReady}
                                    className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-300 text-white font-medium py-3 px-4 rounded-lg flex items-center justify-center gap-2"
                                >
                                    {isProcessing ? (
                                        <>
                                            <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                                            Processing...
                                        </>
                                    ) : (
                                        <>
                                            <Zap />
                                            Detect Symbols
                                        </>
                                    )}
                                </button>

                                {/* Manual Selection Controls */}
                                <div className="bg-amber-50 border border-amber-200 rounded-lg p-4">
                                    <h3 className="font-semibold text-amber-800 mb-2">Manual Selection</h3>
                                    <div className="space-y-2">
                                        {!manualSelectionMode ? (
                                            <button
                                                onClick={startManualSelection}
                                                disabled={!uploadedImage}
                                                className="w-full bg-amber-600 hover:bg-amber-700 disabled:bg-gray-300 text-white font-medium py-2 px-4 rounded-lg"
                                            >
                                                Draw Selection
                                            </button>
                                        ) : (
                                            <div className="space-y-2">
                                                <div className="text-sm text-amber-700 mb-2">
                                                    Click and drag to select a symbol region
                                                </div>
                                                <button
                                                    onClick={cancelManualSelection}
                                                    className="w-full bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg"
                                                >
                                                    Cancel Selection
                                                </button>
                                            </div>
                                        )}
                                        <div className="text-xs text-amber-600">
                                            Use when automatic detection misses symbols or when you need precise control
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div className="space-y-4">
                                <h3 className="font-semibold text-gray-800">Analysis</h3>
                                
                                <div 
                                    ref={imageContainerRef}
                                    className="relative bg-gray-100 rounded-lg overflow-hidden border-2 border-gray-200" 
                                    style={{minHeight: '400px'}}
                                >
                                    {uploadedImage ? (
                                        <div className="relative p-4">
                                            <img
                                                ref={imageRef}
                                                src={uploadedImage}
                                                alt="Hakli inscription"
                                                className="max-w-full h-auto block mx-auto"
                                                onLoad={() => {
                                                    if (recognitionResults.length > 0) {
                                                        setTimeout(drawDetectionResults, 100);
                                                    }
                                                }}
                                            />
                                            <canvas
                                                ref={canvasRef}
                                                className={`absolute ${manualSelectionMode ? 'cursor-crosshair' : 'cursor-pointer'}`}
                                                style={{ 
                                                    display: recognitionResults.length > 0 || manualSelectionMode ? 'block' : 'none',
                                                    left: '0px',
                                                    top: '0px'
                                                }}
                                                onClick={!manualSelectionMode ? handleCanvasClick : undefined}
                                                onMouseDown={manualSelectionMode ? handleMouseDown : undefined}
                                                onMouseMove={manualSelectionMode ? handleMouseMove : undefined}
                                                onMouseUp={manualSelectionMode ? handleMouseUp : undefined}
                                            />
                                        </div>
                                    ) : (
                                        <div className="text-center text-gray-500 p-8">
                                            <Camera />
                                            <p className="text-lg font-medium mb-2 mt-4">Upload Image</p>
                                            <p className="text-sm">Upload an inscription to analyze</p>
                                        </div>
                                    )}
                                </div>

                                {recognitionResults.length > 0 && (
                                    <div className="bg-green-50 border border-green-200 rounded-lg p-4">
                                        <h3 className="font-semibold text-green-800 mb-3">
                                            Detection Results ({recognitionResults.length} matches found)
                                        </h3>
                                        
                                        <div className="mb-4 p-4 bg-white rounded-lg border">
                                            <div className="flex justify-between items-center mb-2">
                                                <h4 className="font-semibold text-gray-800">Reconstructed Inscription:</h4>
                                                <button
                                                    onClick={() => setWordBoundaries(new Set())}
                                                    className="text-xs bg-gray-500 text-white px-2 py-1 rounded hover:bg-gray-600"
                                                >
                                                    Clear Boundaries
                                                </button>
                                            </div>
                                            <div className="space-y-2">
                                                <div>
                                                    <span className="text-sm text-gray-600 mr-2">Latin:</span>
                                                    <span className="text-lg font-mono text-blue-800">
                                                        {formatInscriptionWithBoundaries(recognitionResults)}
                                                    </span>
                                                </div>
                                                
                                                <div dir="rtl">
                                                    <span className="text-sm text-gray-600 ml-2">Arabic:</span>
                                                    <span className="text-lg text-green-800">
                                                        {formatArabicWithBoundaries(recognitionResults)}
                                                    </span>
                                                </div>
                                                
                                                <div className="text-xs text-gray-500">
                                                    Average confidence: {(recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length * 100).toFixed(0)}%
                                                    | Reading direction: Left to Right
                                                    | {recognitionResults.length} symbols detected
                                                    {wordBoundaries.size > 0 && ` | ${wordBoundaries.size} word boundaries`}
                                                </div>
                                            </div>
                                        </div>

                                        <div className="space-y-2">
                                            <div className="flex justify-between items-center">
                                                <h4 className="font-medium text-gray-800">Individual Matches:</h4>
                                                <div className="text-xs text-gray-600">
                                                    Sorted by position (left to right)
                                                </div>
                                            </div>
                                            {recognitionResults
                                                .sort((a, b) => a.position.x - b.position.x)
                                                .map((result, index) => {
                                                    // Force re-render by including renderKey in component
                                                    const uniqueKey = `${index}-${result.matchType}-${result.symbol.id}-${result.confidence.toFixed(3)}-${renderKey}`;
                                                    
                                                    return (
                                                <div key={uniqueKey} className={`bg-white rounded p-3 border-l-4 ${
                                                    result.confidence > 0.7 ? 'border-green-500' : 
                                                    result.confidence > 0.5 ? 'border-yellow-500' : 'border-red-500'
                                                }`}>
                                                    <div className="flex justify-between items-center">
                                                        <div className="flex items-center gap-3">
                                                            <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
                                                                #{index + 1}
                                                            </span>
                                                            
                                                            {/* Symbol Image Display */}
                                                            <div className="flex items-center gap-2">
                                                                {(() => {
                                                                    // Create a canvas to show the detected region
                                                                    const debugCanvas = document.createElement('canvas');
                                                                    const debugCtx = debugCanvas.getContext('2d');
                                                                    debugCanvas.width = result.position.width;
                                                                    debugCanvas.height = result.position.height;
                                                                    
                                                                    if (imageRef.current) {
                                                                        debugCtx.drawImage(
                                                                            imageRef.current,
                                                                            result.position.x, result.position.y, result.position.width, result.position.height,
                                                                            0, 0, result.position.width, result.position.height
                                                                        );
                                                                    }
                                                                    
                                                                    const debugDataUrl = debugCanvas.toDataURL();
                                                                    
                                                                    return (
                                                                        <div className="flex items-center gap-2">
                                                                            <div className="w-12 h-12 bg-gray-100 border rounded flex-shrink-0">
                                                                                <img 
                                                                                    src={debugDataUrl}
                                                                                    alt={`Detected: ${result.symbol.name}`}
                                                                                    className="w-full h-full object-contain"
                                                                                />
                                                                            </div>
                                                                            <div className="text-sm text-gray-400"></div>
                                                                            <div className="w-12 h-12 bg-gray-50 border rounded flex-shrink-0">
                                                                                {(() => {
                                                                                    let templateImg = null;
                                                                                    if (result.matchType === 'primary') {
                                                                                        templateImg = loadedSymbolImages[`${result.symbol.id}_primary`];
                                                                                    } else if (result.matchType === 'variant' && result.variantIndex !== undefined) {
                                                                                        templateImg = loadedSymbolImages[`${result.symbol.id}_variant_${result.variantIndex}`];
                                                                                    }
                                                                                    
                                                                                    if (templateImg) {
                                                                                        return (
                                                                                            <img 
                                                                                                src={templateImg.src}
                                                                                                alt={`Template: ${result.symbol.name}`}
                                                                                                className="w-full h-full object-contain"
                                                                                            />
                                                                                        );
                                                                                    } else {
                                                                                        return (
                                                                                            <div className="w-full h-full flex items-center justify-center text-xs text-gray-400">
                                                                                                {result.matchType === 'combined' ? 'COMB' : 'N/A'}
                                                                                            </div>
                                                                                        );
                                                                                    }
                                                                                })()}
                                                                            </div>
                                                                        </div>
                                                                    );
                                                                })()}
                                                            </div>
                                                            
                                                            <div>
                                                                <div className="flex items-center gap-2">
                                                                    <span className="font-medium">{result.symbol.name}</span>
                                                                    {result.symbol.arabic && (
                                                                        <span className="text-lg">({result.symbol.arabic})</span>
                                                                    )}
                                                                    <span className={`text-xs px-2 py-1 rounded ${
                                                                        result.matchType === 'primary' ? 'bg-green-100 text-green-700' : 
                                                                        result.matchType === 'variant' ? 'bg-purple-100 text-purple-700' :
                                                                        result.matchType === 'combined' ? 'bg-amber-100 text-amber-700' :
                                                                        result.matchType === 'corrected' ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-700'
                                                                    }`}>
                                                                        {result.matchType === 'combined' ? 'combined' : 
                                                                         result.matchType === 'variant' ? `variant v${result.variantIndex + 1}` : 
                                                                         result.matchType === 'corrected' ? 'user corrected' :
                                                                         result.matchType}
                                                                        {result.matchDetails?.reanalyzed && ' (reanalyzed)'}
                                                                        {result.matchDetails?.manual && ' (manual)'}
                                                                    </span>
                                                                </div>
                                                                <div className="text-xs text-gray-500 mt-1">
                                                                    Position: ({result.position.x}, {result.position.y}) Size: {result.position.width}x{result.position.height}px
                                                                </div>
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-2">
                                                            {/* Validation Controls */}
                                                            <div className="flex items-center gap-1 mr-2">
                                                                {validations[index] ? (
                                                                    <span className={`text-xs px-2 py-1 rounded ${
                                                                        validations[index].isCorrect 
                                                                            ? 'bg-green-100 text-green-700' 
                                                                            : 'bg-red-100 text-red-700'
                                                                    }`}>
                                                                        {validations[index].isCorrect ? 'Validated ' : 'Rejected '}
                                                                    </span>
                                                                ) : (
                                                                    <>
                                                                        <button
                                                                            onClick={() => validateDetection(index, true)}
                                                                            className="text-xs bg-green-600 text-white px-2 py-1 rounded hover:bg-green-700"
                                                                            title="Mark as correct"
                                                                        >
                                                                            
                                                                        </button>
                                                                        <button
                                                                            onClick={() => validateDetection(index, false)}
                                                                            className="text-xs bg-red-600 text-white px-2 py-1 rounded hover:bg-red-700"
                                                                            title="Mark as incorrect"
                                                                        >
                                                                            
                                                                        </button>
                                                                        <button
                                                                            onClick={() => openCorrectionModal(index)}
                                                                            className="text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700"
                                                                            title="Correct this detection"
                                                                        >
                                                                            Fix
                                                                        </button>
                                                                    </>
                                                                )}
                                                            </div>

                                                            {/* Template Addition */}
                                                            <button
                                                                onClick={() => addAsTemplate(index)}
                                                                className="text-xs bg-purple-600 text-white px-2 py-1 rounded hover:bg-purple-700"
                                                                title="Add as template to database"
                                                            >
                                                                + Template
                                                            </button>

                                                            <button
                                                                onClick={() => toggleWordBoundary(index)}
                                                                className={`text-xs px-2 py-1 rounded transition-colors ${
                                                                    wordBoundaries.has(index)
                                                                        ? 'bg-purple-500 text-white'
                                                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                                }`}
                                                                title={wordBoundaries.has(index) ? "Remove word boundary" : "Add word boundary before this symbol"}
                                                            >
                                                                {wordBoundaries.has(index) ? '| Word' : '+ Word'}
                                                            </button>
                                                            {result.matchType === 'combined' && (
                                                                <button
                                                                    onClick={() => reanalyzeCombinedSymbol(index)}
                                                                    className="text-xs bg-green-600 text-white px-2 py-1 rounded hover:bg-green-700"
                                                                    title="Re-analyze this combined symbol"
                                                                >
                                                                    Re-analyze
                                                                </button>
                                                            )}
                                                            <div className="text-right">
                                                                <div className={`px-2 py-1 rounded text-sm font-medium ${
                                                                    result.confidence > 0.7 
                                                                        ? 'bg-green-100 text-green-800' 
                                                                        : result.confidence > 0.5
                                                                            ? 'bg-yellow-100 text-yellow-800'
                                                                            : 'bg-red-100 text-red-800'
                                                                }`}>
                                                                    {(result.confidence * 100).toFixed(0)}%
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            )})}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* Correction Modal */}
                    {showCorrectionModal && correctionTarget !== null && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                                <h3 className="text-lg font-semibold mb-4">Correct Detection</h3>
                                <div className="mb-4">
                                    <p className="text-sm text-gray-600 mb-2">
                                        Current detection: <strong>{recognitionResults[correctionTarget]?.symbol.name}</strong>
                                    </p>
                                    <label className="block text-sm font-medium mb-2">
                                        Select correct symbol:
                                    </label>
                                    
                                    {/* Custom dropdown with images */}
                                    <div className="relative">
                                        <div className="w-full border border-gray-300 rounded px-3 py-2 bg-white cursor-pointer min-h-[40px] flex items-center" 
                                             onClick={() => setShowSymbolDropdown(!showSymbolDropdown)}>
                                            {correctionSymbolId ? (
                                                <div className="flex items-center gap-2">
                                                    <div className="w-8 h-8 bg-gray-100 border rounded flex-shrink-0">
                                                        {(() => {
                                                            const selectedSymbol = equivalenceChart?.symbols?.find(s => s.id === correctionSymbolId);
                                                            const symbolImg = selectedSymbol ? loadedSymbolImages[`${selectedSymbol.id}_primary`] : null;
                                                            
                                                            if (symbolImg) {
                                                                return <img src={symbolImg.src} alt={selectedSymbol.name} className="w-full h-full object-contain" />;
                                                            } else {
                                                                return <div className="w-full h-full flex items-center justify-center text-xs text-gray-400">N/A</div>;
                                                            }
                                                        })()}
                                                    </div>
                                                    <span>
                                                        {equivalenceChart?.symbols?.find(s => s.id === correctionSymbolId)?.name || 'Unknown'} 
                                                        ({equivalenceChart?.symbols?.find(s => s.id === correctionSymbolId)?.arabic || 'N/A'})
                                                    </span>
                                                </div>
                                            ) : (
                                                <span className="text-gray-500">Choose correct symbol...</span>
                                            )}
                                            <div className="ml-auto"></div>
                                        </div>
                                        
                                        {showSymbolDropdown && (
                                            <div className="absolute z-10 w-full max-h-60 overflow-y-auto bg-white border border-gray-300 rounded-b shadow-lg">
                                                {equivalenceChart?.symbols?.map(symbol => (
                                                    <div 
                                                        key={symbol.id} 
                                                        className="flex items-center gap-3 p-2 hover:bg-gray-100 cursor-pointer border-b border-gray-100 last:border-b-0"
                                                        onClick={() => {
                                                            setCorrectionSymbolId(symbol.id);
                                                            setShowSymbolDropdown(false);
                                                        }}
                                                    >
                                                        <div className="w-8 h-8 bg-gray-100 border rounded flex-shrink-0">
                                                            {(() => {
                                                                const symbolImg = loadedSymbolImages[`${symbol.id}_primary`];
                                                                if (symbolImg) {
                                                                    return <img src={symbolImg.src} alt={symbol.name} className="w-full h-full object-contain" />;
                                                                } else {
                                                                    return <div className="w-full h-full flex items-center justify-center text-xs text-gray-400">N/A</div>;
                                                                }
                                                            })()}
                                                        </div>
                                                        <div className="flex-1">
                                                            <div className="font-medium">{symbol.name}</div>
                                                            <div className="text-sm text-gray-500">
                                                                Arabic: {symbol.arabic || 'N/A'}  ID: {symbol.id}
                                                            </div>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                    
                                    {(!equivalenceChart?.symbols || equivalenceChart.symbols.length === 0) && (
                                        <div className="text-sm text-red-600 mt-1">
                                            No symbols loaded. Please reload the chart.
                                        </div>
                                    )}
                                </div>
                                <div className="mb-4">
                                    <label className="block text-sm font-medium mb-2">
                                        Confidence in correction:
                                    </label>
                                    <input
                                        type="range"
                                        min="0.5"
                                        max="1.0"
                                        step="0.1"
                                        value={correctionConfidence}
                                        onChange={(e) => setCorrectionConfidence(parseFloat(e.target.value))}
                                        className="w-full"
                                    />
                                    <div className="text-xs text-gray-500 mt-1">
                                        Current: {Math.round(correctionConfidence * 100)}%
                                    </div>
                                </div>
                                <div className="flex gap-3">
                                    <button
                                        onClick={() => {
                                            console.log('Submit button clicked:', { correctionSymbolId, correctionConfidence });
                                            if (correctionSymbolId) {
                                                submitCorrection(correctionTarget, correctionSymbolId, correctionConfidence);
                                            } else {
                                                alert('Please select a correct symbol');
                                            }
                                        }}
                                        className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
                                        disabled={!correctionSymbolId}
                                    >
                                        Submit Correction
                                    </button>
                                    <button
                                        onClick={() => {
                                            setShowCorrectionModal(false);
                                            setCorrectionTarget(null);
                                            setCorrectionSymbolId('');
                                            setCorrectionConfidence(0.9);
                                            setShowSymbolDropdown(false);
                                        }}
                                        className="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<HakliSymbolRecognizer />);
    </script>
</body>
</html>