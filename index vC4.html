<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Symbol Recognizer - OpenCV Enhanced</title>
    <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useCallback, useEffect } = React;

        const Eye = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                <circle cx="12" cy="12" r="3"/>
            </svg>
        );

        const Upload = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                <polyline points="7,10 12,15 17,10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
        );

        const Zap = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"/>
            </svg>
        );

        const Camera = () => (
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M23 19a2 2 0 01-2 2H3a2 2 0 01-2-2V8a2 2 0 012-2h4l2-3h6l2 3h4a2 2 0 012 2z"/>
                <circle cx="12" cy="13" r="4"/>
            </svg>
        );

        const HakliSymbolRecognizer = () => {
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [uploadedImage, setUploadedImage] = useState(null);
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [chartLoadStatus, setChartLoadStatus] = useState('ready');
            const [loadedSymbolImages, setLoadedSymbolImages] = useState({});
            const [isOpenCVReady, setIsOpenCVReady] = useState(false);
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [isolatedSymbolsDebug, setIsolatedSymbolsDebug] = useState([]);
            const [processingSettings, setProcessingSettings] = useState({
                contrastThreshold: 127,
                minSymbolSize: 15,
                maxSymbolSize: 200,
                detectionSensitivity: 0.4,
                variantMatching: true
            });
            
            const canvasRef = useRef(null);
            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);

            // Format inscription with word boundaries
            const formatInscriptionWithBoundaries = (results) => {
                const sortedResults = results.sort((a, b) => a.position.x - b.position.x);
                const parts = [];
                
                sortedResults.forEach((result, index) => {
                    if (index === 0 || wordBoundaries.has(index)) {
                        if (parts.length > 0) parts.push(' | ');
                    }
                    parts.push(result.symbol.name);
                    if (index < sortedResults.length - 1 && !wordBoundaries.has(index + 1)) {
                        parts.push('-');
                    }
                });
                
                return parts.join('');
            };

            // Format Arabic with word boundaries
            const formatArabicWithBoundaries = (results) => {
                const sortedResults = results.sort((a, b) => a.position.x - b.position.x);
                const parts = [];
                
                sortedResults.forEach((result, index) => {
                    if (index === 0 || wordBoundaries.has(index)) {
                        if (parts.length > 0) parts.push(' ');
                    }
                    parts.push(result.symbol.arabic || result.symbol.name);
                });
                
                return parts.join('');
            };

            // Toggle word boundary before a symbol
            const toggleWordBoundary = (symbolIndex) => {
                setWordBoundaries(prev => {
                    const newBoundaries = new Set(prev);
                    if (newBoundaries.has(symbolIndex)) {
                        newBoundaries.delete(symbolIndex);
                    } else {
                        newBoundaries.add(symbolIndex);
                    }
                    return newBoundaries;
                });
            };

            // Check if OpenCV is ready
            useEffect(() => {
                const checkOpenCV = () => {
                    if (typeof cv !== 'undefined' && cv.Mat) {
                        console.log('✅ OpenCV.js loaded successfully');
                        setIsOpenCVReady(true);
                    } else {
                        console.log('⏳ Waiting for OpenCV.js...');
                        setTimeout(checkOpenCV, 100);
                    }
                };
                checkOpenCV();
            }, []);

            // Convert relative paths to full GitHub URLs
            const convertToGitHubUrl = useCallback((relativePath) => {
                if (!relativePath) return null;
                if (relativePath.startsWith('http')) return relativePath;
                
                const baseUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/';
                const fullUrl = baseUrl + relativePath;
                return fullUrl;
            }, []);

            // Load symbol images from URLs
            const loadSymbolImages = useCallback(async (symbols) => {
                const imageCache = {};
                
                for (const symbol of symbols) {
                    try {
                        if (symbol.images) {
                            // Load primary image
                            if (symbol.images.primary) {
                                try {
                                    const fullUrl = convertToGitHubUrl(symbol.images.primary);
                                    if (fullUrl) {
                                        const img = new Image();
                                        img.crossOrigin = 'anonymous';
                                        await new Promise((resolve, reject) => {
                                            img.onload = () => {
                                                imageCache[`${symbol.id}_primary`] = img;
                                                resolve();
                                            };
                                            img.onerror = reject;
                                            img.src = fullUrl;
                                        });
                                    }
                                } catch (e) {
                                    console.warn(`Failed to load primary image for ${symbol.name}:`, e);
                                }
                            }

                            // Load variant images
                            if (symbol.images.variants && Array.isArray(symbol.images.variants)) {
                                for (let i = 0; i < symbol.images.variants.length; i++) {
                                    try {
                                        const fullUrl = convertToGitHubUrl(symbol.images.variants[i]);
                                        if (fullUrl) {
                                            const img = new Image();
                                            img.crossOrigin = 'anonymous';
                                            await new Promise((resolve, reject) => {
                                                img.onload = () => {
                                                    imageCache[`${symbol.id}_variant_${i}`] = img;
                                                    resolve();
                                                };
                                                img.onerror = reject;
                                                img.src = fullUrl;
                                            });
                                        }
                                    } catch (e) {
                                        console.warn(`Failed to load variant ${i} for ${symbol.name}:`, e);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.warn(`Error processing images for symbol ${symbol.name}:`, error);
                    }
                }
                
                return imageCache;
            }, [convertToGitHubUrl]);

            // Symbol isolation using OpenCV contour detection (from v71)
            const isolateSymbols = useCallback((imageElement) => {
                if (!isOpenCVReady || !imageElement) {
                    console.warn('OpenCV not ready or no image');
                    return [];
                }

                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = imageElement.naturalWidth;
                    canvas.height = imageElement.naturalHeight;
                    ctx.drawImage(imageElement, 0, 0);

                    const src = cv.imread(canvas);
                    const gray = new cv.Mat();
                    const binary = new cv.Mat();
                    const morphKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                    const contours = new cv.MatVector();
                    const hierarchy = new cv.Mat();

                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
                    cv.morphologyEx(binary, binary, cv.MORPH_CLOSE, morphKernel);
                    cv.morphologyEx(binary, binary, cv.MORPH_OPEN, morphKernel);
                    cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    const isolatedSymbols = [];
                    const minArea = processingSettings.minSymbolSize * processingSettings.minSymbolSize;
                    const maxArea = processingSettings.maxSymbolSize * processingSettings.maxSymbolSize;

                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const boundingRect = cv.boundingRect(contour);
                        const area = cv.contourArea(contour);

                        if (area > minArea && area < maxArea) {
                            const aspectRatio = boundingRect.width / boundingRect.height;
                            
                            if (aspectRatio > 0.2 && aspectRatio < 5.0) {
                                const padding = 5;
                                const x = Math.max(0, boundingRect.x - padding);
                                const y = Math.max(0, boundingRect.y - padding);
                                const width = Math.min(src.cols - x, boundingRect.width + 2 * padding);
                                const height = Math.min(src.rows - y, boundingRect.height + 2 * padding);

                                isolatedSymbols.push({
                                    x: x,
                                    y: y,
                                    width: width,
                                    height: height,
                                    area: area,
                                    contour: contour.clone()
                                });
                            }
                        }
                        contour.delete();
                    }

                    src.delete();
                    gray.delete();
                    binary.delete();
                    morphKernel.delete();
                    contours.delete();
                    hierarchy.delete();

                    isolatedSymbols.sort((a, b) => a.x - b.x);
                    console.log(`🔍 Isolated ${isolatedSymbols.length} potential symbols`);
                    
                    // Create debug images of isolated symbols
                    const debugSymbols = isolatedSymbols.map((symbol, index) => {
                        const debugCanvas = document.createElement('canvas');
                        const debugCtx = debugCanvas.getContext('2d');
                        debugCanvas.width = symbol.width;
                        debugCanvas.height = symbol.height;
                        
                        debugCtx.drawImage(
                            canvas, 
                            symbol.x, symbol.y, symbol.width, symbol.height,
                            0, 0, symbol.width, symbol.height
                        );
                        
                        return {
                            id: index,
                            dataUrl: debugCanvas.toDataURL(),
                            bounds: symbol,
                            area: symbol.area
                        };
                    });
                    
                    // Store debug info
                    setIsolatedSymbolsDebug(debugSymbols);
                    
                    return isolatedSymbols;

                } catch (error) {
                    console.error('Error in symbol isolation:', error);
                    return [];
                }
            }, [isOpenCVReady, processingSettings]);

            const loadChart = useCallback(() => {
                const loadChartInternal = async () => {
                    setChartLoadStatus('loading');
                    
                    const githubJsonUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/Hakli_symbols.JSON';
                    
                    try {
                        console.log('📡 Fetching JSON from:', githubJsonUrl);
                        const response = await fetch(githubJsonUrl);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const chartData = await response.json();
                        console.log('✅ JSON loaded successfully');
                        
                        const processedChart = {
                            symbols: chartData.symbols.map(symbol => ({
                                ...symbol,
                                confidence_weights: {
                                    primary: 1.0,
                                    variants: 0.9
                                }
                            }))
                        };
                        
                        setEquivalenceChart(processedChart);
                        setChartLoadStatus('loaded');
                        
                        console.log('🖼️ Loading symbol images...');
                        const imageCache = await loadSymbolImages(processedChart.symbols);
                        console.log('✅ Image loading complete. Loaded count:', Object.keys(imageCache).length);
                        setLoadedSymbolImages(imageCache);
                        
                    } catch (error) {
                        console.error('❌ Error loading chart from GitHub:', error);
                        setChartLoadStatus('error');
                    }
                };
                
                loadChartInternal();
            }, [loadSymbolImages]);

            // Auto-load chart on startup
            useEffect(() => {
                loadChart();
            }, [loadChart]);

            // Handle image upload
            const handleImageUpload = useCallback((event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setUploadedImage(e.target.result);
                        setRecognitionResults([]);
                    };
                    reader.readAsDataURL(file);
                }
            }, []);

            // Template matching function for isolated symbols
            const templateMatchIsolated = useCallback((isolatedSymbol, templateImg) => {
                if (!isOpenCVReady || !templateImg) return null;

                try {
                    // Validate image dimensions
                    if (templateImg.width === 0 || templateImg.height === 0) {
                        console.warn('Template image has invalid dimensions');
                        return null;
                    }

                    const symbolCanvas = document.createElement('canvas');
                    const symbolCtx = symbolCanvas.getContext('2d');
                    symbolCanvas.width = isolatedSymbol.width;
                    symbolCanvas.height = isolatedSymbol.height;
                    
                    symbolCtx.drawImage(
                        imageRef.current,
                        isolatedSymbol.x, isolatedSymbol.y, isolatedSymbol.width, isolatedSymbol.height,
                        0, 0, isolatedSymbol.width, isolatedSymbol.height
                    );

                    const symbolMat = cv.imread(symbolCanvas);
                    const templateCanvas = document.createElement('canvas');
                    const templateCtx = templateCanvas.getContext('2d');
                    templateCanvas.width = templateImg.width;
                    templateCanvas.height = templateImg.height;
                    templateCtx.drawImage(templateImg, 0, 0);
                    const templateMat = cv.imread(templateCanvas);

                    const result = new cv.Mat();
                    const resizedTemplate = new cv.Mat();
                    const symbolSize = new cv.Size(isolatedSymbol.width, isolatedSymbol.height);
                    cv.resize(templateMat, resizedTemplate, symbolSize);

                    const symbolGray = new cv.Mat();
                    const templateGray = new cv.Mat();
                    cv.cvtColor(symbolMat, symbolGray, cv.COLOR_RGBA2GRAY);
                    cv.cvtColor(resizedTemplate, templateGray, cv.COLOR_RGBA2GRAY);

                    cv.matchTemplate(symbolGray, templateGray, result, cv.TM_CCOEFF_NORMED);
                    
                    const minMaxLoc = cv.minMaxLoc(result);
                    const confidence = minMaxLoc.maxVal;

                    symbolMat.delete();
                    templateMat.delete();
                    resizedTemplate.delete();
                    symbolGray.delete();
                    templateGray.delete();
                    result.delete();

                    return {
                        confidence: confidence,
                        position: {
                            x: isolatedSymbol.x,
                            y: isolatedSymbol.y,
                            width: isolatedSymbol.width,
                            height: isolatedSymbol.height
                        }
                    };

                } catch (error) {
                    console.error('Template matching error:', error.message || error);
                    return null;
                }
            }, [isOpenCVReady]);

            // Enhanced symbol detection with isolation (from v71)
            const detectSymbols = useCallback(async () => {
                if (!uploadedImage || !equivalenceChart || !imageRef.current) {
                    console.log('Missing requirements for detection');
                    return;
                }
                
                setIsProcessing(true);
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                console.log('🔍 Starting symbol isolation...');
                const isolatedSymbols = isolateSymbols(imageRef.current);
                
                if (isolatedSymbols.length === 0) {
                    console.warn('No symbols isolated');
                    setIsProcessing(false);
                    return;
                }

                console.log(`📊 Found ${isolatedSymbols.length} isolated symbols, now matching...`);
                console.log(`🖼️ Available symbol images: ${Object.keys(loadedSymbolImages).length}`);
                
                const detectionResults = [];
                let matchAttempts = 0;
                let successfulMatches = 0;
                
                for (let i = 0; i < isolatedSymbols.length; i++) {
                    const isolatedSymbol = isolatedSymbols[i];
                    let bestMatch = null;
                    
                    console.log(`🔍 Testing isolated symbol #${i + 1} (${isolatedSymbol.width}x${isolatedSymbol.height}, area: ${isolatedSymbol.area.toFixed(0)})`);
                    
                    for (const symbol of equivalenceChart.symbols) {
                        const primaryImg = loadedSymbolImages[`${symbol.id}_primary`];
                        if (primaryImg) {
                            matchAttempts++;
                            const match = templateMatchIsolated(isolatedSymbol, primaryImg);
                            const confidence = match ? match.confidence : 0;
                            
                            if (match && confidence > processingSettings.detectionSensitivity) {
                                console.log(`${symbol.name} (primary): ${confidence.toFixed(4)} ✅`);
                                if (!bestMatch || confidence > bestMatch.confidence) {
                                    bestMatch = {
                                        ...match,
                                        symbol: symbol,
                                        matchType: 'primary',
                                        confidence: confidence
                                    };
                                }
                            }
                        }
                        
                        if (processingSettings.variantMatching && symbol.images.variants) {
                            symbol.images.variants.forEach((variantPath, index) => {
                                const variantImg = loadedSymbolImages[`${symbol.id}_variant_${index}`];
                                if (variantImg) {
                                    matchAttempts++;
                                    const match = templateMatchIsolated(isolatedSymbol, variantImg);
                                    const confidence = match ? match.confidence : 0;
                                    const threshold = processingSettings.detectionSensitivity * 0.9;
                                    
                                    if (match && confidence > threshold) {
                                        console.log(`${symbol.name} (variant ${index + 1}): ${confidence.toFixed(4)} ✅`);
                                        const weightedConfidence = confidence * 0.9;
                                        if (!bestMatch || weightedConfidence > bestMatch.confidence) {
                                            bestMatch = {
                                                ...match,
                                                symbol: symbol,
                                                matchType: 'variant',
                                                variantIndex: index,
                                                confidence: weightedConfidence
                                            };
                                        }
                                    }
                                }
                            });
                        }
                    }
                    
                    if (bestMatch) {
                        successfulMatches++;
                        detectionResults.push({
                            symbol: bestMatch.symbol,
                            confidence: Math.min(0.95, bestMatch.confidence),
                            position: bestMatch.position,
                            matchDetails: {
                                type: bestMatch.matchType,
                                variantIndex: bestMatch.variantIndex,
                                scale: 1.0,
                                isolatedIndex: i
                            },
                            matchType: bestMatch.matchType,
                            variantIndex: bestMatch.variantIndex
                        });
                    }
                }
                
                // Clean up contours
                isolatedSymbols.forEach(symbol => {
                    if (symbol.contour) {
                        symbol.contour.delete();
                    }
                });
                
                console.log(`✅ Detection complete: ${detectionResults.length} symbols matched out of ${isolatedSymbols.length} isolated`);
                console.log(`📊 Total match attempts: ${matchAttempts}, Successful matches: ${successfulMatches}`);
                
                setRecognitionResults(detectionResults);
                setIsProcessing(false);
            }, [uploadedImage, equivalenceChart, loadedSymbolImages, processingSettings, isolateSymbols, templateMatchIsolated, isOpenCVReady]);

            // Fixed detection results drawing with proper alignment
            const drawDetectionResults = useCallback(() => {
                if (!canvasRef.current || !imageRef.current || !imageContainerRef.current || recognitionResults.length === 0) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;
                const container = imageContainerRef.current;
                
                // Wait for image to be fully loaded and rendered
                if (img.naturalWidth === 0 || img.naturalHeight === 0 || img.offsetWidth === 0 || img.offsetHeight === 0) {
                    setTimeout(drawDetectionResults, 100);
                    return;
                }

                // Get the actual position and size of the image within its container
                const containerRect = container.getBoundingClientRect();
                const imgRect = img.getBoundingClientRect();
                
                // Calculate the offset of the image within its container
                const offsetX = imgRect.left - containerRect.left;
                const offsetY = imgRect.top - containerRect.top;
                
                // Set canvas size to match the container
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
                canvas.style.width = container.offsetWidth + 'px';
                canvas.style.height = container.offsetHeight + 'px';
                
                // Position canvas to exactly overlay the container
                canvas.style.left = '0px';
                canvas.style.top = '0px';
                
                // Calculate scaling factors from natural image size to displayed image size
                const scaleX = img.offsetWidth / img.naturalWidth;
                const scaleY = img.offsetHeight / img.naturalHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                console.log('🎯 Drawing detection boxes with improved alignment:', {
                    imageNatural: `${img.naturalWidth}x${img.naturalHeight}`,
                    imageDisplay: `${img.offsetWidth}x${img.offsetHeight}`,
                    containerSize: `${container.offsetWidth}x${container.offsetHeight}`,
                    imageOffset: `${offsetX.toFixed(1)}, ${offsetY.toFixed(1)}`,
                    scale: `${scaleX.toFixed(3)}x${scaleY.toFixed(3)}`,
                    results: recognitionResults.length
                });
                
                recognitionResults.forEach((result, index) => {
                    const { position, matchType, symbol } = result;
                    
                    // Scale coordinates from natural image size to display size, then add image offset
                    const x = (position.x * scaleX) + offsetX;
                    const y = (position.y * scaleY) + offsetY;
                    const width = position.width * scaleX;
                    const height = position.height * scaleY;
                    
                    console.log(`📍 Symbol ${index + 1} (${result.symbol.name}):`, {
                        originalCoords: `${position.x},${position.y} ${position.width}x${position.height}`,
                        scaledCoords: `${(position.x * scaleX).toFixed(1)},${(position.y * scaleY).toFixed(1)} ${(position.width * scaleX).toFixed(1)}x${(position.height * scaleY).toFixed(1)}`,
                        finalCoords: `${x.toFixed(1)},${y.toFixed(1)} ${width.toFixed(1)}x${height.toFixed(1)}`
                    });
                    
                    // Color coding and line style for match types
                    let color = '#10b981'; // green for primary
                    if (matchType === 'variant') {
                        ctx.setLineDash([4, 4]); // dashed line for variants
                        color = '#8b5cf6'; // purple for variants
                    } else {
                        ctx.setLineDash([]);
                    }
                    
                    // Draw bounding box
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, width, height);
                    ctx.setLineDash([]);
                    
                    // Add character label with better positioning
                    const character = symbol.arabic || symbol.name;
                    const labelText = character.length > 3 ? symbol.name : character;
                    
                    ctx.font = 'bold 14px Arial';
                    const textMetrics = ctx.measureText(labelText);
                    const textWidth = textMetrics.width + 8;
                    const textHeight = 18;
                    
                    // Position label above the box (or below if too close to top)
                    const labelX = x;
                    const labelY = y - textHeight > 0 ? y - 2 : y + height + textHeight;
                    
                    // Draw label background
                    ctx.fillStyle = color;
                    ctx.fillRect(labelX, labelY - textHeight + 2, textWidth, textHeight);
                    
                    // Draw label text
                    ctx.fillStyle = 'white';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(labelText, labelX + 4, labelY - textHeight/2 + 2);
                    ctx.textBaseline = 'alphabetic'; // reset to default
                    
                    // Optional: Draw confidence indicator
                    const confidenceText = `${(result.confidence * 100).toFixed(0)}%`;
                    ctx.font = '10px Arial';
                    const confWidth = ctx.measureText(confidenceText).width + 4;
                    
                    // Position confidence at bottom-right of box
                    const confX = x + width - confWidth;
                    const confY = y + height - 2;
                    
                    if (confY > textHeight) { // Only show if there's space
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(confX, confY - 12, confWidth, 14);
                        ctx.fillStyle = 'white';
                        ctx.fillText(confidenceText, confX + 2, confY - 2);
                    }
                });
                
                // Reset font
                ctx.font = 'bold 14px Arial';
            }, [recognitionResults]);

            // Trigger drawing when results change or image loads
            useEffect(() => {
                if (uploadedImage && recognitionResults.length > 0) {
                    const timer = setTimeout(drawDetectionResults, 300);
                    return () => clearTimeout(timer);
                }
            }, [uploadedImage, recognitionResults, drawDetectionResults]);

            // Also redraw when window resizes
            useEffect(() => {
                const handleResize = () => {
                    if (recognitionResults.length > 0) {
                        setTimeout(drawDetectionResults, 100);
                    }
                };
                
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [recognitionResults, drawDetectionResults]);

            return (
                <div className="max-w-6xl mx-auto p-4 bg-gray-50 min-h-screen">
                    <div className="bg-white rounded-lg shadow-lg p-6">
                        <h1 className="text-3xl font-bold text-gray-800 mb-4 flex items-center gap-3">
                            <Eye />
                            Hakli Symbol Recognizer
                            <span className="text-sm font-normal text-gray-500 ml-2">based on Ahmad Al-Jallad (2025), The Decipherment of the Dhofari Script</span>
                        </h1>