<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Glyph Recognizer</title>
    <meta name="description" content="Ancient South Arabian script recognition tool">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#5d4e6d">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <!-- React & Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'ancient-purple': '#5d4e6d',
                        'stone': '#8b7d6b',
                        'patina': '#6b8e7f',
                        'ochre': '#b8956a',
                        'rust': '#a0674f',
                    }
                }
            }
        }
    </script>
    
    <!-- OpenCV -->
    <script>
        var isOpenCvReady = false;
        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('‚úÖ OpenCV.js is ready');
            window.dispatchEvent(new Event('opencv-ready'));
        }
    </script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <style>
        .detection-box {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
            border: 3px solid;
            border-radius: 4px;
            cursor: pointer;
        }
        .detection-box.validated-correct { border-color: #6b8e7f; background: rgba(107, 142, 127, 0.25); }
        .detection-box.validated-incorrect { border-color: #a0674f; background: rgba(239, 68, 68, 0.25); }
        .detection-box.unvalidated { border-color: #8b7d6b; background: rgba(59, 130, 246, 0.25); }
        .detection-box.selected { border-color: #b8956a; background: rgba(245, 158, 11, 0.3); border-width: 4px; }
        .detection-box.uncertain { border-style: dashed; }
        .detection-label {
            position: absolute;
            top: -22px;
            left: 0;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: bold;
            color: white;
            border-radius: 3px;
        }
        .reading-order-badge {
            position: absolute;
            top: -16px;
            left: -16px;
            width: 22px;
            height: 22px;
            background: #b8956a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            z-index: 20;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <!-- Core modules (must load first) -->
    <script src="src/core/config.js"></script>
    <script src="src/utils/helpers.js"></script>
    
    <!-- Storage modules -->
    <script src="src/storage/hki.js"></script>
    <script src="src/storage/cache.js"></script>
    <script src="src/storage/corrections.js"></script>
    <script src="src/storage/drive-sync.js"></script>
    
    <!-- Recognition modules -->
    <script src="src/recognition/preprocessing.js"></script>
    <script src="src/recognition/isolation.js"></script>
    <script src="src/recognition/matching.js"></script>
    <script src="src/recognition/nms.js"></script>
    <script src="src/recognition/validation.js"></script>
    <script src="src/recognition/template-learning.js"></script>
    
    <!-- Reading modules -->
    <script src="src/reading/reading.js"></script>
    <script src="src/reading/transcription.js"></script>

    <!-- Main Application -->
    <script type="text/babel">
        const APP_VERSION = 'v251224';
        console.log('üöÄ Hakli Glyph Recognizer ' + APP_VERSION);

        function HakliGlyphRecognizer() {
            const { useState, useEffect, useRef, useCallback, useMemo } = React;
            
            // ========== STATE ==========
            const [originalImage, setOriginalImage] = useState(null);
            const [displayImage, setDisplayImage] = useState(null);
            const [isImageLoading, setIsImageLoading] = useState(false);
            
            const [chartData, setChartData] = useState(null);
            const [chartStatus, setChartStatus] = useState('not-loaded');
            const [loadedGlyphImages, setLoadedGlyphImages] = useState({});
            const [glyphThumbnails, setGlyphThumbnails] = useState({});
            const [chartLoadProgress, setChartLoadProgress] = useState({ loaded: 0, total: 0 });
            
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [validations, setValidations] = useState({});
            const [isProcessing, setIsProcessing] = useState(false);
            const [processingStatus, setProcessingStatus] = useState('');
            
            const [viewMode, setViewMode] = useState('detection');
            const [readingDirection, setReadingDirection] = useState('rtl');
            const [readingOrder, setReadingOrder] = useState([]);
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [lineBreaks, setLineBreaks] = useState(new Set());
            
            const [selectedRegions, setSelectedRegions] = useState(new Set());
            const [showArabicLabels, setShowArabicLabels] = useState(false);
            const [isPreprocessingCollapsed, setIsPreprocessingCollapsed] = useState(false);
            
            const [preprocessing, setPreprocessing] = useState({
                rotation: 0,
                useAdaptiveThreshold: false,
                blockSize: 11,
                constantOffset: 2,
                gaussianBlur: 0,
                morphologyOperation: 'none',
                invertColors: false
            });
            
            const [opencvReady, setOpencvReady] = useState(false);
            const originalMatRef = useRef(null);
            const preprocessedMatRef = useRef(null);
            
            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);
            const fileInputRef = useRef(null);
            
            // ========== OPENCV SETUP ==========
            useEffect(() => {
                const checkOpenCV = () => {
                    if (typeof cv !== 'undefined' && cv.Mat) {
                        setOpencvReady(true);
                        console.log('‚úÖ OpenCV ready in React');
                    } else {
                        setTimeout(checkOpenCV, 100);
                    }
                };
                checkOpenCV();
                
                return () => {
                    if (originalMatRef.current) try { originalMatRef.current.delete(); } catch(e) {}
                    if (preprocessedMatRef.current) try { preprocessedMatRef.current.delete(); } catch(e) {}
                };
            }, []);
            
            // ========== LOAD CHART ==========
            useEffect(() => {
                const loadChart = async () => {
                    setChartStatus('loading');
                    try {
                        const response = await fetch('Hakli_glyphs.JSON');
                        const data = await response.json();
                        setChartData(data);
                        console.log(`üìú Loaded chart with ${data.glyphs.length} glyphs`);
                        
                        let loaded = 0;
                        const total = data.glyphs.length;
                        const newImages = {};
                        const newThumbnails = {};
                        
                        for (const glyph of data.glyphs) {
                            if (glyph.images?.primary) {
                                try {
                                    const img = new Image();
                                    img.crossOrigin = 'anonymous';
                                    await new Promise((resolve, reject) => {
                                        img.onload = resolve;
                                        img.onerror = reject;
                                        img.src = glyph.images.primary;
                                    });
                                    newImages[glyph.id] = img;
                                    newThumbnails[glyph.id] = img.src;
                                } catch (e) {
                                    console.warn(`Failed to load glyph ${glyph.id}`);
                                }
                            }
                            loaded++;
                            setChartLoadProgress({ loaded, total });
                        }
                        
                        setLoadedGlyphImages(newImages);
                        setGlyphThumbnails(newThumbnails);
                        setChartStatus('loaded');
                        console.log(`‚úÖ Loaded ${Object.keys(newImages).length} glyph images`);
                    } catch (error) {
                        console.error('Failed to load chart:', error);
                        setChartStatus('error');
                    }
                };
                loadChart();
            }, []);
            
            // ========== IMAGE HANDLING ==========
            const loadImageToMat = useCallback((imageSource) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = img.naturalWidth;
                            canvas.height = img.naturalHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            const mat = cv.imread(canvas);
                            resolve(mat);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = imageSource;
                });
            }, []);
            
            const matToDataUrl = useCallback((mat) => {
                const canvas = document.createElement('canvas');
                cv.imshow(canvas, mat);
                return canvas.toDataURL('image/png');
            }, []);
            
            const handleImageUpload = useCallback(async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                setIsImageLoading(true);
                
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const dataUrl = e.target.result;
                    setOriginalImage(dataUrl);
                    setDisplayImage(dataUrl);
                    
                    if (opencvReady) {
                        try {
                            if (originalMatRef.current) originalMatRef.current.delete();
                            originalMatRef.current = await loadImageToMat(dataUrl);
                            console.log('‚úÖ Image loaded:', originalMatRef.current.cols, 'x', originalMatRef.current.rows);
                        } catch (error) {
                            console.error('Failed to load image to OpenCV:', error);
                        }
                    }
                    
                    setRecognitionResults([]);
                    setValidations({});
                    setReadingOrder([]);
                    setWordBoundaries(new Set());
                    setLineBreaks(new Set());
                    setSelectedRegions(new Set());
                    setIsImageLoading(false);
                };
                reader.onerror = () => {
                    alert('Failed to read image file');
                    setIsImageLoading(false);
                };
                reader.readAsDataURL(file);
            }, [opencvReady, loadImageToMat]);
            
            // ========== PREPROCESSING ==========
            const applyPreprocessing = useCallback(async () => {
                if (!originalMatRef.current || !opencvReady) {
                    console.warn('No image or OpenCV not ready');
                    return;
                }
                
                try {
                    // Use the Preprocessing module if available
                    if (typeof Preprocessing !== 'undefined' && Preprocessing.processImageWithSettings) {
                        if (preprocessedMatRef.current) preprocessedMatRef.current.delete();
                        preprocessedMatRef.current = Preprocessing.processImageWithSettings(
                            originalMatRef.current, 
                            preprocessing
                        );
                        const dataUrl = matToDataUrl(preprocessedMatRef.current);
                        setDisplayImage(dataUrl);
                        console.log('‚úÖ Preprocessing applied via Preprocessing module');
                    } else {
                        // Fallback: manual preprocessing
                        if (preprocessedMatRef.current) preprocessedMatRef.current.delete();
                        
                        let result = originalMatRef.current.clone();
                        
                        // Rotation
                        if (preprocessing.rotation !== 0) {
                            const center = new cv.Point(result.cols / 2, result.rows / 2);
                            const rotMatrix = cv.getRotationMatrix2D(center, -preprocessing.rotation, 1.0);
                            const cos = Math.abs(rotMatrix.doubleAt(0, 0));
                            const sin = Math.abs(rotMatrix.doubleAt(0, 1));
                            const newWidth = Math.floor(result.rows * sin + result.cols * cos);
                            const newHeight = Math.floor(result.rows * cos + result.cols * sin);
                            rotMatrix.doublePtr(0, 2)[0] += (newWidth - result.cols) / 2;
                            rotMatrix.doublePtr(1, 2)[0] += (newHeight - result.rows) / 2;
                            const rotated = new cv.Mat();
                            cv.warpAffine(result, rotated, rotMatrix, new cv.Size(newWidth, newHeight), 
                                cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255, 255, 255, 255));
                            result.delete();
                            rotMatrix.delete();
                            result = rotated;
                        }
                        
                        // Grayscale
                        let gray = new cv.Mat();
                        if (result.channels() === 4) cv.cvtColor(result, gray, cv.COLOR_RGBA2GRAY);
                        else if (result.channels() === 3) cv.cvtColor(result, gray, cv.COLOR_RGB2GRAY);
                        else gray = result.clone();
                        
                        // Blur
                        if (preprocessing.gaussianBlur > 0) {
                            const ksize = preprocessing.gaussianBlur % 2 === 0 ? preprocessing.gaussianBlur + 1 : preprocessing.gaussianBlur;
                            cv.GaussianBlur(gray, gray, new cv.Size(ksize, ksize), 0);
                        }
                        
                        // Threshold
                        if (preprocessing.useAdaptiveThreshold) {
                            const blockSize = preprocessing.blockSize % 2 === 0 ? preprocessing.blockSize + 1 : preprocessing.blockSize;
                            cv.adaptiveThreshold(gray, gray, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, blockSize, preprocessing.constantOffset);
                        }
                        
                        // Morphology
                        if (preprocessing.morphologyOperation !== 'none') {
                            const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                            const morphed = new cv.Mat();
                            switch (preprocessing.morphologyOperation) {
                                case 'erode': cv.erode(gray, morphed, kernel); break;
                                case 'dilate': cv.dilate(gray, morphed, kernel); break;
                                case 'open': cv.morphologyEx(gray, morphed, cv.MORPH_OPEN, kernel); break;
                                case 'close': cv.morphologyEx(gray, morphed, cv.MORPH_CLOSE, kernel); break;
                                default: gray.copyTo(morphed);
                            }
                            gray.delete();
                            kernel.delete();
                            gray = morphed;
                        }
                        
                        // Invert
                        if (preprocessing.invertColors) {
                            cv.bitwise_not(gray, gray);
                        }
                        
                        result.delete();
                        preprocessedMatRef.current = gray;
                        
                        const dataUrl = matToDataUrl(gray);
                        setDisplayImage(dataUrl);
                        console.log('‚úÖ Preprocessing applied (fallback)');
                    }
                } catch (error) {
                    console.error('Preprocessing error:', error);
                    alert('Preprocessing failed: ' + error.message);
                }
            }, [preprocessing, opencvReady, matToDataUrl]);
            
            const resetPreprocessing = useCallback(() => {
                setPreprocessing({
                    rotation: 0,
                    useAdaptiveThreshold: false,
                    blockSize: 11,
                    constantOffset: 2,
                    gaussianBlur: 0,
                    morphologyOperation: 'none',
                    invertColors: false
                });
                if (originalImage) setDisplayImage(originalImage);
                if (preprocessedMatRef.current) {
                    preprocessedMatRef.current.delete();
                    preprocessedMatRef.current = null;
                }
            }, [originalImage]);
            
            // ========== RECOGNITION ==========
            const recognizeGlyphs = useCallback(async () => {
                if (!displayImage || !chartData || Object.keys(loadedGlyphImages).length === 0) {
                    alert('‚ùå Please load an image and wait for the glyph chart to load');
                    return;
                }
                
                if (!opencvReady) {
                    alert('‚ùå OpenCV not ready yet');
                    return;
                }
                
                setIsProcessing(true);
                setRecognitionResults([]);
                setValidations({});
                setProcessingStatus('Isolating glyphs...');
                
                try {
                    console.log('üîç Starting glyph recognition...');
                    
                    // Get the mat to use (preprocessed or original)
                    let inputMat = preprocessedMatRef.current || originalMatRef.current;
                    if (!inputMat) {
                        inputMat = await loadImageToMat(displayImage);
                    }
                    
                    // Clone for isolation (Isolation module may modify it)
                    const matForIsolation = inputMat.clone();
                    
                    // Step 1: Isolate potential glyph regions
                    let regions = [];
                    if (typeof Isolation !== 'undefined' && Isolation.isolateGlyphs) {
                        try {
                            regions = Isolation.isolateGlyphs(matForIsolation);
                            console.log(`üì¶ Isolated ${regions.length} regions via Isolation module`);
                        } catch (e) {
                            console.error('Isolation module error:', e);
                            // Fallback
                            regions = await fallbackIsolation(inputMat);
                        }
                    } else {
                        regions = await fallbackIsolation(inputMat);
                    }
                    
                    matForIsolation.delete();
                    
                    if (regions.length === 0) {
                        alert('‚ö†Ô∏è No glyph regions detected. Try adjusting preprocessing settings.');
                        setIsProcessing(false);
                        return;
                    }
                    
                    // Filter overlapping regions
                    if (typeof Isolation !== 'undefined' && Isolation.filterOverlappingRegions) {
                        regions = Isolation.filterOverlappingRegions(regions, 0.3);
                    }
                    
                    setProcessingStatus(`Matching ${regions.length} regions...`);
                    
                    // Step 2: Match each region against templates
                    const allDetections = [];
                    
                    for (let i = 0; i < regions.length; i++) {
                        const region = regions[i];
                        setProcessingStatus(`Matching region ${i + 1}/${regions.length}...`);
                        
                        // Get position from region
                        const position = region.bounds || region;
                        
                        // Match against all glyphs
                        const regionDetections = [];
                        
                        for (const glyph of chartData.glyphs) {
                            const templateImg = loadedGlyphImages[glyph.id];
                            if (!templateImg) continue;
                            
                            // Simple shape-based matching (aspect ratio comparison)
                            const regionAspect = position.width / position.height;
                            const templateAspect = templateImg.naturalWidth / templateImg.naturalHeight;
                            const aspectDiff = Math.abs(regionAspect - templateAspect);
                            let confidence = Math.max(0, 1 - aspectDiff * 0.5);
                            
                            // Add solidity bonus if available
                            if (region.solidity && glyph.expected_solidity) {
                                const solidityDiff = Math.abs(region.solidity - glyph.expected_solidity);
                                confidence += Math.max(0, 1 - solidityDiff) * 0.2;
                            }
                            
                            if (confidence > 0.35) {
                                regionDetections.push({
                                    glyph: glyph,
                                    confidence: Math.min(confidence, 0.99),
                                    position: position,
                                    thumbnail: region.thumbnail || null
                                });
                            }
                        }
                        
                        // Keep best match
                        if (regionDetections.length > 0) {
                            regionDetections.sort((a, b) => b.confidence - a.confidence);
                            const best = regionDetections[0];
                            best.topMatches = regionDetections.slice(0, 5);
                            allDetections.push(best);
                        }
                    }
                    
                    setProcessingStatus('Applying NMS...');
                    
                    // Step 3: Apply NMS
                    let finalDetections = allDetections;
                    if (typeof NMS !== 'undefined' && NMS.applyNMS) {
                        finalDetections = NMS.applyNMS(allDetections, CONFIG.RECOGNITION.IOU_THRESHOLD);
                    } else {
                        // Simple NMS fallback
                        finalDetections = simpleNMS(allDetections, 0.3);
                    }
                    
                    console.log(`‚ú® Final detections: ${finalDetections.length}`);
                    setRecognitionResults(finalDetections);
                    
                    // Step 4: Auto-detect reading order
                    if (finalDetections.length > 0) {
                        if (typeof ReadingOrder !== 'undefined' && ReadingOrder.generateOrder) {
                            const order = ReadingOrder.generateOrder(finalDetections, readingDirection);
                            setReadingOrder(order);
                        } else {
                            // Simple fallback
                            const order = finalDetections
                                .map((d, i) => ({ i, x: d.position.x, y: d.position.y }))
                                .sort((a, b) => {
                                    const rowDiff = Math.floor(a.y / 50) - Math.floor(b.y / 50);
                                    if (rowDiff !== 0) return rowDiff;
                                    return readingDirection === 'rtl' ? b.x - a.x : a.x - b.x;
                                })
                                .map(d => d.i);
                            setReadingOrder(order);
                        }
                    }
                    
                    alert(`‚úÖ Recognition complete! Found ${finalDetections.length} glyphs`);
                    
                } catch (error) {
                    console.error('Recognition error:', error);
                    alert('‚ùå Recognition failed: ' + error.message);
                } finally {
                    setIsProcessing(false);
                    setProcessingStatus('');
                }
            }, [displayImage, chartData, loadedGlyphImages, opencvReady, loadImageToMat, readingDirection]);
            
            // Fallback isolation
            const fallbackIsolation = async (mat) => {
                const regions = [];
                try {
                    let gray = new cv.Mat();
                    if (mat.channels() > 1) cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
                    else gray = mat.clone();
                    
                    let binary = new cv.Mat();
                    cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
                    
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                    
                    const imageArea = mat.rows * mat.cols;
                    const minArea = imageArea * 0.0005;
                    const maxArea = imageArea * 0.15;
                    
                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const area = cv.contourArea(contour);
                        
                        if (area < minArea || area > maxArea) continue;
                        
                        const rect = cv.boundingRect(contour);
                        const aspectRatio = rect.width / rect.height;
                        
                        if (aspectRatio < 0.2 || aspectRatio > 5.0) continue;
                        
                        // Extract thumbnail
                        const roi = mat.roi(new cv.Rect(rect.x, rect.y, rect.width, rect.height));
                        const canvas = document.createElement('canvas');
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                        cv.imshow(canvas, roi);
                        roi.delete();
                        
                        regions.push({
                            bounds: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },
                            area: area,
                            aspectRatio: aspectRatio,
                            solidity: area / (rect.width * rect.height),
                            thumbnail: canvas.toDataURL()
                        });
                    }
                    
                    gray.delete();
                    binary.delete();
                    contours.delete();
                    hierarchy.delete();
                } catch (e) {
                    console.error('Fallback isolation error:', e);
                }
                return regions;
            };
            
            // Simple NMS
            const simpleNMS = (detections, threshold) => {
                const sorted = [...detections].sort((a, b) => b.confidence - a.confidence);
                const kept = [];
                for (const det of sorted) {
                    let dominated = false;
                    for (const kept_det of kept) {
                        const iou = Utils.calculateIoU(det.position, kept_det.position);
                        if (iou > threshold) { dominated = true; break; }
                    }
                    if (!dominated) kept.push(det);
                }
                return kept;
            };
            
            // ========== VALIDATION ==========
            const validateDetection = useCallback((index, isCorrect) => {
                setValidations(prev => ({
                    ...prev,
                    [index]: { isCorrect, timestamp: new Date().toISOString() }
                }));
            }, []);
            
            const deleteDetection = useCallback((index) => {
                setRecognitionResults(prev => prev.filter((_, i) => i !== index));
                setValidations(prev => {
                    const updated = {};
                    Object.entries(prev).forEach(([k, v]) => {
                        const oldIdx = parseInt(k);
                        if (oldIdx < index) updated[oldIdx] = v;
                        else if (oldIdx > index) updated[oldIdx - 1] = v;
                    });
                    return updated;
                });
                setReadingOrder(prev => prev.filter(i => i !== index).map(i => i > index ? i - 1 : i));
            }, []);

            // ============================================
            // RENDER
            // ============================================
            return (
                <div className="min-h-screen bg-gray-100 flex flex-col">
                    {/* Header */}
                    <header className="bg-ancient-purple text-white shadow-lg flex-shrink-0">
                        <div className="max-w-7xl mx-auto px-4 py-2">
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                    <span className="text-2xl">üìú</span>
                                    <div>
                                        <h1 className="text-base font-bold leading-tight">Hakli Glyph Recognizer</h1>
                                        <p className="text-xs text-purple-200 leading-tight">
                                            Based on Ahmad Al-Jallad (2025), <em>The Decipherment of the Dhofari Script</em>
                                        </p>
                                        <p className="text-xs text-purple-300 leading-tight">
                                            beta {APP_VERSION} ¬© hoopoe holdings
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="flex items-center gap-2">
                                    <div className={`px-2 py-1 rounded-full text-xs ${chartStatus === 'loaded' ? 'bg-patina' : 'bg-ochre'}`}>
                                        {chartStatus === 'loaded' ? `‚úÖ ${chartData?.glyphs?.length || 0} glyphs` : `‚è≥ Loading...`}
                                    </div>
                                    <div className={`px-2 py-1 rounded-full text-xs ${opencvReady ? 'bg-patina' : 'bg-ochre'}`}>
                                        {opencvReady ? '‚úÖ CV' : '‚è≥ CV'}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </header>
                    
                    {/* Main Content */}
                    <main className="flex-1 max-w-7xl w-full mx-auto px-4 py-4">
                        <div className="grid grid-cols-12 gap-4">
                            {/* Left Sidebar */}
                            <aside className="col-span-3 space-y-3">
                                {/* Image Upload */}
                                <div className="bg-white rounded-lg shadow p-3">
                                    <h3 className="font-bold text-gray-700 mb-2 text-sm">üì∑ Image</h3>
                                    <input ref={fileInputRef} type="file" accept="image/*" onChange={handleImageUpload} className="hidden" />
                                    <button onClick={() => fileInputRef.current?.click()} disabled={isImageLoading}
                                        className="w-full px-3 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3d5a] text-sm font-medium disabled:bg-gray-300">
                                        {isImageLoading ? '‚è≥ Loading...' : (originalImage ? 'üîÑ Change Image' : 'üì§ Upload Image')}
                                    </button>
                                </div>
                                
                                {/* Preprocessing */}
                                {originalImage && (
                                    <div className="bg-white rounded-lg shadow overflow-hidden">
                                        <div className="px-3 py-2 bg-gray-50 flex items-center justify-between cursor-pointer hover:bg-gray-100"
                                            onClick={() => setIsPreprocessingCollapsed(!isPreprocessingCollapsed)}>
                                            <div className="flex items-center gap-2">
                                                <span className="text-sm">üîß</span>
                                                <span className="font-semibold text-gray-700 text-sm">Preprocessing</span>
                                                {preprocessing.useAdaptiveThreshold && <span className="px-1.5 py-0.5 bg-ancient-purple text-white text-xs rounded">Active</span>}
                                            </div>
                                            <svg className={`w-4 h-4 transition-transform ${isPreprocessingCollapsed ? '' : 'rotate-180'}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                            </svg>
                                        </div>
                                        
                                        {!isPreprocessingCollapsed && (
                                            <div className="p-3 space-y-3 text-sm">
                                                {/* Rotation */}
                                                <div>
                                                    <div className="flex justify-between text-gray-600 mb-1"><span>üîÑ Rotation</span><span>{preprocessing.rotation}¬∞</span></div>
                                                    <input type="range" min="-180" max="180" value={preprocessing.rotation}
                                                        onChange={(e) => setPreprocessing(p => ({ ...p, rotation: parseInt(e.target.value) }))} className="w-full" />
                                                </div>
                                                
                                                {/* Blur */}
                                                <div>
                                                    <div className="flex justify-between text-gray-600 mb-1"><span>üå´Ô∏è Blur</span><span>{preprocessing.gaussianBlur}</span></div>
                                                    <input type="range" min="0" max="15" step="2" value={preprocessing.gaussianBlur}
                                                        onChange={(e) => setPreprocessing(p => ({ ...p, gaussianBlur: parseInt(e.target.value) }))} className="w-full" />
                                                </div>
                                                
                                                {/* Adaptive Threshold */}
                                                <div className="p-2 bg-gray-50 rounded space-y-2">
                                                    <div className="flex items-center justify-between">
                                                        <span className="text-gray-700">üìä Adaptive Threshold</span>
                                                        <button onClick={() => setPreprocessing(p => ({ ...p, useAdaptiveThreshold: !p.useAdaptiveThreshold }))}
                                                            className={`w-10 h-5 rounded-full ${preprocessing.useAdaptiveThreshold ? 'bg-ancient-purple' : 'bg-gray-300'}`}>
                                                            <div className={`w-4 h-4 bg-white rounded-full shadow transform ${preprocessing.useAdaptiveThreshold ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                        </button>
                                                    </div>
                                                    {preprocessing.useAdaptiveThreshold && (
                                                        <>
                                                            <div>
                                                                <div className="flex justify-between text-xs text-gray-500 mb-1"><span>Block Size</span><span>{preprocessing.blockSize}</span></div>
                                                                <input type="range" min="3" max="51" step="2" value={preprocessing.blockSize}
                                                                    onChange={(e) => setPreprocessing(p => ({ ...p, blockSize: parseInt(e.target.value) }))} className="w-full" />
                                                            </div>
                                                            <div>
                                                                <div className="flex justify-between text-xs text-gray-500 mb-1"><span>Offset</span><span>{preprocessing.constantOffset}</span></div>
                                                                <input type="range" min="-20" max="20" value={preprocessing.constantOffset}
                                                                    onChange={(e) => setPreprocessing(p => ({ ...p, constantOffset: parseInt(e.target.value) }))} className="w-full" />
                                                            </div>
                                                        </>
                                                    )}
                                                </div>
                                                
                                                {/* Morphology */}
                                                <div>
                                                    <span className="text-gray-600 block mb-1">üî≤ Morphology</span>
                                                    <select value={preprocessing.morphologyOperation}
                                                        onChange={(e) => setPreprocessing(p => ({ ...p, morphologyOperation: e.target.value }))}
                                                        className="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                                                        <option value="none">None</option>
                                                        <option value="erode">Erode</option>
                                                        <option value="dilate">Dilate</option>
                                                        <option value="open">Open</option>
                                                        <option value="close">Close</option>
                                                    </select>
                                                </div>
                                                
                                                {/* Invert */}
                                                <div className="flex items-center justify-between">
                                                    <span className="text-gray-700">üîÑ Invert</span>
                                                    <button onClick={() => setPreprocessing(p => ({ ...p, invertColors: !p.invertColors }))}
                                                        className={`w-10 h-5 rounded-full ${preprocessing.invertColors ? 'bg-ancient-purple' : 'bg-gray-300'}`}>
                                                        <div className={`w-4 h-4 bg-white rounded-full shadow transform ${preprocessing.invertColors ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                    </button>
                                                </div>
                                                
                                                {/* Buttons */}
                                                <div className="flex gap-2 pt-2">
                                                    <button onClick={resetPreprocessing} className="flex-1 px-2 py-1.5 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded text-sm">üîÑ Reset</button>
                                                    <button onClick={applyPreprocessing} disabled={!opencvReady}
                                                        className="flex-1 px-2 py-1.5 bg-ancient-purple hover:bg-[#4a3d5a] text-white rounded text-sm disabled:bg-gray-300">‚ú® Apply</button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </aside>
                            
                            {/* Center - Image */}
                            <div className="col-span-6">
                                <div className="bg-white rounded-lg shadow p-3 h-full flex flex-col">
                                    {displayImage ? (
                                        <div ref={imageContainerRef} className="relative flex-1 flex items-center justify-center overflow-hidden">
                                            <img ref={imageRef} src={displayImage} alt="Inscription" className="max-w-full max-h-full object-contain" />
                                            
                                            {/* Detection boxes */}
                                            {recognitionResults.map((result, index) => {
                                                const validation = validations[index];
                                                const isSelected = selectedRegions.has(index);
                                                
                                                let boxClass = 'detection-box unvalidated';
                                                let labelBg = 'bg-stone';
                                                
                                                if (isSelected) { boxClass = 'detection-box selected'; labelBg = 'bg-ochre'; }
                                                else if (validation?.isCorrect) { boxClass = 'detection-box validated-correct'; labelBg = 'bg-patina'; }
                                                else if (validation && !validation.isCorrect) { boxClass = 'detection-box validated-incorrect'; labelBg = 'bg-rust'; }
                                                if (result.confidence < 0.5) boxClass += ' uncertain';
                                                
                                                const img = imageRef.current;
                                                if (!img) return null;
                                                
                                                const containerRect = imageContainerRef.current?.getBoundingClientRect();
                                                const imgRect = img.getBoundingClientRect();
                                                const scaleX = imgRect.width / img.naturalWidth;
                                                const scaleY = imgRect.height / img.naturalHeight;
                                                const offsetX = (containerRect?.width - imgRect.width) / 2 || 0;
                                                const offsetY = (containerRect?.height - imgRect.height) / 2 || 0;
                                                
                                                return (
                                                    <div key={index} className={boxClass}
                                                        style={{
                                                            left: offsetX + result.position.x * scaleX,
                                                            top: offsetY + result.position.y * scaleY,
                                                            width: result.position.width * scaleX,
                                                            height: result.position.height * scaleY
                                                        }}
                                                        onClick={() => setSelectedRegions(prev => {
                                                            const next = new Set(prev);
                                                            next.has(index) ? next.delete(index) : next.add(index);
                                                            return next;
                                                        })}
                                                        title={`${result.glyph.name} (${Math.round(result.confidence * 100)}%)`}>
                                                        <div className={`detection-label ${labelBg}`}>
                                                            {showArabicLabels ? result.glyph.arabic : result.glyph.transliteration}
                                                        </div>
                                                        {viewMode === 'reading' && <div className="reading-order-badge">{readingOrder.indexOf(index) + 1}</div>}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ) : (
                                        <div className="flex-1 flex flex-col items-center justify-center text-gray-400">
                                            <span className="text-5xl mb-3">üì∑</span>
                                            <p>Upload an inscription image to begin</p>
                                        </div>
                                    )}
                                </div>
                            </div>
                            
                            {/* Right Sidebar */}
                            <aside className="col-span-3 flex flex-col gap-3">
                                {/* Recognition Button */}
                                <div className="bg-white rounded-lg shadow p-3">
                                    <button onClick={recognizeGlyphs} disabled={isProcessing || chartStatus !== 'loaded' || !displayImage}
                                        className="w-full px-3 py-2.5 bg-patina text-white rounded-lg hover:bg-[#5a7d6e] text-sm font-medium disabled:bg-gray-300">
                                        {isProcessing ? `‚è≥ ${processingStatus || 'Processing...'}` : 'üîç Recognize Glyphs'}
                                    </button>
                                </div>
                                
                                {/* Detection List */}
                                <div className="bg-white rounded-lg shadow p-3 flex-1 overflow-hidden flex flex-col">
                                    <div className="flex items-center justify-between mb-2">
                                        <h3 className="font-bold text-gray-700 text-sm">
                                            {recognitionResults.length > 0 ? `üîç ${recognitionResults.length} Detections` : 'üîç No detections yet'}
                                        </h3>
                                        {recognitionResults.length > 0 && (
                                            <button onClick={() => setShowArabicLabels(!showArabicLabels)}
                                                className={`px-2 py-1 rounded text-xs ${showArabicLabels ? 'bg-ancient-purple text-white' : 'bg-gray-200'}`}>
                                                {showArabicLabels ? 'ÿπÿ±ÿ®Ÿä' : 'ABC'}
                                            </button>
                                        )}
                                    </div>
                                    
                                    {recognitionResults.length === 0 ? (
                                        <div className="flex-1 flex flex-col items-center justify-center text-gray-400 text-sm">
                                            <span className="text-3xl mb-2">üîç</span>
                                            <p>Run recognition to detect glyphs</p>
                                        </div>
                                    ) : (
                                        <>
                                            <div className="flex gap-1 mb-2">
                                                <button onClick={() => setViewMode('detection')}
                                                    className={`flex-1 px-2 py-1 rounded text-xs ${viewMode === 'detection' ? 'bg-ancient-purple text-white' : 'bg-gray-100'}`}>üîç Detection</button>
                                                <button onClick={() => setViewMode('reading')}
                                                    className={`flex-1 px-2 py-1 rounded text-xs ${viewMode === 'reading' ? 'bg-ancient-purple text-white' : 'bg-gray-100'}`}>üìñ Reading</button>
                                            </div>
                                            
                                            <div className="flex-1 overflow-y-auto space-y-2">
                                                {(viewMode === 'reading' ? readingOrder : recognitionResults.map((_, i) => i)).map((idx, displayIdx) => {
                                                    const result = recognitionResults[idx];
                                                    if (!result) return null;
                                                    
                                                    const validation = validations[idx];
                                                    const isSelected = selectedRegions.has(idx);
                                                    const conf = Math.round(result.confidence * 100);
                                                    
                                                    let borderColor = 'border-gray-200';
                                                    if (isSelected) borderColor = 'border-ochre';
                                                    else if (validation?.isCorrect) borderColor = 'border-patina';
                                                    else if (validation && !validation.isCorrect) borderColor = 'border-rust';
                                                    
                                                    return (
                                                        <div key={idx} className={`border-2 ${borderColor} rounded-lg p-2 cursor-pointer hover:shadow ${isSelected ? 'bg-yellow-50' : ''}`}
                                                            onClick={() => setSelectedRegions(prev => { const n = new Set(prev); n.has(idx) ? n.delete(idx) : n.add(idx); return n; })}>
                                                            <div className="flex gap-2">
                                                                {result.thumbnail && <div className="w-10 h-10 bg-gray-100 rounded overflow-hidden flex-shrink-0">
                                                                    <img src={result.thumbnail} alt="" className="w-full h-full object-contain" />
                                                                </div>}
                                                                <div className="flex-1 min-w-0">
                                                                    <div className="flex items-center gap-1">
                                                                        <span className="font-bold text-xs text-gray-500">#{viewMode === 'reading' ? displayIdx + 1 : idx + 1}</span>
                                                                        <span className={`text-xs font-medium ${conf >= 70 ? 'text-patina' : conf >= 50 ? 'text-ochre' : 'text-rust'}`}>{conf}%</span>
                                                                    </div>
                                                                    <div className="font-medium text-gray-900 text-sm truncate">{result.glyph.name}</div>
                                                                    <div className="text-lg text-ancient-purple leading-tight">{result.glyph.arabic || result.glyph.transliteration}</div>
                                                                </div>
                                                                <div className="flex flex-col gap-1">
                                                                    {!validation && (
                                                                        <>
                                                                            <button onClick={(e) => { e.stopPropagation(); validateDetection(idx, true); }}
                                                                                className="w-6 h-6 bg-patina text-white rounded text-xs hover:bg-[#5a7d6e]">‚úì</button>
                                                                            <button onClick={(e) => { e.stopPropagation(); validateDetection(idx, false); }}
                                                                                className="w-6 h-6 bg-rust text-white rounded text-xs hover:bg-[#8a574a]">‚úó</button>
                                                                        </>
                                                                    )}
                                                                    <button onClick={(e) => { e.stopPropagation(); if(confirm('Delete?')) deleteDetection(idx); }}
                                                                        className="w-6 h-6 bg-gray-200 text-gray-600 rounded text-xs hover:bg-gray-300">üóë</button>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </>
                                    )}
                                </div>
                            </aside>
                        </div>
                    </main>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<HakliGlyphRecognizer />);
    </script>

    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(() => console.log('‚úÖ SW registered')).catch(console.error);
        }
    </script>
</body>
</html>
