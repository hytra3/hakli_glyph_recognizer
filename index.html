<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Symbol Recognizer - With Rotation</title>
    <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useCallback, useEffect } = React;

        // SVG Icons
        const RotateCw = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
        );

        const Upload = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
        );

        const Zap = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
            </svg>
        );

        const Camera = () => (
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M23 19a2 2 0 01-2 2H3a2 2 0 01-2-2V8a2 2 0 012-2h4l2-3h6l2 3h4a2 2 0 012 2z"/>
                <circle cx="12" cy="13" r="4"/>
            </svg>
        );

        const HakliSymbolRecognizer = () => {
            // State management
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [uploadedImage, setUploadedImage] = useState(null);
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [isOpenCVReady, setIsOpenCVReady] = useState(false);
            const [validations, setValidations] = useState({});
            const [corrections, setCorrections] = useState({});
            const [activeRotation, setActiveRotation] = useState(null); // Track which box is being rotated
            
            // Refs
            const imageRef = useRef(null);
            const canvasRef = useRef(null);
            const fileInputRef = useRef(null);

            // OpenCV initialization
            useEffect(() => {
                if (window.cv && window.cv.Mat) {
                    console.log('OpenCV.js is ready');
                    setIsOpenCVReady(true);
                } else {
                    const checkOpenCV = setInterval(() => {
                        if (window.cv && window.cv.Mat) {
                            console.log('OpenCV.js loaded');
                            setIsOpenCVReady(true);
                            clearInterval(checkOpenCV);
                        }
                    }, 100);
                }
            }, []);

            // Load equivalence chart
            useEffect(() => {
                const loadChart = async () => {
                    try {
                        const response = await fetch('https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/Hakli_symbols.JSON');
                        const data = await response.json();
                        setEquivalenceChart(data);
                        console.log('Equivalence chart loaded:', data.length, 'symbols');
                    } catch (error) {
                        console.error('Failed to load equivalence chart:', error);
                    }
                };
                loadChart();
            }, []);

            // Image upload handler
            const handleImageUpload = useCallback((event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setUploadedImage(e.target.result);
                        setRecognitionResults([]);
                        setValidations({});
                        setCorrections({});
                    };
                    reader.readAsDataURL(file);
                }
            }, []);

            // Rotate region and perform template matching
            const rotateAndMatch = useCallback((isolatedSymbol, angle, template) => {
                if (!isOpenCVReady) return null;

                try {
                    const cv = window.cv;
                    
                    // Create source image from canvas
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = isolatedSymbol.width;
                    tempCanvas.height = isolatedSymbol.height;
                    
                    const img = new Image();
                    img.src = uploadedImage;
                    tempCtx.drawImage(
                        img,
                        isolatedSymbol.x, isolatedSymbol.y,
                        isolatedSymbol.width, isolatedSymbol.height,
                        0, 0,
                        isolatedSymbol.width, isolatedSymbol.height
                    );

                    // Convert to OpenCV Mat
                    let symbolMat = cv.imread(tempCanvas);
                    
                    // Rotate the image if angle is not 0
                    if (angle !== 0) {
                        const center = new cv.Point(symbolMat.cols / 2, symbolMat.rows / 2);
                        const rotationMatrix = cv.getRotationMatrix2D(center, angle, 1.0);
                        cv.warpAffine(symbolMat, symbolMat, rotationMatrix, new cv.Size(symbolMat.cols, symbolMat.rows));
                        rotationMatrix.delete();
                    }

                    // Convert to grayscale
                    let symbolGray = new cv.Mat();
                    cv.cvtColor(symbolMat, symbolGray, cv.COLOR_RGBA2GRAY);

                    // Load template
                    const templateImg = new Image();
                    templateImg.src = template;
                    const templateCanvas = document.createElement('canvas');
                    const templateCtx = templateCanvas.getContext('2d');
                    templateCanvas.width = templateImg.width;
                    templateCanvas.height = templateImg.height;
                    templateCtx.drawImage(templateImg, 0, 0);

                    let templateMat = cv.imread(templateCanvas);
                    
                    // Resize template to match symbol
                    let resizedTemplate = new cv.Mat();
                    cv.resize(templateMat, resizedTemplate, new cv.Size(symbolMat.cols, symbolMat.rows));

                    // Convert template to grayscale
                    let templateGray = new cv.Mat();
                    cv.cvtColor(resizedTemplate, templateGray, cv.COLOR_RGBA2GRAY);

                    // Perform template matching
                    let result = new cv.Mat();
                    cv.matchTemplate(symbolGray, templateGray, result, cv.TM_CCOEFF_NORMED);
                    
                    const minMaxLoc = cv.minMaxLoc(result);
                    const confidence = minMaxLoc.maxVal;

                    // Cleanup
                    symbolMat.delete();
                    templateMat.delete();
                    resizedTemplate.delete();
                    symbolGray.delete();
                    templateGray.delete();
                    result.delete();

                    return {
                        confidence: confidence,
                        position: {
                            x: isolatedSymbol.x,
                            y: isolatedSymbol.y,
                            width: isolatedSymbol.width,
                            height: isolatedSymbol.height
                        }
                    };

                } catch (error) {
                    console.error('Template matching error:', error);
                    return null;
                }
            }, [isOpenCVReady, uploadedImage]);

            // Symbol detection with OpenCV
            const detectSymbols = useCallback(async () => {
                if (!uploadedImage || !equivalenceChart || !imageRef.current || !isOpenCVReady) {
                    console.log('Missing requirements for detection');
                    return;
                }
                
                setIsProcessing(true);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                try {
                    const cv = window.cv;
                    const img = imageRef.current;
                    
                    // Create canvas for processing
                    const tempCanvas = document.createElement('canvas');
                    const ctx = tempCanvas.getContext('2d');
                    tempCanvas.width = img.naturalWidth;
                    tempCanvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);

                    // Load image into OpenCV
                    let src = cv.imread(tempCanvas);
                    let gray = new cv.Mat();
                    let binary = new cv.Mat();
                    
                    // Convert to grayscale
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    
                    // Apply threshold
                    cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
                    
                    // Find contours
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    console.log(`Found ${contours.size()} contours`);

                    // Process each contour
                    const results = [];
                    const minArea = 100; // Minimum area to consider

                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const area = cv.contourArea(contour);
                        
                        if (area > minArea) {
                            const rect = cv.boundingRect(contour);
                            
                            // Add padding
                            const padding = 5;
                            const x = Math.max(0, rect.x - padding);
                            const y = Math.max(0, rect.y - padding);
                            const width = Math.min(tempCanvas.width - x, rect.width + 2 * padding);
                            const height = Math.min(tempCanvas.height - y, rect.height + 2 * padding);

                            // Initial detection with 0 rotation
                            results.push({
                                id: i,
                                symbol: '?',
                                confidence: 0,
                                position: { x, y, width, height },
                                area: area,
                                rotation: 0 // Default rotation angle
                            });
                        }
                    }

                    // Sort by x position (left to right)
                    results.sort((a, b) => a.position.x - b.position.x);

                    // Try to match with templates
                    for (const result of results) {
                        let bestMatch = null;
                        let bestConfidence = 0;

                        for (const symbol of equivalenceChart) {
                            if (symbol.primary_template) {
                                const match = rotateAndMatch(result.position, result.rotation, symbol.primary_template);
                                if (match && match.confidence > bestConfidence) {
                                    bestConfidence = match.confidence;
                                    bestMatch = symbol.Arabic_letter || '?';
                                }
                            }
                        }

                        if (bestMatch) {
                            result.symbol = bestMatch;
                            result.confidence = bestConfidence;
                        }
                    }

                    // Cleanup OpenCV objects
                    src.delete();
                    gray.delete();
                    binary.delete();
                    contours.delete();
                    hierarchy.delete();

                    console.log('Detection results:', results);
                    setRecognitionResults(results);
                    
                } catch (error) {
                    console.error('Detection error:', error);
                } finally {
                    setIsProcessing(false);
                }
            }, [uploadedImage, equivalenceChart, isOpenCVReady, rotateAndMatch]);

            // Update rotation for a specific detection
            const updateRotation = useCallback((detectionId, newRotation) => {
                setRecognitionResults(prevResults => {
                    const updated = prevResults.map(result => {
                        if (result.id === detectionId) {
                            return { ...result, rotation: newRotation };
                        }
                        return result;
                    });
                    return updated;
                });
            }, []);

            // Re-match after rotation change
            const rematchWithRotation = useCallback(async (detectionId) => {
                const detection = recognitionResults.find(r => r.id === detectionId);
                if (!detection || !equivalenceChart) return;

                setIsProcessing(true);

                try {
                    let bestMatch = null;
                    let bestConfidence = 0;

                    for (const symbol of equivalenceChart) {
                        if (symbol.primary_template) {
                            const match = rotateAndMatch(detection.position, detection.rotation, symbol.primary_template);
                            if (match && match.confidence > bestConfidence) {
                                bestConfidence = match.confidence;
                                bestMatch = symbol.Arabic_letter || '?';
                            }
                        }
                    }

                    if (bestMatch) {
                        setRecognitionResults(prevResults =>
                            prevResults.map(result => {
                                if (result.id === detectionId) {
                                    return {
                                        ...result,
                                        symbol: bestMatch,
                                        confidence: bestConfidence
                                    };
                                }
                                return result;
                            })
                        );
                    }
                } catch (error) {
                    console.error('Re-matching error:', error);
                } finally {
                    setIsProcessing(false);
                }
            }, [recognitionResults, equivalenceChart, rotateAndMatch]);

            // Validation handlers
            const handleValidation = useCallback((index, isCorrect) => {
                setValidations(prev => ({
                    ...prev,
                    [index]: isCorrect
                }));
            }, []);

            const handleCorrection = useCallback((index, newSymbol) => {
                setCorrections(prev => ({
                    ...prev,
                    [index]: newSymbol
                }));
            }, []);

            // Draw detection results on canvas
            useEffect(() => {
                if (recognitionResults.length > 0 && canvasRef.current && imageRef.current) {
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    const img = imageRef.current;

                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;

                    // Draw image
                    ctx.drawImage(img, 0, 0);

                    // Draw detection boxes
                    recognitionResults.forEach((result, index) => {
                        const isValidated = validations[index] !== undefined;
                        const isCorrect = validations[index] === true;
                        const isCorrected = corrections[index] !== undefined;

                        // Choose color
                        let color = 'rgb(59, 130, 246)'; // blue - unvalidated
                        if (isValidated) {
                            color = isCorrect ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)'; // green : red
                        }
                        if (isCorrected) {
                            color = 'rgb(249, 115, 22)'; // orange - corrected
                        }

                        // Draw rectangle
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(result.position.x, result.position.y, result.position.width, result.position.height);

                        // Draw rotation indicator if rotated
                        if (result.rotation !== 0) {
                            ctx.save();
                            ctx.translate(result.position.x + result.position.width / 2, result.position.y - 15);
                            ctx.rotate((result.rotation * Math.PI) / 180);
                            ctx.fillStyle = color;
                            ctx.font = '12px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText(`↻ ${result.rotation}°`, 0, 0);
                            ctx.restore();
                        }

                        // Draw symbol label
                        const displaySymbol = corrections[index] || result.symbol;
                        ctx.fillStyle = color;
                        ctx.font = 'bold 24px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(displaySymbol, result.position.x + result.position.width / 2, result.position.y - 25);
                    });
                }
            }, [recognitionResults, validations, corrections]);

            // Statistics
            const stats = {
                total: recognitionResults.length,
                validated: Object.keys(validations).length,
                correct: Object.values(validations).filter(v => v === true).length,
                incorrect: Object.values(validations).filter(v => v === false).length,
                corrected: Object.keys(corrections).length,
                unvalidated: recognitionResults.length - Object.keys(validations).length
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-8">
                    <div className="max-w-7xl mx-auto">
                        {/* Header */}
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <h1 className="text-3xl font-bold text-gray-800 mb-2">
                                Hakli Symbol Recognizer
                                <span className="text-sm font-normal text-gray-500 ml-2">
                                    based on Ahmad Al-Jallad (2025), The Decipherment of the Dhofari Script
                                </span>
                            </h1>
                            <p className="text-gray-600">
                                Upload inscription images for automated symbol detection and recognition with rotation adjustment
                            </p>
                        </div>

                        {/* Upload Section */}
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <div className="flex items-center gap-4">
                                <button
                                    onClick={() => fileInputRef.current?.click()}
                                    className="flex items-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                                >
                                    <Upload />
                                    <span>Upload Image</span>
                                </button>
                                <input
                                    ref={fileInputRef}
                                    type="file"
                                    accept="image/*"
                                    onChange={handleImageUpload}
                                    className="hidden"
                                />
                                
                                {uploadedImage && (
                                    <button
                                        onClick={detectSymbols}
                                        disabled={isProcessing || !isOpenCVReady}
                                        className="flex items-center gap-2 px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    >
                                        <Zap />
                                        <span>{isProcessing ? 'Processing...' : 'Detect Symbols'}</span>
                                    </button>
                                )}

                                {!isOpenCVReady && (
                                    <span className="text-sm text-amber-600">Loading OpenCV...</span>
                                )}
                            </div>
                        </div>

                        {/* Image Display */}
                        {uploadedImage && (
                            <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                                <h3 className="text-xl font-semibold mb-4">Inscription Image</h3>
                                <div className="relative inline-block">
                                    <img
                                        ref={imageRef}
                                        src={uploadedImage}
                                        alt="Uploaded inscription"
                                        className="max-w-full h-auto"
                                        style={{ display: recognitionResults.length > 0 ? 'none' : 'block' }}
                                    />
                                    <canvas
                                        ref={canvasRef}
                                        className="max-w-full h-auto"
                                        style={{ display: recognitionResults.length > 0 ? 'block' : 'none' }}
                                    />
                                </div>
                            </div>
                        )}

                        {/* Detection Results */}
                        {recognitionResults.length > 0 && (
                            <div className="bg-white rounded-lg shadow-lg p-6">
                                <h3 className="text-xl font-semibold mb-4">Detection Results</h3>
                                
                                {/* Statistics */}
                                <div className="bg-gray-50 rounded-lg p-4 mb-6">
                                    <div className="flex gap-6 flex-wrap">
                                        <div>Total: <span className="font-bold">{stats.total}</span></div>
                                        <div className="text-green-600">
                                            ✓ Validated Correct: <span className="font-bold">{stats.correct}</span>
                                        </div>
                                        <div className="text-red-600">
                                            ✗ Validated Incorrect: <span className="font-bold">{stats.incorrect}</span>
                                        </div>
                                        <div className="text-orange-600">
                                            ✎ Corrected: <span className="font-bold">{stats.corrected}</span>
                                        </div>
                                        <div className="text-gray-600">
                                            Unvalidated: <span className="font-bold">{stats.unvalidated}</span>
                                        </div>
                                    </div>
                                </div>

                                {/* Individual Results */}
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                    {recognitionResults.map((result, index) => {
                                        const isValidated = validations[index] !== undefined;
                                        const isCorrect = validations[index] === true;
                                        const isCorrected = corrections[index] !== undefined;
                                        const isRotating = activeRotation === result.id;

                                        return (
                                            <div
                                                key={result.id}
                                                className={`border-2 rounded-lg p-4 ${
                                                    isValidated
                                                        ? isCorrect
                                                            ? 'border-green-500 bg-green-50'
                                                            : 'border-red-500 bg-red-50'
                                                        : isCorrected
                                                        ? 'border-orange-500 bg-orange-50'
                                                        : 'border-blue-500 bg-blue-50'
                                                }`}
                                            >
                                                <div className="flex justify-between items-start mb-2">
                                                    <div>
                                                        <h4 className="font-bold text-2xl">
                                                            {corrections[index] || result.symbol}
                                                        </h4>
                                                        <p className="text-sm text-gray-600">
                                                            Confidence: {(result.confidence * 100).toFixed(1)}%
                                                        </p>
                                                    </div>
                                                    <div className="text-right text-xs text-gray-500">
                                                        #{index + 1}
                                                    </div>
                                                </div>

                                                {/* Rotation Control */}
                                                <div className="mb-3 bg-white rounded p-2">
                                                    <div className="flex items-center gap-2 mb-2">
                                                        <RotateCw />
                                                        <span className="text-sm font-semibold">Rotation: {result.rotation}°</span>
                                                        <button
                                                            onClick={() => setActiveRotation(isRotating ? null : result.id)}
                                                            className="ml-auto text-xs px-2 py-1 bg-blue-100 hover:bg-blue-200 rounded"
                                                        >
                                                            {isRotating ? 'Done' : 'Adjust'}
                                                        </button>
                                                    </div>
                                                    
                                                    {isRotating && (
                                                        <div className="space-y-2">
                                                            <input
                                                                type="range"
                                                                min="-180"
                                                                max="180"
                                                                value={result.rotation}
                                                                onChange={(e) => updateRotation(result.id, parseInt(e.target.value))}
                                                                className="w-full"
                                                            />
                                                            <div className="flex gap-2">
                                                                <button
                                                                    onClick={() => updateRotation(result.id, result.rotation - 5)}
                                                                    className="px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded text-xs"
                                                                >
                                                                    -5°
                                                                </button>
                                                                <button
                                                                    onClick={() => updateRotation(result.id, 0)}
                                                                    className="px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded text-xs"
                                                                >
                                                                    Reset
                                                                </button>
                                                                <button
                                                                    onClick={() => updateRotation(result.id, result.rotation + 5)}
                                                                    className="px-2 py-1 bg-gray-200 hover:bg-gray-300 rounded text-xs"
                                                                >
                                                                    +5°
                                                                </button>
                                                                <button
                                                                    onClick={() => {
                                                                        rematchWithRotation(result.id);
                                                                        setActiveRotation(null);
                                                                    }}
                                                                    disabled={isProcessing}
                                                                    className="ml-auto px-3 py-1 bg-green-600 text-white hover:bg-green-700 rounded text-xs disabled:bg-gray-400"
                                                                >
                                                                    Re-match
                                                                </button>
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>

                                                {/* Validation Buttons */}
                                                {!isValidated && !isCorrected && (
                                                    <div className="flex gap-2 mt-3">
                                                        <button
                                                            onClick={() => handleValidation(index, true)}
                                                            className="flex-1 px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors text-sm"
                                                        >
                                                            ✓ Correct
                                                        </button>
                                                        <button
                                                            onClick={() => handleValidation(index, false)}
                                                            className="flex-1 px-3 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors text-sm"
                                                        >
                                                            ✗ Incorrect
                                                        </button>
                                                    </div>
                                                )}

                                                {/* Correction Input */}
                                                {validations[index] === false && (
                                                    <div className="mt-3">
                                                        <input
                                                            type="text"
                                                            placeholder="Enter correct symbol"
                                                            value={corrections[index] || ''}
                                                            onChange={(e) => handleCorrection(index, e.target.value)}
                                                            className="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-orange-500"
                                                        />
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        )}

                        {/* Empty State */}
                        {!uploadedImage && (
                            <div className="bg-white rounded-lg shadow-lg p-12 text-center">
                                <Camera />
                                <h3 className="text-xl font-semibold text-gray-700 mt-4 mb-2">
                                    No Image Uploaded
                                </h3>
                                <p className="text-gray-500">
                                    Upload an inscription image to begin symbol detection and recognition
                                </p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        ReactDOM.render(<HakliSymbolRecognizer />, document.getElementById('root'));
    </script>
</body>
</html>
