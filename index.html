<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Symbol Recognizer</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        var isOpenCvReady = false;
        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('OpenCV.js is ready');
        }
    </script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        .detection-box {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
            border: 3px solid;
            border-radius: 4px;
            cursor: pointer;
        }
        .detection-box.validated-correct { border-color: #10b981; background: rgba(16, 185, 129, 0.25); }
        .detection-box.validated-incorrect { border-color: #ef4444; background: rgba(239, 68, 68, 0.25); }
        .detection-box.unvalidated { border-color: #3b82f6; background: rgba(59, 130, 246, 0.25); }
        .detection-box.selected { border-color: #f59e0b; background: rgba(245, 158, 11, 0.3); border-width: 4px; }
        
        .canvas-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }
        
        .manual-selection-box {
            position: absolute;
            border: 2px dashed #f59e0b;
            background: rgba(245, 158, 11, 0.1);
            pointer-events: none;
            z-index: 5;
        }
        
        .region-boundary {
            position: absolute;
            border: 1px solid rgba(156, 163, 175, 0.5);
            background: rgba(156, 163, 175, 0.05);
            pointer-events: none;
            z-index: 3;
        }
        
        .merge-indicator {
            position: absolute;
            border: 3px solid #8b5cf6;
            background: rgba(139, 92, 246, 0.15);
            border-radius: 8px;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function HakliSymbolRecognizer() {
            const [image, setImage] = useState(null);
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [chartLoadStatus, setChartLoadStatus] = useState('not-loaded');
            const [loadedSymbolImages, setLoadedSymbolImages] = useState({});
            const [manualDetectionMode, setManualDetectionMode] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawStart, setDrawStart] = useState(null);
            const [drawCurrent, setDrawCurrent] = useState(null);
            const [selectedRegions, setSelectedRegions] = useState(new Set());
            const [validations, setValidations] = useState({});
            const [actionHistory, setActionHistory] = useState([]);
            const [isolatedSymbols, setIsolatedSymbols] = useState([]);
            const [showRegionBoundaries, setShowRegionBoundaries] = useState(false);
            const [mergeIndicator, setMergeIndicator] = useState(null);

            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);

            const [viewMode, setViewMode] = useState('detection'); // 'detection' or 'reading'
            const [readingDirection, setReadingDirection] = useState('detection'); // 'detection', 'ltr', 'rtl', 'ttb'
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [readingOrder, setReadingOrder] = useState([]); // Array of indices for manual ordering
            const [draggedItem, setDraggedItem] = useState(null);
            const [correctionMode, setCorrectionMode] = useState(null); // Index of detection being corrected, or null
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [stateHistory, setStateHistory] = useState([]);
            const [confidenceThreshold, setConfidenceThreshold] = useState(0);
            const [useConfidenceFilter, setUseConfidenceFilter] = useState(false);


            const convertToGitHubUrl = (githubUrl) => {
                if (!githubUrl) return null;
                if (githubUrl.indexOf('http') === 0) {
                    if (githubUrl.indexOf('github.com') !== -1 && githubUrl.indexOf('/blob/') !== -1) {
                        return githubUrl.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                    }
                    return githubUrl;
                }
                if (typeof githubUrl === 'string' && githubUrl.length > 0) {
                    const baseUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/';
                    const cleanPath = githubUrl.indexOf('/') === 0 ? githubUrl.substring(1) : githubUrl;
                    return baseUrl + cleanPath;
                }
                return null;
            };

            const recordAction = (actionType, actionData) => {
                const action = {
                    type: actionType,
                    data: actionData,
                    timestamp: new Date().toISOString(),
                    id: Date.now()
                };
                setActionHistory(prev => [...prev, action].slice(-50));
                console.log('Action recorded:', action);
                
                // Take snapshot after modifying actions
                const modifyingActions = ['validation', 'delete_detection', 'merge_detections', 
                                        'add_manual_detection', 'correct_symbol', 'reorder_reading', 
                                        'toggle_word_boundary'];
                if (modifyingActions.includes(actionType)) {
                    setTimeout(takeSnapshot, 0);
                }
            };

            const takeSnapshot = () => {
                const snapshot = {
                    recognitionResults: [...recognitionResults],
                    validations: { ...validations },
                    selectedRegions: new Set(selectedRegions),
                    wordBoundaries: new Set(wordBoundaries),
                    readingOrder: [...readingOrder],
                    isolatedSymbols: [...isolatedSymbols]
                };
                
                // Remove any "future" history if we're not at the end
                const newHistory = stateHistory.slice(0, historyIndex + 1);
                newHistory.push(snapshot);
                
                // Keep only last 50 states
                const trimmedHistory = newHistory.slice(-50);
                
                setStateHistory(trimmedHistory);
                setHistoryIndex(trimmedHistory.length - 1);
            };

            const validateDetection = (detectionIndex, isCorrect) => {
                recordAction('validation', {
                    detectionIndex,
                    isCorrect,
                    detectionData: recognitionResults[detectionIndex]
                });
                setValidations(prev => ({
                    ...prev,
                    [detectionIndex]: {
                        isCorrect,
                        timestamp: new Date().toISOString(),
                        detectionData: recognitionResults[detectionIndex]
                    }
                }));
            };

            const deleteDetection = (detectionIndex) => {
                recordAction('delete_detection', {
                    index: detectionIndex,
                    detection: recognitionResults[detectionIndex]
                });
                setRecognitionResults(prev => prev.filter((_, i) => i !== detectionIndex));
                setValidations(prev => {
                    const newValidations = { ...prev };
                    delete newValidations[detectionIndex];
                    const shifted = {};
                    Object.keys(newValidations).forEach(key => {
                        const numKey = parseInt(key);
                        shifted[numKey > detectionIndex ? numKey - 1 : numKey] = newValidations[key];
                    });
                    return shifted;
                });
            };

            const mergeSelectedDetections = () => {
                const selectedIndices = Array.from(selectedRegions).sort((a, b) => a - b);
                if (selectedIndices.length < 2) {
                    alert('Please select at least 2 detections to merge');
                    return;
                }
                const detectionsToMerge = selectedIndices.map(i => recognitionResults[i]);
                const minX = Math.min(...detectionsToMerge.map(d => d.position.x));
                const minY = Math.min(...detectionsToMerge.map(d => d.position.y));
                const maxX = Math.max(...detectionsToMerge.map(d => d.position.x + d.position.width));
                const maxY = Math.max(...detectionsToMerge.map(d => d.position.y + d.position.height));
                const baseDetection = detectionsToMerge.reduce((best, current) => 
                    current.confidence > best.confidence ? current : best
                );
                const mergedDetection = {
                    ...baseDetection,
                    position: { x: minX, y: minY, width: maxX - minX, height: maxY - minY },
                    confidence: detectionsToMerge.reduce((sum, d) => sum + d.confidence, 0) / detectionsToMerge.length,
                    mergedFrom: detectionsToMerge.length,
                    isMerged: true
                };
                recordAction('merge_detections', { indices: selectedIndices, detections: detectionsToMerge, mergedResult: mergedDetection });
                let newResults = recognitionResults.slice();
                for (let i = selectedIndices.length - 1; i >= 0; i--) {
                    newResults.splice(selectedIndices[i], 1);
                }
                newResults.push(mergedDetection);
                setRecognitionResults(newResults);
                setSelectedRegions(new Set());
                setMergeIndicator(null);
            };

            const getImageCoordinates = (event) => {
                if (!imageRef.current) return null;
                const rect = imageRef.current.getBoundingClientRect();
                const scaleX = imageRef.current.naturalWidth / rect.width;
                const scaleY = imageRef.current.naturalHeight / rect.height;
                return {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            };

            const handleImageMouseDown = (event) => {
                if (!manualDetectionMode) return;
                const coords = getImageCoordinates(event);
                if (!coords) return;
                setIsDrawing(true);
                setDrawStart(coords);
                setDrawCurrent(coords);
            };

           const handleImageMouseMove = (event) => {
                if (!manualDetectionMode) return;
                if (!isDrawing) return;
                
                event.preventDefault(); // Prevent default drag behavior
                const coords = getImageCoordinates(event);
                if (coords) {
                    setDrawCurrent(coords);
                }
            };

            const handleImageMouseUp = (event) => {
                if (!manualDetectionMode || !isDrawing || !drawStart) return;
                const coords = getImageCoordinates(event);
                if (!coords) return;
                const bounds = {
                    x: Math.min(drawStart.x, coords.x),
                    y: Math.min(drawStart.y, coords.y),
                    width: Math.abs(coords.x - drawStart.x),
                    height: Math.abs(coords.y - drawStart.y)
                };
                if (bounds.width > 10 && bounds.height > 10) {
                    const manualDetection = {
                        symbol: { id: 'unknown', name: 'Unknown', transliteration: '?' },
                        confidence: 0.5,
                        position: bounds,
                        matchType: 'manual',
                        isManual: true
                    };
                    setRecognitionResults(prev => [...prev, manualDetection]);
                }
                setIsDrawing(false);
                setDrawStart(null);
                setDrawCurrent(null);
            };

            const toggleRegionSelection = (regionIndex) => {
                setSelectedRegions(prev => {
                    const newSet = new Set(prev);
                    newSet.has(regionIndex) ? newSet.delete(regionIndex) : newSet.add(regionIndex);
                    return newSet;
                });
            };

            const handleDetectionClick = (event, index) => {
                if (event.ctrlKey || event.metaKey) {
                    event.stopPropagation();
                    toggleRegionSelection(index);
                }
            };

            const getReadingOrderedResults = () => {
                if (viewMode === 'detection') return recognitionResults;
                
                // If manual reading order exists, use it
                if (readingOrder.length === recognitionResults.length) {
                    return readingOrder.map(idx => recognitionResults[idx]);
                }
                
                // Otherwise, auto-sort by direction
            const sorted = recognitionResults.map((result, idx) => ({ result, originalIndex: idx }));
                
                if (readingDirection === 'ltr') {
                    sorted.sort((a, b) => 
                        a.result.position.y - b.result.position.y || 
                        a.result.position.x - b.result.position.x
                    );
                } else if (readingDirection === 'rtl') {
                    sorted.sort((a, b) => 
                        a.result.position.y - b.result.position.y || 
                        b.result.position.x - a.result.position.x
                    );
                } else if (readingDirection === 'ttb') {
                    sorted.sort((a, b) => 
                        a.result.position.x - b.result.position.x || 
                        a.result.position.y - b.result.position.y
                    );
                }
                
                return sorted.map(item => item.result);
            };

        const getFilteredResults = () => {
                if (!useConfidenceFilter) {
                    return recognitionResults;
                }
            return recognitionResults.filter(result => result.confidence >= confidenceThreshold / 100);
         };   

        const getReadingOrderIndex = (detectionIndex) => {
            const orderedResults = getReadingOrderedResults();
                return orderedResults.findIndex(result => 
                recognitionResults.indexOf(result) === detectionIndex
            ) + 1;
        };

        const applyReadingDirection = (direction) => {
            setReadingDirection(direction);
                
            // Auto-generate reading order based on direction
            const sorted = recognitionResults.map((result, idx) => ({ result, idx }));
                
            if (direction === 'ltr') {
                sorted.sort((a, b) => 
                    a.result.position.y - b.result.position.y || 
                    a.result.position.x - b.result.position.x
                );
            } else if (direction === 'rtl') {
                sorted.sort((a, b) => 
                    a.result.position.y - b.result.position.y || 
                    b.result.position.x - a.result.position.x
                );
            } else if (direction === 'ttb') {
                sorted.sort((a, b) => 
                    a.result.position.x - b.result.position.x || 
                    a.result.position.y - b.result.position.y
                );
            } else {
                // Detection order - just use original indices
                setReadingOrder(recognitionResults.map((_, idx) => idx));
                return;
            }
            
                setReadingOrder(sorted.map(item => item.idx));
            };

            const toggleWordBoundary = (readingOrderIndex) => {
                setWordBoundaries(prev => {
                    const newSet = new Set(prev);
                    newSet.has(readingOrderIndex) ? newSet.delete(readingOrderIndex) : newSet.add(readingOrderIndex);
                    return newSet;
                });
                recordAction('toggle_word_boundary', { readingOrderIndex });
            };

            const handleDragStart = (e, index) => {
                // Prevent dragging in detection order mode
                if (readingDirection === 'detection') {
                    e.preventDefault();
                    alert('⚠️ Cannot reorder in Detection Order mode.\n\nPlease select a reading direction (LTR, RTL, or TTB) to manually reorder symbols.');
                    return;
                }
                setDraggedItem(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = (e, dropIndex) => {
                e.preventDefault();
                if (draggedItem === null || draggedItem === dropIndex) return;
                
                const newOrder = [...readingOrder];
                const draggedValue = newOrder[draggedItem];
                newOrder.splice(draggedItem, 1);
                newOrder.splice(dropIndex, 0, draggedValue);
                
                setReadingOrder(newOrder);
                setDraggedItem(null);
                
                recordAction('reorder_reading', { from: draggedItem, to: dropIndex });
            };

            useEffect(() => {
                if (selectedRegions.size >= 2) {
                    const selectedDetections = Array.from(selectedRegions).map(i => recognitionResults[i]);
                    if (selectedDetections.length > 0) {
                        const minX = Math.min(...selectedDetections.map(d => d.position.x));
                        const minY = Math.min(...selectedDetections.map(d => d.position.y));
                        const maxX = Math.max(...selectedDetections.map(d => d.position.x + d.position.width));
                        const maxY = Math.max(...selectedDetections.map(d => d.position.y + d.position.height));
                        setMergeIndicator({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });
                    }
                } else {
                    setMergeIndicator(null);
                }
            }, [selectedRegions, recognitionResults]);

            const isolateSymbols = (inputImage) => {
                if (!isOpenCvReady) return [];
                try {
                    const src = cv.imread(inputImage);
                    const gray = new cv.Mat();
                    const binary = new cv.Mat();
                    const morphKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
                    const processed = new cv.Mat();
                    if (src.channels() > 1) {
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    } else {
                        gray = src.clone();
                    }
                    cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
                    cv.morphologyEx(binary, processed, cv.MORPH_CLOSE, morphKernel);
                    const contours = new cv.MatVector();
                    const hierarchy = new cv.Mat();
                    cv.findContours(processed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                    const isolatedRegions = [];
                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const boundingRect = cv.boundingRect(contour);
                        const area = boundingRect.width * boundingRect.height;
                        const aspectRatio = boundingRect.width / boundingRect.height;
                        if (area >= 100 && area <= 10000 && aspectRatio >= 0.2 && aspectRatio <= 5.0) {
                            const padding = 5;
                            isolatedRegions.push({
                                bounds: {
                                    x: Math.max(0, boundingRect.x - padding),
                                    y: Math.max(0, boundingRect.y - padding),
                                    width: Math.min(src.cols - boundingRect.x + padding, boundingRect.width + 2 * padding),
                                    height: Math.min(src.rows - boundingRect.y + padding, boundingRect.height + 2 * padding)
                                },
                                area,
                                aspectRatio
                            });
                        }
                    }
                    isolatedRegions.sort((a, b) => a.bounds.x - b.bounds.x);
                    src.delete(); gray.delete(); binary.delete(); morphKernel.delete(); processed.delete();
                    contours.delete(); hierarchy.delete();
                    return isolatedRegions;
                } catch (error) {
                    console.error('Symbol isolation error:', error);
                    return [];
                }
            };
            
            const performTemplateMatchingOnRegion = (inputImage, templateImage, region) => {
                if (!isOpenCvReady) return [];
                try {
                    const src = cv.imread(inputImage);
                    const regionMat = src.roi(new cv.Rect(region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height));
                    const templ = cv.imread(templateImage);
                    const matches = [];
                    
                    // Try multiple scales if template doesn't fit
                    const scales = [1.0, 0.8, 0.6, 0.4, 0.2];
                    
                    for (const scale of scales) {
                        const scaledTempl = new cv.Mat();
                        const newSize = new cv.Size(Math.floor(templ.cols * scale), Math.floor(templ.rows * scale));
                        
                        // Skip if scaled template is invalid size
                        if (newSize.width < 10 || newSize.height < 10 || newSize.width > regionMat.cols || newSize.height > regionMat.rows) {
                            continue;
                        }
                        
                        cv.resize(templ, scaledTempl, newSize, 0, 0, cv.INTER_AREA);
                        const dst = new cv.Mat();
                        cv.matchTemplate(regionMat, scaledTempl, dst, cv.TM_CCOEFF_NORMED);
                        const result = cv.minMaxLoc(dst);
                        
                        if (result.maxVal >= 0.5) {
                            matches.push({ 
                                confidence: result.maxVal * (1.0 - Math.abs(1.0 - scale) * 0.1),
                                position: region.bounds,
                                scale: scale
                            });
                        }
                        
                        dst.delete();
                        scaledTempl.delete();
                    }
                    
                    src.delete(); 
                    regionMat.delete(); 
                    templ.delete();
                    return matches;
                } catch (error) {
                    console.error('Template matching error:', error);
                    return [];
                }
            };

            const calculateIoU = (box1, box2) => {
                const x1 = Math.max(box1.x, box2.x);
                const y1 = Math.max(box1.y, box2.y);
                const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
                const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);
                
                const intersectionArea = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
                const box1Area = box1.width * box1.height;
                const box2Area = box2.width * box2.height;
                const unionArea = box1Area + box2Area - intersectionArea;
                
                return unionArea > 0 ? intersectionArea / unionArea : 0;
            };

            const applyNonMaximumSuppression = (detections, iouThreshold = 0.3) => {
                if (detections.length === 0) return detections;
                
                // Sort by confidence (highest first)
                const sorted = [...detections].sort((a, b) => b.confidence - a.confidence);
                const keep = [];
                
                while (sorted.length > 0) {
                    const current = sorted.shift();
                    keep.push(current);
                    
                    // Remove detections that overlap too much with current
                    for (let i = sorted.length - 1; i >= 0; i--) {
                        const iou = calculateIoU(current.position, sorted[i].position);
                        if (iou > iouThreshold) {
                            sorted.splice(i, 1);
                        }
                    }
                }
                
                return keep;
            };

            const exportTranscription = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';
                
                orderedResults.forEach((result, index) => {
                    transcription += result.symbol.transliteration || result.symbol.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });
                
                const blob = new Blob([transcription], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_transcription_${new Date().toISOString().slice(0,10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                recordAction('export_transcription', { transcription });
            };

            const exportDetectionData = () => {
                const data = {
                    timestamp: new Date().toISOString(),
                    imageFile: image ? 'uploaded_image' : null,
                    viewMode: viewMode,
                    readingDirection: readingDirection,
                    detections: recognitionResults.map((result, index) => ({
                        index: index,
                        symbol: result.symbol.name,
                        transliteration: result.symbol.transliteration,
                        confidence: result.confidence,
                        position: result.position,
                        matchType: result.matchType,
                        isManual: result.isManual || false,
                        isMerged: result.isMerged || false,
                        validated: validations[index] ? validations[index].isCorrect : null
                    })),
                    readingOrder: viewMode === 'reading' ? readingOrder : null,
                    wordBoundaries: Array.from(wordBoundaries),
                    actionHistory: actionHistory
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_detection_data_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                recordAction('export_detection_data', { detectionCount: recognitionResults.length });
            };

            const exportAnnotatedImage = () => {
                if (!imageRef.current) return;
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                
                // Draw original image
                ctx.drawImage(img, 0, 0);
                
                // Draw detection boxes and labels
                recognitionResults.forEach((detection, index) => {
                    const pos = detection.position;
                    
                    // Determine box color based on validation
                    let boxColor = '#3b82f6'; // blue - unvalidated
                    if (validations[index]) {
                        boxColor = validations[index].isCorrect ? '#10b981' : '#ef4444'; // green or red
                    }
                    
                    // Draw box
                    ctx.strokeStyle = boxColor;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(pos.x, pos.y, pos.width, pos.height);
                    
                    // Draw semi-transparent background for label
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    const labelText = detection.symbol.name;
                    ctx.font = '16px Arial';
                    const textWidth = ctx.measureText(labelText).width;
                    ctx.fillRect(pos.x, pos.y - 25, textWidth + 10, 25);
                    
                    // Draw label text
                    ctx.fillStyle = 'white';
                    ctx.fillText(labelText, pos.x + 5, pos.y - 7);
                    
                    // Draw reading order number if in reading view
                    if (viewMode === 'reading') {
                        const orderNum = getReadingOrderIndex(index);
                        ctx.fillStyle = '#facc15';
                        ctx.beginPath();
                        ctx.arc(pos.x - 15, pos.y - 15, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#ca8a04';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(orderNum.toString(), pos.x - 15, pos.y - 15);
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'alphabetic';
                    }
                });
                
                // Convert to blob and download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hakli_annotated_${new Date().toISOString().slice(0,10)}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    recordAction('export_annotated_image', {});
                });
            };

            const copyTranscriptionToClipboard = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';
                
                orderedResults.forEach((result, index) => {
                    transcription += result.symbol.transliteration || result.symbol.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });
                
                navigator.clipboard.writeText(transcription).then(() => {
                    alert('Transcription copied to clipboard!');
                    recordAction('copy_transcription', {});
                }).catch(err => {
                    console.error('Failed to copy:', err);
                });
            };

            const startCorrection = (detectionIndex) => {
                setCorrectionMode(detectionIndex);
            };

            const applyCorrection = (detectionIndex, newSymbol) => {
                recordAction('correct_symbol', {
                    detectionIndex: detectionIndex,
                    oldSymbol: recognitionResults[detectionIndex].symbol,
                    newSymbol: newSymbol
                });
                
                setRecognitionResults(prev => prev.map((result, index) => {
                    if (index === detectionIndex) {
                        return {
                            ...result,
                            symbol: newSymbol,
                            corrected: true,
                            originalSymbol: result.symbol
                        };
                    }
                    return result;
                }));
                
                setCorrectionMode(null);
            };

            const cancelCorrection = () => {
                setCorrectionMode(null);
            };
            
            const undo = () => {
                if (historyIndex <= 0) return;
                
                const previousState = stateHistory[historyIndex - 1];
                setRecognitionResults(previousState.recognitionResults);
                setValidations(previousState.validations);
                setSelectedRegions(previousState.selectedRegions);
                setWordBoundaries(previousState.wordBoundaries);
                setReadingOrder(previousState.readingOrder);
                setIsolatedSymbols(previousState.isolatedSymbols);
                setHistoryIndex(historyIndex - 1);
                
                console.log('Undo to state', historyIndex - 1);
            };

            const redo = () => {
                if (historyIndex >= stateHistory.length - 1) return;
                
                const nextState = stateHistory[historyIndex + 1];
                setRecognitionResults(nextState.recognitionResults);
                setValidations(nextState.validations);
                setSelectedRegions(nextState.selectedRegions);
                setWordBoundaries(nextState.wordBoundaries);
                setReadingOrder(nextState.readingOrder);
                setIsolatedSymbols(nextState.isolatedSymbols);
                setHistoryIndex(historyIndex + 1);
                
                console.log('Redo to state', historyIndex + 1);
            }; 

            const recognizeSymbols = () => {
                if (!image || !equivalenceChart || !isOpenCvReady) return;
                setIsProcessing(true);
                setRecognitionResults([]);
                console.log('Starting recognition with', equivalenceChart.symbols.length, 'symbols and', Object.keys(loadedSymbolImages).length, 'loaded images');
                try {
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        const isolated = isolateSymbols(tempImg);
                        setIsolatedSymbols(isolated);
                        console.log('Isolated', isolated.length, 'regions');
                        if (isolated.length === 0) {
                            console.log('No regions found - check image contrast and size');
                            setIsProcessing(false);
                            return;
                        }
                        const results = [];
                        let totalMatches = 0;
                        for (const region of isolated) {
                            let bestMatch = null;
                            
                            for (const symbol of equivalenceChart.symbols) {
                                // Check primary image
                                if (loadedSymbolImages[symbol.id]) {
                                    const matches = performTemplateMatchingOnRegion(tempImg, loadedSymbolImages[symbol.id], region);
                                    totalMatches += matches.length;
                                    for (const match of matches) {
                                        if (!bestMatch || match.confidence > bestMatch.confidence) {
                                            bestMatch = {
                                                symbol,
                                                confidence: match.confidence,
                                                position: region.bounds,
                                                matchType: 'primary'
                                            };
                                        }
                                    }
                                }
                                
                                // Check variant images
                                if (symbol.images && symbol.images.variants) {
                                    for (let i = 0; i < symbol.images.variants.length; i++) {
                                        const variantKey = `${symbol.id}_variant_${i}`;
                                        if (loadedSymbolImages[variantKey]) {
                                            const matches = performTemplateMatchingOnRegion(tempImg, loadedSymbolImages[variantKey], region);
                                            for (const match of matches) {
                                                const weightedConfidence = match.confidence * 0.9;
                                                if (!bestMatch || weightedConfidence > bestMatch.confidence) {
                                                    bestMatch = {
                                                        symbol,
                                                        confidence: weightedConfidence,
                                                        position: region.bounds,
                                                        matchType: 'variant',
                                                        variantIndex: i
                                                    };
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                // Check example images
                                if (symbol.images && symbol.images.examples) {
                                    for (let i = 0; i < symbol.images.examples.length; i++) {
                                        const exampleKey = `${symbol.id}_example_${i}`;
                                        if (loadedSymbolImages[exampleKey]) {
                                            const matches = performTemplateMatchingOnRegion(tempImg, loadedSymbolImages[exampleKey], region);
                                            for (const match of matches) {
                                                const weightedConfidence = match.confidence * 0.8;
                                                if (!bestMatch || weightedConfidence > bestMatch.confidence) {
                                                    bestMatch = {
                                                        symbol,
                                                        confidence: weightedConfidence,
                                                        position: region.bounds,
                                                        matchType: 'example',
                                                        exampleIndex: i
                                                    };
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            if (bestMatch && bestMatch.confidence > 0.4) {
                                results.push(bestMatch);
                                console.log(`Region ${isolated.indexOf(region)}: Matched ${bestMatch.symbol.name} with ${(bestMatch.confidence * 100).toFixed(1)}% confidence`);
                            }
                        }
                                                    console.log(`Recognition complete: ${results.length} symbols detected from ${isolated.length} regions (${totalMatches} total template matches tested)`);
                        
                        // Apply non-maximum suppression to remove overlapping detections
                        const filteredResults = applyNonMaximumSuppression(results, 0.3);
                        console.log(`After NMS: ${filteredResults.length} detections (removed ${results.length - filteredResults.length} overlapping)`);
                        
                        setRecognitionResults(filteredResults);
                        setIsProcessing(false);
                    };
                    tempImg.src = image;
                } catch (error) {
                    console.error('Recognition error:', error);
                    setIsProcessing(false);
                }
            };

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file && file.type.indexOf('image/') === 0) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setImage(e.target.result);
                        setRecognitionResults([]);
                        setValidations({});
                        setActionHistory([]);
                        setIsolatedSymbols([]);
                        setSelectedRegions(new Set());
                        setMergeIndicator(null);
                    };
                    reader.readAsDataURL(file);
                }
            };

            const getDetectionBoxStyle = (index) => {
                const detection = recognitionResults[index];
                if (!detection || !imageRef.current) return {};
                const imageRect = imageRef.current.getBoundingClientRect();
                const scaleX = imageRect.width / imageRef.current.naturalWidth;
                const scaleY = imageRect.height / imageRef.current.naturalHeight;
                return {
                    left: detection.position.x * scaleX + 'px',
                    top: detection.position.y * scaleY + 'px',
                    width: detection.position.width * scaleX + 'px',
                    height: detection.position.height * scaleY + 'px'
                };
            };

            const getDetectionBoxClass = (index) => {
                let classes = ['detection-box'];
                if (validations[index]) {
                    classes.push(validations[index].isCorrect ? 'validated-correct' : 'validated-incorrect');
                } else {
                    classes.push('unvalidated');
                }
                if (selectedRegions.has(index)) classes.push('selected');
                return classes.join(' ');
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Escape: Close correction modal
                    if (e.key === 'Escape' && correctionMode !== null) {
                        e.preventDefault();
                        cancelCorrection();
                        return;
                    }
                    
                    // Undo: Ctrl+Z (or Cmd+Z on Mac)
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        undo();
                    }
                    // Redo: Ctrl+Shift+Z or Ctrl+Y (or Cmd equivalents on Mac)
                    if ((e.ctrlKey || e.metaKey) && (e.shiftKey && e.key === 'z' || e.key === 'y')) {
                        e.preventDefault();
                        redo();
                    }
                };
                    
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [historyIndex, stateHistory, correctionMode]);

                        useEffect(() => {
                if (chartLoadStatus === 'not-loaded') {
                    setChartLoadStatus('loading');
                    const githubJsonUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/Hakli_symbols.JSON';
                    fetch(githubJsonUrl)
                        .then(response => response.json())
                        .then(chartData => {
                            setEquivalenceChart(chartData);
                            const imageCache = {};
                            const loadPromises = [];
                            
                            for (const symbol of chartData.symbols) {
                                // Load primary image
                                if (symbol.images && symbol.images.primary) {
                                    const fullUrl = convertToGitHubUrl(symbol.images.primary);
                                    if (fullUrl) {
                                        const promise = new Promise((resolve) => {
                                            const img = new Image();
                                            img.crossOrigin = 'anonymous';
                                            img.onload = () => {
                                                imageCache[symbol.id] = img;
                                                resolve();
                                            };
                                            img.onerror = () => resolve();
                                            img.src = fullUrl;
                                        });
                                        loadPromises.push(promise);
                                    }
                                }
                                
                                // Load variant images
                                if (symbol.images && symbol.images.variants) {
                                    for (let i = 0; i < symbol.images.variants.length; i++) {
                                        const fullUrl = convertToGitHubUrl(symbol.images.variants[i]);
                                        if (fullUrl) {
                                            const variantKey = `${symbol.id}_variant_${i}`;
                                            const promise = new Promise((resolve) => {
                                                const img = new Image();
                                                img.crossOrigin = 'anonymous';
                                                img.onload = () => {
                                                    imageCache[variantKey] = img;
                                                    resolve();
                                                };
                                                img.onerror = () => resolve();
                                                img.src = fullUrl;
                                            });
                                            loadPromises.push(promise);
                                        }
                                    }
                                }
                                
                                // Load example images
                                if (symbol.images && symbol.images.examples) {
                                    for (let i = 0; i < symbol.images.examples.length; i++) {
                                        const fullUrl = convertToGitHubUrl(symbol.images.examples[i]);
                                        if (fullUrl) {
                                            const exampleKey = `${symbol.id}_example_${i}`;
                                            const promise = new Promise((resolve) => {
                                                const img = new Image();
                                                img.crossOrigin = 'anonymous';
                                                img.onload = () => {
                                                    imageCache[exampleKey] = img;
                                                    resolve();
                                                };
                                                img.onerror = () => resolve();
                                                img.src = fullUrl;
                                            });
                                            loadPromises.push(promise);
                                        }
                                    }
                                }
                            }
                            
                            Promise.all(loadPromises).then(() => {
                                console.log(`Loaded ${Object.keys(imageCache).length} total images`);
                                setLoadedSymbolImages(imageCache);
                                setChartLoadStatus('loaded');
                            });
                        })
                        .catch(() => setChartLoadStatus('error'));
                }
            }, [chartLoadStatus]);

            return (
                <div className="max-w-6xl mx-auto p-6 bg-white">
                    <div className="mb-8">
                        <h1 className="text-3xl font-bold text-gray-900 mb-2">Hakli Symbol Recognizer</h1>
                        <p className="text-gray-600">Enhanced with Manual Detection and Merge Features</p>
                    </div>

                    <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                        <div className="flex items-center justify-between">
                            <div>
                                <h3 className="font-semibold text-gray-900">Equivalence Chart Status</h3>
                                <div className="flex items-center gap-2 mt-1">
                                    {chartLoadStatus === 'loading' && <span className="text-blue-600">Loading...</span>}
                                    {chartLoadStatus === 'loaded' && <span className="text-green-600">Loaded ({equivalenceChart?.symbols?.length || 0} symbols, {Object.keys(loadedSymbolImages).length} images)</span>}
                                    {chartLoadStatus === 'error' && <span className="text-red-600">Error loading chart</span>}
                                </div>
                            </div>
                            <button onClick={() => setChartLoadStatus('not-loaded')} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600" disabled={chartLoadStatus === 'loading'}>
                                Reload Chart
                            </button>
                        </div>
                    </div>

                    <div className="mb-6">
                        <input type="file" accept="image/*" onChange={handleFileUpload} className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" />
                    </div>

                    {recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                            <div className="flex items-center justify-between mb-4">
                                <h3 className="font-semibold text-gray-900">View Mode</h3>
                                <div className="flex gap-2">
                                    <button 
                                        onClick={() => setViewMode('detection')}
                                        className={`px-4 py-2 rounded font-medium ${viewMode === 'detection' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        📷 Detection View
                                    </button>
                                    <button 
                                        onClick={() => {
                                            setViewMode('reading');
                                            if (readingOrder.length === 0) {
                                                setReadingOrder(recognitionResults.map((_, idx) => idx));
                                            }
                                        }}
                                        className={`px-4 py-2 rounded font-medium ${viewMode === 'reading' ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        📖 Reading Order View
                                    </button>
                                </div>
                            </div>
                            
                            {viewMode === 'reading' && (
                                <div className="pt-4 border-t border-gray-300">
                                    <div className="flex items-center justify-between">
                                        <span className="text-sm font-medium text-gray-700">Reading Direction:</span>
                                        <div className="flex gap-2">
                                            <button 
                                                onClick={() => applyReadingDirection('detection')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'detection' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Original detection order"
                                            >
                                                🔢 Detection Order
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('ltr')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'ltr' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Left to Right"
                                            >
                                                → LTR
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('rtl')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'rtl' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Right to Left"
                                            >
                                                ← RTL
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('ttb')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'ttb' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Top to Bottom"
                                            >
                                                ↓ TTB
                                            </button>
                                        </div>
                                    </div>
                                    <div className="mt-3 p-3 bg-blue-50 border border-blue-200 rounded text-sm text-blue-800">
                                        💡 Tip: In Reading Order View, you can drag detection cards below to manually reorder them.
                                    </div>
                                </div>
                            )}
                            
                            {viewMode === 'detection' && (
                                <div className="pt-4 border-t border-gray-300">
                                    <div className="p-3 bg-gray-100 border border-gray-300 rounded text-sm text-gray-700">
                                        📷 Detection View shows symbols in the order they were detected (left-to-right on the image). Use this mode for validation and editing.
                                    </div>
                                </div>
                            )}
                        </div>
                    )}


                    {image && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <div className="flex flex-wrap gap-3 items-center mb-4">
                                <button onClick={recognizeSymbols} disabled={isProcessing || !equivalenceChart} className="px-6 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50">
                                    {isProcessing ? 'Processing...' : 'Recognize Symbols'}
                                </button>

                                <button onClick={() => setManualDetectionMode(!manualDetectionMode)} className={`px-4 py-2 rounded ${manualDetectionMode ? 'bg-orange-500 text-white hover:bg-orange-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>
                                    {manualDetectionMode ? 'Exit Manual Mode' : 'Manual Detection'}
                                </button>
                                <button onClick={() => setShowRegionBoundaries(!showRegionBoundaries)} className={`px-4 py-2 rounded ${showRegionBoundaries ? 'bg-purple-500 text-white hover:bg-purple-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>
                                    Region Boundaries
                                </button>
                                <span className="text-sm text-gray-600">{recognitionResults.length} detections</span>
                            </div>

                            {recognitionResults.length > 0 && (
                                <div className="mt-4 p-4 bg-white border-2 border-gray-300 rounded-lg">
                                    <div className="flex items-center justify-between mb-3">
                                        <div className="flex items-center gap-3">
                                            <h4 className="font-semibold text-gray-900">Confidence Filter</h4>
                                            <label className="flex items-center gap-2 cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={useConfidenceFilter}
                                                    onChange={(e) => setUseConfidenceFilter(e.target.checked)}
                                                    className="w-4 h-4"
                                                />
                                                <span className="text-sm text-gray-700">Enable</span>
                                            </label>
                                        </div>
                                        <div className="text-sm">
                                            {useConfidenceFilter ? (
                                                <span className="text-blue-600 font-semibold">
                                                    Showing {getFilteredResults().length} of {recognitionResults.length} detections
                                                    {recognitionResults.length - getFilteredResults().length > 0 && (
                                                        <span className="text-gray-500 ml-2">
                                                            ({recognitionResults.length - getFilteredResults().length} hidden)
                                                        </span>
                                                    )}
                                                </span>
                                            ) : (
                                                <span className="text-gray-600">Showing all {recognitionResults.length} detections</span>
                                            )}
                                        </div>
                                    </div>
                                    
                                    <div className="flex items-center gap-4">
                                        <label className="text-sm font-medium text-gray-700 whitespace-nowrap">
                                            Min Confidence: {confidenceThreshold}%
                                        </label>
                                        <input
                                            type="range"
                                            min="0"
                                            max="100"
                                            value={confidenceThreshold}
                                            onChange={(e) => setConfidenceThreshold(parseInt(e.target.value))}
                                            disabled={!useConfidenceFilter}
                                            className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed"
                                            style={{
                                                background: useConfidenceFilter 
                                                    ? `linear-gradient(to right, #ef4444 0%, #f59e0b ${confidenceThreshold / 2}%, #10b981 ${confidenceThreshold}%, #e5e7eb ${confidenceThreshold}%, #e5e7eb 100%)`
                                                    : '#e5e7eb'
                                            }}
                                        />
                                        <span className="text-xs text-gray-500 whitespace-nowrap">
                                            {confidenceThreshold < 40 && '🔴 Low'}
                                            {confidenceThreshold >= 40 && confidenceThreshold < 70 && '🟡 Medium'}
                                            {confidenceThreshold >= 70 && '🟢 High'}
                                        </span>
                                    </div>
                                </div>
                            )}
                                <button 
                                    onClick={undo}
                                    disabled={historyIndex <= 0}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed"
                                    title="Undo (Ctrl+Z)"
                                >
                                    ↶ Undo
                                </button>
                                <button 
                                    onClick={redo}
                                    disabled={historyIndex >= stateHistory.length - 1}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed"
                                    title="Redo (Ctrl+Y)"
                                >
                                    ↷ Redo
                                </button>

                            {selectedRegions.size > 0 && (
                                <div className="flex flex-wrap gap-3 items-center pt-3 border-t border-gray-200">
                                    <span className="text-sm text-gray-600">{selectedRegions.size} selected</span>
                                    {selectedRegions.size >= 2 && (
                                        <button onClick={mergeSelectedDetections} className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600">
                                            Merge Selected
                                        </button>
                                    )}
                                    <button onClick={() => setSelectedRegions(new Set())} className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                                        Clear Selection
                                    </button>
                                </div>
                            )}
                            
                            {manualDetectionMode && (
                                <div className="mt-3 p-3 bg-orange-50 border border-orange-200 rounded text-sm text-orange-800">
                                    Manual Mode: Click and drag to create detections. Ctrl/Cmd+Click to select for merging.
                                </div>
                            )}
                            {recognitionResults.length > 0 && (
                                <div className="mt-3 p-3 bg-blue-50 border border-blue-200 rounded text-sm text-blue-800">
                                    💡 Tip: Ctrl/Cmd+Click any detection box to select it. Delete (✕) and Merge (⚡) buttons will appear.
                                </div>
                            )}
                        </div>
                    )}

                    {image && (
                        <div className="mb-6">
                            <div className="canvas-container relative" ref={imageContainerRef}
                                onMouseMove={handleImageMouseMove}
                                onMouseUp={handleImageMouseUp}
                                onMouseLeave={handleImageMouseUp}
                            >
                                <img
                                    ref={imageRef}
                                    src={image}
                                    alt="Uploaded inscription"
                                    className="max-w-full h-auto border border-gray-300 rounded"
                                    onMouseDown={handleImageMouseDown}
                                    style={{ 
                                        cursor: manualDetectionMode ? 'crosshair' : 'default',
                                        userSelect: 'none',
                                        pointerEvents: 'auto'
                                    }}
                                    draggable={false}
                                />
                                
                                {showRegionBoundaries && isolatedSymbols.map((region, index) => {
                                    if (!imageRef.current) return null;
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div key={`region-${index}`} className="region-boundary" style={{
                                            left: region.bounds.x * scaleX + 'px',
                                            top: region.bounds.y * scaleY + 'px',
                                            width: region.bounds.width * scaleX + 'px',
                                            height: region.bounds.height * scaleY + 'px'
                                        }} />
                                    );
                                })}
                                
                                {getFilteredResults().map((detection) => {
                                    const index = recognitionResults.indexOf(detection);
                                    return (
                                    <div key={`detection-${index}`} className={getDetectionBoxClass(index)} style={getDetectionBoxStyle(index)} onClick={(e) => handleDetectionClick(e, index)}>               
                                        {viewMode === 'reading' && (
                                            <div className="absolute -top-3 -left-3 w-6 h-6 rounded-full bg-yellow-400 border-2 border-yellow-600 text-xs font-bold flex items-center justify-center shadow-lg" style={{ pointerEvents: 'none' }}>
                                                {getReadingOrderIndex(index)}
                                            </div>
                                        )}

                                        <div className="absolute top-1 left-1 bg-black bg-opacity-75 text-white text-xs px-1 py-0.5 rounded flex items-center gap-1" style={{ pointerEvents: 'none' }}>
                                             {detection.corrected && <span title="Corrected symbol">✏️</span>}
                                                <span>{detection.symbol.name}</span>
                                        </div>

                                        {selectedRegions.has(index) && (
                                        <>
                                            <div className="absolute bottom-1 right-1 bg-black bg-opacity-75 text-white text-xs px-1 py-0.5 rounded" style={{ pointerEvents: 'none' }}>
                                                {Math.round(detection.confidence * 100)}%
                                            </div>
                                            <div className="absolute top-1 right-1 flex gap-1" style={{ pointerEvents: 'auto' }}>
                                                <button 
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        startCorrection(index);
                                                    }}
                                                    className="px-2 py-1 bg-orange-500 text-white text-xs rounded hover:bg-orange-600"
                                                    title="Change symbol"
                                                >
                                                    ✏️
                                                </button>
                                                <button 
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        deleteDetection(index);
                                                    }}
                                                    className="px-2 py-1 bg-red-500 text-white text-xs rounded hover:bg-red-600"
                                                    title="Delete this detection"
                                                >
                                                    ✕
                                                </button>
                                                {selectedRegions.size >= 2 && (
                                                    <button 
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            mergeSelectedDetections();
                                                        }}
                                                        className="px-2 py-1 bg-purple-500 text-white text-xs rounded hover:bg-purple-600"
                                                        title="Merge selected detections"
                                                    >
                                                        ⚡
                                                    </button>
                                                )}
                                            </div>
                                        </>
                                    )}
                                    </div>
                                );
                                })}
                                
                                {isDrawing && drawStart && drawCurrent && imageRef.current && (() => {
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div className="manual-selection-box" style={{
                                            left: Math.min(drawStart.x, drawCurrent.x) * scaleX + 'px',
                                            top: Math.min(drawStart.y, drawCurrent.y) * scaleY + 'px',
                                            width: Math.abs(drawCurrent.x - drawStart.x) * scaleX + 'px',
                                            height: Math.abs(drawCurrent.y - drawStart.y) * scaleY + 'px'
                                        }} />
                                    );
                                })()}
                                
                                {mergeIndicator && imageRef.current && (() => {
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div className="merge-indicator" style={{
                                            left: mergeIndicator.x * scaleX + 'px',
                                            top: mergeIndicator.y * scaleY + 'px',
                                            width: mergeIndicator.width * scaleX + 'px',
                                            height: mergeIndicator.height * scaleY + 'px'
                                        }} />
                                    );
                                })()}
                            </div>
                        </div>
                    )}

                    {correctionMode !== null && equivalenceChart && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={cancelCorrection}>
                            <div className="bg-white rounded-lg p-6 max-w-5xl w-full max-h-[85vh] overflow-y-auto shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900">Select Correct Symbol</h3>
                                    <button 
                                        onClick={cancelCorrection} 
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none w-8 h-8 flex items-center justify-center"
                                        title="Close (Esc)"
                                    >
                                        &times;
                                    </button>
                                </div>
                                
                                <div className="mb-4 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-blue-200 rounded-lg">
                                    <div className="flex items-center justify-between">
                                        <div>
                                            <span className="text-sm text-gray-600">Currently detected as:</span>
                                            <div className="text-xl font-bold text-gray-900 mt-1">
                                                {recognitionResults[correctionMode].symbol.name}
                                                <span className="ml-3 text-base font-normal text-gray-600">
                                                    ({recognitionResults[correctionMode].symbol.transliteration || recognitionResults[correctionMode].symbol.name})
                                                </span>
                                            </div>
                                        </div>
                                        <div className="text-sm text-gray-500">
                                            {Math.round(recognitionResults[correctionMode].confidence * 100)}% confidence
                                        </div>
                                    </div>
                                </div>
                                
                                <div className="mb-4">
                                    <input
                                        type="text"
                                        placeholder="Search symbols by name or transliteration..."
                                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none"
                                        onChange={(e) => {
                                            const searchTerm = e.target.value.toLowerCase();
                                            const symbolGrid = e.target.parentElement.nextElementSibling;
                                            const buttons = symbolGrid.querySelectorAll('button');
                                            buttons.forEach(btn => {
                                                const text = btn.textContent.toLowerCase();
                                                btn.style.display = text.includes(searchTerm) ? '' : 'none';
                                            });
                                        }}
                                    />
                                </div>
                                
                                <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2">
                                    {equivalenceChart.symbols.map((symbol) => {
                                        const isCurrentSymbol = symbol.id === recognitionResults[correctionMode].symbol.id;
                                        return (
                                            <button
                                                key={symbol.id}
                                                onClick={() => applyCorrection(correctionMode, symbol)}
                                                className={`p-3 border-2 rounded-lg flex flex-col items-center gap-1 transition-all hover:scale-105 ${
                                                    isCurrentSymbol 
                                                        ? 'border-blue-500 bg-blue-50 ring-2 ring-blue-300' 
                                                        : 'border-gray-200 hover:border-blue-400 hover:bg-blue-50'
                                                }`}
                                                title={`${symbol.name} (${symbol.transliteration || symbol.name})`}
                                            >
                                                <div className="font-bold text-xl">{symbol.name}</div>
                                                <div className="text-xs text-gray-600 text-center leading-tight">
                                                    {symbol.transliteration || symbol.name}
                                                </div>
                                                {isCurrentSymbol && (
                                                    <div className="text-xs text-blue-600 font-semibold mt-1">Current</div>
                                                )}
                                            </button>
                                        );
                                    })}
                                </div>
                                
                                <div className="mt-6 pt-4 border-t border-gray-200 flex items-center justify-between">
                                    <div className="text-sm text-gray-500">
                                        💡 Tip: You can also search symbols above to find them quickly
                                    </div>
                                    <button 
                                        onClick={cancelCorrection}
                                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <h3 className="font-semibold text-gray-900 mb-3">
                                {viewMode === 'detection' ? 'Detection Results' : 'Reading Order Results'}
                                {viewMode === 'reading' && <span className="ml-2 text-sm text-gray-600">(drag cards to reorder)</span>}
                            </h3>
                            
                            {/* Validation Statistics */}
                            <div className="mb-4 flex flex-wrap gap-4 text-sm">
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-600">Total:</span>
                                    <span className="font-semibold text-gray-900">{recognitionResults.length}</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-green-600">✓ Validated Correct:</span>
                                    <span className="font-semibold text-green-700">
                                        {Object.values(validations).filter(v => v.isCorrect).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-red-600">✗ Validated Incorrect:</span>
                                    <span className="font-semibold text-red-700">
                                        {Object.values(validations).filter(v => !v.isCorrect).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-orange-600">✏️ Corrected:</span>
                                    <span className="font-semibold text-orange-700">
                                        {recognitionResults.filter(r => r.corrected).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-600">Unvalidated:</span>
                                    <span className="font-semibold text-gray-700">
                                        {recognitionResults.length - Object.keys(validations).length}
                                    </span>
                                </div>
                            </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                        {(viewMode === 'detection' ? getFilteredResults() : getReadingOrderedResults().filter(r => getFilteredResults().includes(r))).map((result, displayIndex) => {
                            const originalIndex = viewMode === 'detection' ? displayIndex : recognitionResults.indexOf(result);
                            const readingOrderNum = viewMode === 'reading' ? displayIndex + 1 : null;
                            
                            return (
                                <div 
                                    key={`result-${originalIndex}`} 
                                    className={`p-3 bg-white rounded border ${selectedRegions.has(originalIndex) ? 'ring-2 ring-amber-400' : ''} ${validations[originalIndex] ? (validations[originalIndex].isCorrect ? 'border-green-300' : 'border-red-300') : 'border-gray-200'} ${viewMode === 'reading' ? 'cursor-move' : ''}`}
                                    draggable={viewMode === 'reading'}
                                    onDragStart={(e) => viewMode === 'reading' && handleDragStart(e, displayIndex)}
                                    onDragOver={(e) => viewMode === 'reading' && handleDragOver(e, displayIndex)}
                                    onDrop={(e) => viewMode === 'reading' && handleDrop(e, displayIndex)}
                                >
                                    <div className="flex items-start justify-between mb-2">
                                        <div className="flex-1">
                                            <div className="flex items-center gap-2">
                                                {viewMode === 'reading' && (
                                                    <div className="flex-shrink-0 w-6 h-6 rounded-full bg-yellow-400 border-2 border-yellow-600 text-xs font-bold flex items-center justify-center">
                                                        {readingOrderNum}
                                                    </div>
                                                )}
                                                <div className="flex-1">
                                                    <div className="font-medium text-gray-900 flex items-center gap-2">
                                                        {result.symbol.name}
                                                        {result.corrected && (
                                                            <span className="text-xs bg-orange-100 text-orange-700 px-2 py-0.5 rounded border border-orange-300">
                                                                ✏️ Corrected
                                                            </span>
                                                        )}
                                                        {result.isMerged && <span className="text-xs text-gray-500">(merged)</span>}
                                                        {result.isManual && <span className="text-xs text-gray-500">(manual)</span>}
                                                    </div>
                                                    {result.corrected && result.originalSymbol && (
                                                        <div className="text-xs text-gray-500 mt-0.5">
                                                            Originally: <span className="line-through">{result.originalSymbol.name}</span>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="text-sm text-gray-600 mt-1">{result.symbol.transliteration || result.symbol.name}</div>
                                            <div className="text-xs text-gray-500">Confidence: {Math.round(result.confidence * 100)}%</div>
                                        </div>
                                        <div className="flex gap-1">
                                            <button 
                                                onClick={() => startCorrection(originalIndex)} 
                                                className="text-orange-500 hover:text-orange-700 text-sm"
                                                title="Change symbol"
                                            >
                                                ✏️
                                            </button>
                                            <button 
                                                onClick={() => deleteDetection(originalIndex)} 
                                                className="text-red-500 hover:text-red-700 text-sm"
                                                title="Delete detection"
                                            >
                                                ✕
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex gap-2 flex-wrap">
                                        <button 
                                            onClick={() => validateDetection(originalIndex, true)} 
                                            className={`px-3 py-1 text-xs rounded ${validations[originalIndex]?.isCorrect ? 'bg-green-500 text-white' : 'bg-green-100 text-green-700 hover:bg-green-200'}`}
                                        >
                                            ✓ Correct
                                        </button>
                                        <button 
                                            onClick={() => validateDetection(originalIndex, false)} 
                                            className={`px-3 py-1 text-xs rounded ${validations[originalIndex] && !validations[originalIndex].isCorrect ? 'bg-red-500 text-white' : 'bg-red-100 text-red-700 hover:bg-red-200'}`}
                                        >
                                            ✗ Incorrect
                                        </button>
                                        {viewMode === 'reading' && (
                                            <button 
                                                onClick={() => toggleWordBoundary(displayIndex)} 
                                                className={`px-3 py-1 text-xs rounded ${wordBoundaries.has(displayIndex) ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Mark word boundary after this symbol"
                                            >
                                                | Word Break
                                            </button>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                    </div>
                    )}


                    {viewMode === 'reading' && recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border-2 border-blue-200">
                            <div className="flex items-center justify-between mb-3">
                                <h3 className="font-semibold text-gray-900">Transcription</h3>
                                <div className="flex gap-2">
                                    <button 
                                        onClick={copyTranscriptionToClipboard}
                                        className="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 flex items-center gap-1"
                                        title="Copy transcription to clipboard"
                                    >
                                        📋 Copy
                                    </button>
                                    <button 
                                        onClick={exportTranscription}
                                        className="px-3 py-1 bg-green-500 text-white text-sm rounded hover:bg-green-600 flex items-center gap-1"
                                        title="Download transcription as text file"
                                    >
                                        💾 Export TXT
                                    </button>
                                </div>
                            </div>
                            <div className="p-4 bg-white rounded border-2 border-blue-300 shadow-inner">
                                <div className="font-mono text-lg leading-relaxed">
                                    {getReadingOrderedResults().map((result, index) => (
                                        <span key={index}>
                                            <span className="text-gray-900">{result.symbol.transliteration || result.symbol.name}</span>
                                            {wordBoundaries.has(index) && <span className="text-blue-600 font-bold mx-1">|</span>}
                                            {!wordBoundaries.has(index) && index < getReadingOrderedResults().length - 1 && <span className="text-gray-400">·</span>}
                                        </span>
                                    ))}
                                </div>
                            </div>

                            <div className="mt-3 text-xs text-gray-600">
                                <span className="text-blue-600 font-bold">|</span> = word boundary &middot; 
                                <span className="text-gray-400">&middot;</span> = symbol separator
                            </div>
                        </div>
                    )}

                    <div className="mt-8 p-4 bg-gray-50 rounded-lg">
                        <div className="text-sm text-gray-600">
                            <div className="flex items-center gap-2">
                                <span className={`w-2 h-2 rounded-full ${isOpenCvReady ? 'bg-green-500' : 'bg-red-500'}`} />
                                OpenCV Status: {isOpenCvReady ? 'Ready' : 'Loading...'}
                                {actionHistory.length > 0 && <span className="ml-4 text-xs text-gray-500">{actionHistory.length} actions recorded</span>}
                            </div>
                        </div>
                    </div>

                    {recognitionResults.length > 0 && (
                        <div className="mt-6 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                            <h3 className="font-semibold text-gray-900 mb-3">Export Options</h3>
                            <div className="flex flex-wrap gap-3">
                                <button 
                                    onClick={exportDetectionData}
                                    className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 flex items-center gap-2"
                                >
                                    📊 Export Detection Data (JSON)
                                </button>
                                <button 
                                    onClick={exportAnnotatedImage}
                                    className="px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 flex items-center gap-2"
                                >
                                    🖼️ Export Annotated Image
                                </button>
                                {viewMode === 'reading' && (
                                    <button 
                                        onClick={exportTranscription}
                                        className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 flex items-center gap-2"
                                    >
                                        📝 Export Transcription (TXT)
                                    </button>
                                )}
                            </div>
                            <div className="mt-3 text-xs text-gray-600">
                                Export your work in different formats: JSON for data analysis, annotated images for presentations, or plain text transcriptions.
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<HakliSymbolRecognizer />);
    </script>
</body>
</html>