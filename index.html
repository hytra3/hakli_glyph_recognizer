<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Glyph Recognizer</title>
    <meta name="description" content="Ancient South Arabian script recognition tool">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#5d4e6d">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <!-- Favicons -->
    <link rel="icon" type="image/png" sizes="192x192" href="favicon.png">
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="hh-logo.png">
    
    <!-- React & Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'ancient-purple': '#5d4e6d',
                        'stone': '#8b7d6b',
                        'patina': '#6b8e7f',
                        'ochre': '#b8956a',
                        'rust': '#a0674f',
                    }
                }
            }
        }
    </script>
    
    <!-- jsPDF for booklet generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- OpenCV -->
    <script>
        var isOpenCvReady = false;
        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('âœ… OpenCV.js is ready');
            window.dispatchEvent(new Event('opencv-ready'));
        }
    </script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <style>
        .detection-box {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
            border: 3px solid;
            border-radius: 4px;
            cursor: pointer;
        }
        .detection-box.validated-correct { border-color: #6b8e7f; background: rgba(107, 142, 127, 0.25); }
        .detection-box.validated-incorrect { border-color: #a0674f; background: rgba(239, 68, 68, 0.25); }
        .detection-box.unvalidated { border-color: #8b7d6b; background: rgba(59, 130, 246, 0.25); }
        .detection-box.selected { border-color: #b8956a; background: rgba(245, 158, 11, 0.3); border-width: 4px; }
        .detection-box.uncertain { border-style: dashed; }
        .detection-label {
            position: absolute;
            top: 2px;
            left: 2px;
            padding: 1px 4px;
            font-size: 10px;
            font-weight: 600;
            color: white;
            border-radius: 2px;
            white-space: nowrap;
            text-shadow: 0 1px 2px rgba(0,0,0,0.7);
            letter-spacing: 0.3px;
            min-width: 14px;
            min-height: 12px;
            text-align: center;
            line-height: 1.2;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            opacity: 0.85;
        }
        .detection-label.bg-stone { background: rgba(139, 125, 107, 0.7); }
        .detection-label.bg-ochre { background: rgba(184, 149, 106, 0.8); }
        .detection-label.bg-patina { background: rgba(107, 142, 127, 0.7); }
        .detection-label.bg-rust { background: rgba(160, 103, 79, 0.7); }
        .reading-order-badge {
            position: absolute;
            top: -16px;
            left: -16px;
            width: 22px;
            height: 22px;
            background: #b8956a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            z-index: 20;
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- Eruda Mobile Console (remove after debugging) -->
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    
    <div id="root"></div>

    <!-- Core modules (must load first) -->
    <script src="src/core/config.js"></script>
    <script src="src/utils/helpers.js"></script>
    
    <!-- Storage modules -->
    <script src="src/storage/hki.js"></script>
    <script src="src/storage/cache.js"></script>
    <script src="src/storage/corrections.js"></script>
    <script src="src/storage/change-tracker.js"></script>
    <script src="src/storage/drive-sync.js"></script>
    <script src="src/storage/access-control.js"></script>
    <script src="src/storage/sync-manager.js"></script>
    <script src="src/storage/local-autosave.js"></script>
    
    <!-- ============================================ -->
    <!-- CACHE-BUSTING: When updating, change v=XXXXXX in ALL script tags below to match APP_VERSION -->
    <!-- Current version: v260122d -->
    <!-- ============================================ -->
    
    <!-- Recognition modules -->
    <script src="src/recognition/preprocessing.js"></script>
    <script src="src/recognition/isolation.js"></script>
    <script src="src/recognition/matching.js"></script>
    <script src="src/recognition/nms.js"></script>
    <script src="src/recognition/validation.js"></script>
    <script src="src/recognition/template-learning.js"></script>
    
    <!-- Reading modules -->
    <script src="src/reading/reading.js"></script>
    <script src="src/reading/transcription.js"></script>
    
    <!-- UI Components (loaded as Babel) -->
    <script type="text/babel" src="src/components/common/CommonComponents.jsx?v=260210c"></script>
    <script type="text/babel" src="src/components/common/DetectionCard.jsx?v=260210c"></script>
    <script type="text/babel" src="src/components/panels/InscriptionPanel.jsx?v=260210c"></script>
    <script type="text/babel" src="src/components/panels/ExportPanel.jsx?v=260210c"></script>
    <script type="text/babel" src="src/components/common/AccessControlUI.jsx?v=260210c"></script>
    <script type="text/babel" src="src/components/modals/WarehouseModal.jsx?v=260210c"></script>
    <script type="text/babel" src="src/components/modals/CollaboratorManager.jsx?v=260210c"></script>
    <script type="text/babel" src="src/components/modals/BookletGenerator.jsx?v=260210c"></script>

    <!-- Main Application -->
    <script type="text/babel">
        const APP_VERSION = 'v260210c';
        console.log('ðŸš€ Hakli Glyph Recognizer ' + APP_VERSION + ' (Transcription Syncs with Reading Order!)');

        function HakliGlyphRecognizer() {
            const { useState, useEffect, useRef, useCallback, useMemo } = React;
            
            // ========== STATE ==========
            const [originalImage, setOriginalImage] = useState(null);
            const [displayImage, setDisplayImage] = useState(null);
            const [isImageLoading, setIsImageLoading] = useState(false);
            
            const [chartData, setChartData] = useState(null);
            const [chartStatus, setChartStatus] = useState('not-loaded');
            const [loadedGlyphImages, setLoadedGlyphImages] = useState({});
            const [glyphThumbnails, setGlyphThumbnails] = useState({});
            const [chartLoadProgress, setChartLoadProgress] = useState({ loaded: 0, total: 0 });
            const [chartModified, setChartModified] = useState(false); // Track unsaved changes
            const [lastSavedTime, setLastSavedTime] = useState(null); // When chart was last saved
            
            const [confidenceThreshold, setConfidenceThreshold] = useState(0); // 0-100, filter detections
            
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
            const [chartVersion, setChartVersion] = useState(null);
            const [validations, setValidations] = useState({});
            const [changeLog, setChangeLog] = useState([]); // Track edit history
            const [isProcessing, setIsProcessing] = useState(false);
            const [processingStatus, setProcessingStatus] = useState('');
            
            const [viewMode, setViewMode] = useState('detection');
            const [readingDirection, setReadingDirection] = useState('rtl');
            const [readingOrder, setReadingOrder] = useState([]);
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [lineBreaks, setLineBreaks] = useState(new Set());
            
            const [selectedRegions, setSelectedRegions] = useState(new Set());
            const [lastSelectedIdx, setLastSelectedIdx] = useState(null); // For Shift+click range selection
            const [showArabicLabels, setShowArabicLabels] = useState(false);
            const [isPreprocessingCollapsed, setIsPreprocessingCollapsed] = useState(false);
            const [isLeftPanelHidden, setIsLeftPanelHidden] = useState(false); // Hide entire left panel
            const [isRightPanelHidden, setIsRightPanelHidden] = useState(false); // Hide entire right panel
            const [isToolsCollapsed, setIsToolsCollapsed] = useState(true);
            
            // Mobile responsive state
            const [mobilePanel, setMobilePanel] = useState(null); // null, 'preprocessing', or 'detections'
            const [headerCollapsed, setHeaderCollapsed] = useState(false); // Mobile header collapsed state
            
            // Force re-render of detection boxes when layout changes
            const [boxLayoutKey, setBoxLayoutKey] = useState(0);
            const [imageDimensions, setImageDimensions] = useState({ width: 0, height: 0 });
            const [canvasZoom, setCanvasZoom] = useState(1); // 0.5 to 3x zoom
            
            // Enhanced detection card state
            const [expandedCards, setExpandedCards] = useState(new Set()); // Cards showing alternatives
            const [quickSubstitutionCard, setQuickSubstitutionCard] = useState(null); // Card showing quick substitution modal
            const [excludedDetections, setExcludedDetections] = useState(new Set()); // Excluded from reading
            const [editMenuCardIdx, setEditMenuCardIdx] = useState(null); // Which card has edit menu open
            const [breaksMenuCardIdx, setBreaksMenuCardIdx] = useState(null); // Which card has breaks menu open
            const [historyCardIdx, setHistoryCardIdx] = useState(null); // Which card shows history
            const [editingBoxIdx, setEditingBoxIdx] = useState(null); // Index of detection being edited
            
            // Manual box drawing state
            const [manualBoxMode, setManualBoxMode] = useState(false);
            const [drawingBox, setDrawingBox] = useState(null); // {startX, startY, currentX, currentY}
            // Glyph selector: { mode: 'manual', position: {...} } OR { mode: 'change', detectionIndex: n }
            const [showGlyphSelector, setShowGlyphSelector] = useState(null);
            const [glyphSelectorSearch, setGlyphSelectorSearch] = useState('');
            
            // Drag-and-drop reorder state
            const [draggedCardIdx, setDraggedCardIdx] = useState(null); // Index in readingOrder being dragged
            const [dragOverCardIdx, setDragOverCardIdx] = useState(null); // Index being dragged over
            // Translation & inscription state
            const [translationEnglish, setTranslationEnglish] = useState('');
            const [translationArabic, setTranslationArabic] = useState('');
            const [showTranslationSection, setShowTranslationSection] = useState(false);
            const [inscriptionNotes, setInscriptionNotes] = useState('');
            const [inscriptionTitle, setInscriptionTitle] = useState('');
            const [inscriptionComplete, setInscriptionComplete] = useState(false);
            const [transcriptionScript, setTranscriptionScript] = useState('english');
            
            // Transcription display state
            const [showTranscription, setShowTranscription] = useState(true);
            const [showEnhancedTranscription, setShowEnhancedTranscription] = useState(false);
            const [transcriptionFormat, setTranscriptionFormat] = useState('horizontal-ltr');
            
            // Sync transcription format with reading direction
            useEffect(() => {
                const formatMap = {
                    'ltr': 'horizontal-ltr',
                    'rtl': 'horizontal-rtl',
                    'ttb-rtl': 'vertical-rtl',
                    'ttb-ltr': 'vertical-ltr',
                    'btt-rtl': 'vertical-rtl', // Bottom-to-top same as top-to-bottom in transcription
                    'btt-ltr': 'vertical-ltr',
                    'boustrophedon': 'horizontal-rtl' // Default to RTL for boustrophedon
                };
                const newFormat = formatMap[readingDirection] || 'horizontal-ltr';
                setTranscriptionFormat(newFormat);
            }, [readingDirection]);
            
            // Storage state
            const [showStorageSection, setShowStorageSection] = useState(true);
            const [currentInscriptionId, setCurrentInscriptionId] = useState(null);
            const [columnBreaks, setColumnBreaks] = useState(new Set());
            const [actionHistory, setActionHistory] = useState([]);
            
            // Undo/Redo stacks
            const [undoStack, setUndoStack] = useState([]);
            const [redoStack, setRedoStack] = useState([]);
            const MAX_UNDO = 50;
            
            // Access Control & Sync state
            const [isReadOnly, setIsReadOnly] = useState(false);
            const [showUnlockModal, setShowUnlockModal] = useState(false);
            const [pendingHkiData, setPendingHkiData] = useState(null);
            const [accessControl, setAccessControl] = useState(null);
            const [currentUser, setCurrentUser] = useState(null);
            const [syncStatus, setSyncStatus] = useState({ isOnline: navigator.onLine, pending: 0 });
            const [visibility, setVisibility] = useState('draft'); // 'draft' | 'review' | 'published'
            const [driveSignedIn, setDriveSignedIn] = useState(false);
            const [driveUserEmail, setDriveUserEmail] = useState(null);
            const [showWarehouse, setShowWarehouse] = useState(false);
            const [currentFileId, setCurrentFileId] = useState(null); // Drive file ID for updates
            const [fileOwner, setFileOwner] = useState(null); // Owner email of current file
            const [localSaveTime, setLocalSaveTime] = useState(null); // Last local auto-save time
            
            // Push state to undo stack before making changes
            const pushUndo = useCallback((actionType, data) => {
                const snapshot = {
                    type: actionType,
                    timestamp: Date.now(),
                    data: data
                };
                setUndoStack(prev => [...prev.slice(-MAX_UNDO + 1), snapshot]);
                setRedoStack([]); // Clear redo on new action
            }, []);
            
            // Undo function
            const undo = useCallback(() => {
                if (undoStack.length === 0) return;
                
                const lastAction = undoStack[undoStack.length - 1];
                
                // Save current state to redo stack
                let redoData = {};
                switch (lastAction.type) {
                    case 'preprocessing':
                        redoData = { ...preprocessing };
                        setPreprocessing(lastAction.data);
                        break;
                    case 'validation':
                        redoData = { ...validations };
                        setValidations(lastAction.data);
                        break;
                    case 'readingOrder':
                        redoData = [...readingOrder];
                        setReadingOrder(lastAction.data);
                        break;
                    case 'wordBoundaries':
                        redoData = new Set(wordBoundaries);
                        setWordBoundaries(new Set(lastAction.data));
                        break;
                    case 'lineBreaks':
                        redoData = new Set(lineBreaks);
                        setLineBreaks(new Set(lastAction.data));
                        break;
                    case 'columnBreaks':
                        redoData = new Set(columnBreaks);
                        setColumnBreaks(new Set(lastAction.data));
                        break;
                    case 'excludedDetections':
                        redoData = new Set(excludedDetections);
                        setExcludedDetections(new Set(lastAction.data));
                        break;
                    default:
                        return;
                }
                
                setRedoStack(prev => [...prev, { type: lastAction.type, data: redoData }]);
                setUndoStack(prev => prev.slice(0, -1));
            }, [undoStack, preprocessing, validations, readingOrder, wordBoundaries, lineBreaks, columnBreaks, excludedDetections]);
            
            // Redo function
            const redo = useCallback(() => {
                if (redoStack.length === 0) return;
                
                const nextAction = redoStack[redoStack.length - 1];
                
                // Save current state to undo stack
                let undoData = {};
                switch (nextAction.type) {
                    case 'preprocessing':
                        undoData = { ...preprocessing };
                        setPreprocessing(nextAction.data);
                        break;
                    case 'validation':
                        undoData = { ...validations };
                        setValidations(nextAction.data);
                        break;
                    case 'readingOrder':
                        undoData = [...readingOrder];
                        setReadingOrder(nextAction.data);
                        break;
                    case 'wordBoundaries':
                        undoData = new Set(wordBoundaries);
                        setWordBoundaries(new Set(nextAction.data));
                        break;
                    case 'lineBreaks':
                        undoData = new Set(lineBreaks);
                        setLineBreaks(new Set(nextAction.data));
                        break;
                    case 'columnBreaks':
                        undoData = new Set(columnBreaks);
                        setColumnBreaks(new Set(nextAction.data));
                        break;
                    case 'excludedDetections':
                        undoData = new Set(excludedDetections);
                        setExcludedDetections(new Set(nextAction.data));
                        break;
                    default:
                        return;
                }
                
                setUndoStack(prev => [...prev, { type: nextAction.type, data: undoData }]);
                setRedoStack(prev => prev.slice(0, -1));
            }, [redoStack, preprocessing, validations, readingOrder, wordBoundaries, lineBreaks, columnBreaks, excludedDetections]);
            
            // Template training state
            const [templateTrainingMode, setTemplateTrainingMode] = useState(false);
            const [selectedForTemplate, setSelectedForTemplate] = useState(null);
            
            // Eraser tool state
            const [eraserMode, setEraserMode] = useState(false);
            const [eraserSize, setEraserSize] = useState(15);
            const [brushPreviewPos, setBrushPreviewPos] = useState(null); // {x, y} for touch brush preview
            const [canvasDimensions, setCanvasDimensions] = useState({ width: 0, height: 0 });
            const eraserCanvasRef = useRef(null);
            const activeEraserCanvasRef = useRef(null); // Stores the VISIBLE canvas (not overwritten by React)
            const isDrawingRef = useRef(false);
            
            // Audio recording state
            const [audioData, setAudioData] = useState(null); // Stores audio as data URL
            const [isRecording, setIsRecording] = useState(false);
            const [audioRecorder, setAudioRecorder] = useState(null);
            const audioChunksRef = useRef([]);
            const audioInputRef = useRef(null);
            const audioPlayerRef = useRef(null);
            
            // Region editor state (per-detection eraser)
            const [regionEditorIdx, setRegionEditorIdx] = useState(null);
            const [regionEditorSize, setRegionEditorSize] = useState(10);
            const regionEditorCanvasRef = useRef(null);
            const regionEditorDrawingRef = useRef(false);
            
            // Chart Manager state
            const [showChartManager, setShowChartManager] = useState(false);
            const [chartViewMode, setChartViewMode] = useState('glyphs'); // 'glyphs', 'primary', 'variants', 'examples'
            const [focusedGlyphId, setFocusedGlyphId] = useState(null); // For training mode - focus on one glyph
            const [showGlyphEditor, setShowGlyphEditor] = useState(false);
            const [editingGlyph, setEditingGlyph] = useState(null);
            const [glyphEditorMode, setGlyphEditorMode] = useState('add');
            
            // Quick Start / Help state
            const [showQuickStart, setShowQuickStart] = useState(false);
            const [quickStartStep, setQuickStartStep] = useState(0);
            
            const [preprocessing, setPreprocessing] = useState({
                rotation: 0,
                useAdaptiveThreshold: false,
                blockSize: 11,
                constantOffset: 2,
                gaussianBlur: 0,
                morphologyOperation: 'none',
                invertColors: false
            });
            
            // Crop mode state (one-shot operation)
            const [cropMode, setCropMode] = useState(false);
            const [cropSelection, setCropSelection] = useState(null); // { startX, startY, currentX, currentY }
            
            const [opencvReady, setOpencvReady] = useState(false);
            const originalMatRef = useRef(null);
            const preprocessedMatRef = useRef(null);
            
            // Track dimensions of the image used for recognition (for box alignment)
            const [recognitionSourceDims, setRecognitionSourceDims] = useState(null);
            
            // Debounce timer for real-time preprocessing
            const preprocessDebounceRef = useRef(null);
            
            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);
            const fileInputRef = useRef(null);
            
            // ========== OPENCV SETUP ==========
            useEffect(() => {
                const checkOpenCV = () => {
                    if (typeof cv !== 'undefined' && cv.Mat) {
                        setOpencvReady(true);
                        console.log('âœ… OpenCV ready in React');
                    } else {
                        setTimeout(checkOpenCV, 100);
                    }
                };
                checkOpenCV();
                
                return () => {
                    if (originalMatRef.current) try { originalMatRef.current.delete(); } catch(e) {}
                    if (preprocessedMatRef.current) try { preprocessedMatRef.current.delete(); } catch(e) {}
                };
            }, []);
            
            // ========== SYNC MANAGER SETUP ==========
            useEffect(() => {
                // Initialize SyncManager if available
                if (typeof SyncManager !== 'undefined') {
                    SyncManager.initialize();
                    
                    // Check initial Drive sign-in status
                    if (typeof DriveSync !== 'undefined') {
                        setDriveSignedIn(DriveSync.isSignedIn());
                        setDriveUserEmail(DriveSync.getUserEmail());
                    }
                    
                    // Listen for sync events
                    const unsubscribe = SyncManager.addListener((event) => {
                        setSyncStatus(SyncManager.getSummary());
                        
                        // Also check Drive sign-in status on each event
                        if (typeof DriveSync !== 'undefined') {
                            setDriveSignedIn(DriveSync.isSignedIn());
                            setDriveUserEmail(DriveSync.getUserEmail());
                        }
                        
                        if (event.type === 'synced') {
                            console.log(`â˜ï¸ Synced: ${event.inscriptionId}`);
                        } else if (event.type === 'error') {
                            console.warn(`âš ï¸ Sync failed: ${event.inscriptionId} - ${event.error}`);
                        }
                    });
                    
                    return unsubscribe;
                }
            }, []);
            
            // ========== LOCAL AUTO-SAVE SETUP ==========
            useEffect(() => {
                if (typeof LocalAutoSave !== 'undefined') {
                    // Set up callback to update UI when save completes
                    LocalAutoSave.onSave((saveTime) => {
                        setLocalSaveTime(saveTime);
                        setLastSavedTime(Date.now());
                        setHasUnsavedChanges(false);
                    });
                    
                    // Check for saved work on page load
                    const checkSavedWork = async () => {
                        try {
                            const saved = await LocalAutoSave.loadLastWork();
                            if (saved && saved.data && saved.data.recognitionResults && saved.data.recognitionResults.length > 0) {
                                const savedDate = new Date(saved.timestamp);
                                const timeAgo = Math.round((Date.now() - savedDate) / 60000);
                                const timeStr = timeAgo < 60 ? `${timeAgo} minutes` : `${Math.round(timeAgo / 60)} hours`;
                                
                                const restore = confirm(
                                    `ðŸ“‚ Found unsaved work from ${timeStr} ago.\n\n` +
                                    `Title: ${saved.data.title || 'Untitled'}\n` +
                                    `Glyphs: ${saved.data.recognitionResults.length}\n\n` +
                                    `Would you like to restore it?`
                                );
                                
                                if (restore) {
                                    // Restore the saved data
                                    const data = saved.data;
                                    if (data.image) setOriginalImage(data.image);
                                    if (data.displayImage) setDisplayImage(data.displayImage);
                                    if (data.recognitionResults) setRecognitionResults(data.recognitionResults);
                                    if (data.validations) setValidations(data.validations);
                                    if (data.changeLog) setChangeLog(data.changeLog);
                                    if (data.inscriptionId) setCurrentInscriptionId(data.inscriptionId);
                                    if (data.title) setInscriptionTitle(data.title);
                                    if (data.notes) setInscriptionNotes(data.notes);
                                    if (data.translationEnglish) setTranslationEnglish(data.translationEnglish);
                                    if (data.translationArabic) setTranslationArabic(data.translationArabic);
                                    if (data.readingData) {
                                        if (data.readingData.direction) setReadingDirection(data.readingData.direction);
                                        if (data.readingData.order) setReadingOrder(data.readingData.order);
                                        if (data.readingData.wordBoundaries) setWordBoundaries(new Set(data.readingData.wordBoundaries));
                                        if (data.readingData.lineBreaks) setLineBreaks(new Set(data.readingData.lineBreaks));
                                        if (data.readingData.columnBreaks) setColumnBreaks(new Set(data.readingData.columnBreaks));
                                    }
                                    if (data.preprocessing) setPreprocessing(data.preprocessing);
                                    if (data.recognitionSourceDims) setRecognitionSourceDims(data.recognitionSourceDims);
                                    setLocalSaveTime(savedDate);
                                    console.log('âœ… Restored saved work');
                                    
                                    // Force box recalculation after image settles
                                    // Multiple delays to catch different settling times
                                    [100, 300, 600, 1000].forEach(delay => {
                                        setTimeout(() => setBoxLayoutKey(k => k + 1), delay);
                                    });
                                }
                            }
                        } catch (err) {
                            console.warn('Could not check for saved work:', err);
                        }
                    };
                    
                    // Check after a short delay to let the app initialize
                    setTimeout(checkSavedWork, 1000);
                }
            }, []);
            
            // ========== UNSAVED CHANGES WARNING ==========
            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    if (hasUnsavedChanges) {
                        e.preventDefault();
                        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                        return e.returnValue;
                    }
                };
                
                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [hasUnsavedChanges]);
            
            // ========== LOCAL AUTO-SAVE TRIGGER ==========
            useEffect(() => {
                if (typeof LocalAutoSave !== 'undefined' && recognitionResults && recognitionResults.length > 0) {
                    // Mark as having unsaved changes
                    setHasUnsavedChanges(true);
                    
                    // Schedule a save when data changes
                    LocalAutoSave.scheduleSave(() => ({
                        version: '2.0',
                        inscriptionId: currentInscriptionId,
                        title: inscriptionTitle,
                        notes: inscriptionNotes,
                        complete: inscriptionComplete,
                        visibility: visibility,
                        image: originalImage,
                        displayImage: displayImage,
                        recognitionSourceDims: recognitionSourceDims,
                        recognitionResults: recognitionResults.map(r => ({
                            glyph: {
                                id: r.glyph?.id,
                                name: r.glyph?.name,
                                transliteration: r.glyph?.transliteration,
                                arabic: r.glyph?.arabic,
                                description: r.glyph?.description
                            },
                            confidence: r.confidence,
                            position: r.position,
                            thumbnail: r.thumbnail,
                            corrected: r.corrected || false
                        })),
                        validations: validations,
                        readingData: {
                            direction: readingDirection,
                            order: readingOrder,
                            wordBoundaries: wordBoundaries ? Array.from(wordBoundaries) : [],
                            lineBreaks: lineBreaks ? Array.from(lineBreaks) : [],
                            columnBreaks: columnBreaks ? Array.from(columnBreaks) : []
                        },
                        translationEnglish: translationEnglish,
                        translationArabic: translationArabic,
                        preprocessing: preprocessing
                    }));
                }
            }, [recognitionResults, recognitionSourceDims, validations, readingOrder, wordBoundaries, lineBreaks, columnBreaks, 
                translationEnglish, translationArabic, inscriptionTitle, inscriptionNotes, visibility]);
            
            // ========== LOAD CHART ==========
            useEffect(() => {
                const loadChart = async () => {
                    setChartStatus('loading');
                    try {
                        const response = await fetch('Hakli_glyphs.JSON');
                        const data = await response.json();
                        setChartData(data);
                        
                        // Extract and store chart version
                        const version = data.version || data.chartVersion || '1.0.0';
                        setChartVersion(version);
                        console.log(`ðŸ“œ Loaded chart v${version} with ${data.glyphs.length} glyphs`);
                        
                        // Count total templates to load
                        let totalTemplates = 0;
                        for (const glyph of data.glyphs) {
                            if (glyph.images?.primary) totalTemplates++;
                            if (glyph.images?.variants) totalTemplates += glyph.images.variants.length;
                        }
                        
                        let loaded = 0;
                        const newImages = {};
                        const newThumbnails = {};
                        
                        for (const glyph of data.glyphs) {
                            // Load primary template
                            if (glyph.images?.primary) {
                                try {
                                    const img = new Image();
                                    img.crossOrigin = 'anonymous';
                                    await new Promise((resolve, reject) => {
                                        img.onload = resolve;
                                        img.onerror = reject;
                                        img.src = glyph.images.primary;
                                    });
                                    newImages[glyph.id] = img;
                                    newThumbnails[glyph.id] = img.src;
                                } catch (e) {
                                    console.debug(`Skipped glyph ${glyph.id} primary (image not available)`);
                                }
                                loaded++;
                                setChartLoadProgress({ loaded, total: totalTemplates });
                            }
                            
                            // Load variant templates
                            if (glyph.images?.variants) {
                                for (let i = 0; i < glyph.images.variants.length; i++) {
                                    try {
                                        const img = new Image();
                                        img.crossOrigin = 'anonymous';
                                        await new Promise((resolve, reject) => {
                                            img.onload = resolve;
                                            img.onerror = reject;
                                            img.src = glyph.images.variants[i];
                                        });
                                        const key = `${glyph.id}_variant_${i}`;
                                        newImages[key] = img;
                                        newThumbnails[key] = img.src;
                                    } catch (e) {
                                        console.debug(`Skipped glyph ${glyph.id} variant ${i}`);
                                    }
                                    loaded++;
                                    setChartLoadProgress({ loaded, total: totalTemplates });
                                }
                            }
                        }
                        
                        setLoadedGlyphImages(newImages);
                        setGlyphThumbnails(newThumbnails);
                        setChartStatus('loaded');
                        console.log(`âœ… Loaded ${Object.keys(newImages).length} template images`);
                    } catch (error) {
                        console.error('Failed to load chart:', error);
                        setChartStatus('error');
                    }
                };
                loadChart();
            }, []);
            
            // ========== AUTO-SAVE TO LOCALSTORAGE ==========
            useEffect(() => {
                if (!chartData || !chartModified) return;
                
                // Debounce saves - wait 2 seconds after last change
                const saveTimer = setTimeout(() => {
                    try {
                        localStorage.setItem('hakli_chart_backup', JSON.stringify(chartData));
                        localStorage.setItem('hakli_chart_backup_time', new Date().toISOString());
                        console.log('ðŸ’¾ Auto-saved chart to localStorage');
                    } catch (e) {
                        console.warn('Failed to auto-save:', e);
                    }
                }, 2000);
                
                return () => clearTimeout(saveTimer);
            }, [chartData, chartModified]);
            
            // ========== CHECK FOR BACKUP ON LOAD ==========
            useEffect(() => {
                const backup = localStorage.getItem('hakli_chart_backup');
                const backupTime = localStorage.getItem('hakli_chart_backup_time');
                if (backup && backupTime) {
                    const timeAgo = new Date() - new Date(backupTime);
                    const hoursAgo = Math.floor(timeAgo / (1000 * 60 * 60));
                    if (hoursAgo < 24) {
                        console.log(`ðŸ“¦ Found backup from ${hoursAgo}h ago - will restore if chart fails to load`);
                    }
                }
            }, []);
            
            // ========== SHOW QUICK START FOR NEW USERS ==========
            useEffect(() => {
                const hasSeenQuickStart = localStorage.getItem('hakli_seen_quickstart');
                if (!hasSeenQuickStart) {
                    // Small delay so the UI loads first
                    setTimeout(() => setShowQuickStart(true), 500);
                }
            }, []);
            
            // ========== TRACK IMAGE DIMENSIONS FOR BOX ALIGNMENT ==========
            const [imageReady, setImageReady] = useState(false);
            const lastImageSize = useRef({ width: 0, height: 0 });
            
            useEffect(() => {
                const img = imageRef.current;
                const container = imageContainerRef.current;
                if (!img || !container) return;
                
                setImageReady(false);
                
                // Update dimensions when image loads
                const handleImageLoad = () => {
                    setImageDimensions({ 
                        width: img.naturalWidth, 
                        height: img.naturalHeight 
                    });
                    
                    // Wait for layout to settle, then mark ready
                    const checkSettled = () => {
                        const rect = img.getBoundingClientRect();
                        if (rect.width > 0 && rect.height > 0) {
                            if (rect.width === lastImageSize.current.width && 
                                rect.height === lastImageSize.current.height) {
                                // Dimensions stable - we're ready
                                setImageReady(true);
                                setBoxLayoutKey(k => k + 1);
                            } else {
                                // Still changing, check again
                                lastImageSize.current = { width: rect.width, height: rect.height };
                                requestAnimationFrame(checkSettled);
                            }
                        } else {
                            requestAnimationFrame(checkSettled);
                        }
                    };
                    
                    requestAnimationFrame(checkSettled);
                };
                
                img.addEventListener('load', handleImageLoad);
                
                // Observe BOTH container and image for resize
                let resizeTimeout;
                const triggerRecalc = () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        const rect = img.getBoundingClientRect();
                        lastImageSize.current = { width: rect.width, height: rect.height };
                        setBoxLayoutKey(k => k + 1);
                    }, 50);
                };
                
                const containerObserver = new ResizeObserver(triggerRecalc);
                const imageObserver = new ResizeObserver(triggerRecalc);
                
                containerObserver.observe(container);
                imageObserver.observe(img);
                
                // If image is already loaded, trigger immediately
                if (img.complete && img.naturalWidth > 0) {
                    handleImageLoad();
                }
                
                return () => {
                    img.removeEventListener('load', handleImageLoad);
                    containerObserver.disconnect();
                    imageObserver.disconnect();
                    clearTimeout(resizeTimeout);
                };
            }, [displayImage]);
            
            // ========== UPDATE BOX LAYOUT WHEN PANELS TOGGLE ==========
            useEffect(() => {
                // Multiple recalcs to catch CSS transitions settling
                const timers = [100, 200, 350].map(delay => 
                    setTimeout(() => setBoxLayoutKey(k => k + 1), delay)
                );
                return () => timers.forEach(clearTimeout);
            }, [isLeftPanelHidden, isRightPanelHidden]);
            
            // ========== IMAGE HANDLING ==========
            const loadImageToMat = useCallback((imageSource) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = img.naturalWidth;
                            canvas.height = img.naturalHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            const mat = cv.imread(canvas);
                            resolve(mat);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = imageSource;
                });
            }, []);
            
            const matToDataUrl = useCallback((mat) => {
                const canvas = document.createElement('canvas');
                cv.imshow(canvas, mat);
                return canvas.toDataURL('image/png');
            }, []);
            
            const handleImageUpload = useCallback(async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                // Reset file input to allow selecting same file again
                event.target.value = '';
                
                setIsImageLoading(true);
                setCanvasZoom(1); // Reset zoom for new image
                
                // Clear LocalAutoSave so old data doesn't restore on refresh
                if (typeof LocalAutoSave !== 'undefined') {
                    LocalAutoSave.clearAutosave().catch(err => console.warn('Could not clear autosave:', err));
                }
                
                // Clear previous state IMMEDIATELY before loading new image
                setRecognitionResults([]);
                setValidations({});
                setReadingOrder([]);
                setWordBoundaries(new Set());
                setLineBreaks(new Set());
                setColumnBreaks(new Set());
                setSelectedRegions(new Set());
                setRecognitionSourceDims(null);
                setChangeLog([]);
                setUndoStack([]);
                setRedoStack([]);
                // Reset inscription metadata for fresh start
                setCurrentInscriptionId(null);
                setInscriptionTitle('');
                setInscriptionNotes('');
                setInscriptionComplete(false);
                setTranslationEnglish('');
                setTranslationArabic('');
                setCurrentFileId(null);
                setFileOwner(null);
                setIsReadOnly(false);
                // Reset preprocessing to defaults
                setPreprocessing({ rotation: 0, gaussianBlur: 0, useAdaptiveThreshold: false, blockSize: 11, constantOffset: 2, morphologyOperation: 'none', invertColors: false });
                setLocalSaveTime(null);
                
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const dataUrl = e.target.result;
                    setOriginalImage(dataUrl);
                    setDisplayImage(dataUrl);
                    
                    if (opencvReady) {
                        try {
                            if (originalMatRef.current) originalMatRef.current.delete();
                            originalMatRef.current = await loadImageToMat(dataUrl);
                            console.log('âœ… Image loaded:', originalMatRef.current.cols, 'x', originalMatRef.current.rows);
                        } catch (error) {
                            console.error('Failed to load image to OpenCV:', error);
                        }
                    }
                    
                    setIsImageLoading(false);
                };
                reader.onerror = () => {
                    alert('Failed to read image file');
                    setIsImageLoading(false);
                };
                reader.readAsDataURL(file);
            }, [opencvReady, loadImageToMat]);
            
            // ========== PREPROCESSING ==========
            const applyPreprocessing = useCallback(async () => {
                if (!originalMatRef.current || !opencvReady) {
                    console.warn('No image or OpenCV not ready');
                    return;
                }
                
                try {
                    // Use the Preprocessing module if available
                    if (typeof Preprocessing !== 'undefined' && Preprocessing.processImageWithSettings) {
                        if (preprocessedMatRef.current) preprocessedMatRef.current.delete();
                        preprocessedMatRef.current = Preprocessing.processImageWithSettings(
                            originalMatRef.current, 
                            preprocessing
                        );
                        const dataUrl = matToDataUrl(preprocessedMatRef.current);
                        setDisplayImage(dataUrl);
                        // Track the dimensions of the preprocessed image for box alignment
                        setRecognitionSourceDims({
                            width: preprocessedMatRef.current.cols,
                            height: preprocessedMatRef.current.rows
                        });
                        console.log('âœ… Preprocessing applied via Preprocessing module');
                    } else {
                        // Fallback: manual preprocessing
                        if (preprocessedMatRef.current) preprocessedMatRef.current.delete();
                        
                        let result = originalMatRef.current.clone();
                        
                        // Rotation
                        if (preprocessing.rotation !== 0) {
                            const center = new cv.Point(result.cols / 2, result.rows / 2);
                            const rotMatrix = cv.getRotationMatrix2D(center, -preprocessing.rotation, 1.0);
                            const cos = Math.abs(rotMatrix.doubleAt(0, 0));
                            const sin = Math.abs(rotMatrix.doubleAt(0, 1));
                            const newWidth = Math.floor(result.rows * sin + result.cols * cos);
                            const newHeight = Math.floor(result.rows * cos + result.cols * sin);
                            rotMatrix.doublePtr(0, 2)[0] += (newWidth - result.cols) / 2;
                            rotMatrix.doublePtr(1, 2)[0] += (newHeight - result.rows) / 2;
                            const rotated = new cv.Mat();
                            cv.warpAffine(result, rotated, rotMatrix, new cv.Size(newWidth, newHeight), 
                                cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255, 255, 255, 255));
                            result.delete();
                            rotMatrix.delete();
                            result = rotated;
                        }
                        
                        // Grayscale
                        let gray = new cv.Mat();
                        if (result.channels() === 4) cv.cvtColor(result, gray, cv.COLOR_RGBA2GRAY);
                        else if (result.channels() === 3) cv.cvtColor(result, gray, cv.COLOR_RGB2GRAY);
                        else gray = result.clone();
                        
                        // Blur
                        if (preprocessing.gaussianBlur > 0) {
                            const ksize = preprocessing.gaussianBlur % 2 === 0 ? preprocessing.gaussianBlur + 1 : preprocessing.gaussianBlur;
                            cv.GaussianBlur(gray, gray, new cv.Size(ksize, ksize), 0);
                        }
                        
                        // Threshold
                        if (preprocessing.useAdaptiveThreshold) {
                            const blockSize = preprocessing.blockSize % 2 === 0 ? preprocessing.blockSize + 1 : preprocessing.blockSize;
                            cv.adaptiveThreshold(gray, gray, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, blockSize, preprocessing.constantOffset);
                        }
                        
                        // Morphology
                        if (preprocessing.morphologyOperation !== 'none') {
                            const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                            const morphed = new cv.Mat();
                            switch (preprocessing.morphologyOperation) {
                                case 'erode': cv.erode(gray, morphed, kernel); break;
                                case 'dilate': cv.dilate(gray, morphed, kernel); break;
                                case 'open': cv.morphologyEx(gray, morphed, cv.MORPH_OPEN, kernel); break;
                                case 'close': cv.morphologyEx(gray, morphed, cv.MORPH_CLOSE, kernel); break;
                                default: gray.copyTo(morphed);
                            }
                            gray.delete();
                            kernel.delete();
                            gray = morphed;
                        }
                        
                        // Invert
                        if (preprocessing.invertColors) {
                            cv.bitwise_not(gray, gray);
                        }
                        
                        result.delete();
                        preprocessedMatRef.current = gray;
                        
                        const dataUrl = matToDataUrl(gray);
                        setDisplayImage(dataUrl);
                        // Track the dimensions of the preprocessed image for box alignment
                        setRecognitionSourceDims({
                            width: gray.cols,
                            height: gray.rows
                        });
                        console.log('âœ… Preprocessing applied (fallback)');
                    }
                } catch (error) {
                    console.error('Preprocessing error:', error);
                    alert('Preprocessing failed: ' + error.message);
                }
            }, [preprocessing, opencvReady, matToDataUrl]);
            
            const resetPreprocessing = useCallback(() => {
                // If there are active detections, warn user
                if (recognitionResults.length > 0) {
                    const confirmed = confirm(
                        'âš ï¸ Resetting will misalign detection boxes since they were positioned on the preprocessed image.\n\n' +
                        'Options:\n' +
                        'â€¢ OK - Reset anyway (boxes may not align)\n' +
                        'â€¢ Cancel - Keep current preprocessing\n\n' +
                        'Tip: Clear detections first, or re-run recognition after reset.'
                    );
                    if (!confirmed) return;
                }
                
                setPreprocessing({
                    rotation: 0,
                    useAdaptiveThreshold: false,
                    blockSize: 11,
                    constantOffset: 2,
                    gaussianBlur: 0,
                    morphologyOperation: 'none',
                    invertColors: false
                });
                setCropMode(false);
                setCropSelection(null);
                if (originalImage) setDisplayImage(originalImage);
                if (preprocessedMatRef.current) {
                    preprocessedMatRef.current.delete();
                    preprocessedMatRef.current = null;
                }
                
                // Only reset recognitionSourceDims if no detections
                // Otherwise keep it so boxes at least scale consistently
                if (recognitionResults.length === 0) {
                    setRecognitionSourceDims(null);
                }
            }, [originalImage, recognitionResults.length]);
            
            // ========== START NEW INSCRIPTION ==========
            const startNewInscription = useCallback(() => {
                // Check for unsaved work
                const hasWork = recognitionResults.length > 0 || inscriptionTitle || inscriptionNotes;
                
                if (hasWork) {
                    const message = hasUnsavedChanges 
                        ? "You have UNSAVED changes! Starting a new inscription will discard all current work.\n\nAre you sure you want to continue?"
                        : "Starting a new inscription will clear all current work.\n\nAre you sure you want to continue?";
                    
                    if (!confirm(message)) {
                        return; // User cancelled
                    }
                }
                
                // Clear everything
                setOriginalImage(null);
                setDisplayImage(null);
                setRecognitionResults([]);
                setValidations({});
                setChangeLog([]);
                setReadingOrder([]);
                setSelectedRegions(new Set());
                setExcludedDetections(new Set());
                setWordBoundaries(new Set());
                setColumnBreaks(new Set());
                setLineBreaks(new Set());
                setExpandedCards(new Set());
                setInscriptionTitle('');
                setInscriptionNotes('');
                setInscriptionComplete(false);
                setCurrentInscriptionId(null);
                setRecognitionSourceDims(null);
                setHasUnsavedChanges(false);
                
                // Clear OpenCV mats
                if (originalMatRef.current) {
                    originalMatRef.current.delete();
                    originalMatRef.current = null;
                }
                if (preprocessedMatRef.current) {
                    preprocessedMatRef.current.delete();
                    preprocessedMatRef.current = null;
                }
                
                console.log('ðŸ†• Started new inscription - all data cleared');
            }, [recognitionResults.length, inscriptionTitle, inscriptionNotes, hasUnsavedChanges]);
            
            // ========== REAL-TIME PREPROCESSING ==========
            // Auto-apply preprocessing when settings change (with debounce)
            useEffect(() => {
                // Only auto-apply if we have an image and OpenCV
                if (!originalMatRef.current || !opencvReady) return;
                
                // Clear previous timeout
                if (preprocessDebounceRef.current) {
                    clearTimeout(preprocessDebounceRef.current);
                }
                
                // Debounce: wait 50ms after last change before applying (fluid feel)
                preprocessDebounceRef.current = setTimeout(() => {
                    applyPreprocessing();
                }, 50);
                
                return () => {
                    if (preprocessDebounceRef.current) {
                        clearTimeout(preprocessDebounceRef.current);
                    }
                };
            }, [preprocessing, opencvReady, applyPreprocessing]);
            
            // ========== ERASER TOOL ==========
            const initEraserCanvas = useCallback(() => {
                // Find the VISIBLE image (there may be multiple with same alt text)
                const images = document.querySelectorAll('img[alt="Inscription"]');
                let visibleImg = null;
                images.forEach(img => {
                    const rect = img.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        visibleImg = img;
                    }
                });
                
                if (!visibleImg) {
                    console.error('âŒ No visible image found!');
                    return false;
                }
                
                console.log('âœ… Found visible image:', visibleImg.getBoundingClientRect());
                
                // Find the canvas that's a sibling of the visible image (in same container)
                const container = visibleImg.parentElement;
                if (!container) {
                    console.warn('âš ï¸ No parent container');
                    return false;
                }
                
                // Find canvas in the same container as the visible image
                const canvas = container.querySelector('canvas');
                if (!canvas) {
                    console.warn('âš ï¸ No canvas found in container');
                    return false;
                }
                
                // Store in our controlled ref (NOT the React-managed one)
                activeEraserCanvasRef.current = canvas;
                console.log('ðŸŽ¯ Stored active canvas in activeEraserCanvasRef');
                
                const img = visibleImg;
                
                const rect = container.getBoundingClientRect();
                const containerWidth = Math.round(rect.width);
                const containerHeight = Math.round(rect.height);
                
                // Get actual image rendered size
                const imgRect = img.getBoundingClientRect();
                const imgWidth = Math.round(imgRect.width);
                const imgHeight = Math.round(imgRect.height);
                
                console.log('ðŸ“¦ Container size:', containerWidth, 'x', containerHeight);
                console.log('ðŸ–¼ï¸ Image rendered size:', imgWidth, 'x', imgHeight);
                console.log('ðŸ“ Image natural size:', img.naturalWidth, 'x', img.naturalHeight);
                
                // Verify we have valid dimensions
                if (imgWidth === 0 || imgHeight === 0) {
                    console.error('âŒ Image has no dimensions yet!');
                    return false;
                }
                
                // Set canvas internal dimensions to match image's rendered size for proper quality
                canvas.width = imgWidth;
                canvas.height = imgHeight;
                
                // Set CSS dimensions DIRECTLY on canvas (don't wait for React re-render!)
                canvas.style.width = `${imgWidth}px`;
                canvas.style.height = `${imgHeight}px`;
                
                // Also update React state for consistency
                setCanvasDimensions({ width: imgWidth, height: imgHeight });
                
                // Draw the image at its full resolution
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
                console.log('âœ… Eraser canvas initialized with CSS dimensions:', imgWidth, 'x', imgHeight);
                return true;
            }, [setCanvasDimensions]);
            
            const handleEraserDraw = useCallback((e) => {
                // Use the ACTIVE canvas ref, not the React-managed one
                const canvas = activeEraserCanvasRef.current;
                if (!isDrawingRef.current || !eraserMode || !canvas || !imageRef.current) {
                    return;
                }
                
                try {
                    // Prevent scrolling on touch devices while drawing
                    if (e.type.startsWith('touch')) {
                        e.preventDefault();
                    }
                    
                    // PALM REJECTION for touch events
                    if (e.touches && e.touches.length > 0) {
                        const touch = e.touches[0];
                        
                        // Filter out touches with large contact areas (likely palm)
                        const touchRadius = Math.max(
                            touch.radiusX || 0,
                            touch.radiusY || 0
                        );
                        
                        if (touchRadius > 25) {
                            console.log('ðŸ–ï¸ Palm rejected (radius:', touchRadius, ')');
                            return;
                        }
                        
                        if (e.touches.length > 1) {
                            console.log('ðŸ‘† Multi-touch detected, using first');
                        }
                    }
                    
                    const ctx = canvas.getContext('2d');
                    const rect = canvas.getBoundingClientRect();
                    
                    // Verify canvas has dimensions
                    if (rect.width === 0 || rect.height === 0 || canvas.width === 0) {
                        console.warn('âŒ Canvas has no dimensions:', { 
                            cssW: rect.width, cssH: rect.height, 
                            internalW: canvas.width, internalH: canvas.height 
                        });
                        return;
                    }
                    
                    // Get coordinates from either mouse or touch event
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    // Update brush preview position for touch devices (relative to canvas)
                    if (e.touches) {
                        setBrushPreviewPos({ 
                            x: clientX - rect.left, 
                            y: clientY - rect.top 
                        });
                    }
                    
                    // Calculate position relative to canvas (accounting for scaling and zoom)
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (clientX - rect.left) * scaleX;
                    const y = (clientY - rect.top) * scaleY;
                    
                    // Check if coordinates are valid
                    if (isNaN(x) || isNaN(y) || x < 0 || y < 0 || x > canvas.width || y > canvas.height) {
                        console.warn('âŒ Invalid coordinates:', { x, y, canvasW: canvas.width, canvasH: canvas.height });
                        return;
                    }
                    
                    const brushRadius = eraserSize * scaleX;
                    
                    // Draw white circle (erase)
                    ctx.beginPath();
                    ctx.arc(x, y, brushRadius, 0, Math.PI * 2);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fill();
                    
                    console.log('âœ… Drew at:', Math.round(x), Math.round(y));
                } catch (error) {
                    console.error('âŒ Draw error:', error);
                }
            }, [eraserMode, eraserSize]);
            
            const handleEraserStart = useCallback((e) => {
                // Use the ACTIVE canvas ref
                const canvas = activeEraserCanvasRef.current;
                if (!eraserMode || !canvas) {
                    console.warn('âš ï¸ Cannot start eraser - mode:', eraserMode, 'activeCanvas:', !!canvas);
                    // Update debug display
                    const debug = document.getElementById('eraser-debug');
                    if (debug) debug.textContent = `ERROR: Mode=${eraserMode} ActiveCanvas=${!!canvas}`;
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                console.log('ðŸ–±ï¸ Eraser started - Canvas rect:', rect.width, 'x', rect.height, 'Canvas internal:', canvas.width, 'x', canvas.height);
                
                isDrawingRef.current = true;
                
                // Update debug display
                const debug = document.getElementById('eraser-debug');
                if (debug) debug.textContent = `Drawing started! Mode=âœ“ ActiveCanvas=âœ“`;
                
                handleEraserDraw(e);
            }, [eraserMode, handleEraserDraw]);
            
            const handleEraserEnd = useCallback(() => {
                isDrawingRef.current = false;
                setBrushPreviewPos(null); // Hide brush preview on touch end
            }, []);
            
            const applyEraser = useCallback(async () => {
                // Use the ACTIVE canvas ref
                const canvas = activeEraserCanvasRef.current;
                if (!canvas || !opencvReady) {
                    console.warn('Cannot apply eraser - canvas:', !!canvas, 'opencv:', opencvReady);
                    return;
                }
                
                try {
                    // Get erased canvas data
                    const dataUrl = canvas.toDataURL('image/png');
                    
                    // Update display image
                    setDisplayImage(dataUrl);
                    
                    // Create mat from erased image
                    const img = new Image();
                    img.src = dataUrl;
                    await new Promise(resolve => { img.onload = resolve; });
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = img.naturalWidth;
                    tempCanvas.height = img.naturalHeight;
                    tempCanvas.getContext('2d').drawImage(img, 0, 0);
                    const newMat = cv.imread(tempCanvas);
                    
                    // Update BOTH originalMatRef AND preprocessedMatRef
                    // This ensures subsequent preprocessing works on the erased image
                    if (originalMatRef.current) originalMatRef.current.delete();
                    originalMatRef.current = newMat.clone();
                    
                    if (preprocessedMatRef.current) preprocessedMatRef.current.delete();
                    preprocessedMatRef.current = newMat;
                    
                    // Also update originalImage so Reset goes back to erased version
                    setOriginalImage(dataUrl);
                    
                    // Reset rotation to 0 since it's now baked into the new original image
                    // This prevents double-rotation on next preprocessing
                    setPreprocessing(prev => ({ ...prev, rotation: 0 }));
                    
                    // Track dimensions
                    setRecognitionSourceDims({
                        width: newMat.cols,
                        height: newMat.rows
                    });
                    
                    setEraserMode(false);
                    setMobilePanel(null); // Close mobile panel after applying
                    console.log('âœ… Eraser applied (original updated, rotation reset to 0)');
                } catch (error) {
                    console.error('Eraser apply error:', error);
                }
            }, [opencvReady]);
            
            const cancelEraser = useCallback(() => {
                setEraserMode(false);
                setMobilePanel(null); // Close mobile panel after canceling
            }, []);
            
            // ========== AUDIO RECORDING ==========
            const startRecording = useCallback(async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const recorder = new MediaRecorder(stream);
                    audioChunksRef.current = [];
                    
                    recorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            audioChunksRef.current.push(e.data);
                        }
                    };
                    
                    recorder.onstop = () => {
                        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            setAudioData(reader.result); // Store as data URL
                            console.log('ðŸŽ¤ Audio recorded successfully');
                        };
                        reader.readAsDataURL(audioBlob);
                        
                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                    };
                    
                    recorder.start();
                    setAudioRecorder(recorder);
                    setIsRecording(true);
                    console.log('ðŸŽ¤ Recording started...');
                } catch (error) {
                    console.error('Error starting recording:', error);
                    alert('Could not access microphone. Please grant permission.');
                }
            }, []);
            
            const stopRecording = useCallback(() => {
                if (audioRecorder) {
                    audioRecorder.stop();
                    setIsRecording(false);
                    setAudioRecorder(null);
                    console.log('â¹ï¸ Recording stopped');
                }
            }, [audioRecorder]);
            
            const uploadAudioFile = useCallback((e) => {
                const file = e.target.files?.[0];
                if (file) {
                    if (!file.type.startsWith('audio/')) {
                        alert('Please select an audio file');
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setAudioData(reader.result);
                        console.log('ðŸ“Ž Audio file uploaded successfully');
                    };
                    reader.readAsDataURL(file);
                }
            }, []);
            
            const deleteAudio = useCallback(() => {
                if (confirm('Delete audio recording?')) {
                    setAudioData(null);
                    if (audioPlayerRef.current) {
                        audioPlayerRef.current.pause();
                        audioPlayerRef.current.currentTime = 0;
                    }
                    console.log('ðŸ—‘ï¸ Audio deleted');
                }
            }, []);
            
            // Initialize eraser canvas when mode is enabled
            useEffect(() => {
                if (eraserMode) {
                    // Simple retry logic - initEraserCanvas finds canvas via DOM query
                    const initWithRetry = (attempt = 0) => {
                        setTimeout(() => {
                            console.log('ðŸ§¹ Attempt', attempt + 1, 'to initialize eraser canvas...');
                            
                            // Call initEraserCanvas - it will find the visible canvas via DOM query
                            const success = initEraserCanvas();
                            
                            if (!success && attempt < 10) {
                                console.warn('âš ï¸ Init failed, retrying...');
                                initWithRetry(attempt + 1);
                            } else if (success) {
                                console.log('ðŸŽ‰ Eraser canvas ready!');
                            }
                        }, attempt === 0 ? 300 : 400);
                    };
                    
                    initWithRetry();
                }
            }, [eraserMode, initEraserCanvas, displayImage]);
            
            // ========== BOX ADJUSTMENT ==========
            const shrinkBox = useCallback((index, amount = 5) => {
                setRecognitionResults(prev => {
                    const updated = [...prev];
                    if (updated[index]) {
                        const pos = updated[index].position;
                        updated[index] = {
                            ...updated[index],
                            position: {
                                x: pos.x + amount,
                                y: pos.y + amount,
                                width: Math.max(10, pos.width - amount * 2),
                                height: Math.max(10, pos.height - amount * 2)
                            }
                        };
                    }
                    return updated;
                });
            }, []);
            
            const expandBox = useCallback((index, amount = 5) => {
                setRecognitionResults(prev => {
                    const updated = [...prev];
                    if (updated[index]) {
                        const pos = updated[index].position;
                        updated[index] = {
                            ...updated[index],
                            position: {
                                x: Math.max(0, pos.x - amount),
                                y: Math.max(0, pos.y - amount),
                                width: pos.width + amount * 2,
                                height: pos.height + amount * 2
                            }
                        };
                    }
                    return updated;
                });
            }, []);
            
            // ========== REGION EDITOR (Per-Detection Eraser) ==========
            const openRegionEditor = useCallback((detectionIdx) => {
                setRegionEditorIdx(detectionIdx);
            }, []);
            
            const initRegionEditorCanvas = useCallback(() => {
                if (regionEditorIdx === null || !regionEditorCanvasRef.current || !displayImage) return;
                
                const detection = recognitionResults[regionEditorIdx];
                if (!detection) return;
                
                const canvas = regionEditorCanvasRef.current;
                const pos = detection.position;
                
                // Add padding around the region
                const padding = 20;
                const regionX = Math.max(0, pos.x - padding);
                const regionY = Math.max(0, pos.y - padding);
                const regionW = pos.width + padding * 2;
                const regionH = pos.height + padding * 2;
                
                // Set canvas size to region size (scaled up for easier editing)
                const scale = Math.min(400 / regionW, 400 / regionH, 3);
                canvas.width = regionW * scale;
                canvas.height = regionH * scale;
                
                // Store region info on canvas for later
                canvas.dataset.regionX = regionX;
                canvas.dataset.regionY = regionY;
                canvas.dataset.regionW = regionW;
                canvas.dataset.regionH = regionH;
                canvas.dataset.scale = scale;
                
                // Draw the region from the display image
                const img = new Image();
                img.onload = () => {
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        img,
                        regionX, regionY, regionW, regionH,  // Source
                        0, 0, canvas.width, canvas.height     // Destination
                    );
                };
                img.src = displayImage;
            }, [regionEditorIdx, recognitionResults, displayImage]);
            
            const handleRegionEditorStart = useCallback((e) => {
                if (regionEditorIdx === null || !regionEditorCanvasRef.current) return;
                regionEditorDrawingRef.current = true;
                handleRegionEditorDraw(e);
            }, [regionEditorIdx]);
            
            const handleRegionEditorDraw = useCallback((e) => {
                if (!regionEditorDrawingRef.current || regionEditorIdx === null || !regionEditorCanvasRef.current) return;
                
                const canvas = regionEditorCanvasRef.current;
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                // Scale the brush size to match cursor (cursor is in screen pixels, canvas is in canvas coords)
                const scale = canvas.width / rect.width;
                const scaledSize = regionEditorSize * scale;
                
                // Draw white circle (erase) - scaled to match cursor appearance
                ctx.beginPath();
                ctx.arc(x, y, scaledSize, 0, Math.PI * 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();
            }, [regionEditorIdx, regionEditorSize]);
            
            const handleRegionEditorEnd = useCallback(() => {
                regionEditorDrawingRef.current = false;
            }, []);
            
            const applyRegionEdit = useCallback(async () => {
                if (regionEditorIdx === null || !regionEditorCanvasRef.current) return;
                
                try {
                    const canvas = regionEditorCanvasRef.current;
                    
                    // ONLY update the thumbnail for this detection card
                    // Do NOT modify the main display image - keep it intact for viewing all boxes
                    const detection = recognitionResults[regionEditorIdx];
                    if (detection) {
                        // Create thumbnail directly from the edited canvas
                        // Scale it down to detection size
                        const pos = detection.position;
                        const padding = 20;
                        
                        // The canvas contains the region with padding, extract just the detection area
                        const thumbCanvas = document.createElement('canvas');
                        thumbCanvas.width = pos.width;
                        thumbCanvas.height = pos.height;
                        const thumbCtx = thumbCanvas.getContext('2d');
                        
                        // Calculate where the actual detection is within the padded canvas
                        const scale = parseFloat(canvas.dataset.scale || 1);
                        const paddingScaled = padding * scale;
                        
                        thumbCtx.drawImage(
                            canvas,
                            paddingScaled, paddingScaled,  // Source x,y (skip padding)
                            pos.width * scale, pos.height * scale,  // Source w,h
                            0, 0, pos.width, pos.height  // Dest
                        );
                        
                        const newThumbnail = thumbCanvas.toDataURL();
                        
                        // Update recognition results with new thumbnail ONLY
                        setRecognitionResults(prev => {
                            const updated = [...prev];
                            if (updated[regionEditorIdx]) {
                                updated[regionEditorIdx] = {
                                    ...updated[regionEditorIdx],
                                    thumbnail: newThumbnail,
                                    thumbnailEdited: true  // Flag that this was manually edited
                                };
                            }
                            return updated;
                        });
                    }
                    
                    const closedIdx = regionEditorIdx;
                    setRegionEditorIdx(null);
                    console.log(`âœ… Thumbnail updated for detection #${closedIdx + 1} (main image unchanged)`);
                } catch (error) {
                    console.error('Region edit error:', error);
                    alert('Failed to apply region edit');
                }
            }, [regionEditorIdx, recognitionResults]);
            
            const cancelRegionEdit = useCallback(() => {
                setRegionEditorIdx(null);
            }, []);
            
            // ========== MANUAL BOX DRAWING ==========
            const handleManualBoxStart = useCallback((e) => {
                if (!manualBoxMode || !imageContainerRef.current) return;
                
                // Find the image - could be imageRef or query within container
                const img = imageRef.current || imageContainerRef.current.querySelector('img');
                if (!img) {
                    console.warn('âŒ Manual box: No image found');
                    return;
                }
                
                // Wait a tick for the image to be fully rendered
                if (!img.complete || img.naturalWidth === 0) {
                    console.warn('âŒ Image not fully loaded yet');
                    return;
                }
                
                const imgRect = img.getBoundingClientRect();
                const containerRect = imageContainerRef.current.getBoundingClientRect();
                
                // The image is centered in the container, so we need to find its actual position
                // Calculate how the image is sized within the container
                const containerWidth = containerRect.width;
                const containerHeight = containerRect.height;
                const imageAspect = img.naturalWidth / img.naturalHeight;
                const containerAspect = containerWidth / containerHeight;
                
                let renderedWidth, renderedHeight, offsetX, offsetY;
                
                if (containerAspect > imageAspect) {
                    // Container is wider than image - image is constrained by height
                    renderedHeight = containerHeight;
                    renderedWidth = renderedHeight * imageAspect;
                    offsetX = (containerWidth - renderedWidth) / 2;
                    offsetY = 0;
                } else {
                    // Container is taller than image - image is constrained by width
                    renderedWidth = containerWidth;
                    renderedHeight = renderedWidth / imageAspect;
                    offsetX = 0;
                    offsetY = (containerHeight - renderedHeight) / 2;
                }
                
                console.log('ðŸ“¦ Manual box start:', { 
                    containerW: Math.round(containerWidth),
                    containerH: Math.round(containerHeight),
                    renderedW: Math.round(renderedWidth),
                    renderedH: Math.round(renderedHeight),
                    offsetX: Math.round(offsetX),
                    offsetY: Math.round(offsetY),
                    naturalW: img.naturalWidth,
                    naturalH: img.naturalHeight
                });
                
                // Calculate position relative to the container
                const x = (e.clientX - containerRect.left - offsetX) / canvasZoom;
                const y = (e.clientY - containerRect.top - offsetY) / canvasZoom;
                
                console.log('Touch at:', { x: Math.round(x), y: Math.round(y) });
                
                // Only start if click is within image bounds
                if (x >= 0 && x <= renderedWidth && y >= 0 && y <= renderedHeight) {
                    setDrawingBox({ startX: x, startY: y, currentX: x, currentY: y });
                } else {
                    console.warn('Touch outside image bounds');
                }
            }, [manualBoxMode, canvasZoom]);
            
            const handleManualBoxMove = useCallback((e) => {
                if (!drawingBox || !imageContainerRef.current) return;
                
                const img = imageRef.current || imageContainerRef.current.querySelector('img');
                if (!img || !img.complete) return;
                
                const containerRect = imageContainerRef.current.getBoundingClientRect();
                const containerWidth = containerRect.width;
                const containerHeight = containerRect.height;
                const imageAspect = img.naturalWidth / img.naturalHeight;
                const containerAspect = containerWidth / containerHeight;
                
                let offsetX, offsetY;
                if (containerAspect > imageAspect) {
                    const renderedWidth = containerHeight * imageAspect;
                    offsetX = (containerWidth - renderedWidth) / 2;
                    offsetY = 0;
                } else {
                    const renderedHeight = containerWidth / imageAspect;
                    offsetX = 0;
                    offsetY = (containerHeight - renderedHeight) / 2;
                }
                
                const x = (e.clientX - containerRect.left - offsetX) / canvasZoom;
                const y = (e.clientY - containerRect.top - offsetY) / canvasZoom;
                
                setDrawingBox(prev => prev ? { ...prev, currentX: x, currentY: y } : null);
            }, [drawingBox, canvasZoom]);
            
            const handleManualBoxEnd = useCallback((e) => {
                if (!drawingBox || !imageContainerRef.current) return;
                
                const img = imageRef.current || imageContainerRef.current.querySelector('img');
                if (!img || !img.complete) return;
                
                const sourceWidth = recognitionSourceDims?.width || img.naturalWidth;
                const sourceHeight = recognitionSourceDims?.height || img.naturalHeight;
                
                const containerRect = imageContainerRef.current.getBoundingClientRect();
                const containerWidth = containerRect.width;
                const containerHeight = containerRect.height;
                const imageAspect = img.naturalWidth / img.naturalHeight;
                const containerAspect = containerWidth / containerHeight;
                
                let renderedWidth, renderedHeight;
                if (containerAspect > imageAspect) {
                    renderedHeight = containerHeight;
                    renderedWidth = renderedHeight * imageAspect;
                } else {
                    renderedWidth = containerWidth;
                    renderedHeight = renderedWidth / imageAspect;
                }
                
                // Scale from rendered size to source size
                const scaleX = sourceWidth / renderedWidth;
                const scaleY = sourceHeight / renderedHeight;
                
                const x = Math.min(drawingBox.startX, drawingBox.currentX) * scaleX;
                const y = Math.min(drawingBox.startY, drawingBox.currentY) * scaleY;
                const width = Math.abs(drawingBox.currentX - drawingBox.startX) * scaleX;
                const height = Math.abs(drawingBox.currentY - drawingBox.startY) * scaleY;
                
                console.log('ðŸ“¦ Manual box end:', { x: Math.round(x), y: Math.round(y), w: Math.round(width), h: Math.round(height) });
                
                // Only create box if it has reasonable size
                if (width > 5 && height > 5) {
                    setShowGlyphSelector({ mode: 'manual', position: { x, y, width, height } });
                    setGlyphSelectorSearch('');
                }
                
                setDrawingBox(null);
            }, [drawingBox, recognitionSourceDims]);
            
            // Crop selection handlers (one-shot operation)
            const handleCropStart = useCallback((e) => {
                if (!cropMode || !imageRef.current) return;
                
                const img = imageRef.current;
                const imgRect = img.getBoundingClientRect();
                
                const x = (e.clientX - imgRect.left) / canvasZoom;
                const y = (e.clientY - imgRect.top) / canvasZoom;
                
                if (x >= 0 && x <= img.clientWidth && y >= 0 && y <= img.clientHeight) {
                    setCropSelection({ startX: x, startY: y, currentX: x, currentY: y });
                }
            }, [cropMode, canvasZoom]);
            
            const handleCropMove = useCallback((e) => {
                if (!cropSelection || !imageRef.current) return;
                
                const img = imageRef.current;
                const imgRect = img.getBoundingClientRect();
                
                const x = (e.clientX - imgRect.left) / canvasZoom;
                const y = (e.clientY - imgRect.top) / canvasZoom;
                
                setCropSelection(prev => prev ? { ...prev, currentX: x, currentY: y } : null);
            }, [cropSelection, canvasZoom]);
            
            const handleCropEnd = useCallback(async () => {
                console.log('âœ‚ï¸ Crop end triggered');
                
                if (!cropSelection) {
                    console.log('âŒ No crop selection');
                    return;
                }
                if (!imageRef.current) {
                    console.log('âŒ No image ref');
                    return;
                }
                if (!opencvReady) {
                    console.log('âŒ OpenCV not ready');
                    return;
                }
                
                const img = imageRef.current;
                const sourceWidth = recognitionSourceDims?.width || img.naturalWidth;
                const sourceHeight = recognitionSourceDims?.height || img.naturalHeight;
                
                const scaleX = sourceWidth / img.clientWidth;
                const scaleY = sourceHeight / img.clientHeight;
                
                const x = Math.round(Math.min(cropSelection.startX, cropSelection.currentX) * scaleX);
                const y = Math.round(Math.min(cropSelection.startY, cropSelection.currentY) * scaleY);
                const width = Math.round(Math.abs(cropSelection.currentX - cropSelection.startX) * scaleX);
                const height = Math.round(Math.abs(cropSelection.currentY - cropSelection.startY) * scaleY);
                
                console.log(`âœ‚ï¸ Crop selection: ${width}Ã—${height}px at (${x},${y})`);
                
                // Only crop if selection is reasonable size
                if (width <= 20 || height <= 20) {
                    console.log('âš ï¸ Crop area too small (minimum 20Ã—20px)');
                    setCropMode(false);
                    setCropSelection(null);
                    return;
                }
                
                try {
                    // Crop the original mat
                    if (!originalMatRef.current) {
                        console.log('âŒ No original mat');
                        setCropMode(false);
                        setCropSelection(null);
                        return;
                    }
                    
                    const cropX = Math.max(0, Math.min(x, originalMatRef.current.cols - 1));
                    const cropY = Math.max(0, Math.min(y, originalMatRef.current.rows - 1));
                    const cropW = Math.min(width, originalMatRef.current.cols - cropX);
                    const cropH = Math.min(height, originalMatRef.current.rows - cropY);
                    
                    console.log(`âœ‚ï¸ Adjusted crop: ${cropW}Ã—${cropH}px at (${cropX},${cropY})`);
                    
                    if (cropW <= 0 || cropH <= 0) {
                        console.log('âŒ Invalid crop dimensions');
                        setCropMode(false);
                        setCropSelection(null);
                        return;
                    }
                    
                    const croppedRegion = originalMatRef.current.roi(new cv.Rect(cropX, cropY, cropW, cropH));
                    const croppedClone = croppedRegion.clone();
                    
                    // Delete old mat and replace with cropped version
                    originalMatRef.current.delete();
                    originalMatRef.current = croppedClone;
                    
                    // Also crop preprocessed if it exists
                    if (preprocessedMatRef.current) {
                        preprocessedMatRef.current.delete();
                        preprocessedMatRef.current = null;
                    }
                    
                    // Update display
                    const dataUrl = matToDataUrl(croppedClone);
                    setOriginalImage(dataUrl);
                    setDisplayImage(dataUrl);
                    
                    // Update recognition source dims
                    setRecognitionSourceDims({
                        width: croppedClone.cols,
                        height: croppedClone.rows
                    });
                    
                    console.log(`âœ… Crop successful: ${cropW}Ã—${cropH}px`);
                } catch (error) {
                    console.error('âŒ Crop error:', error);
                    alert('Crop failed: ' + error.message);
                }
                
                // Auto-disable crop mode and clear selection
                setCropMode(false);
                setCropSelection(null);
            }, [cropSelection, recognitionSourceDims, opencvReady, matToDataUrl]);
            
            // Open glyph selector to change an existing detection's glyph
            const openChartSelector = useCallback((detectionIndex) => {
                setShowGlyphSelector({ mode: 'change', detectionIndex });
                setGlyphSelectorSearch('');
            }, []);
            
            const addManualDetection = useCallback((glyph, position) => {
                if (!glyph || !position) return;
                
                // Create thumbnail from image
                let thumbnail = null;
                if (imageRef.current) {
                    try {
                        const img = imageRef.current;
                        const canvas = document.createElement('canvas');
                        canvas.width = position.width;
                        canvas.height = position.height;
                        const ctx = canvas.getContext('2d');
                        
                        // Draw from the source image
                        const tempImg = new Image();
                        tempImg.crossOrigin = 'anonymous';
                        tempImg.src = displayImage;
                        ctx.drawImage(tempImg, 
                            position.x, position.y, position.width, position.height,
                            0, 0, position.width, position.height
                        );
                        thumbnail = canvas.toDataURL('image/png');
                    } catch (e) {
                        console.warn('Could not create thumbnail:', e);
                    }
                }
                
                const newIndex = recognitionResults.length;
                const newDetection = {
                    glyph: glyph,
                    confidence: 1.0, // Manual = high confidence
                    position: position,
                    thumbnail: thumbnail,
                    matchType: 'manual',
                    isManual: true,
                    regionIndex: newIndex
                };
                
                setRecognitionResults(prev => [...prev, newDetection]);
                
                // Add to reading order at the end
                setReadingOrder(prev => [...prev, newIndex]);
                
                setShowGlyphSelector(null);
                setManualBoxMode(false);
                
                console.log('âœ… Added manual detection:', glyph.name, 'at index', newIndex);
            }, [displayImage, recognitionResults.length]);
            
            // Initialize region editor canvas when opened
            useEffect(() => {
                if (regionEditorIdx !== null) {
                    // Small delay to ensure canvas is mounted
                    setTimeout(initRegionEditorCanvas, 50);
                }
            }, [regionEditorIdx, initRegionEditorCanvas]);
            
            // ========== TRANSCRIPTION HELPERS ==========
            const getReadingOrderedResults = useCallback(() => {
                if (viewMode !== 'reading' || readingOrder.length === 0) {
                    return recognitionResults.filter(r => Math.round(r.confidence * 100) >= confidenceThreshold);
                }
                return readingOrder
                    .filter(idx => !excludedDetections.has(idx) && Math.round(recognitionResults[idx]?.confidence * 100) >= confidenceThreshold)
                    .map(idx => recognitionResults[idx])
                    .filter(Boolean);
            }, [viewMode, readingOrder, recognitionResults, excludedDetections, confidenceThreshold]);
            
            const copyTranscriptionToClipboard = useCallback(() => {
                const results = getReadingOrderedResults();
                const text = results.map((r, idx) => {
                    let char = showArabicLabels 
                        ? (r.glyph.arabic || r.glyph.name)
                        : (r.glyph.transliteration || r.glyph.name);
                    if (wordBoundaries.has(idx)) char += ' ';
                    if (lineBreaks.has(idx)) char += '\n';
                    return char;
                }).join('');
                
                navigator.clipboard.writeText(text).then(() => {
                    alert('âœ… Transcription copied to clipboard!');
                }).catch(err => {
                    console.error('Copy failed:', err);
                    alert('âŒ Failed to copy');
                });
            }, [getReadingOrderedResults, showArabicLabels, wordBoundaries, lineBreaks]);
            
            const exportTranscription = useCallback(() => {
                const results = getReadingOrderedResults();
                let translitText = '';
                let arabicText = '';
                
                results.forEach((r, idx) => {
                    translitText += r.glyph.transliteration || r.glyph.name;
                    arabicText += r.glyph.arabic || r.glyph.name;
                    if (wordBoundaries.has(idx)) {
                        translitText += ' ';
                        arabicText += ' ';
                    }
                    if (lineBreaks.has(idx)) {
                        translitText += '\n';
                        arabicText += '\n';
                    }
                });
                
                const content = [
                    '='.repeat(60),
                    'HAKLI INSCRIPTION TRANSCRIPTION',
                    `Title: ${inscriptionTitle || 'Untitled'}`,
                    `Date: ${new Date().toLocaleString()}`,
                    '='.repeat(60),
                    '',
                    'TRANSLITERATION:',
                    translitText,
                    '',
                    'ARABIC:',
                    arabicText,
                    '',
                    translationEnglish ? `ENGLISH TRANSLATION:\n${translationEnglish}\n` : '',
                    translationArabic ? `ARABIC TRANSLATION:\n${translationArabic}\n` : '',
                    '='.repeat(60),
                    `Total glyphs: ${results.length}`,
                    `Words: ${Array.from(wordBoundaries).length + 1}`,
                    `Lines: ${Array.from(lineBreaks).length + 1}`,
                    '='.repeat(60)
                ].join('\n');
                
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${inscriptionTitle || 'transcription'}_${new Date().toISOString().slice(0,10)}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            }, [getReadingOrderedResults, wordBoundaries, lineBreaks, inscriptionTitle, translationEnglish, translationArabic]);
            
            // ========== BOOKLET GENERATION ==========
            const generateHtmlBooklet = useCallback(() => {
                const results = getReadingOrderedResults();
                let translitText = '';
                let arabicText = '';
                
                results.forEach((r, idx) => {
                    translitText += r.glyph.transliteration || r.glyph.name;
                    arabicText += r.glyph.arabic || r.glyph.name;
                    if (wordBoundaries.has(idx)) {
                        translitText += ' ';
                        arabicText += ' ';
                    }
                    if (lineBreaks.has(idx)) {
                        translitText += '<br>';
                        arabicText += '<br>';
                    }
                });
                
                const bookletHtml = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Inscription Booklet - ${inscriptionTitle || 'Untitled'}</title>
    <style>
        @page { size: A5 portrait; margin: 1.5cm; }
        body { 
            font-family: Georgia, serif;
            line-height: 1.6;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        .cover {
            text-align: center;
            padding: 60px 20px;
            border: 3px solid #4a3d5a;
            margin-bottom: 40px;
        }
        .cover h1 {
            font-size: 32px;
            color: #4a3d5a;
            margin-bottom: 20px;
        }
        .cover p {
            font-size: 16px;
            color: #666;
        }
        .section {
            margin: 30px 0;
            padding: 20px;
            background: #f9f9f9;
            border-left: 4px solid #b87333;
        }
        .section-title {
            font-size: 18px;
            font-weight: bold;
            color: #4a3d5a;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .inscription-image {
            width: 100%;
            max-width: 400px;
            border: 2px solid #ddd;
            margin: 20px auto;
            display: block;
        }
        .transliteration {
            font-size: 20px;
            font-family: 'Courier New', monospace;
            color: #2d5a3d;
            line-height: 1.8;
        }
        .arabic {
            font-size: 24px;
            font-family: 'Traditional Arabic', 'Arabic Typesetting', 'Scheherazade', sans-serif;
            direction: rtl;
            text-align: right;
            color: #b87333;
            line-height: 2;
        }
        .translation {
            font-size: 16px;
            font-style: italic;
            color: #555;
            line-height: 1.8;
        }
        .metadata {
            font-size: 14px;
            color: #999;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        .footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
            font-size: 12px;
            color: #999;
        }
        .print-button {
            display: block;
            margin: 20px auto;
            padding: 15px 30px;
            background: #4a3d5a;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
        }
        .print-button:hover {
            background: #3a2d4a;
        }
        @media print {
            .no-print { display: none; }
            body { padding: 0; }
        }
    </style>
</head>
<body>
    <div class="cover">
        <h1>ðŸ“œ ${inscriptionTitle || 'Hakli Inscription'}</h1>
        <p>${inscriptionNotes || ''}</p>
        <p class="metadata">
            ID: ${currentInscriptionId || 'Unknown'}<br>
            Date: ${new Date().toLocaleDateString()}<br>
            Total Glyphs: ${results.length}
        </p>
    </div>
    
    <button class="print-button no-print" onclick="window.print()">ðŸ–¨ï¸ Print Booklet</button>
    
    ${originalImage ? `
    <div class="section">
        <div class="section-title">Original Inscription</div>
        <img src="${originalImage}" alt="Inscription" class="inscription-image">
    </div>
    ` : ''}
    
    <div class="section">
        <div class="section-title">Transliteration</div>
        <div class="transliteration">${translitText}</div>
    </div>
    
    <div class="section">
        <div class="section-title">Ù†Ø³Ø® Ø¹Ø±Ø¨ÙŠ (Arabic Transcription)</div>
        <div class="arabic">${arabicText}</div>
    </div>
    
    ${translationEnglish ? `
    <div class="section">
        <div class="section-title">English Translation</div>
        <div class="translation">${translationEnglish.replace(/\n/g, '<br>')}</div>
    </div>
    ` : ''}
    
    ${translationArabic ? `
    <div class="section">
        <div class="section-title">Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Arabic Translation)</div>
        <div class="translation arabic">${translationArabic.replace(/\n/g, '<br>')}</div>
    </div>
    ` : ''}
    
    <div class="footer">
        <p>Based on Ahmad Al-Jallad (2025), <em>The Decipherment of the Dhofari Script</em></p>
        <p>Â© hoopoe holdings Â· Hakli Glyph Recognizer</p>
    </div>
</body>
</html>`;
                
                const bookletWindow = window.open('', '_blank');
                bookletWindow.document.write(bookletHtml);
                bookletWindow.document.close();
                
                console.log('ðŸ“– HTML Booklet generated');
            }, [getReadingOrderedResults, wordBoundaries, lineBreaks, inscriptionTitle, inscriptionNotes, currentInscriptionId, originalImage, translationEnglish, translationArabic]);
            
            const generatePdfBooklet = useCallback(async () => {
                if (typeof jspdf === 'undefined' || !jspdf.jsPDF) {
                    alert('âŒ jsPDF library not loaded');
                    return;
                }
                
                // Helper to convert special transliteration chars to ASCII for PDF
                // jsPDF default fonts don't support Unicode diacritics
                // Uses CAPITALS for emphatic/pharyngeal consonants (standard Semitic convention)
                const toAsciiTranslit = (text) => {
                    return text
                        .replace(/á¸¥/g, 'H')    // pharyngeal h â†’ H
                        .replace(/á¸¤/g, 'H')
                        .replace(/á¹£/g, 'S')    // emphatic s â†’ S
                        .replace(/á¹¢/g, 'S')
                        .replace(/á¹­/g, 'T')    // emphatic t â†’ T
                        .replace(/á¹¬/g, 'T')
                        .replace(/á¸/g, 'D')    // emphatic d â†’ D
                        .replace(/á¸Œ/g, 'D')
                        .replace(/áº“/g, 'Z')    // emphatic z â†’ Z
                        .replace(/áº’/g, 'Z')
                        .replace(/á¸/g, 'dh')   // d with line below (eth)
                        .replace(/á¹¯/g, 'th')   // t with line below (thorn)
                        .replace(/Ä¡/g, 'gh')   // g with dot above
                        .replace(/Ê¿/g, "c")    // ayin â†’ c (common convention)
                        .replace(/Ê¾/g, "'")    // aleph/hamza
                        .replace(/Å¡/g, 'sh')   // s with caron
                        .replace(/Ä/g, 'aa')   // long vowels doubled
                        .replace(/Ä«/g, 'ii')
                        .replace(/Å«/g, 'uu')
                        .replace(/Ä“/g, 'ee')
                        .replace(/Å/g, 'oo');
                };
                
                const { jsPDF } = jspdf;
                const pdf = new jsPDF({ format: 'a5', unit: 'mm' });
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 15;
                const contentWidth = pageWidth - (margin * 2);
                
                const results = getReadingOrderedResults();
                let translitText = '';
                let arabicText = '';
                
                results.forEach((r, idx) => {
                    translitText += r.glyph.transliteration || r.glyph.name;
                    arabicText += r.glyph.arabic || r.glyph.name;
                    if (wordBoundaries.has(idx)) {
                        translitText += ' ';
                        arabicText += ' ';
                    }
                    if (lineBreaks.has(idx)) {
                        translitText += '\n';
                        arabicText += '\n';
                    }
                });
                
                // Convert to ASCII for PDF compatibility
                const pdfTranslitText = toAsciiTranslit(translitText);
                
                // Cover page
                pdf.setFontSize(20);
                pdf.setFont('helvetica', 'bold');
                pdf.text(inscriptionTitle || 'Hakli Inscription', pageWidth / 2, 50, { align: 'center' });
                
                pdf.setFontSize(12);
                pdf.setFont('helvetica', 'normal');
                if (inscriptionNotes) {
                    const notesLines = pdf.splitTextToSize(inscriptionNotes, contentWidth);
                    pdf.text(notesLines, pageWidth / 2, 70, { align: 'center' });
                }
                
                pdf.setFontSize(10);
                pdf.text(`ID: ${currentInscriptionId || 'Unknown'}`, pageWidth / 2, 100, { align: 'center' });
                pdf.text(`Date: ${new Date().toLocaleDateString()}`, pageWidth / 2, 110, { align: 'center' });
                pdf.text(`Total Glyphs: ${results.length}`, pageWidth / 2, 120, { align: 'center' });
                
                // New page for inscription image
                if (originalImage) {
                    pdf.addPage();
                    pdf.setFontSize(14);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('Original Inscription', margin, 20);
                    
                    try {
                        const imgWidth = contentWidth;
                        const imgHeight = (imgWidth * 3) / 4; // Maintain aspect ratio
                        pdf.addImage(originalImage, 'JPEG', margin, 30, imgWidth, imgHeight);
                    } catch (err) {
                        console.warn('Could not add image to PDF:', err);
                    }
                }
                
                // Transliteration page
                pdf.addPage();
                pdf.setFontSize(14);
                pdf.setFont('helvetica', 'bold');
                pdf.text('Transliteration', margin, 20);
                
                pdf.setFontSize(12);
                pdf.setFont('courier', 'normal');
                const translitLines = pdf.splitTextToSize(pdfTranslitText, contentWidth);
                pdf.text(translitLines, margin, 35);
                
                // Note about special characters
                pdf.setFontSize(8);
                pdf.setFont('helvetica', 'italic');
                pdf.text('(Note: Special diacritics simplified for PDF - use HTML Booklet for accurate rendering)', margin, pageHeight - 10);
                
                // Arabic page - PDF fonts don't support Arabic, show placeholder
                pdf.addPage();
                pdf.setFontSize(14);
                pdf.setFont('helvetica', 'bold');
                pdf.text('Arabic Transcription', margin, 20);
                
                pdf.setFontSize(11);
                pdf.setFont('helvetica', 'italic');
                pdf.text('(Arabic text cannot be rendered in PDF - use HTML Booklet for Arabic)', margin, 35);
                pdf.setFont('helvetica', 'normal');
                pdf.text('Transliteration: ' + pdfTranslitText.substring(0, 100) + (pdfTranslitText.length > 100 ? '...' : ''), margin, 50);
                
                // Translations
                if (translationEnglish) {
                    pdf.addPage();
                    pdf.setFontSize(14);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('English Translation', margin, 20);
                    
                    pdf.setFontSize(11);
                    pdf.setFont('helvetica', 'normal');
                    const englishLines = pdf.splitTextToSize(translationEnglish, contentWidth);
                    pdf.text(englishLines, margin, 35);
                }
                
                if (translationArabic) {
                    pdf.addPage();
                    pdf.setFontSize(14);
                    pdf.setFont('helvetica', 'bold');
                    pdf.text('Arabic Translation', margin, 20);
                    
                    pdf.setFontSize(11);
                    pdf.setFont('helvetica', 'italic');
                    pdf.text('(Arabic text cannot be rendered in PDF - use HTML Booklet for Arabic)', margin, 35);
                }
                
                // Footer on last page
                const lastPageNum = pdf.internal.pages.length - 1;
                pdf.setPage(lastPageNum);
                pdf.setFontSize(8);
                pdf.setFont('helvetica', 'italic');
                pdf.text('Based on Ahmad Al-Jallad (2025), The Decipherment of the Dhofari Script', pageWidth / 2, pageHeight - 20, { align: 'center' });
                pdf.text('Â© hoopoe holdings Â· Hakli Glyph Recognizer', pageWidth / 2, pageHeight - 15, { align: 'center' });
                
                // Save
                pdf.save(`${inscriptionTitle || 'booklet'}_${new Date().toISOString().slice(0,10)}.pdf`);
                console.log('ðŸ“– PDF Booklet generated (Note: Arabic text may not render correctly in PDF)');
            }, [getReadingOrderedResults, wordBoundaries, lineBreaks, inscriptionTitle, inscriptionNotes, currentInscriptionId, originalImage, translationEnglish, translationArabic]);
            
            // ========== TEMPLATE TRAINING ==========
            const saveAsTemplate = useCallback((detectionIndex, templateType) => {
                const detection = recognitionResults[detectionIndex];
                if (!detection || !detection.thumbnail) {
                    alert('No detection thumbnail available');
                    return;
                }

                const imageDataUrl = detection.thumbnail;
                const updatedChart = { ...chartData };
                const glyphIndex = updatedChart.glyphs.findIndex(g => g.id === detection.glyph.id);

                if (glyphIndex === -1) {
                    alert('Glyph not found in chart!');
                    return;
                }

                const glyph = updatedChart.glyphs[glyphIndex];

                // Initialize images object if it doesn't exist
                if (!glyph.images) {
                    glyph.images = { primary: null, variants: [], examples: [] };
                }

                // Add based on template type
                if (templateType === 'primary') {
                    // If there's an existing primary, move it to variants first
                    if (glyph.images.primary) {
                        if (!glyph.images.variants) glyph.images.variants = [];
                        glyph.images.variants.push(glyph.images.primary);
                        alert(`âœ… Saved as PRIMARY template for "${glyph.name}"\n\nPrevious primary moved to variants.`);
                    } else {
                        alert(`âœ… Saved as PRIMARY template for "${glyph.name}"`);
                    }
                    glyph.images.primary = imageDataUrl;
                } else if (templateType === 'variant') {
                    if (!glyph.images.variants) glyph.images.variants = [];
                    glyph.images.variants.push(imageDataUrl);
                    alert(`âœ… Saved as VARIANT template for "${glyph.name}"\n\nVariants: ${glyph.images.variants.length}`);
                } else if (templateType === 'example') {
                    if (!glyph.images.examples) glyph.images.examples = [];
                    glyph.images.examples.push(imageDataUrl);
                    alert(`âœ… Saved as EXAMPLE template for "${glyph.name}"\n\nExamples: ${glyph.images.examples.length}`);
                }

                setChartData(updatedChart);
                setChartModified(true);

                // Reload the image in the cache
                const img = new Image();
                img.onload = () => {
                    const newCache = { ...loadedGlyphImages };
                    const newThumbnails = { ...glyphThumbnails };
                    if (templateType === 'primary') {
                        newCache[glyph.id] = img;
                        newThumbnails[glyph.id] = img.src;
                    } else if (templateType === 'variant') {
                        const key = `${glyph.id}_variant_${glyph.images.variants.length - 1}`;
                        newCache[key] = img;
                        newThumbnails[key] = img.src;
                    } else if (templateType === 'example') {
                        const key = `${glyph.id}_example_${glyph.images.examples.length - 1}`;
                        newCache[key] = img;
                        newThumbnails[key] = img.src;
                    }
                    setLoadedGlyphImages(newCache);
                    setGlyphThumbnails(newThumbnails);
                };
                img.src = imageDataUrl;

                setSelectedForTemplate(null);
                console.log(`âœ… Saved ${templateType} template for ${glyph.name}`);
            }, [recognitionResults, chartData, loadedGlyphImages, glyphThumbnails]);
            
            // Delete a template from a glyph
            const deleteTemplate = useCallback((glyphId, templateType, index = null) => {
                const updatedChart = { ...chartData };
                const glyphIndex = updatedChart.glyphs.findIndex(g => g.id === glyphId);
                
                if (glyphIndex === -1) return;
                
                const glyph = updatedChart.glyphs[glyphIndex];
                if (!glyph.images) return;
                
                let confirmMsg = '';
                if (templateType === 'primary') {
                    confirmMsg = `Delete PRIMARY template for "${glyph.name}"?`;
                } else if (templateType === 'variant' && index !== null) {
                    confirmMsg = `Delete VARIANT #${index + 1} for "${glyph.name}"?`;
                } else if (templateType === 'example' && index !== null) {
                    confirmMsg = `Delete EXAMPLE #${index + 1} for "${glyph.name}"?`;
                }
                
                if (!confirm(confirmMsg)) return;
                
                if (templateType === 'primary') {
                    glyph.images.primary = null;
                } else if (templateType === 'variant' && index !== null) {
                    glyph.images.variants.splice(index, 1);
                } else if (templateType === 'example' && index !== null) {
                    glyph.images.examples.splice(index, 1);
                }
                
                setChartData(updatedChart);
                setChartModified(true);
                console.log(`ðŸ—‘ï¸ Deleted ${templateType} template for ${glyph.name}`);
            }, [chartData]);
            
            // ========== KEYBOARD SHORTCUTS ==========
            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Don't trigger if user is typing in an input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    // Number keys 1-9 to select detections
                    if (e.key >= '1' && e.key <= '9' && !e.ctrlKey && !e.metaKey) {
                        const idx = parseInt(e.key) - 1;
                        if (idx < recognitionResults.length) {
                            e.preventDefault();
                            setSelectedRegions(prev => {
                                const next = new Set(prev);
                                next.has(idx) ? next.delete(idx) : next.add(idx);
                                return next;
                            });
                        }
                    }
                    
                    // Arrow keys to navigate detections (when one is selected)
                    if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && selectedRegions.size === 1) {
                        e.preventDefault();
                        const currentIdx = Array.from(selectedRegions)[0];
                        const newIdx = e.key === 'ArrowRight' 
                            ? Math.min(currentIdx + 1, recognitionResults.length - 1)
                            : Math.max(currentIdx - 1, 0);
                        setSelectedRegions(new Set([newIdx]));
                    }
                    
                    // V/E/P to save as Variant/Example/Primary (when training mode & detection selected)
                    if (templateTrainingMode && selectedRegions.size === 1 && showChartManager) {
                        const idx = Array.from(selectedRegions)[0];
                        if (e.key.toLowerCase() === 'v') {
                            e.preventDefault();
                            saveAsTemplate(idx, 'variant');
                        } else if (e.key.toLowerCase() === 'e') {
                            e.preventDefault();
                            saveAsTemplate(idx, 'example');
                        } else if (e.key.toLowerCase() === 'p') {
                            e.preventDefault();
                            saveAsTemplate(idx, 'primary');
                        }
                    }
                    
                    // Escape to close modals/menus
                    if (e.key === 'Escape') {
                        if (editMenuCardIdx !== null) setEditMenuCardIdx(null);
                        else if (showGlyphSelector) setShowGlyphSelector(null);
                        else if (showChartManager) setShowChartManager(false);
                        else setSelectedRegions(new Set());
                    }
                    
                    // Enter to validate selected detection as correct
                    if (e.key === 'Enter' && selectedRegions.size === 1 && !showChartManager) {
                        e.preventDefault();
                        const idx = Array.from(selectedRegions)[0];
                        setValidations(prev => ({ ...prev, [idx]: { isCorrect: true } }));
                    }
                    
                    // Zoom controls: +/= to zoom in, - to zoom out, 0 to reset
                    if ((e.key === '+' || e.key === '=') && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        setCanvasZoom(z => Math.min(3, z + 0.25));
                    }
                    if (e.key === '-' && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        setCanvasZoom(z => Math.max(0.5, z - 0.25));
                    }
                    if (e.key === '0' && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        setCanvasZoom(1);
                    }
                    
                    // Toggle left panel: [ key
                    if (e.key === '[' && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        setIsLeftPanelHidden(h => !h);
                    }
                    
                    // Toggle right panel: ] key
                    if (e.key === ']' && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        setIsRightPanelHidden(h => !h);
                    }
                    
                    // Undo: Ctrl+Z
                    if (e.key === 'z' && (e.ctrlKey || e.metaKey) && !e.shiftKey) {
                        e.preventDefault();
                        undo();
                    }
                    
                    // Redo: Ctrl+Y or Ctrl+Shift+Z
                    if ((e.key === 'y' && (e.ctrlKey || e.metaKey)) || 
                        (e.key === 'z' && (e.ctrlKey || e.metaKey) && e.shiftKey)) {
                        e.preventDefault();
                        redo();
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [recognitionResults.length, selectedRegions, templateTrainingMode, showChartManager, editMenuCardIdx, showGlyphSelector, saveAsTemplate, undo, redo]);
            
            // ========== RECOGNITION ==========
            const recognizeGlyphs = useCallback(async () => {
                if (!displayImage || !chartData || Object.keys(loadedGlyphImages).length === 0) {
                    alert('âŒ Please load an image and wait for the glyph chart to load');
                    return;
                }
                
                if (!opencvReady) {
                    alert('âŒ OpenCV not ready yet');
                    return;
                }
                
                setIsProcessing(true);
                setRecognitionResults([]);
                setValidations({});
                setProcessingStatus('Isolating glyphs...');
                
                try {
                    console.log('ðŸ” Starting glyph recognition...');
                    
                    // Get the mat to use (preprocessed or original)
                    let inputMat = preprocessedMatRef.current || originalMatRef.current;
                    if (!inputMat) {
                        inputMat = await loadImageToMat(displayImage);
                    }
                    
                    // Store the dimensions of the image we're running recognition on
                    // This is critical for aligning detection boxes later
                    setRecognitionSourceDims({
                        width: inputMat.cols,
                        height: inputMat.rows
                    });
                    
                    // Clone for isolation (Isolation module may modify it)
                    const matForIsolation = inputMat.clone();
                    
                    // Step 1: Isolate potential glyph regions
                    let regions = [];
                    if (typeof Isolation !== 'undefined' && Isolation.isolateGlyphs) {
                        try {
                            regions = Isolation.isolateGlyphs(matForIsolation);
                            console.log(`ðŸ“¦ Isolated ${regions.length} regions via Isolation module`);
                        } catch (e) {
                            console.error('Isolation module error:', e);
                            // Fallback
                            regions = await fallbackIsolation(inputMat);
                        }
                    } else {
                        regions = await fallbackIsolation(inputMat);
                    }
                    
                    matForIsolation.delete();
                    
                    if (regions.length === 0) {
                        alert('âš ï¸ No glyph regions detected. Try adjusting preprocessing settings.');
                        setIsProcessing(false);
                        return;
                    }
                    
                    // Filter overlapping regions
                    if (typeof Isolation !== 'undefined' && Isolation.filterOverlappingRegions) {
                        regions = Isolation.filterOverlappingRegions(regions, 0.3);
                    }
                    
                    setProcessingStatus(`Matching ${regions.length} regions...`);
                    
                    // Step 2: Match each region against templates
                    const allDetections = [];
                    
                    for (let i = 0; i < regions.length; i++) {
                        const region = regions[i];
                        setProcessingStatus(`Matching region ${i + 1}/${regions.length}...`);
                        
                        // Get position from region
                        const position = region.bounds || region;
                        
                        // Match against all glyphs (primary + variants)
                        const regionDetections = [];
                        
                        for (const glyph of chartData.glyphs) {
                            // Collect all templates for this glyph
                            const templates = [];
                            
                            // Primary template
                            const primaryImg = loadedGlyphImages[glyph.id];
                            if (primaryImg) {
                                templates.push({ img: primaryImg, type: 'primary', label: 'ðŸŽ¯' });
                            }
                            
                            // Variant templates (if loaded)
                            if (glyph.images?.variants) {
                                glyph.images.variants.forEach((variantSrc, idx) => {
                                    const varKey = `${glyph.id}_variant_${idx}`;
                                    const varImg = loadedGlyphImages[varKey];
                                    if (varImg) {
                                        templates.push({ img: varImg, type: 'variant', index: idx, label: `â­${idx+1}` });
                                    }
                                });
                            }
                            
                            if (templates.length === 0) continue;
                            
                            // Find best matching template for this glyph
                            let bestConfidence = 0;
                            let bestTemplate = null;
                            
                            for (const template of templates) {
                                const regionAspect = position.width / position.height;
                                const templateAspect = template.img.naturalWidth / template.img.naturalHeight;
                                const aspectDiff = Math.abs(regionAspect - templateAspect);
                                let confidence = Math.max(0, 1 - aspectDiff * 0.5);
                                
                                // Add solidity bonus if available
                                if (region.solidity && glyph.expected_solidity) {
                                    const solidityDiff = Math.abs(region.solidity - glyph.expected_solidity);
                                    confidence += Math.max(0, 1 - solidityDiff) * 0.2;
                                }
                                
                                if (confidence > bestConfidence) {
                                    bestConfidence = confidence;
                                    bestTemplate = template;
                                }
                            }
                            
                            if (bestConfidence > 0.35 && bestTemplate) {
                                regionDetections.push({
                                    glyph: glyph,
                                    confidence: Math.min(bestConfidence, 0.99),
                                    position: position,
                                    thumbnail: region.thumbnail || null,
                                    matchedTemplate: bestTemplate.type,
                                    matchedTemplateLabel: bestTemplate.label,
                                    matchedTemplateIndex: bestTemplate.index
                                });
                            }
                        }
                        
                        // Keep best match
                        if (regionDetections.length > 0) {
                            regionDetections.sort((a, b) => b.confidence - a.confidence);
                            const best = regionDetections[0];
                            best.topMatches = regionDetections.slice(0, 5);
                            allDetections.push(best);
                        }
                    }
                    
                    setProcessingStatus('Applying NMS...');
                    
                    // Step 3: Apply NMS
                    let finalDetections = allDetections;
                    if (typeof NMS !== 'undefined' && NMS.applyNMS) {
                        finalDetections = NMS.applyNMS(allDetections, CONFIG.RECOGNITION.IOU_THRESHOLD);
                    } else {
                        // Simple NMS fallback
                        finalDetections = simpleNMS(allDetections, 0.3);
                    }
                    
                    console.log(`âœ¨ Final detections: ${finalDetections.length}`);
                    setRecognitionResults(finalDetections);
                    
                    // Step 4: Auto-detect reading order
                    if (finalDetections.length > 0) {
                        if (typeof ReadingOrder !== 'undefined' && ReadingOrder.generateOrder) {
                            const order = ReadingOrder.generateOrder(finalDetections, readingDirection);
                            setReadingOrder(order);
                        } else {
                            // Simple fallback
                            const order = finalDetections
                                .map((d, i) => ({ i, x: d.position.x, y: d.position.y }))
                                .sort((a, b) => {
                                    const rowDiff = Math.floor(a.y / 50) - Math.floor(b.y / 50);
                                    if (rowDiff !== 0) return rowDiff;
                                    return readingDirection === 'rtl' ? b.x - a.x : a.x - b.x;
                                })
                                .map(d => d.i);
                            setReadingOrder(order);
                        }
                    }
                    
                    alert(`âœ… Recognition complete! Found ${finalDetections.length} glyphs`);
                    
                } catch (error) {
                    console.error('Recognition error:', error);
                    alert('âŒ Recognition failed: ' + error.message);
                } finally {
                    setIsProcessing(false);
                    setProcessingStatus('');
                }
            }, [displayImage, chartData, loadedGlyphImages, opencvReady, loadImageToMat, readingDirection]);
            
            // Fallback isolation
            const fallbackIsolation = async (mat) => {
                const regions = [];
                try {
                    let gray = new cv.Mat();
                    if (mat.channels() > 1) cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
                    else gray = mat.clone();
                    
                    let binary = new cv.Mat();
                    cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
                    
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                    
                    const imageArea = mat.rows * mat.cols;
                    const minArea = imageArea * 0.0005;
                    const maxArea = imageArea * 0.15;
                    
                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const area = cv.contourArea(contour);
                        
                        if (area < minArea || area > maxArea) continue;
                        
                        const rect = cv.boundingRect(contour);
                        const aspectRatio = rect.width / rect.height;
                        
                        if (aspectRatio < 0.2 || aspectRatio > 5.0) continue;
                        
                        // Extract thumbnail
                        const roi = mat.roi(new cv.Rect(rect.x, rect.y, rect.width, rect.height));
                        const canvas = document.createElement('canvas');
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                        cv.imshow(canvas, roi);
                        roi.delete();
                        
                        regions.push({
                            bounds: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },
                            area: area,
                            aspectRatio: aspectRatio,
                            solidity: area / (rect.width * rect.height),
                            thumbnail: canvas.toDataURL()
                        });
                    }
                    
                    gray.delete();
                    binary.delete();
                    contours.delete();
                    hierarchy.delete();
                } catch (e) {
                    console.error('Fallback isolation error:', e);
                }
                return regions;
            };
            
            // Simple NMS
            const simpleNMS = (detections, threshold) => {
                const sorted = [...detections].sort((a, b) => b.confidence - a.confidence);
                const kept = [];
                for (const det of sorted) {
                    let dominated = false;
                    for (const kept_det of kept) {
                        const iou = Utils.calculateIoU(det.position, kept_det.position);
                        if (iou > threshold) { dominated = true; break; }
                    }
                    if (!dominated) kept.push(det);
                }
                return kept;
            };
            
            // ========== VALIDATION ==========
            const validateDetection = useCallback((index, isCorrect) => {
                pushUndo('validation', { ...validations });
                
                // Log the validation change if user is logged in
                if (driveUserEmail && typeof ChangeTracker !== 'undefined') {
                    const oldStatus = validations[index]?.isCorrect;
                    // Only log if status actually changed
                    if (oldStatus !== isCorrect) {
                        const entry = ChangeTracker.logValidation(index, oldStatus, isCorrect, driveUserEmail);
                        setChangeLog(prev => [...prev, entry]);
                    }
                }
                
                setValidations(prev => ({
                    ...prev,
                    [index]: { isCorrect, timestamp: new Date().toISOString() }
                }));
            }, [validations, pushUndo, driveUserEmail]);
            
            const deleteDetection = useCallback((index) => {
                setRecognitionResults(prev => prev.filter((_, i) => i !== index));
                setValidations(prev => {
                    const updated = {};
                    Object.entries(prev).forEach(([k, v]) => {
                        const oldIdx = parseInt(k);
                        if (oldIdx < index) updated[oldIdx] = v;
                        else if (oldIdx > index) updated[oldIdx - 1] = v;
                    });
                    return updated;
                });
                setReadingOrder(prev => prev.filter(i => i !== index).map(i => i > index ? i - 1 : i));
                setExcludedDetections(prev => {
                    const updated = new Set();
                    prev.forEach(i => {
                        if (i < index) updated.add(i);
                        else if (i > index) updated.add(i - 1);
                    });
                    return updated;
                });
                setExpandedCards(prev => {
                    const updated = new Set();
                    prev.forEach(i => {
                        if (i < index) updated.add(i);
                        else if (i > index) updated.add(i - 1);
                    });
                    return updated;
                });
            }, []);
            
            // Change glyph assignment to an alternative match
            const changeGlyphAssignment = useCallback((detectionIdx, newGlyph) => {
                // Get old glyph for logging
                const oldGlyph = recognitionResults[detectionIdx]?.glyph;
                
                // Log the change if user is logged in and glyph actually changed
                if (driveUserEmail && oldGlyph?.id !== newGlyph?.id && typeof ChangeTracker !== 'undefined') {
                    const entry = ChangeTracker.logCorrection(detectionIdx, oldGlyph, newGlyph, driveUserEmail);
                    setChangeLog(prev => [...prev, entry]);
                }
                
                setRecognitionResults(prev => {
                    const updated = [...prev];
                    if (updated[detectionIdx]) {
                        updated[detectionIdx] = {
                            ...updated[detectionIdx],
                            glyph: newGlyph,
                            // Find confidence from topMatches
                            confidence: updated[detectionIdx].topMatches?.find(m => m.glyph.id === newGlyph.id)?.confidence || updated[detectionIdx].confidence
                        };
                    }
                    return updated;
                });
                // Clear validation when glyph changes
                setValidations(prev => {
                    const updated = { ...prev };
                    delete updated[detectionIdx];
                    return updated;
                });
            }, [recognitionResults, driveUserEmail]);
            
            // Toggle exclusion of a detection from reading order
            const toggleExcludeDetection = useCallback((index) => {
                pushUndo('excludedDetections', Array.from(excludedDetections));
                setExcludedDetections(prev => {
                    const updated = new Set(prev);
                    if (updated.has(index)) {
                        updated.delete(index);
                    } else {
                        updated.add(index);
                    }
                    return updated;
                });
            }, [excludedDetections, pushUndo]);
            
            // Toggle word boundary with undo
            const toggleWordBoundary = useCallback((idx) => {
                pushUndo('wordBoundaries', Array.from(wordBoundaries));
                setWordBoundaries(prev => {
                    const next = new Set(prev);
                    next.has(idx) ? next.delete(idx) : next.add(idx);
                    return next;
                });
            }, [wordBoundaries, pushUndo]);
            
            // Toggle line break with undo
            const toggleLineBreak = useCallback((idx) => {
                pushUndo('lineBreaks', Array.from(lineBreaks));
                setLineBreaks(prev => {
                    const next = new Set(prev);
                    next.has(idx) ? next.delete(idx) : next.add(idx);
                    return next;
                });
            }, [lineBreaks, pushUndo]);
            
            // Toggle column break with undo
            const toggleColumnBreak = useCallback((idx) => {
                pushUndo('columnBreaks', Array.from(columnBreaks));
                setColumnBreaks(prev => {
                    const next = new Set(prev);
                    next.has(idx) ? next.delete(idx) : next.add(idx);
                    return next;
                });
            }, [columnBreaks, pushUndo]);
            
            // Drag handlers for reordering reading order
            const handleDragStart = useCallback((e, readingOrderPosition) => {
                setDraggedCardIdx(readingOrderPosition);
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', readingOrderPosition.toString());
            }, []);
            
            const handleDragOver = useCallback((e, readingOrderPosition) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                setDragOverCardIdx(readingOrderPosition);
            }, []);
            
            const handleDragLeave = useCallback(() => {
                setDragOverCardIdx(null);
            }, []);
            
            const handleDrop = useCallback((e, targetPosition) => {
                e.preventDefault();
                const sourcePosition = draggedCardIdx;
                
                if (sourcePosition !== null && sourcePosition !== targetPosition) {
                    // Save current state for undo
                    pushUndo('readingOrder', [...readingOrder]);
                    
                    setReadingOrder(prev => {
                        const newOrder = [...prev];
                        // Remove from source position
                        const [movedItem] = newOrder.splice(sourcePosition, 1);
                        // Insert at target position
                        newOrder.splice(targetPosition, 0, movedItem);
                        return newOrder;
                    });
                }
                
                setDraggedCardIdx(null);
                setDragOverCardIdx(null);
            }, [draggedCardIdx, readingOrder, pushUndo]);
            
            const handleDragEnd = useCallback(() => {
                setDraggedCardIdx(null);
                setDragOverCardIdx(null);
            }, []);
            
            // Merge two selected detections
            const mergeSelectedDetections = useCallback(() => {
                if (selectedRegions.size !== 2) {
                    alert('Select exactly 2 detections to merge');
                    return;
                }
                
                const indices = Array.from(selectedRegions).sort((a, b) => a - b);
                const [idx1, idx2] = indices;
                const det1 = recognitionResults[idx1];
                const det2 = recognitionResults[idx2];
                
                if (!det1 || !det2) return;
                
                // Create merged detection - use higher confidence one as base
                const baseDet = det1.confidence >= det2.confidence ? det1 : det2;
                const mergedPosition = {
                    x: Math.min(det1.position.x, det2.position.x),
                    y: Math.min(det1.position.y, det2.position.y),
                    width: Math.max(det1.position.x + det1.position.width, det2.position.x + det2.position.width) - Math.min(det1.position.x, det2.position.x),
                    height: Math.max(det1.position.y + det1.position.height, det2.position.y + det2.position.height) - Math.min(det1.position.y, det2.position.y)
                };
                
                const merged = {
                    ...baseDet,
                    position: mergedPosition,
                    isMerged: true,
                    mergedFrom: [idx1, idx2]
                };
                
                // Remove both, add merged at first position
                setRecognitionResults(prev => {
                    const updated = prev.filter((_, i) => i !== idx1 && i !== idx2);
                    updated.splice(idx1, 0, merged);
                    return updated;
                });
                
                setSelectedRegions(new Set());
                setReadingOrder(prev => {
                    // Remove old indices, adjust remaining
                    return prev
                        .filter(i => i !== idx1 && i !== idx2)
                        .map(i => i > idx2 ? i - 2 : i > idx1 ? i - 1 : i)
                        .concat([idx1]); // Add merged at end
                });
                
                alert('âœ… Detections merged');
            }, [selectedRegions, recognitionResults]);
            
            // Toggle card expansion (show alternatives)
            const toggleCardExpansion = useCallback((index) => {
                setExpandedCards(prev => {
                    const updated = new Set(prev);
                    if (updated.has(index)) {
                        updated.delete(index);
                    } else {
                        updated.add(index);
                    }
                    return updated;
                });
            }, []);

            // ============================================
            // RENDER
            // ============================================
            return (
                <div className="min-h-screen bg-gray-100 flex flex-col">
                    {/* Header */}
                    <header className="bg-ancient-purple text-white shadow-lg flex-shrink-0">
                        <div className="max-w-7xl mx-auto px-4 py-2">
                            <div className="flex items-center justify-between">
                                <div 
                                    className="flex items-center gap-3 flex-1 cursor-pointer lg:cursor-default"
                                    onClick={() => setHeaderCollapsed(!headerCollapsed)}
                                >
                                    <img src="hh-logo.png" alt="Hoopoe Holdings" className="w-10 h-10 rounded-full object-cover flex-shrink-0" />
                                    <div className="flex-1 min-w-0">
                                        <h1 className={`font-bold leading-tight ${headerCollapsed ? 'text-sm' : 'text-base'}`}>
                                            Hakli Glyph Recognizer
                                        </h1>
                                        {!headerCollapsed && (
                                            <>
                                                <p className="text-[10px] text-purple-200 leading-tight">
                                                    Based on Ahmad Al-Jallad (2025), <em>The Decipherment of the Dhofari Script</em>
                                                </p>
                                                <p className="text-[10px] text-purple-300 leading-tight">
                                                    beta {APP_VERSION} Â© hoopoe holdings
                                                </p>
                                            </>
                                        )}
                                    </div>
                                    {/* Collapse indicator (mobile only) */}
                                    <div className="lg:hidden text-white/50 text-xs">
                                        {headerCollapsed ? 'â–¼' : 'â–²'}
                                    </div>
                                </div>
                                
                                <div className="flex items-center gap-2">
                                    {/* Manage Chart Button */}
                                    <button
                                        onClick={() => setShowChartManager(true)}
                                        disabled={chartStatus !== 'loaded'}
                                        className={`px-3 py-1 rounded-lg text-xs font-medium disabled:opacity-50 ${chartModified ? 'bg-ochre hover:bg-ochre/80' : 'bg-white/20 hover:bg-white/30'}`}
                                        title={chartVersion ? `Chart version ${chartVersion}` : 'Manage glyph chart'}
                                    >
                                        {chartModified ? 'âš ï¸' : 'ðŸ“Š'} Chart{chartVersion ? ` v${chartVersion}` : ''}{chartModified ? '*' : ''}
                                    </button>
                                    
                                    {/* Status indicators - grouped on right */}
                                    <div className="flex items-center gap-1 ml-2 pl-2 border-l border-white/20">
                                        <div 
                                            className={`px-3 py-1 rounded-full text-xs font-bold ${chartStatus === 'loaded' ? 'bg-patina' : 'bg-amber-400 text-amber-900 animate-pulse'}`}
                                            title={chartStatus === 'loaded' ? `${Object.keys(loadedGlyphImages).length} template images loaded for ${chartData?.glyphs?.length || 0} glyphs` : 'Loading glyph chart...'}
                                        >
                                            {chartStatus === 'loaded' 
                                                ? `âœ… ${chartData?.glyphs?.length || 0} glyphs` 
                                                : chartLoadProgress.total > 0 
                                                    ? `â³ ${Math.round((chartLoadProgress.loaded / chartLoadProgress.total) * 100)}%`
                                                    : `â³ Loading...`}
                                        </div>
                                        <div className={`px-2 py-1 rounded-full text-xs ${opencvReady ? 'bg-patina' : 'bg-ochre'}`}>
                                            {opencvReady ? 'âœ… CV' : 'â³ CV'}
                                        </div>
                                        
                                        {/* Save Status Indicator */}
                                        {recognitionResults.length > 0 && (
                                            <div 
                                                className={`px-2 py-1 rounded-full text-xs ${hasUnsavedChanges ? 'bg-amber-400/30 border border-amber-400/50' : 'bg-patina/30 border border-patina/50'}`}
                                                title={hasUnsavedChanges 
                                                    ? 'Unsaved changes - will auto-save in a moment' 
                                                    : lastSavedTime 
                                                        ? `Last saved ${Math.round((Date.now() - lastSavedTime) / 1000)}s ago`
                                                        : 'Saved'}
                                            >
                                                {hasUnsavedChanges ? 'ðŸ’¾ Saving...' : 'âœ… Saved'}
                                            </div>
                                        )}
                                        
                                        {/* Sync Status / Drive Sign-in */}
                                        {currentUser ? (
                                            <div className="flex items-center gap-1 px-2 py-1 bg-green-500/30 rounded-full border border-green-400/50">
                                                <span className="text-xs">âœï¸ {currentUser.name}</span>
                                                <button
                                                    onClick={() => {
                                                        if (typeof AccessControl !== 'undefined') AccessControl.logout();
                                                        setCurrentUser(null);
                                                        setIsReadOnly(true);
                                                    }}
                                                    className="text-green-200 hover:text-white text-xs"
                                                    title="Switch to view-only"
                                                >âœ•</button>
                                            </div>
                                        ) : driveSignedIn ? (
                                            <div className="flex items-center gap-1">
                                                <div className="px-2 py-1 rounded-full text-xs bg-patina flex items-center gap-1">
                                                    <span>â˜ï¸</span>
                                                    <span className="max-w-[100px] truncate">{driveUserEmail || 'Connected'}</span>
                                                </div>
                                                <button
                                                    onClick={async () => {
                                                        if (typeof DriveSync !== 'undefined') {
                                                            try {
                                                                await DriveSync.signIn();
                                                                setDriveSignedIn(DriveSync.isSignedIn());
                                                                setDriveUserEmail(DriveSync.getUserEmail());
                                                                alert('âœ… Connection refreshed!');
                                                            } catch (err) {
                                                                console.error('Refresh failed:', err);
                                                                alert('âŒ Refresh failed. Try signing out and back in.');
                                                            }
                                                        }
                                                    }}
                                                    className="text-white/60 hover:text-white text-xs px-1"
                                                    title="Refresh Google connection"
                                                >ðŸ”„</button>
                                                <button
                                                    onClick={async () => {
                                                        if (typeof DriveSync !== 'undefined') {
                                                            DriveSync.signOut();
                                                            setDriveSignedIn(false);
                                                            setDriveUserEmail(null);
                                                        }
                                                    }}
                                                    className="text-white/60 hover:text-white text-xs"
                                                    title="Sign out of Google Drive"
                                                >âœ•</button>
                                            </div>
                                        ) : (
                                            <button
                                                onClick={async () => {
                                                    if (typeof DriveSync !== 'undefined') {
                                                        try {
                                                            await DriveSync.signIn();
                                                            setDriveSignedIn(DriveSync.isSignedIn());
                                                            setDriveUserEmail(DriveSync.getUserEmail());
                                                        } catch (err) {
                                                            console.error('Drive sign-in failed:', err);
                                                            alert('âŒ Google Drive sign-in failed. Please try again.');
                                                        }
                                                    } else {
                                                        alert('âŒ Drive sync not available');
                                                    }
                                                }}
                                                className="px-2 py-1 bg-blue-500 hover:bg-blue-600 rounded-full text-xs font-medium"
                                                title="Sign in to enable cloud sync"
                                            >
                                                â˜ï¸ Sign in
                                            </button>
                                        )}
                                        
                                        {/* Help Button - far right */}
                                        <button
                                            onClick={() => setShowQuickStart(true)}
                                            className="px-2 py-1 bg-white/20 hover:bg-white/30 rounded-lg text-xs font-medium"
                                            title="Quick Start Guide"
                                        >
                                            â“ Help
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </header>
                    
                    {/* Chart Loading Banner - Shows when chart is loading */}
                    {chartStatus !== 'loaded' && (
                        <div className="bg-amber-400 border-b-4 border-amber-600 px-4 py-4 flex items-center justify-center gap-4 animate-pulse">
                            <div className="animate-spin w-6 h-6 border-3 border-amber-800 border-t-transparent rounded-full"></div>
                            <span className="text-base text-amber-900 font-bold">
                                â³ Loading Glyph Chart {chartLoadProgress.total > 0 ? `(${chartLoadProgress.loaded}/${chartLoadProgress.total})` : '...'}
                            </span>
                            <span className="text-sm text-amber-800 font-medium bg-amber-200 px-2 py-1 rounded">
                                Please wait â€” buttons disabled
                            </span>
                        </div>
                    )}
                    
                    {/* Read-Only Banner - Shows when viewing without edit access */}
                    {isReadOnly && recognitionResults.length > 0 && (
                        <div className="bg-amber-50 border-b-2 border-amber-200 px-4 py-2 flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <span className="text-amber-600">ðŸ‘ï¸</span>
                                <span className="text-sm text-amber-800">
                                    You are viewing this inscription in read-only mode
                                </span>
                            </div>
                            <button
                                onClick={() => setShowUnlockModal(true)}
                                className="px-3 py-1 bg-amber-100 hover:bg-amber-200 text-amber-700 rounded text-sm font-medium"
                            >
                                ðŸ”“ Unlock Editing
                            </button>
                        </div>
                    )}
                    
                    {/* Mobile Navigation Bar - Only visible on small screens */}
                    <div className="lg:hidden flex items-center justify-between px-4 py-2 bg-white border-b shadow-sm gap-2">
                        <button 
                            onClick={() => setMobilePanel(mobilePanel === 'preprocessing' ? null : 'preprocessing')}
                            className={`flex-1 px-3 py-2 rounded-lg text-sm font-medium ${mobilePanel === 'preprocessing' ? 'bg-ancient-purple text-white' : 'bg-gray-100'}`}
                        >
                            â˜° Preprocess
                        </button>
                        <button 
                            onClick={startNewInscription}
                            className="px-2 py-2 bg-rust text-white rounded-lg text-sm font-medium"
                            title="Start new inscription"
                        >
                            ðŸ†•
                        </button>
                        <button 
                            onClick={() => fileInputRef.current?.click()} 
                            disabled={isImageLoading}
                            className="px-3 py-2 bg-ancient-purple text-white rounded-lg text-sm font-medium"
                        >
                            {originalImage ? 'ðŸ”„' : 'ðŸ“¤'} Image
                        </button>
                        <button 
                            onClick={() => setMobilePanel(mobilePanel === 'detections' ? null : 'detections')}
                            className={`flex-1 px-3 py-2 rounded-lg text-sm font-medium ${mobilePanel === 'detections' ? 'bg-patina text-white' : 'bg-gray-100'}`}
                        >
                            Detections {recognitionResults.length > 0 ? `(${recognitionResults.length})` : ''} â˜°
                        </button>
                    </div>
                    
                    {/* Floating Eraser Indicator - Mobile (when panel is closed) */}
                    {eraserMode && !mobilePanel && (
                        <div className="lg:hidden fixed top-20 right-4 z-40 bg-ochre text-white px-4 py-2 rounded-lg shadow-lg">
                            <div className="flex items-center gap-2 mb-1">
                                <span className="text-sm font-medium">ðŸ§¹ Eraser Active ({eraserSize}px)</span>
                                <button 
                                    onClick={() => setMobilePanel('preprocessing')}
                                    className="bg-white/20 hover:bg-white/30 px-2 py-1 rounded text-xs"
                                >
                                    Settings
                                </button>
                            </div>
                            <div id="eraser-debug" className="text-xs font-mono bg-black/30 p-1 rounded mt-1">
                                Canvas: {eraserCanvasRef.current ? 'âœ“' : 'âœ—'} | 
                                Drawing: {isDrawingRef.current ? 'âœ“' : 'âœ—'}
                            </div>
                        </div>
                    )}
                    
                    {/* Floating Manual Box Indicator - Mobile (when panel is closed) */}
                    {manualBoxMode && !mobilePanel && (
                        <div className="lg:hidden fixed top-20 right-4 z-40 bg-amber-500 text-white px-4 py-2 rounded-lg shadow-lg">
                            <div className="flex items-center gap-2">
                                <span className="text-sm font-medium">âž• Manual Box Mode</span>
                                <button 
                                    onClick={() => setManualBoxMode(false)}
                                    className="bg-white/20 hover:bg-white/30 px-2 py-1 rounded text-xs"
                                >
                                    Exit
                                </button>
                            </div>
                            <p className="text-xs mt-1 opacity-80">Draw a box around a glyph</p>
                        </div>
                    )}
                    
                    {/* Mobile Slide-out Panels */}
                    {/* Preprocessing Panel - Mobile */}
                    {mobilePanel === 'preprocessing' && (
                        <div className="lg:hidden fixed inset-0 z-50 flex">
                            <div className="w-80 max-w-[85vw] bg-white shadow-xl overflow-y-auto">
                                <div className="p-3 bg-ancient-purple text-white flex justify-between items-center">
                                    <span className="font-semibold">âš™ï¸ Preprocessing</span>
                                    <button onClick={() => setMobilePanel(null)} className="text-xl px-2">âœ•</button>
                                </div>
                                <div className="p-3 space-y-3">
                                    {/* Image Upload */}
                                    <div className="bg-gray-50 rounded-lg p-3">
                                        <h3 className="font-bold text-gray-700 mb-2 text-sm">ðŸ“· Image</h3>
                                        <div className="flex gap-2">
                                            <button 
                                                onClick={startNewInscription}
                                                className="px-3 py-2 bg-rust text-white rounded-lg text-sm font-medium"
                                                title="Start new inscription (clears all data)"
                                            >
                                                ðŸ†•
                                            </button>
                                            <button onClick={() => { fileInputRef.current?.click(); setMobilePanel(null); }} disabled={isImageLoading}
                                                className="flex-1 px-3 py-2 bg-ancient-purple text-white rounded-lg text-sm font-medium disabled:bg-gray-300">
                                                {isImageLoading ? 'â³ Loading...' : (originalImage ? 'ðŸ”„ Change Image' : 'ðŸ“¤ Upload Image')}
                                            </button>
                                            <button 
                                                onClick={() => { document.getElementById('hkiFileInput')?.click(); setMobilePanel(null); }}
                                                className="px-3 py-2 bg-gray-500 text-white rounded-lg text-sm font-medium"
                                                title="Load saved inscription (.hki file)"
                                            >
                                                ðŸ“‚
                                            </button>
                                        </div>
                                    </div>
                                    
                                    {/* Preprocessing Controls */}
                                    {originalImage && (
                                        <div className="bg-gray-50 rounded-lg p-3 space-y-3">
                                            <h3 className="font-bold text-gray-700 text-sm">ðŸŽ¨ Adjustments</h3>
                                            <div>
                                                <label className="text-xs text-gray-600">Rotation: {preprocessing.rotation}Â°</label>
                                                <input type="range" min="-180" max="180" value={preprocessing.rotation} 
                                                    onChange={e => setPreprocessing(p => ({ ...p, rotation: Number(e.target.value) }))}
                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" />
                                            </div>
                                            <div>
                                                <label className="text-xs text-gray-600">Blur: {preprocessing.gaussianBlur}</label>
                                                <input type="range" min="0" max="10" value={preprocessing.gaussianBlur} 
                                                    onChange={e => setPreprocessing(p => ({ ...p, gaussianBlur: Number(e.target.value) }))}
                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" />
                                            </div>
                                            <div className="flex items-center justify-between">
                                                <span className="text-xs text-gray-600">Adaptive Threshold</span>
                                                <button onClick={() => setPreprocessing(p => ({ ...p, useAdaptiveThreshold: !p.useAdaptiveThreshold }))}
                                                    className={`w-10 h-5 rounded-full transition-colors ${preprocessing.useAdaptiveThreshold ? 'bg-patina' : 'bg-gray-300'}`}>
                                                    <div className={`w-4 h-4 bg-white rounded-full shadow transition-transform ${preprocessing.useAdaptiveThreshold ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                </button>
                                            </div>
                                            {preprocessing.useAdaptiveThreshold && (
                                                <>
                                                    <div>
                                                        <div className="flex justify-between text-xs text-gray-500 mb-1">
                                                            <span>Block Size</span><span>{preprocessing.blockSize}</span>
                                                        </div>
                                                        <input type="range" min="3" max="51" step="2" value={preprocessing.blockSize}
                                                            onChange={(e) => setPreprocessing(p => ({ ...p, blockSize: parseInt(e.target.value) }))}
                                                            className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" />
                                                    </div>
                                                    <div>
                                                        <div className="flex justify-between text-xs text-gray-500 mb-1">
                                                            <span>Offset</span><span>{preprocessing.constantOffset}</span>
                                                        </div>
                                                        <input type="range" min="-20" max="20" value={preprocessing.constantOffset}
                                                            onChange={(e) => setPreprocessing(p => ({ ...p, constantOffset: parseInt(e.target.value) }))}
                                                            className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" />
                                                    </div>
                                                </>
                                            )}
                                            <div>
                                                <span className="text-xs text-gray-600 block mb-1">Morphology</span>
                                                <select value={preprocessing.morphologyOperation}
                                                    onChange={(e) => setPreprocessing(p => ({ ...p, morphologyOperation: e.target.value }))}
                                                    className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm">
                                                    <option value="none">None</option>
                                                    <option value="erode">Erode</option>
                                                    <option value="dilate">Dilate</option>
                                                    <option value="open">Open</option>
                                                    <option value="close">Close</option>
                                                </select>
                                            </div>
                                            <div className="flex items-center justify-between">
                                                <span className="text-xs text-gray-600">Invert</span>
                                                <button onClick={() => setPreprocessing(p => ({ ...p, invertColors: !p.invertColors }))}
                                                    className={`w-10 h-5 rounded-full transition-colors ${preprocessing.invertColors ? 'bg-patina' : 'bg-gray-300'}`}>
                                                    <div className={`w-4 h-4 bg-white rounded-full shadow transition-transform ${preprocessing.invertColors ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                </button>
                                            </div>
                                            
                                            {/* Crop */}
                                            <div className="border-t border-gray-200 pt-3">
                                                <div className="flex items-center justify-between">
                                                    <span className="text-xs text-gray-600 font-semibold">âœ‚ï¸ Crop Image</span>
                                                    <button onClick={() => {
                                                        setCropMode(!cropMode);
                                                        if (!cropMode) setEraserMode(false); // Disable eraser when enabling crop
                                                    }}
                                                        className={`w-10 h-5 rounded-full transition-colors ${cropMode ? 'bg-stone' : 'bg-gray-300'}`}>
                                                        <div className={`w-4 h-4 bg-white rounded-full shadow transition-transform ${cropMode ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                    </button>
                                                </div>
                                                {cropMode && (
                                                    <div className="space-y-2 mt-2">
                                                        <button onClick={() => setMobilePanel(null)}
                                                            className="w-full px-3 py-2 bg-stone text-white rounded font-medium text-sm">
                                                            âœ‚ï¸ Hide Panel &amp; Select Area
                                                        </button>
                                                        <div className="text-xs text-gray-400">
                                                            Click and drag on image to select crop area. Image will crop automatically when you release.
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    )}
                                    
                                    {/* Eraser Tool - Mobile */}
                                    {originalImage && (
                                        <div className="bg-gray-50 rounded-lg p-3 space-y-3">
                                            <div className="flex items-center justify-between">
                                                <span className="text-xs text-gray-600 font-semibold">ðŸ§¹ Eraser</span>
                                                <button onClick={() => {
                                                    setEraserMode(!eraserMode);
                                                    if (!eraserMode) setCropMode(false); // Disable crop when enabling eraser
                                                }}
                                                    className={`w-10 h-5 rounded-full transition-colors ${eraserMode ? 'bg-ochre' : 'bg-gray-300'}`}>
                                                    <div className={`w-4 h-4 bg-white rounded-full shadow transition-transform ${eraserMode ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                </button>
                                            </div>
                                            {eraserMode && (
                                                <div className="space-y-3">
                                                    <div>
                                                        <div className="flex justify-between text-xs text-gray-500 mb-1">
                                                            <span>Brush Size</span><span>{eraserSize}px</span>
                                                        </div>
                                                        <input type="range" min="5" max="50" value={eraserSize}
                                                            onChange={(e) => setEraserSize(parseInt(e.target.value))}
                                                            className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" />
                                                    </div>
                                                    <button onClick={() => setMobilePanel(null)}
                                                        className="w-full px-3 py-2 bg-ochre text-white rounded font-medium text-sm">
                                                        âœï¸ Hide Panel &amp; Draw
                                                    </button>
                                                    <div className="flex gap-2">
                                                        <button onClick={cancelEraser}
                                                            className="flex-1 px-2 py-1.5 bg-gray-200 text-gray-700 rounded text-sm">Cancel</button>
                                                        <button onClick={applyEraser}
                                                            className="flex-1 px-2 py-1.5 bg-patina text-white rounded text-sm">Apply Eraser</button>
                                                    </div>
                                                    <p className="text-xs text-gray-400">Draw on image to erase unwanted marks</p>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                    
                                    {/* Manual Box Tool - Mobile */}
                                    {displayImage && (
                                        <div className="bg-gray-50 rounded-lg p-3 space-y-3">
                                            <div className="flex items-center justify-between">
                                                <span className="text-xs text-gray-600 font-semibold">âž• Manual Box</span>
                                                <button onClick={() => {
                                                    setManualBoxMode(!manualBoxMode);
                                                    if (!manualBoxMode) {
                                                        setEraserMode(false); // Disable eraser when enabling manual box
                                                        setCropMode(false); // Disable crop
                                                    }
                                                }}
                                                    className={`w-10 h-5 rounded-full transition-colors ${manualBoxMode ? 'bg-amber-500' : 'bg-gray-300'}`}>
                                                    <div className={`w-4 h-4 bg-white rounded-full shadow transition-transform ${manualBoxMode ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                </button>
                                            </div>
                                            {manualBoxMode && (
                                                <div className="space-y-3">
                                                    <button onClick={() => setMobilePanel(null)}
                                                        className="w-full px-3 py-2 bg-amber-500 text-white rounded font-medium text-sm">
                                                        âœï¸ Hide Panel &amp; Draw Box
                                                    </button>
                                                    <button onClick={() => setManualBoxMode(false)}
                                                        className="w-full px-2 py-1.5 bg-gray-200 text-gray-700 rounded text-sm">
                                                        âœ‹ Exit Manual Mode
                                                    </button>
                                                    <p className="text-xs text-gray-400">Draw a box around a glyph the recognizer missed</p>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                    
                                    {/* Apply/Reset Buttons - Mobile */}
                                    {originalImage && (
                                        <div className="bg-gray-50 rounded-lg p-3">
                                            <div className="flex gap-2">
                                                <button onClick={resetPreprocessing} className="flex-1 px-2 py-1.5 bg-gray-200 rounded text-sm">â†©ï¸ Reset</button>
                                                <button onClick={applyPreprocessing} className="flex-1 px-2 py-1.5 bg-patina text-white rounded text-sm">âœ… Apply</button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                            <div className="flex-1 bg-black/50" onClick={() => setMobilePanel(null)} />
                        </div>
                    )}
                    
                    {/* Detections Panel - Mobile */}
                    {mobilePanel === 'detections' && (
                        <div className="lg:hidden fixed inset-0 z-50 flex flex-row-reverse">
                            <div className="w-80 max-w-[85vw] bg-white shadow-xl overflow-y-auto flex flex-col">
                                <div className="p-3 bg-patina text-white flex justify-between items-center">
                                    <span className="font-semibold">
                                        ðŸ” Detections ({recognitionResults.filter(r => Math.round(r.confidence * 100) >= confidenceThreshold).length}
                                        {confidenceThreshold > 0 ? `/${recognitionResults.length}` : ''})
                                    </span>
                                    <button onClick={() => setMobilePanel(null)} className="text-xl px-2">âœ•</button>
                                </div>
                                <div className="p-3 space-y-2 flex-1 overflow-y-auto">
                                    {/* Recognize button */}
                                    <button onClick={() => { recognizeGlyphs(); }} disabled={isProcessing || chartStatus !== 'loaded' || !displayImage}
                                        className="w-full px-3 py-2.5 bg-patina text-white rounded-lg text-sm font-medium disabled:bg-gray-300"
                                        title={chartStatus !== 'loaded' ? 'Waiting for chart to load...' : ''}>
                                        {isProcessing ? `â³ ${processingStatus || 'Processing...'}` : chartStatus !== 'loaded' ? 'â³ Loading chart...' : 'ðŸ” Recognize Glyphs'}
                                    </button>
                                    
                                    {/* Multi-selection actions */}
                                    {selectedRegions.size > 0 && (
                                        <div className="bg-ochre/10 rounded p-2 border border-ochre/30">
                                            <div className="text-xs text-gray-600 mb-1.5 font-medium">
                                                {selectedRegions.size} selected
                                            </div>
                                            <div className="flex gap-1 flex-wrap">
                                                {selectedRegions.size === 2 && (
                                                    <button onClick={mergeSelectedDetections}
                                                        className="px-2 py-1 bg-ochre text-white rounded text-xs">
                                                        ðŸ”— Merge
                                                    </button>
                                                )}
                                                <button 
                                                    onClick={() => {
                                                        const indices = Array.from(selectedRegions);
                                                        const glyphIds = new Set(indices.map(i => recognitionResults[i]?.glyph?.id));
                                                        if (glyphIds.size > 1) {
                                                            alert('Selected detections are for different glyphs.');
                                                            return;
                                                        }
                                                        if (confirm(`Save ${indices.length} as VARIANTS?`)) {
                                                            indices.forEach(idx => saveAsTemplate(idx, 'variant'));
                                                            setSelectedRegions(new Set());
                                                        }
                                                    }}
                                                    className="px-2 py-1 bg-patina text-white rounded text-xs"
                                                >
                                                    â­ Variants
                                                </button>
                                                <button 
                                                    onClick={() => {
                                                        const indices = Array.from(selectedRegions);
                                                        const glyphIds = new Set(indices.map(i => recognitionResults[i]?.glyph?.id));
                                                        if (glyphIds.size > 1) {
                                                            alert('Selected detections are for different glyphs.');
                                                            return;
                                                        }
                                                        if (confirm(`Save ${indices.length} as EXAMPLES?`)) {
                                                            indices.forEach(idx => saveAsTemplate(idx, 'example'));
                                                            setSelectedRegions(new Set());
                                                        }
                                                    }}
                                                    className="px-2 py-1 bg-ochre text-white rounded text-xs"
                                                >
                                                    ðŸ“š Examples
                                                </button>
                                                <button onClick={() => setSelectedRegions(new Set())}
                                                    className="ml-auto px-2 py-1 bg-gray-200 text-gray-700 rounded text-xs">
                                                    Clear
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                    
                                    {/* Top controls - Arabic toggle and Clear all */}
                                    {recognitionResults.length > 0 && (
                                        <>
                                            <div className="flex gap-2">
                                                <button onClick={() => setShowArabicLabels(!showArabicLabels)}
                                                    className={`flex-1 px-3 py-2 rounded text-sm font-medium ${showArabicLabels ? 'bg-ancient-purple text-white' : 'bg-gray-100 text-gray-700'}`}>
                                                    {showArabicLabels ? 'Ø¹Ø±Ø¨ÙŠ' : 'ABC'}
                                                </button>
                                                <button onClick={() => { if(confirm('Clear all detections?')) { setRecognitionResults([]); setValidations({}); setReadingOrder([]); setExcludedDetections(new Set()); setExpandedCards(new Set()); }}}
                                                    className="px-3 py-2 bg-red-100 text-red-600 rounded text-sm hover:bg-red-200" title="Clear all detections">
                                                    ðŸ—‘ Clear
                                                </button>
                                            </div>
                                            
                                            {/* Confidence Filter */}
                                            <div className="bg-gray-50 rounded p-2 border border-gray-200">
                                                <div className="flex items-center justify-between mb-1">
                                                    <span className="text-xs text-gray-600">ðŸŽ¯ Confidence Filter</span>
                                                    <span className={`text-xs font-medium ${confidenceThreshold > 0 ? 'text-ancient-purple' : 'text-gray-400'}`}>
                                                        {confidenceThreshold > 0 ? `â‰¥${confidenceThreshold}%` : 'Show All'}
                                                    </span>
                                                </div>
                                                <input 
                                                    type="range" 
                                                    min="0" 
                                                    max="99" 
                                                    value={confidenceThreshold}
                                                    onChange={(e) => setConfidenceThreshold(parseInt(e.target.value))}
                                                    className="w-full h-1.5 accent-ancient-purple"
                                                />
                                            </div>
                                        </>
                                    )}
                                    
                                    {/* Detection/Reading toggle */}
                                    {recognitionResults.length > 0 && (
                                        <div className="flex gap-1 bg-gray-100 p-1 rounded">
                                            <button onClick={() => setViewMode('detection')}
                                                className={`flex-1 px-2 py-1 rounded text-xs ${viewMode === 'detection' ? 'bg-ancient-purple text-white' : ''}`}>ðŸ” Detection</button>
                                            <button onClick={() => setViewMode('reading')}
                                                className={`flex-1 px-2 py-1 rounded text-xs ${viewMode === 'reading' ? 'bg-ancient-purple text-white' : ''}`}>ðŸ“– Reading</button>
                                        </div>
                                    )}
                                    
                                    {/* Reading mode sort controls - mobile */}
                                    {viewMode === 'reading' && recognitionResults.length > 0 && (
                                        <div className="flex gap-1 flex-wrap">
                                            <select 
                                                value={readingDirection}
                                                onChange={(e) => setReadingDirection(e.target.value)}
                                                className="text-xs px-2 py-1 rounded border border-gray-300 bg-white flex-1"
                                            >
                                                <option value="rtl">RTL</option>
                                                <option value="ltr">LTR</option>
                                                <option value="ttb-rtl">TTB-RTL</option>
                                                <option value="ttb-ltr">TTB-LTR</option>
                                                <option value="boustrophedon">Boustrophedon</option>
                                            </select>
                                            <button 
                                                onClick={() => {
                                                    if (typeof ReadingOrder !== 'undefined' && ReadingOrder.generateOrder) {
                                                        pushUndo('readingOrder', [...readingOrder]);
                                                        const newOrder = ReadingOrder.generateOrder(recognitionResults, readingDirection);
                                                        setReadingOrder(newOrder);
                                                    }
                                                }}
                                                className="px-2 py-1 bg-ancient-purple text-white rounded text-xs"
                                            >
                                                ðŸ”„ Sort
                                            </button>
                                            <button 
                                                onClick={() => {
                                                    pushUndo('readingOrder', [...readingOrder]);
                                                    setReadingOrder([...readingOrder].reverse());
                                                }}
                                                className="px-2 py-1 bg-gray-200 text-gray-700 rounded text-xs"
                                            >
                                                â‡…
                                            </button>
                                        </div>
                                    )}
                                    
                                    {/* Detection cards - enhanced for mobile */}
                                    {recognitionResults.length === 0 ? (
                                        <div className="text-center text-gray-400 py-8">
                                            <span className="text-3xl">ðŸ”</span>
                                            <p className="text-sm mt-2">Run recognition to detect glyphs</p>
                                        </div>
                                    ) : (
                                        <div className="space-y-2">
                                            {(viewMode === 'reading' 
                                                ? readingOrder.filter(i => !excludedDetections.has(i) && Math.round(recognitionResults[i]?.confidence * 100) >= confidenceThreshold)
                                                : recognitionResults.map((_, i) => i).filter(i => Math.round(recognitionResults[i]?.confidence * 100) >= confidenceThreshold)
                                            ).map((idx, displayIdx) => {
                                                const result = recognitionResults[idx];
                                                if (!result || displayIdx < 0) return null;
                                                const validation = validations[idx];
                                                const isExpanded = expandedCards.has(idx);
                                                
                                                return (
                                                    <DetectionCard
                                                        key={`m-card-${idx}-${result.position.x}-${result.position.y}`}
                                                        result={result}
                                                        idx={idx}
                                                        displayIdx={displayIdx}
                                                        validation={validation}
                                                        isExpanded={isExpanded}
                                                        viewMode={viewMode}
                                                        showArabicLabels={showArabicLabels}
                                                        isMobile={true}
                                                        selectedRegions={selectedRegions}
                                                        excludedDetections={excludedDetections}
                                                        wordBoundaries={wordBoundaries}
                                                        columnBreaks={columnBreaks}
                                                        lineBreaks={lineBreaks}
                                                        glyphThumbnails={glyphThumbnails}
                                                        setSelectedRegions={setSelectedRegions}
                                                        validateDetection={validateDetection}
                                                        toggleExcludeDetection={toggleExcludeDetection}
                                                        toggleCardExpansion={toggleCardExpansion}
                                                        deleteDetection={deleteDetection}
                                                        changeGlyphAssignment={changeGlyphAssignment}
                                                        toggleWordBoundary={toggleWordBoundary}
                                                        toggleColumnBreak={toggleColumnBreak}
                                                        toggleLineBreak={toggleLineBreak}
                                                        openGlyphSelector={(detectionIdx) => {
                                                            setShowGlyphSelector({ 
                                                                mode: 'relabel', 
                                                                detectionIndex: detectionIdx 
                                                            });
                                                            setGlyphSelectorSearch('');
                                                        }}
                                                        addToChart={(detectionIdx) => {
                                                            // Open chart manager in training mode with this detection
                                                            setShowChartManager(true);
                                                            setTrainingMode(true);
                                                            // TODO: Could pre-select this detection for adding
                                                            console.log('ðŸ“š Add to chart:', detectionIdx);
                                                        }}
                                                    />
                                                );
                                            })}
                                        </div>
                                    )}
                                </div>
                            </div>
                            <div className="flex-1 bg-black/50" onClick={() => setMobilePanel(null)} />
                        </div>
                    )}
                    
                    {/* Main Content */}
                    <main className="flex-1 max-w-7xl w-full mx-auto px-4 py-4 overflow-hidden">
                        {/* Desktop: 3-column grid */}
                        <div className="hidden lg:grid grid-cols-12 gap-4 h-[calc(100vh-140px)]">
                            {/* Left Panel Toggle (shown when panel is hidden) */}
                            {isLeftPanelHidden && (
                                <button 
                                    onClick={() => setIsLeftPanelHidden(false)}
                                    className="fixed left-2 top-24 z-30 bg-ancient-purple text-white p-2 rounded-r-lg shadow-lg hover:bg-[#4a3d5a]"
                                    title="Show preprocessing panel"
                                >
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                                    </svg>
                                </button>
                            )}
                            
                            {/* Left Sidebar - Independent Scroll */}
                            <aside className={`${isLeftPanelHidden ? 'hidden' : 'col-span-3'} overflow-y-auto space-y-3 pr-1`}>
                                {/* Hide panel button */}
                                <button 
                                    onClick={() => setIsLeftPanelHidden(true)}
                                    className="w-full px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-xs text-gray-500 flex items-center justify-center gap-1"
                                    title="Hide preprocessing panel"
                                >
                                    <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                                    </svg>
                                    Hide Panel
                                </button>
                                
                                {/* Image Upload */}
                                <div className="bg-white rounded-lg shadow p-3">
                                    <h3 className="font-bold text-gray-700 mb-2 text-sm">ðŸ“· Image</h3>
                                    <input ref={fileInputRef} type="file" accept="image/*" onChange={handleImageUpload} className="hidden" />
                                    <input 
                                        id="hkiFileInput" 
                                        type="file" 
                                        accept=".hki,.json" 
                                        className="hidden" 
                                        onChange={(e) => {
                                            if (e.target.files[0]) {
                                                const file = e.target.files[0];
                                                const reader = new FileReader();
                                                reader.onload = (event) => {
                                                    try {
                                                        const data = JSON.parse(event.target.result);
                                                        
                                                        // Clear ALL state first (fresh start)
                                                        setRecognitionResults([]);
                                                        setValidations({});
                                                        setReadingOrder([]);
                                                        setReadingDirection('rtl');
                                                        setWordBoundaries(new Set());
                                                        setLineBreaks(new Set());
                                                        setColumnBreaks(new Set());
                                                        setSelectedRegions(new Set());
                                                        setRecognitionSourceDims(null);
                                                        setChangeLog([]);
                                                        setUndoStack([]);
                                                        setRedoStack([]);
                                                        setCurrentInscriptionId(null);
                                                        setInscriptionTitle('');
                                                        setInscriptionNotes('');
                                                        setInscriptionComplete(false);
                                                        setTranslationEnglish('');
                                                        setTranslationArabic('');
                                                        setCurrentFileId(null);
                                                        setFileOwner(null);
                                                        setIsReadOnly(false);
                                                        setPreprocessing({ rotation: 0, gaussianBlur: 0, useAdaptiveThreshold: false, blockSize: 11, constantOffset: 2, morphologyOperation: 'none', invertColors: false });
                                                        setLocalSaveTime(null);
                                                        setCanvasZoom(1);
                                                        
                                                        // Now restore state from HKI file
                                                        if (data.image) setOriginalImage(data.image);
                                                        if (data.displayImage) setDisplayImage(data.displayImage);
                                                        if (data.preprocessing) setPreprocessing(data.preprocessing);
                                                        if (data.recognitionResults) setRecognitionResults(data.recognitionResults);
                                                        if (data.recognitionSourceDims) setRecognitionSourceDims(data.recognitionSourceDims);
                                                        if (data.validations) setValidations(data.validations);
                                                        if (data.changeLog) setChangeLog(data.changeLog);
                                                        if (data.readingOrder) setReadingOrder(data.readingOrder);
                                                        if (data.readingDirection) setReadingDirection(data.readingDirection);
                                                        if (data.wordBoundaries) setWordBoundaries(new Set(data.wordBoundaries));
                                                        if (data.lineBreaks) setLineBreaks(new Set(data.lineBreaks));
                                                        if (data.columnBreaks) setColumnBreaks(new Set(data.columnBreaks));
                                                        if (data.translationEnglish) setTranslationEnglish(data.translationEnglish);
                                                        if (data.translationArabic) setTranslationArabic(data.translationArabic);
                                                        if (data.inscriptionTitle) setInscriptionTitle(data.inscriptionTitle);
                                                        if (data.inscriptionNotes) setInscriptionNotes(data.inscriptionNotes);
                                                        if (data.inscriptionComplete) setInscriptionComplete(data.inscriptionComplete);
                                                        if (data.currentInscriptionId) setCurrentInscriptionId(data.currentInscriptionId);
                                                        if (data.visibility) setVisibility(data.visibility);
                                                        if (data.audioData) setAudioData(data.audioData); // Load audio recording
                                                        
                                                        console.log('ðŸ“‚ Loaded HKI:', data.inscriptionTitle || file.name);
                                                        
                                                        // Auto-switch to reading mode if detections exist
                                                        const detectionCount = data.recognitionResults?.length || 0;
                                                        if (detectionCount > 0) {
                                                            setViewMode('reading');
                                                        }
                                                        
                                                        alert('âœ… Loaded: ' + (data.inscriptionTitle || file.name));
                                                    } catch (err) {
                                                        console.error('Error loading HKI:', err);
                                                        alert('âŒ Error loading file: ' + err.message);
                                                    }
                                                };
                                                reader.readAsText(file);
                                                e.target.value = '';
                                            }
                                        }}
                                    />
                                    <div className="flex gap-2">
                                        <button 
                                            onClick={startNewInscription}
                                            className="px-3 py-2 bg-rust text-white rounded-lg hover:bg-rust/80 text-sm font-medium"
                                            title="Start new inscription (clears all data)"
                                        >
                                            ðŸ†• New
                                        </button>
                                        <button onClick={() => fileInputRef.current?.click()} disabled={isImageLoading}
                                            className="flex-1 px-3 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3d5a] text-sm font-medium disabled:bg-gray-300">
                                            {isImageLoading ? 'â³ Loading...' : (originalImage ? 'ðŸ”„ Change Image' : 'ðŸ“¤ Upload Image')}
                                        </button>
                                        <button 
                                            onClick={() => document.getElementById('hkiFileInput')?.click()}
                                            className="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 text-sm font-medium"
                                            title="Load saved inscription (.hki file)"
                                        >
                                            ðŸ“‚
                                        </button>
                                    </div>
                                </div>
                                
                                {/* Preprocessing */}
                                {originalImage && (
                                    <div className="bg-white rounded-lg shadow overflow-hidden">
                                        <div className="px-3 py-2 bg-gray-50 flex items-center justify-between cursor-pointer hover:bg-gray-100"
                                            onClick={() => setIsPreprocessingCollapsed(!isPreprocessingCollapsed)}>
                                            <div className="flex items-center gap-2">
                                                <span className="text-sm">ðŸ”§</span>
                                                <span className="font-semibold text-gray-700 text-sm">Preprocessing</span>
                                                {preprocessing.useAdaptiveThreshold && <span className="px-1.5 py-0.5 bg-ancient-purple text-white text-xs rounded">Active</span>}
                                            </div>
                                            <svg className={`w-4 h-4 transition-transform ${isPreprocessingCollapsed ? '' : 'rotate-180'}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                            </svg>
                                        </div>
                                        
                                        {!isPreprocessingCollapsed && (
                                            <div className="p-3 space-y-3 text-sm">
                                                {/* Rotation */}
                                                <div>
                                                    <div className="flex justify-between text-gray-600 mb-1"><span>ðŸ”„ Rotation</span><span>{preprocessing.rotation}Â°</span></div>
                                                    <input type="range" min="-180" max="180" value={preprocessing.rotation}
                                                        onChange={(e) => setPreprocessing(p => ({ ...p, rotation: parseInt(e.target.value) }))} className="w-full" />
                                                </div>
                                                
                                                {/* Blur */}
                                                <div>
                                                    <div className="flex justify-between text-gray-600 mb-1"><span>ðŸŒ«ï¸ Blur</span><span>{preprocessing.gaussianBlur}</span></div>
                                                    <input type="range" min="0" max="15" step="2" value={preprocessing.gaussianBlur}
                                                        onChange={(e) => setPreprocessing(p => ({ ...p, gaussianBlur: parseInt(e.target.value) }))} className="w-full" />
                                                </div>
                                                
                                                {/* Adaptive Threshold */}
                                                <div className="p-2 bg-gray-50 rounded space-y-2">
                                                    <div className="flex items-center justify-between">
                                                        <span className="text-gray-700">ðŸ“Š Adaptive Threshold</span>
                                                        <button onClick={() => setPreprocessing(p => ({ ...p, useAdaptiveThreshold: !p.useAdaptiveThreshold }))}
                                                            className={`w-10 h-5 rounded-full ${preprocessing.useAdaptiveThreshold ? 'bg-ancient-purple' : 'bg-gray-300'}`}>
                                                            <div className={`w-4 h-4 bg-white rounded-full shadow transform ${preprocessing.useAdaptiveThreshold ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                        </button>
                                                    </div>
                                                    {preprocessing.useAdaptiveThreshold && (
                                                        <>
                                                            <div>
                                                                <div className="flex justify-between text-xs text-gray-500 mb-1"><span>Block Size</span><span>{preprocessing.blockSize}</span></div>
                                                                <input type="range" min="3" max="51" step="2" value={preprocessing.blockSize}
                                                                    onChange={(e) => setPreprocessing(p => ({ ...p, blockSize: parseInt(e.target.value) }))} className="w-full" />
                                                            </div>
                                                            <div>
                                                                <div className="flex justify-between text-xs text-gray-500 mb-1"><span>Offset</span><span>{preprocessing.constantOffset}</span></div>
                                                                <input type="range" min="-20" max="20" value={preprocessing.constantOffset}
                                                                    onChange={(e) => setPreprocessing(p => ({ ...p, constantOffset: parseInt(e.target.value) }))} className="w-full" />
                                                            </div>
                                                        </>
                                                    )}
                                                </div>
                                                
                                                {/* Morphology */}
                                                <div>
                                                    <span className="text-gray-600 block mb-1">ðŸ”² Morphology</span>
                                                    <select value={preprocessing.morphologyOperation}
                                                        onChange={(e) => setPreprocessing(p => ({ ...p, morphologyOperation: e.target.value }))}
                                                        className="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                                                        <option value="none">None</option>
                                                        <option value="erode">Erode</option>
                                                        <option value="dilate">Dilate</option>
                                                        <option value="open">Open</option>
                                                        <option value="close">Close</option>
                                                    </select>
                                                </div>
                                                
                                                {/* Invert */}
                                                <div className="flex items-center justify-between">
                                                    <span className="text-gray-700">ðŸ”„ Invert</span>
                                                    <button onClick={() => setPreprocessing(p => ({ ...p, invertColors: !p.invertColors }))}
                                                        className={`w-10 h-5 rounded-full ${preprocessing.invertColors ? 'bg-ancient-purple' : 'bg-gray-300'}`}>
                                                        <div className={`w-4 h-4 bg-white rounded-full shadow transform ${preprocessing.invertColors ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                    </button>
                                                </div>
                                                
                                                {/* Crop */}
                                                <div className="pt-2 border-t border-gray-200">
                                                    <div className="flex items-center justify-between">
                                                        <span className="text-gray-700">âœ‚ï¸ Crop Image</span>
                                                        <button onClick={() => {
                                                            setCropMode(!cropMode);
                                                            if (!cropMode) setEraserMode(false); // Disable eraser when enabling crop
                                                        }}
                                                            className={`w-10 h-5 rounded-full ${cropMode ? 'bg-stone' : 'bg-gray-300'}`}>
                                                            <div className={`w-4 h-4 bg-white rounded-full shadow transform ${cropMode ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                        </button>
                                                    </div>
                                                    {cropMode && (
                                                        <div className="text-xs text-gray-500 mt-2">
                                                            Click and drag on image to select crop area. Image will crop automatically when you release.
                                                        </div>
                                                    )}
                                                </div>
                                                
                                                {/* Eraser Tool */}
                                                <div className="pt-2 border-t border-gray-200">
                                                    <div className="flex items-center justify-between mb-2">
                                                        <span className="text-gray-700">ðŸ§¹ Eraser</span>
                                                        <button onClick={() => {
                                                            setEraserMode(!eraserMode);
                                                            if (!eraserMode) setCropMode(false); // Disable crop when enabling eraser
                                                        }}
                                                            className={`w-10 h-5 rounded-full ${eraserMode ? 'bg-ochre' : 'bg-gray-300'}`}>
                                                            <div className={`w-4 h-4 bg-white rounded-full shadow transform ${eraserMode ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                        </button>
                                                    </div>
                                                    {eraserMode && (
                                                        <div className="space-y-2">
                                                            <div>
                                                                <div className="flex justify-between text-xs text-gray-500 mb-1">
                                                                    <span>Brush Size</span><span>{eraserSize}px</span>
                                                                </div>
                                                                <input type="range" min="5" max="50" value={eraserSize}
                                                                    onChange={(e) => setEraserSize(parseInt(e.target.value))} className="w-full" />
                                                            </div>
                                                            <div className="flex gap-2">
                                                                <button onClick={cancelEraser}
                                                                    className="flex-1 px-2 py-1 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded text-xs">Cancel</button>
                                                                <button onClick={applyEraser}
                                                                    className="flex-1 px-2 py-1 bg-patina hover:bg-[#5a7d6e] text-white rounded text-xs">Apply Eraser</button>
                                                            </div>
                                                            <p className="text-xs text-gray-400">Draw on image to erase unwanted marks</p>
                                                        </div>
                                                    )}
                                                </div>
                                                
                                                {/* Buttons */}
                                                <div className="flex gap-2 pt-2">
                                                    <button onClick={resetPreprocessing} 
                                                        className="flex-1 px-2 py-1.5 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded text-sm border border-gray-300">
                                                        â†©ï¸ Reset
                                                    </button>
                                                    <button onClick={applyPreprocessing} disabled={!opencvReady}
                                                        className="flex-1 px-2 py-1.5 bg-patina hover:bg-[#5a7d6e] text-white rounded text-sm font-medium disabled:bg-gray-300">
                                                        âœ… Apply
                                                    </button>
                                                </div>
                                                
                                                {/* Confidence Filter */}
                                                <div className="pt-3 border-t border-gray-200 mt-3">
                                                    <div className="flex items-center justify-between mb-2">
                                                        <span className="text-gray-700">ðŸŽ¯ Confidence Filter</span>
                                                        <span className={`text-xs font-medium ${confidenceThreshold > 0 ? 'text-ancient-purple' : 'text-gray-400'}`}>
                                                            {confidenceThreshold > 0 ? `â‰¥${confidenceThreshold}%` : 'Show All'}
                                                        </span>
                                                    </div>
                                                    <input 
                                                        type="range" 
                                                        min="0" 
                                                        max="99" 
                                                        value={confidenceThreshold}
                                                        onChange={(e) => setConfidenceThreshold(parseInt(e.target.value))}
                                                        className="w-full h-1.5 accent-ancient-purple"
                                                    />
                                                    <p className="text-xs text-gray-400 mt-1">Hide low-confidence detections</p>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </aside>
                            
                            {/* Center - Image (Independent Scroll) */}
                            <div className={`${isLeftPanelHidden && isRightPanelHidden ? 'col-span-12' : isLeftPanelHidden || isRightPanelHidden ? 'col-span-9' : 'col-span-6'} overflow-hidden flex flex-col`}>
                                <div className="bg-white rounded-lg shadow p-3 flex-1 flex flex-col min-h-0">
                                    {/* Eraser mode indicator */}
                                    {eraserMode && (
                                        <div className="mb-2 px-2 py-1 bg-ochre/20 border border-ochre rounded text-xs text-center">
                                            ðŸ§¹ Eraser Mode Active - Draw to erase, then click "Apply Eraser"
                                        </div>
                                    )}
                                    
                                    {displayImage ? (
                                        <div ref={imageContainerRef} 
                                            className="relative flex-1 overflow-auto"
                                            style={{ cursor: (manualBoxMode || cropMode) ? 'crosshair' : 'default' }}
                                            onMouseDown={cropMode ? handleCropStart : (manualBoxMode ? handleManualBoxStart : undefined)}
                                            onMouseMove={cropMode ? handleCropMove : (manualBoxMode ? handleManualBoxMove : undefined)}
                                            onMouseUp={cropMode ? handleCropEnd : (manualBoxMode ? handleManualBoxEnd : undefined)}
                                            onMouseLeave={cropMode ? () => setCropSelection(null) : (manualBoxMode ? () => setDrawingBox(null) : undefined)}
                                        >
                                            {/* Floating toolbar row with undo/redo (left) and zoom (right) */}
                                            <div className="sticky top-2 z-20 flex justify-between items-start px-2">
                                                {/* Undo/Redo floating - top left */}
                                                {(undoStack.length > 0 || redoStack.length > 0) && (
                                                    <div className="flex items-center gap-1 bg-white/90 rounded-lg shadow px-2 py-1">
                                                        <button
                                                            onClick={undo}
                                                            disabled={undoStack.length === 0}
                                                            className="w-7 h-7 flex items-center justify-center rounded bg-gray-100 hover:bg-gray-200 disabled:opacity-30 disabled:cursor-not-allowed text-sm"
                                                            title={`Undo (Ctrl+Z)${undoStack.length > 0 ? ` - ${undoStack.length} action${undoStack.length > 1 ? 's' : ''}` : ''}`}
                                                        >
                                                            â†©ï¸
                                                        </button>
                                                        <button
                                                            onClick={redo}
                                                            disabled={redoStack.length === 0}
                                                            className="w-7 h-7 flex items-center justify-center rounded bg-gray-100 hover:bg-gray-200 disabled:opacity-30 disabled:cursor-not-allowed text-sm"
                                                            title={`Redo (Ctrl+Y)${redoStack.length > 0 ? ` - ${redoStack.length} action${redoStack.length > 1 ? 's' : ''}` : ''}`}
                                                        >
                                                            â†ªï¸
                                                        </button>
                                                        {undoStack.length > 0 && (
                                                            <span className="text-xs text-gray-500 ml-1">{undoStack.length}</span>
                                                        )}
                                                    </div>
                                                )}
                                                {(undoStack.length === 0 && redoStack.length === 0) && <div />}
                                                
                                                {/* Zoom controls - top right */}
                                                <div className="flex items-center gap-1 bg-white/90 rounded-lg shadow px-2 py-1">
                                                    <button onClick={() => setCanvasZoom(z => Math.max(0.5, z - 0.25))} 
                                                        className="w-6 h-6 rounded bg-gray-100 hover:bg-gray-200 text-sm font-bold" title="Zoom out">âˆ’</button>
                                                    <span className="text-xs w-12 text-center font-medium">{Math.round(canvasZoom * 100)}%</span>
                                                    <button onClick={() => setCanvasZoom(z => Math.min(3, z + 0.25))} 
                                                        className="w-6 h-6 rounded bg-gray-100 hover:bg-gray-200 text-sm font-bold" title="Zoom in">+</button>
                                                    {canvasZoom !== 1 && (
                                                        <button onClick={() => setCanvasZoom(1)} 
                                                            className="w-6 h-6 rounded bg-gray-200 hover:bg-gray-300 text-xs" title="Reset zoom">âŸ²</button>
                                                    )}
                                                </div>
                                            </div>
                                            
                                            {/* Zoomable content wrapper with padding for labels */}
                                            <div className="flex items-center justify-center min-h-full" style={{ padding: canvasZoom > 1 ? `${(canvasZoom - 1) * 100}px` : '0' }}>
                                                <div className="relative inline-block" style={{ transform: `scale(${canvasZoom})`, transformOrigin: 'center center', transition: 'transform 0.15s ease' }}>
                                                    {/* Regular image display (hidden when eraser active) */}
                                                    <img ref={imageRef} src={displayImage} alt="Inscription" 
                                                        className="max-w-full max-h-full object-contain block"
                                                        style={{ pointerEvents: eraserMode || manualBoxMode ? 'none' : 'auto' }}
                                                    />
                                            
                                            {/* Manual Box Drawing Overlay */}
                                            {manualBoxMode && drawingBox && (() => {
                                                const img = imageRef.current;
                                                const container = imageContainerRef.current;
                                                if (!img || !container) return null;
                                                
                                                // Use offsetLeft/Top for actual image position
                                                const offsetX = img.offsetLeft;
                                                const offsetY = img.offsetTop;
                                                
                                                const left = offsetX + Math.min(drawingBox.startX, drawingBox.currentX);
                                                const top = offsetY + Math.min(drawingBox.startY, drawingBox.currentY);
                                                const width = Math.abs(drawingBox.currentX - drawingBox.startX);
                                                const height = Math.abs(drawingBox.currentY - drawingBox.startY);
                                                
                                                return (
                                                    <div 
                                                        className="absolute border-2 border-dashed border-ochre bg-ochre/20 pointer-events-none"
                                                        style={{ left, top, width, height }}
                                                    />
                                                );
                                            })()}
                                            
                                            {/* Crop Selection Overlay */}
                                            {cropMode && cropSelection && (() => {
                                                const img = imageRef.current;
                                                const container = imageContainerRef.current;
                                                if (!img || !container) return null;
                                                
                                                const offsetX = img.offsetLeft;
                                                const offsetY = img.offsetTop;
                                                
                                                const left = offsetX + Math.min(cropSelection.startX, cropSelection.currentX);
                                                const top = offsetY + Math.min(cropSelection.startY, cropSelection.currentY);
                                                const width = Math.abs(cropSelection.currentX - cropSelection.startX);
                                                const height = Math.abs(cropSelection.currentY - cropSelection.startY);
                                                
                                                return (
                                                    <div 
                                                        className="absolute border-2 border-dashed border-stone bg-stone/20 pointer-events-none"
                                                        style={{ left, top, width, height }}
                                                    />
                                                );
                                            })()}
                                            
                                            {/* Eraser canvas (shown when eraser active) */}
                                            {eraserMode && (() => {
                                                // Cursor radius is slightly smaller to account for stroke width
                                                const cursorRadius = eraserSize - 1;
                                                const cursorSize = cursorRadius * 2 + 2;
                                                return (
                                                    <canvas ref={eraserCanvasRef}
                                                        className="absolute inset-0"
                                                        style={{ 
                                                            cursor: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="${cursorSize}" height="${cursorSize}" viewBox="0 0 ${cursorSize} ${cursorSize}"><circle cx="${cursorRadius + 1}" cy="${cursorRadius + 1}" r="${cursorRadius}" fill="none" stroke="black" stroke-width="1"/><circle cx="${cursorRadius + 1}" cy="${cursorRadius + 1}" r="${cursorRadius}" fill="none" stroke="white" stroke-width="0.5" stroke-dasharray="2,2"/><line x1="${cursorRadius + 1}" y1="${cursorRadius - 3}" x2="${cursorRadius + 1}" y2="${cursorRadius + 5}" stroke="black" stroke-width="1"/><line x1="${cursorRadius - 3}" y1="${cursorRadius + 1}" x2="${cursorRadius + 5}" y2="${cursorRadius + 1}" stroke="black" stroke-width="1"/></svg>') ${cursorRadius + 1} ${cursorRadius + 1}, crosshair`,
                                                            touchAction: 'none',
                                                            pointerEvents: 'auto',
                                                            objectFit: 'contain',
                                                            width: canvasDimensions.width > 0 ? `${canvasDimensions.width}px` : '100%',
                                                            height: canvasDimensions.height > 0 ? `${canvasDimensions.height}px` : '100%'
                                                        }}
                                                        onMouseDown={handleEraserStart}
                                                        onMouseMove={handleEraserDraw}
                                                        onMouseUp={handleEraserEnd}
                                                        onMouseLeave={handleEraserEnd}
                                                        onTouchStart={handleEraserStart}
                                                        onTouchMove={handleEraserDraw}
                                                        onTouchEnd={handleEraserEnd}
                                                    />
                                                );
                                            })()}
                                            
                                            {/* Detection boxes (hidden during eraser mode) */}
                                            {!eraserMode && recognitionResults.map((result, index) => {
                                                // Filter by confidence threshold
                                                if (Math.round(result.confidence * 100) < confidenceThreshold) return null;
                                                
                                                const validation = validations[index];
                                                const isSelected = selectedRegions.has(index);
                                                
                                                let boxClass = 'detection-box unvalidated';
                                                let labelBg = 'bg-stone';
                                                
                                                if (isSelected) { boxClass = 'detection-box selected'; labelBg = 'bg-ochre'; }
                                                else if (validation?.isCorrect) { boxClass = 'detection-box validated-correct'; labelBg = 'bg-patina'; }
                                                else if (validation && !validation.isCorrect) { boxClass = 'detection-box validated-incorrect'; labelBg = 'bg-rust'; }
                                                if (result.confidence < 0.5) boxClass += ' uncertain';
                                                
                                                const img = imageRef.current;
                                                const container = imageContainerRef.current;
                                                if (!img || !container) return null;
                                                
                                                // Force recalculation by using boxLayoutKey (referenced but not directly used)
                                                const _ = boxLayoutKey;
                                                
                                                // Use tracked recognition source dimensions if available
                                                const sourceWidth = recognitionSourceDims?.width || img.naturalWidth;
                                                const sourceHeight = recognitionSourceDims?.height || img.naturalHeight;
                                                
                                                // Use clientWidth/Height for display dimensions (stable, not affected by transforms)
                                                const displayWidth = img.clientWidth;
                                                const displayHeight = img.clientHeight;
                                                
                                                // Skip rendering if dimensions aren't ready
                                                if (!displayWidth || !displayHeight || !sourceWidth || !sourceHeight) return null;
                                                
                                                // Scale calculation
                                                const scaleX = displayWidth / sourceWidth;
                                                const scaleY = displayHeight / sourceHeight;
                                                
                                                // Get image position relative to its offset parent (the zoom wrapper)
                                                // This accounts for any centering/flexbox positioning
                                                const imgOffsetX = img.offsetLeft;
                                                const imgOffsetY = img.offsetTop;
                                                
                                                return (
                                                    <div key={`box-${index}-${result.position.x}-${result.position.y}`} className={boxClass}
                                                        style={{
                                                            left: imgOffsetX + result.position.x * scaleX,
                                                            top: imgOffsetY + result.position.y * scaleY,
                                                            width: result.position.width * scaleX,
                                                            height: result.position.height * scaleY
                                                        }}
                                                        onClick={() => setSelectedRegions(prev => {
                                                            const next = new Set(prev);
                                                            next.has(index) ? next.delete(index) : next.add(index);
                                                            return next;
                                                        })}
                                                        title={`${result.glyph.name} (${Math.round(result.confidence * 100)}%)`}>
                                                        <div className={`detection-label ${labelBg}`}>
                                                            {showArabicLabels ? (result.glyph.arabic || result.glyph.name) : (result.glyph.transliteration || result.glyph.name)}
                                                        </div>
                                                        {viewMode === 'reading' && <div className="reading-order-badge">{readingOrder.indexOf(index) + 1}</div>}
                                                    </div>
                                                );
                                            })}
                                            </div>{/* End zoom wrapper */}
                                            </div>{/* End padding wrapper */}
                                        </div>
                                    ) : (
                                        <div className="flex-1 flex flex-col items-center justify-center text-gray-400">
                                            <span className="text-5xl mb-3">ðŸ“·</span>
                                            <p>Upload an inscription image to begin</p>
                                        </div>
                                    )}
                                </div>
                            </div>
                            
                            {/* Right Panel Toggle (shown when panel is hidden) */}
                            {isRightPanelHidden && (
                                <button 
                                    onClick={() => setIsRightPanelHidden(false)}
                                    className="fixed right-2 top-24 z-30 bg-ancient-purple text-white p-2 rounded-l-lg shadow-lg hover:bg-[#4a3d5a]"
                                    title="Show detection panel"
                                >
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                                    </svg>
                                </button>
                            )}
                            
                            {/* Right Sidebar - Independent Scroll */}
                            <aside className={`${isRightPanelHidden ? 'hidden' : isLeftPanelHidden ? 'col-span-3' : 'col-span-3'} flex flex-col gap-3 overflow-y-auto pl-1`}>
                                {/* Hide panel button */}
                                <button 
                                    onClick={() => setIsRightPanelHidden(true)}
                                    className="w-full px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded text-xs text-gray-500 flex items-center justify-center gap-1"
                                    title="Hide detection panel"
                                >
                                    Hide Panel
                                    <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                                    </svg>
                                </button>
                                
                                {/* Recognition Section - Collapsible */}
                                <div className="bg-white rounded-lg shadow p-3">
                                    <div className="flex gap-2 items-center">
                                        <button onClick={recognizeGlyphs} disabled={isProcessing || chartStatus !== 'loaded' || !displayImage}
                                            className="flex-1 px-3 py-2.5 bg-patina text-white rounded-lg hover:bg-[#5a7d6e] text-sm font-medium disabled:bg-gray-300"
                                            title={chartStatus !== 'loaded' ? 'Waiting for chart to load...' : ''}>
                                            {isProcessing ? `â³ ${processingStatus || 'Processing...'}` : chartStatus !== 'loaded' ? 'â³ Loading chart...' : 'ðŸ” Recognize Glyphs'}
                                        </button>
                                        <button 
                                            onClick={() => setIsToolsCollapsed(!isToolsCollapsed)}
                                            className="px-2 py-2.5 bg-gray-100 rounded-lg hover:bg-gray-200 text-gray-500 text-xs"
                                            title={isToolsCollapsed ? 'Show tools' : 'Hide tools'}
                                        >
                                            {isToolsCollapsed ? 'â–¼' : 'â–²'}
                                        </button>
                                    </div>
                                    
                                    {/* Expanded: Manual Box & Template Training */}
                                    {!isToolsCollapsed && (
                                        <div className="mt-2 pt-2 border-t border-gray-100 space-y-2">
                                            <button 
                                                onClick={() => {
                                                    setManualBoxMode(!manualBoxMode);
                                                    if (eraserMode) setEraserMode(false);
                                                }}
                                                disabled={!displayImage}
                                                className={`w-full px-3 py-1.5 rounded text-sm font-medium transition-colors ${
                                                    manualBoxMode 
                                                        ? 'bg-ochre text-white' 
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                } disabled:bg-gray-100 disabled:text-gray-400`}
                                            >
                                                {manualBoxMode ? 'âœ‹ Exit Manual Mode' : 'âž• Add Manual Box'}
                                            </button>
                                            
                                            {manualBoxMode && (
                                                <div className="p-2 bg-ochre/10 rounded text-xs text-ochre">
                                                    ðŸ–±ï¸ Click and drag on image to draw a box
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                                
                                {/* Detection List */}
                                <div className="bg-white rounded-lg shadow p-3 flex-1 overflow-hidden flex flex-col">
                                    <div className="flex items-center justify-between mb-2">
                                        <h3 className="font-bold text-gray-700 text-sm">
                                            {recognitionResults.length > 0 
                                                ? `ðŸ” ${recognitionResults.filter(r => Math.round(r.confidence * 100) >= confidenceThreshold).length}${confidenceThreshold > 0 ? '/' + recognitionResults.length : ''} Detections` 
                                                : 'ðŸ” No detections yet'}
                                        </h3>
                                        <div className="flex items-center gap-1">
                                            {/* Keyboard shortcuts help */}
                                            <div className="relative group">
                                                <button className="w-5 h-5 rounded-full bg-gray-100 text-gray-500 text-[10px] hover:bg-gray-200" title="Keyboard shortcuts">?</button>
                                                <div className="absolute right-0 top-full mt-1 bg-gray-900 text-white text-[10px] rounded-lg p-2 w-52 z-30 opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity shadow-lg">
                                                    <div className="font-bold mb-1">âŒ¨ï¸ Shortcuts & Selection</div>
                                                    <div className="space-y-0.5">
                                                        <div><span className="bg-gray-700 px-1 rounded">1-9</span> Select detection</div>
                                                        <div><span className="bg-gray-700 px-1 rounded">â†/â†’</span> Navigate</div>
                                                        <div><span className="bg-gray-700 px-1 rounded">Enter</span> Mark correct</div>
                                                        <div><span className="bg-gray-700 px-1 rounded">Esc</span> Close/deselect</div>
                                                        <div><span className="bg-gray-700 px-1 rounded">Shift+Click</span> Range select</div>
                                                        <div><span className="bg-gray-700 px-1 rounded">+/âˆ’/0</span> Zoom in/out/reset</div>
                                                        <div><span className="bg-gray-700 px-1 rounded">[ / ]</span> Toggle panels</div>
                                                        <div><span className="bg-gray-700 px-1 rounded">Ctrl+Z/Y</span> Undo/Redo</div>
                                                        <div className="border-t border-gray-700 mt-1 pt-1">In Training Mode:</div>
                                                        <div><span className="bg-gray-700 px-1 rounded">P/V/E</span> Save as Pri/Var/Ex</div>
                                                    </div>
                                                </div>
                                            </div>
                                            {recognitionResults.length > 0 && (
                                                <button onClick={() => setShowArabicLabels(!showArabicLabels)}
                                                    className={`px-2 py-1 rounded text-xs ${showArabicLabels ? 'bg-ancient-purple text-white' : 'bg-gray-200'}`}>
                                                    {showArabicLabels ? 'Ø¹Ø±Ø¨ÙŠ' : 'ABC'}
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {recognitionResults.length === 0 ? (
                                        <div className="flex-1 flex flex-col items-center justify-center text-gray-400 text-sm">
                                            <span className="text-3xl mb-2">ðŸ”</span>
                                            <p>Run recognition to detect glyphs</p>
                                        </div>
                                    ) : (
                                        <>
                                            <div className="flex gap-1 mb-2">
                                                <button onClick={() => setViewMode('detection')}
                                                    className={`flex-1 px-2 py-1 rounded text-xs ${viewMode === 'detection' ? 'bg-ancient-purple text-white' : 'bg-gray-100'}`}>ðŸ” Detection</button>
                                                <button onClick={() => setViewMode('reading')}
                                                    className={`flex-1 px-2 py-1 rounded text-xs ${viewMode === 'reading' ? 'bg-ancient-purple text-white' : 'bg-gray-100'}`}>ðŸ“– Reading</button>
                                                <button onClick={() => { if(confirm('Clear all detections?')) { setRecognitionResults([]); setValidations({}); setReadingOrder([]); setExcludedDetections(new Set()); setExpandedCards(new Set()); }}}
                                                    className="px-2 py-1 bg-red-100 text-red-600 rounded text-xs hover:bg-red-200" title="Clear all detections">ðŸ—‘</button>
                                            </div>
                                            
                                            {/* Reading mode sorting controls - compact collapsible */}
                                            {viewMode === 'reading' && recognitionResults.length > 0 && (
                                                <div className="mb-2 flex items-center gap-1 text-xs">
                                                    <select 
                                                        value={readingDirection}
                                                        onChange={(e) => setReadingDirection(e.target.value)}
                                                        className="px-1 py-1 rounded border border-gray-300 bg-white text-xs max-w-[90px]"
                                                        title="Reading direction"
                                                    >
                                                        <option value="rtl">â†’ RTL</option>
                                                        <option value="ltr">â† LTR</option>
                                                        <option value="ttb-rtl">â†“ TTB-R</option>
                                                        <option value="ttb-ltr">â†“ TTB-L</option>
                                                        <option value="boustrophedon">â†” Boust</option>
                                                    </select>
                                                    <button 
                                                        onClick={() => {
                                                            if (typeof ReadingOrder !== 'undefined' && ReadingOrder.generateOrder) {
                                                                pushUndo('readingOrder', [...readingOrder]);
                                                                const newOrder = ReadingOrder.generateOrder(recognitionResults, readingDirection);
                                                                setReadingOrder(newOrder);
                                                                console.log(`ðŸ”„ Re-sorted ${newOrder.length} glyphs by position (${readingDirection})`);
                                                            }
                                                        }}
                                                        className="px-2 py-1 bg-ancient-purple text-white rounded text-xs hover:bg-[#4a3d5a]"
                                                        title="Re-sort all glyphs by their position on the image"
                                                    >
                                                        ðŸ”„ Sort
                                                    </button>
                                                    <button 
                                                        onClick={() => {
                                                            pushUndo('readingOrder', [...readingOrder]);
                                                            setReadingOrder([...readingOrder].reverse());
                                                        }}
                                                        className="px-2 py-1 bg-gray-200 text-gray-700 rounded text-xs hover:bg-gray-300"
                                                        title="Reverse the current order"
                                                    >
                                                        â‡…
                                                    </button>
                                                </div>
                                            )}
                                            
                                            {/* Selection actions */}
                                            {selectedRegions.size > 0 && (
                                                <div className="mb-2 p-2 bg-ochre/10 rounded-lg border border-ochre/30">
                                                    <div className="text-xs text-gray-600 mb-1.5 font-medium">
                                                        {selectedRegions.size} selected
                                                    </div>
                                                    <div className="flex gap-1 flex-wrap">
                                                        {selectedRegions.size === 2 && (
                                                            <button onClick={mergeSelectedDetections}
                                                                className="px-2 py-1 bg-ochre text-white rounded text-xs hover:bg-[#a07f5a]">
                                                                ðŸ”— Merge
                                                            </button>
                                                        )}
                                                        <button 
                                                            onClick={() => {
                                                                const indices = Array.from(selectedRegions);
                                                                const glyphIds = new Set(indices.map(i => recognitionResults[i]?.glyph?.id));
                                                                if (glyphIds.size > 1) {
                                                                    alert('Selected detections are for different glyphs. Please select detections of the same glyph for batch save.');
                                                                    return;
                                                                }
                                                                if (confirm(`Save ${indices.length} detection(s) as VARIANTS?`)) {
                                                                    indices.forEach(idx => saveAsTemplate(idx, 'variant'));
                                                                    setSelectedRegions(new Set());
                                                                }
                                                            }}
                                                            className="px-2 py-1 bg-patina text-white rounded text-xs hover:bg-[#5a7d6e]"
                                                            title="Save all selected as variants"
                                                        >
                                                            â­ Save as Variants
                                                        </button>
                                                        <button 
                                                            onClick={() => {
                                                                const indices = Array.from(selectedRegions);
                                                                const glyphIds = new Set(indices.map(i => recognitionResults[i]?.glyph?.id));
                                                                if (glyphIds.size > 1) {
                                                                    alert('Selected detections are for different glyphs. Please select detections of the same glyph for batch save.');
                                                                    return;
                                                                }
                                                                if (confirm(`Save ${indices.length} detection(s) as EXAMPLES?`)) {
                                                                    indices.forEach(idx => saveAsTemplate(idx, 'example'));
                                                                    setSelectedRegions(new Set());
                                                                }
                                                            }}
                                                            className="px-2 py-1 bg-ochre text-white rounded text-xs hover:bg-[#a07f5a]"
                                                            title="Save all selected as examples"
                                                        >
                                                            ðŸ“š Save as Examples
                                                        </button>
                                                        <button 
                                                            onClick={() => setSelectedRegions(new Set())}
                                                            className="px-2 py-1 bg-gray-200 text-gray-600 rounded text-xs hover:bg-gray-300"
                                                        >
                                                            âœ• Clear
                                                        </button>
                                                    </div>
                                                </div>
                                            )}
                                            
                                            <div className={`flex-1 overflow-y-auto pb-48 ${isLeftPanelHidden && viewMode !== 'reading' ? 'grid grid-cols-2 gap-2 auto-rows-max' : 'space-y-2'}`}>
                                                {(viewMode === 'reading' 
                                                    ? readingOrder.filter(i => !excludedDetections.has(i) && Math.round(recognitionResults[i]?.confidence * 100) >= confidenceThreshold)
                                                    : recognitionResults.map((_, i) => i).filter(i => Math.round(recognitionResults[i]?.confidence * 100) >= confidenceThreshold)
                                                ).map((idx, displayIdx) => {
                                                    const result = recognitionResults[idx];
                                                    if (!result || displayIdx < 0) return null;
                                                    
                                                    const validation = validations[idx];
                                                    const isSelected = selectedRegions.has(idx);
                                                    const isExpanded = expandedCards.has(idx);
                                                    const isExcluded = excludedDetections.has(idx);
                                                    const conf = Math.round(result.confidence * 100);
                                                    
                                                    let borderColor = 'border-gray-200';
                                                    if (isExcluded) borderColor = 'border-gray-300';
                                                    else if (isSelected) borderColor = 'border-ochre';
                                                    else if (validation?.isCorrect) borderColor = 'border-patina';
                                                    else if (validation && !validation.isCorrect) borderColor = 'border-rust';
                                                    
                                                    return (
                                                        <div key={`d-card-${idx}-${result.position.x}-${result.position.y}`} 
                                                            className={`border-2 ${borderColor} rounded-lg ${isSelected ? 'bg-yellow-50' : ''} ${isExcluded ? 'opacity-50' : ''} ${viewMode === 'reading' ? 'cursor-grab' : ''} ${draggedCardIdx === displayIdx ? 'opacity-50' : ''} ${dragOverCardIdx === displayIdx ? 'border-ochre border-dashed' : ''}`}
                                                            draggable={viewMode === 'reading'}
                                                            onDragStart={viewMode === 'reading' ? (e) => handleDragStart(e, displayIdx) : undefined}
                                                            onDragOver={viewMode === 'reading' ? (e) => handleDragOver(e, displayIdx) : undefined}
                                                            onDragLeave={viewMode === 'reading' ? handleDragLeave : undefined}
                                                            onDrop={viewMode === 'reading' ? (e) => handleDrop(e, displayIdx) : undefined}
                                                            onDragEnd={viewMode === 'reading' ? handleDragEnd : undefined}
                                                        >
                                                            {/* Main card header */}
                                                            <div className="p-2 cursor-pointer hover:bg-gray-50"
                                                                onClick={(e) => { 
                                                                    setEditMenuCardIdx(null);
                                                                    setBreaksMenuCardIdx(null);
                                                                    
                                                                    // Shift+click for range selection
                                                                    if (e.shiftKey && lastSelectedIdx !== null) {
                                                                        const start = Math.min(lastSelectedIdx, idx);
                                                                        const end = Math.max(lastSelectedIdx, idx);
                                                                        setSelectedRegions(prev => {
                                                                            const next = new Set(prev);
                                                                            for (let i = start; i <= end; i++) {
                                                                                next.add(i);
                                                                            }
                                                                            return next;
                                                                        });
                                                                    } else {
                                                                        // Normal click - toggle selection
                                                                        setSelectedRegions(prev => { 
                                                                            const n = new Set(prev); 
                                                                            n.has(idx) ? n.delete(idx) : n.add(idx); 
                                                                            return n; 
                                                                        });
                                                                        setLastSelectedIdx(idx);
                                                                    }
                                                                }}>
                                                                <div className="flex gap-2">
                                                                    {/* Thumbnails: Detected vs Chart */}
                                                                    <div className="flex gap-1 flex-shrink-0">
                                                                        {/* Detected region thumbnail - click to edit */}
                                                                        {result.thumbnail && (
                                                                            <div 
                                                                                className="relative cursor-pointer group"
                                                                                onClick={(e) => { e.stopPropagation(); openRegionEditor(idx); }}
                                                                                title="Click to edit region"
                                                                            >
                                                                                <div className={`w-10 h-10 bg-gray-100 rounded overflow-hidden border-2 transition-colors ${result.thumbnailEdited ? 'border-patina' : 'border-gray-300'} group-hover:border-blue-400`}>
                                                                                    <img src={result.thumbnail} alt="Detected" className="w-full h-full object-contain" />
                                                                                </div>
                                                                                <span className="absolute -bottom-1 left-0 right-0 text-center text-[8px] text-gray-400 group-hover:text-blue-500">
                                                                                    {result.thumbnailEdited ? 'âœ“det' : 'âœï¸det'}
                                                                                </span>
                                                                            </div>
                                                                        )}
                                                                        {/* Chart glyph thumbnail - click/touch to change glyph */}
                                                                        {glyphThumbnails[result.glyph.id] && (
                                                                            <div 
                                                                                className="relative cursor-pointer group"
                                                                                onClick={(e) => { e.stopPropagation(); openChartSelector(idx); }}
                                                                                onTouchEnd={(e) => { e.stopPropagation(); e.preventDefault(); openChartSelector(idx); }}
                                                                                title="Tap to change glyph"
                                                                            >
                                                                                <div className="w-10 h-10 bg-white rounded overflow-hidden border-2 border-ancient-purple transition-colors group-hover:border-ochre">
                                                                                    <img src={glyphThumbnails[result.glyph.id]} alt="Chart" className="w-full h-full object-contain" />
                                                                                </div>
                                                                                <span className="absolute -bottom-1 left-0 right-0 text-center text-[8px] text-ancient-purple group-hover:text-ochre">ðŸ“‹tap</span>
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                    <div className="flex-1 min-w-0">
                                                                        <div className="flex items-center gap-1 flex-wrap">
                                                                            <span className="font-bold text-xs text-gray-500">#{viewMode === 'reading' ? displayIdx + 1 : idx + 1}</span>
                                                                            <span className={`text-xs font-medium ${conf >= 70 ? 'text-patina' : conf >= 50 ? 'text-ochre' : 'text-rust'}`}>{conf}%</span>
                                                                            {result.matchedTemplateLabel && (
                                                                                <span className="text-[10px] bg-gray-100 px-1 rounded" title={`Matched ${result.matchedTemplate}${result.matchedTemplateIndex !== undefined ? ' #' + (result.matchedTemplateIndex + 1) : ''}`}>
                                                                                    {result.matchedTemplateLabel}
                                                                                </span>
                                                                            )}
                                                                            {isExcluded && <span className="text-xs text-gray-400">(excluded)</span>}
                                                                            {result.isMerged && <span className="text-xs text-blue-500">ðŸ”—</span>}
                                                                            {/* History indicator - subtle dot if card has edit history */}
                                                                            {driveUserEmail && typeof ChangeTracker !== 'undefined' && ChangeTracker.getDetectionHistory(changeLog, idx).length > 0 && (
                                                                                <span className="w-2 h-2 rounded-full bg-blue-400" title="Has edit history"></span>
                                                                            )}
                                                                            {/* Boundary indicators */}
                                                                            {wordBoundaries.has(idx) && <span className="text-xs font-bold text-stone px-1 bg-stone/20 rounded">|</span>}
                                                                            {columnBreaks.has(idx) && <span className="text-xs font-bold text-amber-700 px-1 bg-stone/20 rounded">â€–</span>}
                                                                            {lineBreaks.has(idx) && <span className="text-xs font-bold text-ancient-purple px-1 bg-ancient-purple/20 rounded">âŽ</span>}
                                                                        </div>
                                                                        <div className="font-medium text-gray-900 text-sm truncate">{result.glyph.name}</div>
                                                                        <div className="text-lg text-ancient-purple leading-tight">{result.glyph.arabic || result.glyph.transliteration || result.glyph.name}</div>
                                                                    </div>
                                                                    <div className="flex flex-col gap-1">
                                                                        {!validation ? (
                                                                            <>
                                                                                <button onClick={(e) => { e.stopPropagation(); validateDetection(idx, true); }}
                                                                                    className="w-6 h-6 bg-patina text-white rounded text-xs hover:bg-[#5a7d6e]" title="Mark correct">âœ“</button>
                                                                                <button onClick={(e) => { e.stopPropagation(); validateDetection(idx, false); }}
                                                                                    className="w-6 h-6 bg-rust text-white rounded text-xs hover:bg-[#8a574a]" title="Mark incorrect">âœ—</button>
                                                                            </>
                                                                        ) : (
                                                                            <button onClick={(e) => { e.stopPropagation(); setValidations(prev => { const n = {...prev}; delete n[idx]; return n; }); }}
                                                                                className="w-6 h-6 bg-gray-400 text-white rounded text-xs hover:bg-gray-500" title="Clear validation">â†©</button>
                                                                        )}
                                                                        <button onClick={(e) => { e.stopPropagation(); if(confirm('Delete?')) deleteDetection(idx); }}
                                                                            className="w-6 h-6 bg-red-500 text-white rounded text-xs hover:bg-red-600" title="Delete">ðŸ—‘</button>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            
                                                            {/* Action buttons row - compact */}
                                                            <div className="px-2 pb-2 flex gap-1 flex-wrap items-center">
                                                                <button onClick={(e) => { e.stopPropagation(); toggleCardExpansion(idx); }}
                                                                    className={`px-2 py-0.5 rounded text-xs ${isExpanded ? 'bg-ancient-purple text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                                                                    title="Show alternative matches">
                                                                    {isExpanded ? 'â–¼' : 'â–¶'} Alts {result.topMatches?.length > 1 ? `(${result.topMatches.length - 1})` : ''}
                                                                </button>
                                                                
                                                                {isExcluded && (
                                                                    <button onClick={(e) => { e.stopPropagation(); toggleExcludeDetection(idx); }}
                                                                        className="px-2 py-0.5 rounded text-xs bg-gray-500 text-white"
                                                                        title="Include in reading">
                                                                        ðŸ‘ Include
                                                                    </button>
                                                                )}
                                                                
                                                                {/* Edit menu toggle */}
                                                                <div className="relative ml-auto">
                                                                    <button onClick={(e) => { e.stopPropagation(); setEditMenuCardIdx(editMenuCardIdx === idx ? null : idx); setBreaksMenuCardIdx(null); }}
                                                                        className={`px-2 py-0.5 rounded text-xs ${editMenuCardIdx === idx ? 'bg-stone text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                                                                        title="Edit options">
                                                                        âœï¸ Edit
                                                                    </button>
                                                                    
                                                                    {/* Edit dropdown menu */}
                                                                    {editMenuCardIdx === idx && (
                                                                        <div className="absolute right-0 top-full mt-1 bg-white border border-gray-200 rounded-lg shadow-lg z-50 py-1 min-w-[140px]">
                                                                            <button onClick={(e) => { e.stopPropagation(); shrinkBox(idx, 3); setEditMenuCardIdx(null); }}
                                                                                className="w-full px-3 py-1.5 text-left text-xs hover:bg-gray-100 flex items-center gap-2">
                                                                                âŠŸ Shrink box
                                                                            </button>
                                                                            <button onClick={(e) => { e.stopPropagation(); expandBox(idx, 3); setEditMenuCardIdx(null); }}
                                                                                className="w-full px-3 py-1.5 text-left text-xs hover:bg-gray-100 flex items-center gap-2">
                                                                                âŠž Expand box
                                                                            </button>
                                                                            <button onClick={(e) => { e.stopPropagation(); setRegionEditorIdx(idx); setEditMenuCardIdx(null); }}
                                                                                className="w-full px-3 py-1.5 text-left text-xs hover:bg-gray-100 flex items-center gap-2">
                                                                                ðŸ–Œï¸ Edit region
                                                                            </button>
                                                                            <div className="border-t border-gray-100 my-1"></div>
                                                                            <button onClick={(e) => { e.stopPropagation(); toggleExcludeDetection(idx); setEditMenuCardIdx(null); }}
                                                                                className={`w-full px-3 py-1.5 text-left text-xs hover:bg-gray-100 flex items-center gap-2 ${isExcluded ? 'text-patina' : 'text-rust'}`}>
                                                                                {isExcluded ? 'ðŸ‘ Include' : 'ðŸš« Exclude'}
                                                                            </button>
                                                                            {/* History - only visible when logged in */}
                                                                            {driveUserEmail && typeof ChangeTracker !== 'undefined' && (
                                                                                <>
                                                                                    <div className="border-t border-gray-100 my-1"></div>
                                                                                    <button onClick={(e) => { e.stopPropagation(); setHistoryCardIdx(historyCardIdx === idx ? null : idx); setEditMenuCardIdx(null); }}
                                                                                        className="w-full px-3 py-1.5 text-left text-xs hover:bg-gray-100 flex items-center gap-2 text-gray-600">
                                                                                        ðŸ“œ History {ChangeTracker.getDetectionHistory(changeLog, idx).length > 0 ? `(${ChangeTracker.getDetectionHistory(changeLog, idx).length})` : ''}
                                                                                    </button>
                                                                                </>
                                                                            )}
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            </div>
                                                            
                                                            {/* Bottom row: Break button + drag handle */}
                                                            <div className="px-2 pb-2 flex items-center gap-1 border-t border-gray-100 pt-1">
                                                                {/* Show active breaks as badges */}
                                                                {(wordBoundaries.has(idx) || columnBreaks.has(idx) || lineBreaks.has(idx)) && (
                                                                    <div className="flex gap-0.5 mr-1">
                                                                        {wordBoundaries.has(idx) && <span className="text-xs font-bold text-stone bg-stone/20 px-1 rounded">|</span>}
                                                                        {columnBreaks.has(idx) && <span className="text-xs font-bold text-amber-700 bg-amber-100 px-1 rounded">â€–</span>}
                                                                        {lineBreaks.has(idx) && <span className="text-xs font-bold text-ancient-purple bg-ancient-purple/20 px-1 rounded">âŽ</span>}
                                                                    </div>
                                                                )}
                                                                {/* Breaks popover button */}
                                                                <div className="relative">
                                                                    <button onClick={(e) => { e.stopPropagation(); setBreaksMenuCardIdx(breaksMenuCardIdx === idx ? null : idx); setEditMenuCardIdx(null); }}
                                                                        onBlur={() => setTimeout(() => setBreaksMenuCardIdx(null), 150)}
                                                                        className={`px-2 py-0.5 rounded text-xs ${breaksMenuCardIdx === idx ? 'bg-stone text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                                                                        title="Add break after this glyph">
                                                                        Break â–¾
                                                                    </button>
                                                                    {breaksMenuCardIdx === idx && (
                                                                        <div className="absolute left-0 bottom-full mb-1 bg-white border border-gray-200 rounded-lg shadow-lg z-50 py-1 min-w-[100px]">
                                                                            <button onClick={(e) => { e.stopPropagation(); toggleWordBoundary(idx); }}
                                                                                className={`w-full px-3 py-1.5 text-left text-xs hover:bg-gray-100 flex items-center gap-2 ${wordBoundaries.has(idx) ? 'text-stone font-bold' : ''}`}>
                                                                                | Word {wordBoundaries.has(idx) && 'âœ“'}
                                                                            </button>
                                                                            <button onClick={(e) => { e.stopPropagation(); toggleColumnBreak(idx); }}
                                                                                className={`w-full px-3 py-1.5 text-left text-xs hover:bg-gray-100 flex items-center gap-2 ${columnBreaks.has(idx) ? 'text-amber-700 font-bold' : ''}`}>
                                                                                â€– Column {columnBreaks.has(idx) && 'âœ“'}
                                                                            </button>
                                                                            <button onClick={(e) => { e.stopPropagation(); toggleLineBreak(idx); }}
                                                                                className={`w-full px-3 py-1.5 text-left text-xs hover:bg-gray-100 flex items-center gap-2 ${lineBreaks.has(idx) ? 'text-ancient-purple font-bold' : ''}`}>
                                                                                âŽ Line {lineBreaks.has(idx) && 'âœ“'}
                                                                            </button>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                                {/* Drag handle - only in reading mode */}
                                                                {viewMode === 'reading' && (
                                                                    <div className="ml-auto px-2 py-0.5 bg-ochre/20 text-ochre text-xs rounded cursor-grab hover:bg-ochre/30 font-medium select-none"
                                                                        title="Drag to reorder">
                                                                        â‹®â‹® drag
                                                                    </div>
                                                                )}
                                                            </div>
                                                            
                                                            {/* Expanded: Alternative matches */}
                                                            {isExpanded && result.topMatches && result.topMatches.length > 1 && (
                                                                <div className="px-2 pb-2 border-t border-gray-100 bg-gray-50">
                                                                    <div className="text-xs text-gray-500 mb-1 pt-1">Alternative matches:</div>
                                                                    <div className="flex flex-wrap gap-1">
                                                                        {result.topMatches.slice(1, 6).map((alt, altIdx) => (
                                                                            <button key={altIdx}
                                                                                onClick={(e) => { e.stopPropagation(); changeGlyphAssignment(idx, alt.glyph); }}
                                                                                className="flex items-center gap-1 px-2 py-1 bg-white border border-gray-200 rounded hover:border-ancient-purple hover:bg-purple-50 transition-colors"
                                                                                title={`Switch to ${alt.glyph.name} (${Math.round(alt.confidence * 100)}%)`}>
                                                                                {glyphThumbnails[alt.glyph.id] && (
                                                                                    <img src={glyphThumbnails[alt.glyph.id]} alt="" className="w-5 h-5 object-contain" />
                                                                                )}
                                                                                <span className="text-xs font-medium">{alt.glyph.transliteration || alt.glyph.name}</span>
                                                                                <span className="text-xs text-gray-400">{Math.round(alt.confidence * 100)}%</span>
                                                                            </button>
                                                                        ))}
                                                                        
                                                                        {/* More button to open full chart */}
                                                                        <button
                                                                            onClick={(e) => {
                                                                                e.stopPropagation();
                                                                                setShowGlyphSelector({ 
                                                                                    mode: 'relabel', 
                                                                                    detectionIndex: idx 
                                                                                });
                                                                                setGlyphSelectorSearch('');
                                                                                toggleCardExpansion(idx); // Close alternatives
                                                                            }}
                                                                            className="flex items-center gap-1 px-2 py-1 bg-ancient-purple text-white border border-ancient-purple rounded hover:bg-ancient-purple/80 transition-colors"
                                                                            title="Browse full glyph chart">
                                                                            <span className="text-xs font-semibold">ðŸ“Š Chart</span>
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                            )}
                                                            
                                                            {/* History panel - shows when historyCardIdx matches */}
                                                            {historyCardIdx === idx && driveUserEmail && typeof ChangeTracker !== 'undefined' && (
                                                                <div className="px-2 pb-2 border-t border-gray-100 bg-blue-50">
                                                                    <div className="flex items-center justify-between pt-1 mb-1">
                                                                        <div className="text-xs text-gray-500">ðŸ“œ Edit History</div>
                                                                        <button onClick={(e) => { e.stopPropagation(); setHistoryCardIdx(null); }}
                                                                            className="text-xs text-gray-400 hover:text-gray-600">âœ•</button>
                                                                    </div>
                                                                    {(() => {
                                                                        const history = ChangeTracker.getDetectionHistory(changeLog, idx);
                                                                        if (history.length === 0) {
                                                                            return <div className="text-xs text-gray-400 italic">No changes recorded</div>;
                                                                        }
                                                                        return (
                                                                            <div className="space-y-1 max-h-24 overflow-y-auto">
                                                                                {history.slice(0, 5).map((entry, i) => (
                                                                                    <div key={entry.id || i} className="text-xs text-gray-600 bg-white px-2 py-1 rounded">
                                                                                        {ChangeTracker.formatEntry(entry)}
                                                                                    </div>
                                                                                ))}
                                                                                {history.length > 5 && (
                                                                                    <div className="text-xs text-gray-400">+{history.length - 5} more</div>
                                                                                )}
                                                                            </div>
                                                                        );
                                                                    })()}
                                                                </div>
                                                            )}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </>
                                    )}
                                </div>
                            </aside>
                        </div>
                        
                        {/* Mobile: Canvas Only View */}
                        <div className="lg:hidden h-[calc(100vh-180px)] flex flex-col">
                            <div className="bg-white rounded-lg shadow p-2 flex-1 flex flex-col min-h-0">
                                {/* Mobile Recognize Button */}
                                <div className="mb-2 flex gap-2">
                                    <button onClick={recognizeGlyphs} disabled={isProcessing || chartStatus !== 'loaded' || !displayImage}
                                        className="flex-1 px-3 py-2 bg-patina text-white rounded-lg text-sm font-medium disabled:bg-gray-300"
                                        title={chartStatus !== 'loaded' ? 'Waiting for chart to load...' : ''}>
                                        {isProcessing ? `â³ ${processingStatus || 'Processing...'}` : chartStatus !== 'loaded' ? 'â³ Chart...' : 'ðŸ” Recognize'}
                                    </button>
                                    {recognitionResults.length > 0 && (
                                        <button onClick={() => setMobilePanel('detections')}
                                            className="px-3 py-2 bg-gray-100 rounded-lg text-sm font-medium">
                                            ðŸ“‹ {recognitionResults.length}
                                        </button>
                                    )}
                                </div>
                                
                                {displayImage ? (
                                    <div ref={imageContainerRef} 
                                        className="relative flex-1 flex items-center justify-center overflow-hidden"
                                        style={{ 
                                            cursor: (manualBoxMode || cropMode) ? 'crosshair' : 'default',
                                            touchAction: (manualBoxMode || cropMode) ? 'none' : 'auto'
                                        }}
                                        onMouseDown={cropMode ? handleCropStart : (manualBoxMode ? handleManualBoxStart : undefined)}
                                        onMouseMove={cropMode ? handleCropMove : (manualBoxMode ? handleManualBoxMove : undefined)}
                                        onMouseUp={cropMode ? handleCropEnd : (manualBoxMode ? handleManualBoxEnd : undefined)}
                                        onTouchStart={cropMode ? (e) => { e.preventDefault(); handleCropStart(e.touches[0]); } : (manualBoxMode ? (e) => { e.preventDefault(); handleManualBoxStart(e.touches[0]); } : undefined)}
                                        onTouchMove={cropMode ? (e) => { e.preventDefault(); handleCropMove(e.touches[0]); } : (manualBoxMode ? (e) => { e.preventDefault(); handleManualBoxMove(e.touches[0]); } : undefined)}
                                        onTouchEnd={cropMode ? handleCropEnd : (manualBoxMode ? handleManualBoxEnd : undefined)}
                                    >
                                        <img src={displayImage} alt="Inscription" className="max-w-full max-h-full object-contain" style={{ visibility: eraserMode ? 'hidden' : 'visible', pointerEvents: (eraserMode || manualBoxMode || cropMode) ? 'none' : 'auto' }} />
                                        
                                        {/* Eraser canvas for mobile - activeEraserCanvasRef will find whichever is visible */}
                                        {eraserMode && (() => {
                                            const cursorRadius = eraserSize - 1;
                                            const cursorSize = cursorRadius * 2 + 2;
                                            return (
                                                <>
                                                <canvas ref={eraserCanvasRef}
                                                    className="absolute inset-0"
                                                    style={{ 
                                                        cursor: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="${cursorSize}" height="${cursorSize}" viewBox="0 0 ${cursorSize} ${cursorSize}"><circle cx="${cursorRadius + 1}" cy="${cursorRadius + 1}" r="${cursorRadius}" fill="none" stroke="black" stroke-width="1"/><circle cx="${cursorRadius + 1}" cy="${cursorRadius + 1}" r="${cursorRadius}" fill="none" stroke="white" stroke-width="0.5" stroke-dasharray="2,2"/><line x1="${cursorRadius + 1}" y1="${cursorRadius - 3}" x2="${cursorRadius + 1}" y2="${cursorRadius + 5}" stroke="black" stroke-width="1"/><line x1="${cursorRadius - 3}" y1="${cursorRadius + 1}" x2="${cursorRadius + 5}" y2="${cursorRadius + 1}" stroke="black" stroke-width="1"/></svg>') ${cursorRadius + 1} ${cursorRadius + 1}, crosshair`,
                                                        touchAction: 'none',
                                                        pointerEvents: 'auto',
                                                        objectFit: 'contain',
                                                        width: canvasDimensions.width > 0 ? `${canvasDimensions.width}px` : '100%',
                                                        height: canvasDimensions.height > 0 ? `${canvasDimensions.height}px` : '100%'
                                                    }}
                                                    onMouseDown={handleEraserStart}
                                                    onMouseMove={handleEraserDraw}
                                                    onMouseUp={handleEraserEnd}
                                                    onMouseLeave={handleEraserEnd}
                                                    onTouchStart={handleEraserStart}
                                                    onTouchMove={handleEraserDraw}
                                                    onTouchEnd={handleEraserEnd}
                                                />
                                                {/* Touch brush preview circle */}
                                                {brushPreviewPos && (
                                                    <div 
                                                        className="absolute pointer-events-none"
                                                        style={{
                                                            left: brushPreviewPos.x - eraserSize,
                                                            top: brushPreviewPos.y - eraserSize,
                                                            width: eraserSize * 2,
                                                            height: eraserSize * 2,
                                                            borderRadius: '50%',
                                                            border: '2px solid rgba(0,0,0,0.7)',
                                                            boxShadow: 'inset 0 0 0 1px rgba(255,255,255,0.7)',
                                                            background: 'rgba(255,255,255,0.2)'
                                                        }}
                                                    />
                                                )}
                                                </>
                                            );
                                        })()}
                                        
                                        {/* Manual Box Drawing Overlay - mobile */}
                                        {manualBoxMode && drawingBox && (() => {
                                            const container = imageContainerRef.current;
                                            if (!container) return null;
                                            
                                            // Find the image element
                                            const img = container.querySelector('img');
                                            if (!img) return null;
                                            
                                            // Use offsetLeft/Top for actual image position within the centered container
                                            const offsetX = img.offsetLeft || 0;
                                            const offsetY = img.offsetTop || 0;
                                            
                                            const left = offsetX + Math.min(drawingBox.startX, drawingBox.currentX);
                                            const top = offsetY + Math.min(drawingBox.startY, drawingBox.currentY);
                                            const width = Math.abs(drawingBox.currentX - drawingBox.startX);
                                            const height = Math.abs(drawingBox.currentY - drawingBox.startY);
                                            
                                            return (
                                                <div 
                                                    className="absolute border-2 border-dashed border-amber-500 bg-amber-500/20 pointer-events-none"
                                                    style={{ left: `${left}px`, top: `${top}px`, width: `${width}px`, height: `${height}px` }}
                                                />
                                            );
                                        })()}
                                        
                                        {/* Crop Selection Overlay - mobile */}
                                        {cropMode && cropSelection && (() => {
                                            const img = imageRef.current;
                                            if (!img) return null;
                                            
                                            const imgRect = img.getBoundingClientRect();
                                            const containerRect = imageContainerRef.current?.getBoundingClientRect();
                                            if (!containerRect) return null;
                                            
                                            const left = Math.min(cropSelection.startX, cropSelection.currentX);
                                            const top = Math.min(cropSelection.startY, cropSelection.currentY);
                                            const width = Math.abs(cropSelection.currentX - cropSelection.startX);
                                            const height = Math.abs(cropSelection.currentY - cropSelection.startY);
                                            
                                            return (
                                                <div 
                                                    className="absolute border-2 border-dashed border-stone bg-stone/20 pointer-events-none"
                                                    style={{ left, top, width, height }}
                                                />
                                            );
                                        })()}
                                        
                                        {/* Detection boxes overlay - mobile */}
                                        {!eraserMode && recognitionResults.map((result, index) => {
                                            // Filter by confidence threshold
                                            if (Math.round(result.confidence * 100) < confidenceThreshold) return null;
                                            
                                            const validation = validations[index];
                                            const isSelected = selectedRegions.has(index);
                                            const isExcluded = excludedDetections.has(index);
                                            
                                            let boxClass = 'detection-box unvalidated';
                                            let labelBg = 'bg-stone';
                                            
                                            if (isSelected) { boxClass = 'detection-box selected'; labelBg = 'bg-ochre'; }
                                            else if (validation?.isCorrect) { boxClass = 'detection-box validated-correct'; labelBg = 'bg-patina'; }
                                            else if (validation && !validation.isCorrect) { boxClass = 'detection-box validated-incorrect'; labelBg = 'bg-rust'; }
                                            if (result.confidence < 0.5) boxClass += ' uncertain';
                                            if (isExcluded) boxClass += ' opacity-50';
                                            
                                            const container = imageContainerRef.current;
                                            if (!container) return null;
                                            
                                            // Find the image element
                                            const img = container.querySelector('img');
                                            if (!img) return null;
                                            
                                            // Use tracked recognition source dimensions if available
                                            const sourceWidth = recognitionSourceDims?.width || img.naturalWidth;
                                            const sourceHeight = recognitionSourceDims?.height || img.naturalHeight;
                                            
                                            // Use getBoundingClientRect for display dimensions (more reliable on mobile)
                                            const imgRect = img.getBoundingClientRect();
                                            const displayWidth = imgRect.width;
                                            const displayHeight = imgRect.height;
                                            
                                            // Skip rendering if dimensions aren't ready
                                            if (!displayWidth || !displayHeight || !sourceWidth || !sourceHeight) return null;
                                            
                                            // Scale calculation
                                            const scaleX = displayWidth / sourceWidth;
                                            const scaleY = displayHeight / sourceHeight;
                                            
                                            // Get image offset position
                                            const imgOffsetX = img.offsetLeft || 0;
                                            const imgOffsetY = img.offsetTop || 0;
                                            
                                            return (
                                                <div key={`box-${index}`} className={boxClass}
                                                    style={{
                                                        left: imgOffsetX + result.position.x * scaleX,
                                                        top: imgOffsetY + result.position.y * scaleY,
                                                        width: result.position.width * scaleX,
                                                        height: result.position.height * scaleY
                                                    }}
                                                    onClick={() => setSelectedRegions(prev => {
                                                        const next = new Set(prev);
                                                        next.has(index) ? next.delete(index) : next.add(index);
                                                        return next;
                                                    })}
                                                    title={`${result.glyph.name} (${Math.round(result.confidence * 100)}%)`}>
                                                    {/* Don't show labels on mobile - too cluttered */}
                                                </div>
                                            );
                                        })}
                                    </div>
                                ) : (
                                    <div className="flex-1 flex flex-col items-center justify-center text-gray-400">
                                        <span className="text-5xl mb-3">ðŸ“·</span>
                                        <p>Tap "Image" to upload</p>
                                    </div>
                                )}
                            </div>
                        </div>
                        
                        {/* ===== TRANSCRIPTION DISPLAY ===== */}
                        {viewMode === 'reading' && recognitionResults.length > 0 && (
                            <div className="mt-6 border border-gray-200 rounded-lg overflow-hidden">
                                <div 
                                    className="w-full px-4 py-3 bg-gradient-to-r from-blue-50 to-indigo-50 hover:from-blue-100 hover:to-indigo-100 flex items-center justify-between transition-colors cursor-pointer"
                                    onClick={() => setShowTranscription(!showTranscription)}
                                >
                                    <div className="flex items-center gap-2">
                                        <span className="font-semibold text-gray-700">ðŸ“œ Transcription</span>
                                    </div>
                                    <div className="flex items-center gap-2">
                                        {showTranscription && (
                                            <div className="flex gap-2" onClick={e => e.stopPropagation()}>
                                                <button 
                                                    onClick={copyTranscriptionToClipboard}
                                                    className="px-2 py-1 bg-stone text-white text-xs rounded hover:bg-[#6d6355]"
                                                    title="Copy transcription to clipboard"
                                                >
                                                    ðŸ“‹ Copy
                                                </button>
                                                <button 
                                                    onClick={exportTranscription}
                                                    className="px-2 py-1 bg-patina text-white text-xs rounded hover:bg-[#5d7a6d]"
                                                    title="Download transcription as text file"
                                                >
                                                    ðŸ’¾ Export
                                                </button>
                                                <button 
                                                    onClick={generateHtmlBooklet}
                                                    className="px-2 py-1 bg-ancient-purple text-white text-xs rounded hover:bg-[#4a3d5a]"
                                                    title="Generate print-friendly HTML booklet (perfect Arabic)"
                                                >
                                                    ðŸ“– HTML Booklet
                                                </button>
                                                <button 
                                                    onClick={generatePdfBooklet}
                                                    className="px-2 py-1 bg-ochre text-white text-xs rounded hover:bg-[#a67c52]"
                                                    title="Generate PDF booklet (Arabic may show incorrectly)"
                                                >
                                                    ðŸ“• PDF Booklet
                                                </button>
                                            </div>
                                        )}
                                        <svg 
                                            className={`w-5 h-5 text-gray-500 transition-transform ${!showTranscription ? '' : 'rotate-180'}`}
                                            fill="none" 
                                            stroke="currentColor" 
                                            viewBox="0 0 24 24"
                                        >
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                        </svg>
                                    </div>
                                </div>
                                
                                {showTranscription && (
                                <div className="p-4 bg-gradient-to-r from-blue-50 to-indigo-50">
                                <div className="mb-3 flex flex-wrap gap-2 items-center">
                                    <span className="text-xs text-gray-500 mr-1">Script:</span>
                                    <button
                                        onClick={() => setTranscriptionScript('english')}
                                        className={`px-3 py-1 rounded text-sm font-medium ${
                                            transcriptionScript === 'english' 
                                                ? 'bg-ancient-purple text-white' 
                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                        }`}
                                    >
                                        Transliteration
                                    </button>
                                    <button
                                        onClick={() => setTranscriptionScript('arabic')}
                                        className={`px-3 py-1 rounded text-sm font-medium ${
                                            transcriptionScript === 'arabic' 
                                                ? 'bg-ancient-purple text-white' 
                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                        }`}
                                    >
                                        Arabic
                                    </button>
                                    
                                    <span className="text-gray-300 mx-2">|</span>
                                    
                                    <span className="text-xs text-gray-500 mr-1">Layout:</span>
                                    <button
                                        onClick={() => setTranscriptionFormat('horizontal-ltr')}
                                        className={`px-2 py-1 rounded text-sm ${
                                            transcriptionFormat === 'horizontal-ltr' 
                                                ? 'bg-stone text-white' 
                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                        }`}
                                        title="Horizontal Left-to-Right"
                                    >
                                        â†’
                                    </button>
                                    <button
                                        onClick={() => setTranscriptionFormat('horizontal-rtl')}
                                        className={`px-2 py-1 rounded text-sm ${
                                            transcriptionFormat === 'horizontal-rtl' 
                                                ? 'bg-stone text-white' 
                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                        }`}
                                        title="Horizontal Right-to-Left"
                                    >
                                        â†
                                    </button>
                                    <button
                                        onClick={() => setTranscriptionFormat('vertical-rtl')}
                                        className={`px-2 py-1 rounded text-sm ${
                                            transcriptionFormat === 'vertical-rtl' 
                                                ? 'bg-stone text-white' 
                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                        }`}
                                        title="Vertical columns, Right-to-Left"
                                    >
                                        â†“ Lâ†R
                                    </button>
                                    <button
                                        onClick={() => setTranscriptionFormat('vertical-ltr')}
                                        className={`px-2 py-1 rounded text-sm ${
                                            transcriptionFormat === 'vertical-ltr' 
                                                ? 'bg-stone text-white' 
                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                        }`}
                                        title="Vertical columns, Left-to-Right"
                                    >
                                        â†“ Lâ†’R
                                    </button>
                                </div>
                                
                                {/* Audio Recording Section */}
                                <div className="mb-3 border-t border-gray-200 pt-3">
                                    <div className="flex items-center gap-2 mb-2">
                                        <span className="text-xs font-semibold text-gray-600">ðŸŽ¤ Audio Notes:</span>
                                        {audioData && (
                                            <span className="text-xs text-patina">â— Recorded</span>
                                        )}
                                    </div>
                                    
                                    {!audioData ? (
                                        /* No audio - show record/upload options */
                                        <div className="flex gap-2">
                                            {!isRecording ? (
                                                <>
                                                    <button
                                                        onClick={startRecording}
                                                        className="flex-1 px-3 py-2 bg-red-500 hover:bg-red-600 text-white rounded text-sm font-medium flex items-center justify-center gap-2"
                                                        title="Record audio explanation"
                                                    >
                                                        âº Record
                                                    </button>
                                                    <button
                                                        onClick={() => audioInputRef.current?.click()}
                                                        className="flex-1 px-3 py-2 bg-stone hover:bg-[#6d6355] text-white rounded text-sm font-medium flex items-center justify-center gap-2"
                                                        title="Upload audio file"
                                                    >
                                                        ðŸ“Ž Upload
                                                    </button>
                                                    <input
                                                        ref={audioInputRef}
                                                        type="file"
                                                        accept="audio/*"
                                                        onChange={uploadAudioFile}
                                                        className="hidden"
                                                    />
                                                </>
                                            ) : (
                                                /* Recording in progress */
                                                <button
                                                    onClick={stopRecording}
                                                    className="flex-1 px-3 py-2 bg-red-600 hover:bg-red-700 text-white rounded text-sm font-medium flex items-center justify-center gap-2 animate-pulse"
                                                    title="Stop recording"
                                                >
                                                    â¹ Stop Recording
                                                </button>
                                            )}
                                        </div>
                                    ) : (
                                        /* Audio exists - show player and delete */
                                        <div className="space-y-2">
                                            <audio
                                                ref={audioPlayerRef}
                                                src={audioData}
                                                controls
                                                className="w-full"
                                                style={{ height: '40px' }}
                                            />
                                            <div className="flex gap-2">
                                                <button
                                                    onClick={() => audioInputRef.current?.click()}
                                                    className="flex-1 px-2 py-1 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded text-xs"
                                                    title="Replace with new recording"
                                                >
                                                    ðŸ”„ Replace
                                                </button>
                                                <button
                                                    onClick={deleteAudio}
                                                    className="px-2 py-1 bg-red-100 hover:bg-red-200 text-red-600 rounded text-xs"
                                                    title="Delete audio"
                                                >
                                                    ðŸ—‘ Delete
                                                </button>
                                                <input
                                                    ref={audioInputRef}
                                                    type="file"
                                                    accept="audio/*"
                                                    onChange={uploadAudioFile}
                                                    className="hidden"
                                                />
                                            </div>
                                        </div>
                                    )}
                                </div>
                                
                                {/* Transcription Content */}
                                <div className="p-4 bg-white rounded border-2 border-stone shadow-inner overflow-x-auto">
                                    {transcriptionFormat.startsWith('vertical') ? (
                                        /* Vertical layout - columns */
                                        <div 
                                            className="flex gap-6"
                                            style={{
                                                direction: transcriptionFormat === 'vertical-rtl' ? 'rtl' : 'ltr',
                                                justifyContent: 'flex-start'
                                            }}
                                        >
                                            {(() => {
                                                // Split into columns based on line breaks OR column breaks
                                                const columns = [];
                                                let currentColumn = [];
                                                const results = getReadingOrderedResults();
                                                results.forEach((result, index) => {
                                                    const actualIdx = readingOrder[index] ?? index;
                                                    const hasWordBoundary = wordBoundaries.has(actualIdx);
                                                    currentColumn.push({ result, index, actualIdx, hasWordBoundary });
                                                    // Split column on LINE break or COLUMN break
                                                    if (lineBreaks.has(actualIdx) || columnBreaks.has(actualIdx)) {
                                                        columns.push(currentColumn);
                                                        currentColumn = [];
                                                    }
                                                });
                                                if (currentColumn.length > 0) columns.push(currentColumn);
                                                
                                                return columns.map((column, colIdx) => (
                                                    <div 
                                                        key={colIdx}
                                                        className={`flex flex-col items-center pl-4 first:pl-0 ${
                                                            transcriptionFormat === 'vertical-rtl' 
                                                                ? 'border-r-2 border-stone/20 pr-4 first:border-r-0 first:pr-0' 
                                                                : 'border-l-2 border-stone/20 first:border-l-0'
                                                        }`}
                                                        style={{
                                                            fontFamily: transcriptionScript === 'arabic'
                                                                ? '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' 
                                                                : '"Noto Sans", "Segoe UI", "Roboto", "DejaVu Sans", "Arial Unicode MS", sans-serif',
                                                            fontSize: '20px',
                                                            lineHeight: '2',
                                                            direction: 'ltr' // Keep text direction LTR within columns
                                                        }}
                                                    >
                                                        {column.map(({ result, index, actualIdx, hasWordBoundary }) => (
                                                            <span 
                                                                key={`vert-${index}-${actualIdx}`} 
                                                                className={`text-gray-900 ${hasWordBoundary ? 'pb-2 mb-2 border-b-2 border-amber-600/50' : ''}`}
                                                            >
                                                                {transcriptionScript === 'arabic'
                                                                    ? (result.glyph.arabic || result.glyph.name)
                                                                    : (result.glyph.transliteration || result.glyph.name)
                                                                }
                                                            </span>
                                                        ))}
                                                    </div>
                                                ));
                                            })()}
                                        </div>
                                    ) : (
                                        /* Horizontal layout */
                                        <div 
                                            className="font-mono text-lg leading-relaxed"
                                            style={{
                                                fontFamily: transcriptionScript === 'arabic'
                                                    ? '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' 
                                                    : '"Noto Sans", "Segoe UI", "Roboto", "DejaVu Sans", "Arial Unicode MS", sans-serif',
                                                direction: transcriptionFormat === 'horizontal-rtl' ? 'rtl' : 'ltr',
                                                textAlign: transcriptionFormat === 'horizontal-rtl' ? 'right' : 'left'
                                            }}
                                        >
                                            {getReadingOrderedResults().map((result, index) => (
                                                <span key={`horiz-${index}`}>
                                                    <span className="text-gray-900">
                                                        {transcriptionScript === 'arabic'
                                                            ? (result.glyph.arabic || result.glyph.name)
                                                            : (result.glyph.transliteration || result.glyph.name)
                                                        }
                                                    </span>
                                                    {lineBreaks.has(readingOrder[index] ?? index) && <span className="text-ancient-purple font-bold mx-2">âŽ<br/></span>}
                                                    {!lineBreaks.has(readingOrder[index] ?? index) && columnBreaks.has(readingOrder[index] ?? index) && <span className="text-amber-700 font-bold mx-1">â€–</span>}
                                                    {!lineBreaks.has(readingOrder[index] ?? index) && !columnBreaks.has(readingOrder[index] ?? index) && wordBoundaries.has(readingOrder[index] ?? index) && <span className="text-amber-700 font-bold mx-1">|</span>}
                                                    {!lineBreaks.has(readingOrder[index] ?? index) && !columnBreaks.has(readingOrder[index] ?? index) && !wordBoundaries.has(readingOrder[index] ?? index) && index < getReadingOrderedResults().length - 1 && <span className="text-gray-400">Â·</span>}
                                                </span>
                                            ))}
                                        </div>
                                    )}
                                </div>

                                <div className="mt-3 text-xs text-gray-600">
                                    <span className="text-ancient-purple font-bold">âŽ</span> = line break Â· 
                                    <span className="text-amber-700 font-bold">â€–</span> = column break Â· 
                                    <span className="text-amber-700 font-bold">|</span> = word boundary Â· 
                                    <span className="text-gray-400">Â·</span> = glyph separator
                                    {transcriptionFormat.startsWith('vertical') && (
                                        <span className="ml-2 text-stone">(Vertical: line/column breaks split into columns)</span>
                                    )}
                                </div>
                                </div>
                                )}
                            </div>
                        )}
                        
                        {/* ===== INSCRIPTION PANEL (Translation & Notes) ===== */}
                        {viewMode === 'reading' && recognitionResults.length > 0 && (
                            <div className="mt-6">
                                <InscriptionPanel
                                    inscriptionTitle={inscriptionTitle}
                                    inscriptionNotes={inscriptionNotes}
                                    inscriptionComplete={inscriptionComplete}
                                    translationEnglish={translationEnglish}
                                    translationArabic={translationArabic}
                                    onTitleChange={setInscriptionTitle}
                                    onNotesChange={setInscriptionNotes}
                                    onCompleteChange={setInscriptionComplete}
                                    onTranslationEnglishChange={setTranslationEnglish}
                                    onTranslationArabicChange={setTranslationArabic}
                                    isCollapsed={!showTranslationSection}
                                    onToggleCollapse={() => setShowTranslationSection(!showTranslationSection)}
                                />
                            </div>
                        )}
                        
                        {/* ===== EXPORT PANEL (Save & Export) ===== */}
                        <div className="mt-6">
                            <ExportPanel
                                    recognitionResults={recognitionResults}
                                    validations={validations}
                                    image={originalImage}
                                    displayImage={displayImage}
                                    preprocessing={preprocessing}
                                    readingDirection={readingDirection}
                                    readingOrder={readingOrder}
                                    wordBoundaries={wordBoundaries}
                                    lineBreaks={lineBreaks}
                                    columnBreaks={columnBreaks}
                                    translationEnglish={translationEnglish}
                                    translationArabic={translationArabic}
                                    currentInscriptionId={currentInscriptionId}
                                    inscriptionTitle={inscriptionTitle}
                                    inscriptionNotes={inscriptionNotes}
                                    inscriptionComplete={inscriptionComplete}
                                    transcriptionFormat={transcriptionFormat}
                                    isCollapsed={!showStorageSection}
                                    onToggleCollapse={() => setShowStorageSection(!showStorageSection)}
                                    onSaveHki={async () => {
                                        // Save = Update existing file (only if owner)
                                        if (!driveSignedIn || !currentFileId) {
                                            alert('âŒ Cannot save: no file loaded or not signed in');
                                            return;
                                        }
                                        
                                        if (fileOwner && fileOwner !== driveUserEmail) {
                                            alert('âŒ You are not the owner. Use "Save As New" instead.');
                                            return;
                                        }
                                        
                                        try {
                                            // Clean recognition results to remove circular references
                                            const cleanResults = recognitionResults.map(r => ({
                                                glyph: {
                                                    id: r.glyph?.id,
                                                    name: r.glyph?.name,
                                                    transliteration: r.glyph?.transliteration,
                                                    arabic: r.glyph?.arabic,
                                                    description: r.glyph?.description
                                                },
                                                confidence: r.confidence,
                                                position: r.position,
                                                thumbnail: r.thumbnail,
                                                matchType: r.matchType,
                                                corrected: r.corrected,
                                                originalGlyph: r.originalGlyph ? {
                                                    id: r.originalGlyph.id,
                                                    name: r.originalGlyph.name,
                                                    transliteration: r.originalGlyph.transliteration
                                                } : null
                                            }));
                                            
                                            const hkiData = {
                                                version: '2.0',
                                                created: new Date().toISOString(),
                                                inscriptionId: currentInscriptionId,
                                                inscriptionTitle: inscriptionTitle || 'Untitled',
                                                inscriptionNotes,
                                                image: originalImage,
                                                displayImage,
                                                preprocessing,
                                                recognitionResults: cleanResults,
                                                readingOrder: Array.isArray(readingOrder) ? readingOrder : Array.from(readingOrder),
                                                readingDirection,
                                                wordBoundaries: Array.from(wordBoundaries),
                                                lineBreaks: Array.from(lineBreaks),
                                                validations,
                                                translationEnglish,
                                                translationArabic,
                                                audioData, // Audio recording/notes
                                                visibility,
                                                changeLog: changeLog || []
                                            };
                                            
                                            const result = await DriveSync.saveHki(hkiData, {
                                                fileId: currentFileId,
                                                title: inscriptionTitle || 'Untitled',
                                                visibility
                                            });
                                            
                                            alert('âœ… Saved to Drive!');
                                        } catch (err) {
                                            console.error('Save failed:', err);
                                            // Check if it's an auth error
                                            const isAuthError = err.message && (
                                                err.message.includes('authentication') ||
                                                err.message.includes('OAuth') ||
                                                err.message.includes('token') ||
                                                err.message.includes('401') ||
                                                err.message.includes('403')
                                            );
                                            if (isAuthError) {
                                                const retry = confirm('âŒ Session expired. Click OK to reconnect to Google Drive.');
                                                if (retry && typeof DriveSync !== 'undefined') {
                                                    try {
                                                        await DriveSync.signIn();
                                                        setDriveSignedIn(DriveSync.isSignedIn());
                                                        setDriveUserEmail(DriveSync.getUserEmail());
                                                        alert('âœ… Reconnected! Please try saving again.');
                                                    } catch (e) {
                                                        setDriveSignedIn(false);
                                                        alert('âŒ Reconnect failed. Please sign in again.');
                                                    }
                                                }
                                            } else {
                                                alert('âŒ Save failed: ' + err.message);
                                            }
                                        }
                                    }}
                                    onSaveAsNew={async () => {
                                        // Save As New = Create new file (user becomes owner)
                                        if (!driveSignedIn) {
                                            alert('âŒ Please sign in to save to Drive');
                                            return;
                                        }
                                        
                                        try {
                                            const newId = `HKI-${Date.now().toString(36).toUpperCase()}`;
                                            
                                            // Clean recognition results to remove circular references
                                            const cleanResults = recognitionResults.map(r => ({
                                                glyph: {
                                                    id: r.glyph?.id,
                                                    name: r.glyph?.name,
                                                    transliteration: r.glyph?.transliteration,
                                                    arabic: r.glyph?.arabic,
                                                    description: r.glyph?.description
                                                },
                                                confidence: r.confidence,
                                                position: r.position,
                                                thumbnail: r.thumbnail,
                                                matchType: r.matchType,
                                                corrected: r.corrected,
                                                originalGlyph: r.originalGlyph ? {
                                                    id: r.originalGlyph.id,
                                                    name: r.originalGlyph.name,
                                                    transliteration: r.originalGlyph.transliteration
                                                } : null
                                            }));
                                            
                                            const hkiData = {
                                                version: '2.0',
                                                created: new Date().toISOString(),
                                                inscriptionId: newId,
                                                inscriptionTitle: inscriptionTitle || 'Untitled',
                                                inscriptionNotes,
                                                image: originalImage,
                                                displayImage,
                                                preprocessing,
                                                recognitionResults: cleanResults,
                                                readingOrder: Array.isArray(readingOrder) ? readingOrder : Array.from(readingOrder),
                                                readingDirection,
                                                wordBoundaries: Array.from(wordBoundaries),
                                                lineBreaks: Array.from(lineBreaks),
                                                validations,
                                                translationEnglish,
                                                translationArabic,
                                                audioData, // Audio recording/notes
                                                visibility: 'draft', // New files start as draft
                                                changeLog: [] // New file starts with empty history
                                            };
                                            
                                            const result = await DriveSync.saveHki(hkiData, {
                                                fileId: null, // null = create new
                                                title: inscriptionTitle || 'Untitled',
                                                visibility: 'draft'
                                            });
                                            
                                            // Update tracking
                                            setCurrentInscriptionId(newId);
                                            setCurrentFileId(result.id);
                                            setFileOwner(driveUserEmail);
                                            setVisibility('draft');
                                            
                                            alert('âœ… Saved as new inscription!');
                                        } catch (err) {
                                            console.error('Save As New failed:', err);
                                            // Check if it's an auth error
                                            const isAuthError = err.message && (
                                                err.message.includes('authentication') ||
                                                err.message.includes('OAuth') ||
                                                err.message.includes('token') ||
                                                err.message.includes('401') ||
                                                err.message.includes('403')
                                            );
                                            if (isAuthError) {
                                                const retry = confirm('âŒ Session expired. Click OK to reconnect to Google Drive.');
                                                if (retry && typeof DriveSync !== 'undefined') {
                                                    try {
                                                        await DriveSync.signIn();
                                                        setDriveSignedIn(DriveSync.isSignedIn());
                                                        setDriveUserEmail(DriveSync.getUserEmail());
                                                        alert('âœ… Reconnected! Please try saving again.');
                                                    } catch (e) {
                                                        setDriveSignedIn(false);
                                                        alert('âŒ Reconnect failed. Please sign in again.');
                                                    }
                                                }
                                            } else {
                                                alert('âŒ Save failed: ' + err.message);
                                            }
                                        }
                                    }}
                                    onOpenWarehouse={() => setShowWarehouse(true)}
                                    onLoadHki={(e) => {
                                        // Load from local file (for offline work)
                                        const file = e.target.files[0];
                                        if (!file) return;
                                        const reader = new FileReader();
                                        reader.onload = (ev) => {
                                            try {
                                                const data = JSON.parse(ev.target.result);
                                                
                                                // Load all data into state
                                                if (data.image) setOriginalImage(data.image);
                                                if (data.displayImage) setDisplayImage(data.displayImage);
                                                if (data.images?.original) setOriginalImage(data.images.original);
                                                if (data.images?.preprocessed) setDisplayImage(data.images.preprocessed);
                                                if (data.preprocessing || data.images?.preprocessingSettings) 
                                                    setPreprocessing(data.preprocessing || data.images.preprocessingSettings);
                                                if (data.recognitionResults) setRecognitionResults(data.recognitionResults);
                                                if (data.detections) setRecognitionResults(data.detections.map(d => ({
                                                    glyph: d.glyph, confidence: d.confidence, position: d.position,
                                                    thumbnail: d.thumbnail, matchType: d.matchType,
                                                    corrected: d.corrected, originalGlyph: d.originalGlyph
                                                })));
                                                if (data.validations) setValidations(data.validations);
                                                if (data.changeLog) setChangeLog(data.changeLog);
                                                if (data.readingOrder) setReadingOrder(data.readingOrder);
                                                if (data.readingData?.readingOrder) setReadingOrder(data.readingData.readingOrder);
                                                if (data.wordBoundaries) setWordBoundaries(new Set(data.wordBoundaries));
                                                if (data.readingData?.wordBoundaries) setWordBoundaries(new Set(data.readingData.wordBoundaries));
                                                if (data.lineBreaks) setLineBreaks(new Set(data.lineBreaks));
                                                if (data.readingData?.lineBreaks) setLineBreaks(new Set(data.readingData.lineBreaks));
                                                if (data.translationEnglish || data.translations?.english)
                                                    setTranslationEnglish(data.translationEnglish || data.translations?.english || '');
                                                if (data.translationArabic || data.translations?.arabic)
                                                    setTranslationArabic(data.translationArabic || data.translations?.arabic || '');
                                                if (data.inscriptionTitle) setInscriptionTitle(data.inscriptionTitle);
                                                if (data.inscriptionNotes) setInscriptionNotes(data.inscriptionNotes);
                                                if (data.inscriptionComplete || data.complete) setInscriptionComplete(data.inscriptionComplete || data.complete);
                                                if (data.inscriptionId) setCurrentInscriptionId(data.inscriptionId);
                                                if (data.visibility) setVisibility(data.visibility);
                                                
                                                // Clear file tracking for local files
                                                setCurrentFileId(null);
                                                setFileOwner(null);
                                                setIsReadOnly(false);
                                                
                                                const detectionCount = data.recognitionResults?.length || data.detections?.length || 0;
                                                
                                                // Auto-switch to reading mode if detections exist
                                                if (detectionCount > 0) {
                                                    setViewMode('reading');
                                                }
                                                
                                                alert(`âœ… Loaded from local file!\n\nðŸ“Š ${detectionCount} detections`);
                                            } catch (err) {
                                                alert('âŒ Failed to load: ' + err.message);
                                            }
                                        };
                                        reader.readAsText(file);
                                    }}
                                    visibility={visibility}
                                    onVisibilityChange={(newVis) => setVisibility(newVis)}
                                    syncStatus={syncStatus}
                                    localSaveTime={localSaveTime}
                                    driveSignedIn={driveSignedIn}
                                    driveUserEmail={driveUserEmail}
                                    currentFileId={currentFileId}
                                    fileOwner={fileOwner}
                                    onSignIn={async () => {
                                        if (typeof DriveSync !== 'undefined') {
                                            await DriveSync.signIn();
                                            setDriveSignedIn(DriveSync.isSignedIn());
                                            setDriveUserEmail(DriveSync.getUserEmail());
                                        }
                                    }}
                                    imageRef={imageRef}
                                    className="bg-[#f7f3ed] border-2 border-ochre"
                                />
                        </div>
                    </main>
                    
                    {/* ===== GLYPH SELECTOR MODAL (for manual box or changing glyph) ===== */}
                    {showGlyphSelector && chartData && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[80vh] flex flex-col">
                                <div className="flex items-center justify-between p-4 border-b">
                                    <div>
                                        <h3 className="text-xl font-bold text-gray-900">ðŸ“‹ Select Glyph</h3>
                                        <p className="text-sm text-gray-500">
                                            {showGlyphSelector.mode === 'manual' 
                                                ? 'Choose which glyph this box represents' 
                                                : `Change glyph for detection #${showGlyphSelector.detectionIndex + 1}`}
                                        </p>
                                    </div>
                                    <button onClick={() => { setShowGlyphSelector(null); setManualBoxMode(false); setGlyphSelectorSearch(''); }} 
                                        className="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
                                </div>
                                
                                {/* Search */}
                                <div className="p-4 border-b">
                                    <input
                                        type="text"
                                        value={glyphSelectorSearch}
                                        placeholder="Search glyphs by name or transliteration..."
                                        className="w-full px-3 py-2 border rounded-lg"
                                        onChange={(e) => setGlyphSelectorSearch(e.target.value.toLowerCase())}
                                        autoFocus
                                    />
                                </div>
                                
                                {/* Glyph Grid */}
                                <div className="flex-1 overflow-y-auto p-4">
                                    <div className="grid grid-cols-4 sm:grid-cols-5 md:grid-cols-6 gap-2">
                                        {chartData.glyphs
                                            .filter(g => {
                                                if (!glyphSelectorSearch) return true;
                                                return (g.name?.toLowerCase().includes(glyphSelectorSearch) || 
                                                        g.transliteration?.toLowerCase().includes(glyphSelectorSearch) ||
                                                        g.arabic?.includes(glyphSelectorSearch));
                                            })
                                            .map(glyph => (
                                                <button
                                                    key={glyph.id}
                                                    onClick={() => {
                                                        if (showGlyphSelector.mode === 'manual') {
                                                            addManualDetection(glyph, showGlyphSelector.position);
                                                        } else {
                                                            // Change existing detection's glyph
                                                            changeGlyphAssignment(showGlyphSelector.detectionIndex, glyph);
                                                            setShowGlyphSelector(null);
                                                        }
                                                        setGlyphSelectorSearch('');
                                                    }}
                                                    className="p-2 border rounded-lg hover:border-ochre hover:bg-ochre/10 flex flex-col items-center gap-1 transition-colors"
                                                >
                                                    {glyphThumbnails[glyph.id] ? (
                                                        <img src={glyphThumbnails[glyph.id]} alt={glyph.name} 
                                                            className="w-10 h-10 object-contain" />
                                                    ) : (
                                                        <div className="w-10 h-10 bg-gray-100 rounded flex items-center justify-center text-gray-400">?</div>
                                                    )}
                                                    <span className="text-xs font-medium truncate w-full text-center">
                                                        {glyph.transliteration || glyph.name}
                                                    </span>
                                                </button>
                                            ))}
                                    </div>
                                </div>
                                
                                {/* Footer */}
                                <div className="p-4 border-t bg-gray-50 flex justify-between items-center">
                                    <span className="text-sm text-gray-500">
                                        {showGlyphSelector.mode === 'manual' 
                                            ? `Box: ${Math.round(showGlyphSelector.position?.width || 0)}Ã—${Math.round(showGlyphSelector.position?.height || 0)}px`
                                            : `Current: ${recognitionResults[showGlyphSelector.detectionIndex]?.glyph?.transliteration || '?'}`}
                                    </span>
                                    <button onClick={() => { setShowGlyphSelector(null); setManualBoxMode(false); setGlyphSelectorSearch(''); }}
                                        className="px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300">
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* ===== CHART MANAGER MODAL ===== */}
                    {showChartManager && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-5xl max-h-[90vh] flex flex-col">
                                {/* Header */}
                                <div className="flex items-center justify-between p-4 border-b">
                                    <div>
                                        <h3 className="text-xl font-bold text-gray-900">ðŸ“Š Glyph Chart Manager</h3>
                                        <p className="text-sm text-gray-500">
                                            {chartData?.glyphs?.length || 0} glyphs Â· {(() => {
                                                const total = chartData?.glyphs?.reduce((sum, g) => {
                                                    return sum + (g.images?.primary ? 1 : 0) + (g.images?.variants?.length || 0) + (g.images?.examples?.length || 0);
                                                }, 0) || 0;
                                                return total;
                                            })()} templates
                                        </p>
                                    </div>
                                    <button onClick={() => setShowChartManager(false)} className="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
                                </div>
                                
                                {/* Toolbar */}
                                <div className="p-4 border-b flex flex-wrap gap-3 items-center">
                                    <button
                                        onClick={() => {
                                            setGlyphEditorMode('add');
                                            setEditingGlyph(null);
                                            setShowGlyphEditor(true);
                                        }}
                                        className="px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5a7d6e]"
                                    >
                                        âž• Add New Glyph
                                    </button>
                                    <button
                                        onClick={() => {
                                            const blob = new Blob([JSON.stringify(chartData, null, 2)], { type: 'application/json' });
                                            const url = URL.createObjectURL(blob);
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.download = `Hakli_glyphs_${new Date().toISOString().slice(0,10)}.JSON`;
                                            a.click();
                                            URL.revokeObjectURL(url);
                                            setChartModified(false);
                                            setLastSavedTime(new Date());
                                            alert('âœ… Chart exported!');
                                        }}
                                        className={`px-4 py-2 rounded-lg hover:bg-[#4a3d5a] ${chartModified ? 'bg-ochre text-white' : 'bg-ancient-purple text-white'}`}
                                    >
                                        {chartModified ? 'âš ï¸ Export Chart*' : 'ðŸ“¥ Export Chart'}
                                    </button>
                                    <button
                                        onClick={() => {
                                            // Generate print-friendly equivalence chart
                                            const printWindow = window.open('', '_blank');
                                            const glyphs = chartData?.glyphs || [];
                                            
                                            const html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hakli Glyph Equivalence Chart</title>
    <style>
        @page { size: A4; margin: 1cm; }
        body { 
            font-family: Arial, sans-serif; 
            max-width: 900px; 
            margin: 0 auto; 
            padding: 20px;
        }
        h1 { 
            text-align: center; 
            color: #4a3d5a; 
            border-bottom: 3px solid #4a3d5a;
            padding-bottom: 10px;
        }
        .meta { 
            text-align: center; 
            color: #666; 
            margin-bottom: 30px;
            font-size: 14px;
        }
        .chart-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
        }
        .chart-columns > table:first-child {
            border-right: 2px solid #ddd;
            padding-right: 20px;
        }
        table { 
            width: 100%; 
            border-collapse: collapse; 
        }
        th { 
            background: #4a3d5a; 
            color: white; 
            padding: 8px 6px; 
            text-align: left;
            font-weight: bold;
            font-size: 12px;
        }
        td { 
            padding: 6px; 
            border-bottom: 1px solid #ddd;
            vertical-align: middle;
        }
        tr:hover { background: #f5f5f5; }
        .glyph-img { 
            max-width: 40px; 
            max-height: 40px; 
            vertical-align: middle;
        }
        .transliteration { 
            font-size: 16px; 
            font-weight: bold; 
            color: #2d5a3d;
        }
        .arabic { 
            font-size: 20px; 
            font-family: 'Traditional Arabic', 'Arabic Typesetting', 'Scheherazade', sans-serif;
            direction: rtl;
            text-align: center;
            color: #b87333;
            width: 50px;
        }
        .footer { 
            margin-top: 40px; 
            text-align: center; 
            color: #999; 
            font-size: 12px;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
        @media print {
            button { display: none; }
            .no-print { display: none; }
        }
    </style>
</head>
<body>
    <h1>ðŸ“œ Hakli Glyph Equivalence Chart</h1>
    <div class="meta">
        <p>Based on Ahmad Al-Jallad (2025), <em>The Decipherment of the Dhofari Script</em></p>
        <p>Generated: ${new Date().toLocaleDateString()} Â· ${glyphs.length} glyphs</p>
        <button class="no-print" onclick="window.print()" style="padding: 10px 20px; background: #4a3d5a; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">ðŸ–¨ï¸ Print</button>
    </div>
    
    <div class="chart-columns">
        <table>
            <thead>
                <tr>
                    <th style="width: 50px;">Glyph</th>
                    <th>Trans.</th>
                    <th style="width: 50px;">Arabic</th>
                </tr>
            </thead>
            <tbody>
                ${glyphs.slice(0, Math.ceil(glyphs.length / 2)).map(glyph => {
                    const imgSrc = glyph.images?.primary || '';
                    const translit = glyph.transliteration || glyph.name || '';
                    const arabic = glyph.arabic || '';
                    
                    return `
                        <tr>
                            <td>${imgSrc ? `<img src="${imgSrc}" class="glyph-img" alt="${glyph.name}">` : 'â€”'}</td>
                            <td class="transliteration">${translit}</td>
                            <td class="arabic">${arabic}</td>
                        </tr>
                    `;
                }).join('')}
            </tbody>
        </table>
        <table>
            <thead>
                <tr>
                    <th style="width: 50px;">Glyph</th>
                    <th>Trans.</th>
                    <th style="width: 50px;">Arabic</th>
                </tr>
            </thead>
            <tbody>
                ${glyphs.slice(Math.ceil(glyphs.length / 2)).map(glyph => {
                    const imgSrc = glyph.images?.primary || '';
                    const translit = glyph.transliteration || glyph.name || '';
                    const arabic = glyph.arabic || '';
                    
                    return `
                        <tr>
                            <td>${imgSrc ? `<img src="${imgSrc}" class="glyph-img" alt="${glyph.name}">` : 'â€”'}</td>
                            <td class="transliteration">${translit}</td>
                            <td class="arabic">${arabic}</td>
                        </tr>
                    `;
                }).join('')}
            </tbody>
        </table>
    </div>
    
    <div class="footer">
        <p>Â© hoopoe holdings Â· Hakli Glyph Recognizer Â· ${new Date().getFullYear()}</p>
    </div>
</body>
</html>`;
                                            
                                            printWindow.document.write(html);
                                            printWindow.document.close();
                                        }}
                                        className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700"
                                    >
                                        ðŸ–¨ï¸ Print Chart
                                    </button>
                                    {recognitionResults.length > 0 && (
                                        <button
                                            onClick={() => {
                                                if (templateTrainingMode) {
                                                    setFocusedGlyphId(null);
                                                }
                                                setTemplateTrainingMode(!templateTrainingMode);
                                            }}
                                            className={`px-4 py-2 rounded-lg font-medium ${
                                                templateTrainingMode 
                                                    ? 'bg-ochre text-white' 
                                                    : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                            }`}
                                        >
                                            ðŸŽ“ {templateTrainingMode ? 'Hide' : 'Show'} Training ({recognitionResults.length})
                                        </button>
                                    )}
                                </div>
                                
                                {/* Training Mode Panel - Focus on one glyph at a time */}
                                {templateTrainingMode && (
                                    <div className="border-b bg-ancient-purple/5 p-4">
                                        {!focusedGlyphId ? (
                                            <div className="text-center text-gray-600">
                                                <p className="font-semibold mb-1">ðŸŽ“ Training Mode Active</p>
                                                <p className="text-sm">Click a glyph below to focus on it and add templates</p>
                                                {recognitionResults.length > 0 && (
                                                    <p className="text-xs text-ancient-purple mt-2">
                                                        {recognitionResults.length} detection{recognitionResults.length !== 1 ? 's' : ''} available to add
                                                    </p>
                                                )}
                                            </div>
                                        ) : (() => {
                                            const glyph = chartData?.glyphs?.find(g => g.id === focusedGlyphId);
                                            if (!glyph) return null;
                                            
                                            const matchingDetections = recognitionResults
                                                .map((r, idx) => ({ ...r, detectionIdx: idx }))
                                                .filter(r => r.glyph.id === focusedGlyphId);
                                            
                                            const hasPrimary = !!(glyph.images?.primary);
                                            const variants = glyph.images?.variants || [];
                                            const examples = glyph.images?.examples || [];
                                            
                                            return (
                                                <div>
                                                    {/* Focused glyph header */}
                                                    <div className="flex items-center justify-between mb-3">
                                                        <div className="flex items-center gap-3">
                                                            <div className="w-12 h-12 bg-gray-100 rounded flex items-center justify-center overflow-hidden">
                                                                {glyphThumbnails[glyph.id] ? (
                                                                    <img src={glyphThumbnails[glyph.id]} alt="" className="max-w-full max-h-full object-contain" />
                                                                ) : (
                                                                    <span className="text-2xl text-ancient-purple">{glyph.arabic}</span>
                                                                )}
                                                            </div>
                                                            <div>
                                                                <div className="font-bold text-lg">{glyph.name} <span className="text-ancient-purple">{glyph.arabic}</span></div>
                                                                <div className="text-xs text-gray-500">
                                                                    ðŸŽ¯{hasPrimary ? 'âœ“' : 'â€”'} â­{variants.length} ðŸ“š{examples.length}
                                                                </div>
                                                            </div>
                                                        </div>
                                                        <button 
                                                            onClick={() => setFocusedGlyphId(null)}
                                                            className="px-3 py-1 bg-gray-200 rounded text-sm hover:bg-gray-300"
                                                        >
                                                            â† Back to Chart
                                                        </button>
                                                    </div>
                                                    
                                                    <div className="grid grid-cols-2 gap-4">
                                                        {/* Current Templates */}
                                                        <div>
                                                            <h5 className="font-semibold text-sm mb-2 text-gray-700">Current Templates ({(hasPrimary ? 1 : 0) + variants.length + examples.length})</h5>
                                                            <div className="flex flex-wrap gap-2 max-h-40 overflow-y-auto">
                                                                {hasPrimary && (
                                                                    <div className="w-14 h-14 border-2 border-stone rounded overflow-hidden bg-gray-50 relative group" title="Primary">
                                                                        <img src={glyph.images.primary} alt="Primary" className="w-full h-full object-contain" />
                                                                        <span className="absolute bottom-0 left-0 right-0 text-[8px] bg-stone text-white text-center">ðŸŽ¯</span>
                                                                        <button 
                                                                            onClick={(e) => { e.stopPropagation(); deleteTemplate(glyph.id, 'primary'); }}
                                                                            className="absolute top-0 right-0 w-4 h-4 bg-rust text-white text-[10px] rounded-bl opacity-0 group-hover:opacity-100 transition-opacity"
                                                                            title="Delete primary"
                                                                        >Ã—</button>
                                                                    </div>
                                                                )}
                                                                {variants.map((v, i) => (
                                                                    <div key={`v-${i}`} className="w-14 h-14 border-2 border-patina rounded overflow-hidden bg-gray-50 relative group" title={`Variant ${i+1}`}>
                                                                        <img src={v} alt={`Variant ${i+1}`} className="w-full h-full object-contain" />
                                                                        <span className="absolute bottom-0 left-0 right-0 text-[8px] bg-patina text-white text-center">â­{i+1}</span>
                                                                        <button 
                                                                            onClick={(e) => { e.stopPropagation(); deleteTemplate(glyph.id, 'variant', i); }}
                                                                            className="absolute top-0 right-0 w-4 h-4 bg-rust text-white text-[10px] rounded-bl opacity-0 group-hover:opacity-100 transition-opacity"
                                                                            title={`Delete variant ${i+1}`}
                                                                        >Ã—</button>
                                                                    </div>
                                                                ))}
                                                                {examples.map((e, i) => (
                                                                    <div key={`e-${i}`} className="w-14 h-14 border-2 border-ochre rounded overflow-hidden bg-gray-50 relative group" title={`Example ${i+1}`}>
                                                                        <img src={e} alt={`Example ${i+1}`} className="w-full h-full object-contain" />
                                                                        <span className="absolute bottom-0 left-0 right-0 text-[8px] bg-ochre text-white text-center">ðŸ“š{i+1}</span>
                                                                        <button 
                                                                            onClick={(e) => { e.stopPropagation(); deleteTemplate(glyph.id, 'example', i); }}
                                                                            className="absolute top-0 right-0 w-4 h-4 bg-rust text-white text-[10px] rounded-bl opacity-0 group-hover:opacity-100 transition-opacity"
                                                                            title={`Delete example ${i+1}`}
                                                                        >Ã—</button>
                                                                    </div>
                                                                ))}
                                                                {!hasPrimary && variants.length === 0 && examples.length === 0 && (
                                                                    <div className="text-gray-400 text-xs">No templates yet</div>
                                                                )}
                                                            </div>
                                                        </div>
                                                        
                                                        {/* Matching Detections */}
                                                        <div>
                                                            <h5 className="font-semibold text-sm mb-2 text-gray-700">
                                                                Matching Detections ({matchingDetections.length})
                                                                {recognitionResults.length > 0 && matchingDetections.length === 0 && (
                                                                    <span className="font-normal text-gray-400 ml-1">- none match this glyph</span>
                                                                )}
                                                            </h5>
                                                            {matchingDetections.length > 0 ? (
                                                                <div className="flex flex-wrap gap-2 max-h-40 overflow-y-auto">
                                                                    {matchingDetections.map((det) => (
                                                                        <div key={det.detectionIdx} className="bg-white border rounded p-2 shadow-sm">
                                                                            <div className="w-16 h-16 bg-gray-100 rounded overflow-hidden mb-1">
                                                                                {det.thumbnail ? (
                                                                                    <img src={det.thumbnail} alt="" className="w-full h-full object-contain" />
                                                                                ) : (
                                                                                    <div className="w-full h-full flex items-center justify-center text-gray-400 text-xs">?</div>
                                                                                )}
                                                                            </div>
                                                                            <div className="text-[10px] text-gray-500 text-center mb-1">
                                                                                #{det.detectionIdx + 1} Â· {Math.round(det.confidence * 100)}%
                                                                            </div>
                                                                            <div className="flex gap-0.5 justify-center">
                                                                                <button
                                                                                    onClick={() => saveAsTemplate(det.detectionIdx, 'primary')}
                                                                                    className={`px-1 py-0.5 text-white text-[9px] rounded ${hasPrimary ? 'bg-stone/70' : 'bg-stone ring-1 ring-ochre'}`}
                                                                                    title={hasPrimary ? 'Replace primary (old moves to variants)' : 'Set as primary template'}
                                                                                >
                                                                                    ðŸŽ¯
                                                                                </button>
                                                                                <button
                                                                                    onClick={() => saveAsTemplate(det.detectionIdx, 'variant')}
                                                                                    className="px-1 py-0.5 bg-patina text-white text-[9px] rounded"
                                                                                    title="Add as variant (alternate form used in matching)"
                                                                                >
                                                                                    â­
                                                                                </button>
                                                                                <button
                                                                                    onClick={() => saveAsTemplate(det.detectionIdx, 'example')}
                                                                                    className="px-1 py-0.5 bg-ochre text-white text-[9px] rounded"
                                                                                    title="Add as example (reference only, not used in matching)"
                                                                                >
                                                                                    ðŸ“š
                                                                                </button>
                                                                            </div>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            ) : (
                                                                <div className="text-gray-400 text-xs">
                                                                    {recognitionResults.length === 0 
                                                                        ? 'Run detection first to find templates to add' 
                                                                        : 'No detections match this glyph'}
                                                                </div>
                                                            )}
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                        })()}
                                    </div>
                                )}
                                
                                {/* View Tabs */}
                                <div className="px-4 pt-4 border-b">
                                    <div className="flex gap-1 mb-3">
                                        {[
                                            { id: 'glyphs', label: 'By Glyph', count: chartData?.glyphs?.length || 0 },
                                            { id: 'primary', label: 'ðŸŽ¯ Primary', count: chartData?.glyphs?.filter(g => g.images?.primary).length || 0 },
                                            { id: 'variants', label: 'â­ Variants', count: chartData?.glyphs?.reduce((sum, g) => sum + (g.images?.variants?.length || 0), 0) || 0 },
                                            { id: 'examples', label: 'ðŸ“š Examples', count: chartData?.glyphs?.reduce((sum, g) => sum + (g.images?.examples?.length || 0), 0) || 0 },
                                        ].map(tab => (
                                            <button
                                                key={tab.id}
                                                onClick={() => setChartViewMode(tab.id)}
                                                className={`px-3 py-1.5 rounded-t text-sm font-medium transition-colors ${
                                                    chartViewMode === tab.id
                                                        ? 'bg-ancient-purple text-white'
                                                        : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                                }`}
                                            >
                                                {tab.label} ({tab.count})
                                            </button>
                                        ))}
                                    </div>
                                </div>
                                
                                {/* Glyph Grid - By Glyph View */}
                                <div className="flex-1 overflow-y-auto p-4">
                                    {chartViewMode === 'glyphs' && (
                                        <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-3">
                                            {chartData?.glyphs?.map((glyph) => {
                                                const primaryCount = glyph.images?.primary ? 1 : 0;
                                                const variantCount = glyph.images?.variants?.length || 0;
                                                const exampleCount = glyph.images?.examples?.length || 0;
                                                const totalImages = primaryCount + variantCount + exampleCount;
                                                
                                                return (
                                                    <div
                                                        key={glyph.id}
                                                        className={`border rounded-lg p-2 hover:border-ancient-purple hover:shadow cursor-pointer transition-all ${
                                                            templateTrainingMode && focusedGlyphId === glyph.id 
                                                                ? 'border-ancient-purple ring-2 ring-ancient-purple bg-ancient-purple/10' 
                                                                : templateTrainingMode && recognitionResults.some(r => r.glyph.id === glyph.id)
                                                                    ? 'border-ochre bg-ochre/10'
                                                                    : 'border-gray-200'
                                                        }`}
                                                        onClick={() => {
                                                            if (templateTrainingMode) {
                                                                setFocusedGlyphId(glyph.id);
                                                            } else {
                                                                setGlyphEditorMode('edit');
                                                                setEditingGlyph(glyph);
                                                                setShowGlyphEditor(true);
                                                            }
                                                        }}
                                                    >
                                                        <div className="aspect-square bg-gray-100 rounded flex items-center justify-center mb-1 overflow-hidden relative">
                                                            {glyphThumbnails[glyph.id] ? (
                                                                <img src={glyphThumbnails[glyph.id]} alt={glyph.name} className="max-w-full max-h-full object-contain" />
                                                            ) : (
                                                                <span className="text-gray-400 text-xs">?</span>
                                                            )}
                                                            {/* Show detection count badge in training mode */}
                                                            {templateTrainingMode && (() => {
                                                                const count = recognitionResults.filter(r => r.glyph.id === glyph.id).length;
                                                                return count > 0 ? (
                                                                    <span className="absolute top-0 right-0 bg-ochre text-white text-[10px] px-1 rounded-bl font-bold">
                                                                        +{count}
                                                                    </span>
                                                                ) : null;
                                                            })()}
                                                        </div>
                                                        <div className="text-center">
                                                            <div className="text-xs font-medium text-gray-700 truncate">{glyph.name}</div>
                                                            <div className="text-lg text-ancient-purple leading-tight">{glyph.arabic || glyph.transliteration}</div>
                                                            <div className="text-[10px] text-gray-400">
                                                                {totalImages} template{totalImages !== 1 ? 's' : ''}
                                                            </div>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                    
                                    {/* Primary Templates View */}
                                    {chartViewMode === 'primary' && (
                                        <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-3">
                                            {chartData?.glyphs?.filter(g => g.images?.primary).map((glyph) => (
                                                <div
                                                    key={glyph.id}
                                                    className={`border rounded-lg p-2 hover:border-ancient-purple hover:shadow cursor-pointer transition-all bg-stone/5 ${
                                                        templateTrainingMode && focusedGlyphId === glyph.id 
                                                            ? 'border-ancient-purple ring-2 ring-ancient-purple' 
                                                            : 'border-stone'
                                                    }`}
                                                    onClick={() => {
                                                        if (templateTrainingMode) {
                                                            setFocusedGlyphId(glyph.id);
                                                        } else {
                                                            setGlyphEditorMode('edit');
                                                            setEditingGlyph(glyph);
                                                            setShowGlyphEditor(true);
                                                        }
                                                    }}
                                                >
                                                    <div className="aspect-square bg-gray-100 rounded flex items-center justify-center mb-1 overflow-hidden">
                                                        <img src={glyph.images.primary} alt={glyph.name} className="max-w-full max-h-full object-contain" />
                                                    </div>
                                                    <div className="text-center">
                                                        <div className="text-xs font-medium text-gray-700 truncate">{glyph.name}</div>
                                                        <div className="text-sm text-ancient-purple">{glyph.arabic}</div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    
                                    {/* Variants View */}
                                    {chartViewMode === 'variants' && (
                                        <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-3">
                                            {chartData?.glyphs?.flatMap((glyph) => 
                                                (glyph.images?.variants || []).map((variant, idx) => (
                                                    <div
                                                        key={`${glyph.id}-var-${idx}`}
                                                        className={`border rounded-lg p-2 hover:border-ancient-purple hover:shadow cursor-pointer transition-all bg-patina/5 ${
                                                            templateTrainingMode && focusedGlyphId === glyph.id 
                                                                ? 'border-ancient-purple ring-2 ring-ancient-purple' 
                                                                : 'border-patina'
                                                        }`}
                                                        onClick={() => {
                                                            if (templateTrainingMode) {
                                                                setFocusedGlyphId(glyph.id);
                                                            } else {
                                                                setGlyphEditorMode('edit');
                                                                setEditingGlyph(glyph);
                                                                setShowGlyphEditor(true);
                                                            }
                                                        }}
                                                    >
                                                        <div className="aspect-square bg-gray-100 rounded flex items-center justify-center mb-1 overflow-hidden">
                                                            <img src={variant} alt={`${glyph.name} variant ${idx + 1}`} className="max-w-full max-h-full object-contain" />
                                                        </div>
                                                        <div className="text-center">
                                                            <div className="text-xs font-medium text-gray-700 truncate">{glyph.name}</div>
                                                            <div className="text-sm text-ancient-purple">{glyph.arabic}</div>
                                                            <div className="text-[10px] text-patina">var #{idx + 1}</div>
                                                        </div>
                                                    </div>
                                                ))
                                            )}
                                        </div>
                                    )}
                                    
                                    {/* Examples View */}
                                    {chartViewMode === 'examples' && (
                                        <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-3">
                                            {chartData?.glyphs?.flatMap((glyph) => 
                                                (glyph.images?.examples || []).map((example, idx) => (
                                                    <div
                                                        key={`${glyph.id}-ex-${idx}`}
                                                        className={`border rounded-lg p-2 hover:border-ancient-purple hover:shadow cursor-pointer transition-all bg-ochre/5 ${
                                                            templateTrainingMode && focusedGlyphId === glyph.id 
                                                                ? 'border-ancient-purple ring-2 ring-ancient-purple' 
                                                                : 'border-ochre'
                                                        }`}
                                                        onClick={() => {
                                                            if (templateTrainingMode) {
                                                                setFocusedGlyphId(glyph.id);
                                                            } else {
                                                                setGlyphEditorMode('edit');
                                                                setEditingGlyph(glyph);
                                                                setShowGlyphEditor(true);
                                                            }
                                                        }}
                                                    >
                                                        <div className="aspect-square bg-gray-100 rounded flex items-center justify-center mb-1 overflow-hidden">
                                                            <img src={example} alt={`${glyph.name} example ${idx + 1}`} className="max-w-full max-h-full object-contain" />
                                                        </div>
                                                        <div className="text-center">
                                                            <div className="text-xs font-medium text-gray-700 truncate">{glyph.name}</div>
                                                            <div className="text-sm text-ancient-purple">{glyph.arabic}</div>
                                                            <div className="text-[10px] text-ochre">ex #{idx + 1}</div>
                                                        </div>
                                                    </div>
                                                ))
                                            )}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* ===== GLYPH EDITOR MODAL ===== */}
                    {showGlyphEditor && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[60] p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg max-h-[90vh] flex flex-col">
                                <div className="flex items-center justify-between p-4 border-b">
                                    <h3 className="text-xl font-bold">{glyphEditorMode === 'add' ? 'âž• Add New Glyph' : 'âœï¸ Edit Glyph'}</h3>
                                    <button onClick={() => setShowGlyphEditor(false)} className="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
                                </div>
                                
                                <div className="flex-1 overflow-y-auto p-4 space-y-4">
                                    {/* Form fields */}
                                    <GlyphEditorForm
                                        mode={glyphEditorMode}
                                        glyph={editingGlyph}
                                        chartData={chartData}
                                        setChartData={setChartData}
                                        setChartModified={setChartModified}
                                        loadedGlyphImages={loadedGlyphImages}
                                        setLoadedGlyphImages={setLoadedGlyphImages}
                                        glyphThumbnails={glyphThumbnails}
                                        setGlyphThumbnails={setGlyphThumbnails}
                                        onClose={() => setShowGlyphEditor(false)}
                                    />
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* ===== REGION EDITOR MODAL ===== */}
                    {regionEditorIdx !== null && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[60] p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col">
                                <div className="flex items-center justify-between p-4 border-b">
                                    <div>
                                        <h3 className="text-xl font-bold">âœï¸ Edit Region #{regionEditorIdx + 1}</h3>
                                        <p className="text-sm text-gray-500">Clean up thumbnail only (main image stays intact)</p>
                                    </div>
                                    <button onClick={() => setRegionEditorIdx(null)} className="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
                                </div>
                                
                                <div className="flex-1 overflow-auto p-4">
                                    {/* Brush size control */}
                                    <div className="mb-4">
                                        <div className="flex justify-between text-sm text-gray-600 mb-1">
                                            <span>ðŸ–Œï¸ Eraser Size</span>
                                            <span>{regionEditorSize}px</span>
                                        </div>
                                        <input type="range" min="3" max="30" value={regionEditorSize}
                                            onChange={(e) => setRegionEditorSize(parseInt(e.target.value))}
                                            className="w-full" />
                                    </div>
                                    
                                    {/* Canvas for editing */}
                                    <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 flex items-center justify-center">
                                        <canvas 
                                            ref={regionEditorCanvasRef}
                                            className="max-w-full border border-gray-200 bg-white"
                                            style={{ 
                                                imageRendering: 'pixelated',
                                                cursor: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="${regionEditorSize * 2 + 2}" height="${regionEditorSize * 2 + 2}" viewBox="0 0 ${regionEditorSize * 2 + 2} ${regionEditorSize * 2 + 2}"><circle cx="${regionEditorSize + 1}" cy="${regionEditorSize + 1}" r="${regionEditorSize}" fill="none" stroke="black" stroke-width="1.5"/><circle cx="${regionEditorSize + 1}" cy="${regionEditorSize + 1}" r="${regionEditorSize}" fill="none" stroke="white" stroke-width="0.5"/><line x1="${regionEditorSize + 1}" y1="${regionEditorSize - 4}" x2="${regionEditorSize + 1}" y2="${regionEditorSize + 7}" stroke="black" stroke-width="1"/><line x1="${regionEditorSize - 4}" y1="${regionEditorSize + 1}" x2="${regionEditorSize + 7}" y2="${regionEditorSize + 1}" stroke="black" stroke-width="1"/></svg>') ${regionEditorSize + 1} ${regionEditorSize + 1}, crosshair`
                                            }}
                                            onMouseDown={handleRegionEditorStart}
                                            onMouseMove={handleRegionEditorDraw}
                                            onMouseUp={handleRegionEditorEnd}
                                            onMouseLeave={handleRegionEditorEnd}
                                        />
                                    </div>
                                    
                                    <p className="text-xs text-gray-400 mt-2 text-center">
                                        Erase stray marks to clean up the thumbnail. The main image display won't change.
                                    </p>
                                </div>
                                
                                <div className="flex justify-end gap-2 p-4 border-t">
                                    <button onClick={() => setRegionEditorIdx(null)}
                                        className="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg">
                                        Cancel
                                    </button>
                                    <button onClick={() => { initRegionEditorCanvas(); }}
                                        className="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg">
                                        ðŸ”„ Reset
                                    </button>
                                    <button onClick={applyRegionEdit}
                                        className="px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5a7d6e]">
                                        âœ… Apply Changes
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* ===== UNLOCK MODAL (Access Control) ===== */}
                    {showUnlockModal && pendingHkiData && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[70] p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md">
                                <div className="p-6">
                                    <div className="text-center mb-6">
                                        <div className="w-16 h-16 bg-ancient-purple/10 rounded-full flex items-center justify-center mx-auto mb-4">
                                            <span className="text-3xl">ðŸ”’</span>
                                        </div>
                                        <h3 className="text-xl font-bold text-gray-900">Unlock Editing</h3>
                                        <p className="text-gray-600 mt-2">
                                            Enter your keyword to edit<br />
                                            <span className="font-medium text-ancient-purple">{pendingHkiData.inscriptionTitle || 'this inscription'}</span>
                                        </p>
                                    </div>

                                    <form onSubmit={(e) => {
                                        e.preventDefault();
                                        const keyword = e.target.keyword.value;
                                        
                                        if (typeof AccessControl !== 'undefined') {
                                            const user = AccessControl.authenticate(pendingHkiData.accessControl, keyword);
                                            
                                            if (user) {
                                                // Load with edit access
                                                setCurrentUser(user);
                                                setIsReadOnly(!user.permissions.includes('edit'));
                                                
                                                // Load the data
                                                const data = pendingHkiData;
                                                if (data.image) setOriginalImage(data.image);
                                                if (data.displayImage) setDisplayImage(data.displayImage);
                                                if (data.images?.original) setOriginalImage(data.images.original);
                                                if (data.images?.preprocessed) setDisplayImage(data.images.preprocessed);
                                                if (data.preprocessing || data.images?.preprocessingSettings) 
                                                    setPreprocessing(data.preprocessing || data.images.preprocessingSettings);
                                                if (data.recognitionResults) setRecognitionResults(data.recognitionResults);
                                                if (data.detections) setRecognitionResults(data.detections.map(d => ({
                                                    glyph: d.glyph, confidence: d.confidence, position: d.position,
                                                    thumbnail: d.thumbnail, matchType: d.matchType,
                                                    corrected: d.corrected, originalGlyph: d.originalGlyph
                                                })));
                                                if (data.validations) setValidations(data.validations);
                                                if (data.changeLog) setChangeLog(data.changeLog);
                                                if (data.readingOrder) setReadingOrder(data.readingOrder);
                                                if (data.readingData?.readingOrder) setReadingOrder(data.readingData.readingOrder);
                                                if (data.wordBoundaries) setWordBoundaries(new Set(data.wordBoundaries));
                                                if (data.readingData?.wordBoundaries) setWordBoundaries(new Set(data.readingData.wordBoundaries));
                                                if (data.lineBreaks) setLineBreaks(new Set(data.lineBreaks));
                                                if (data.readingData?.lineBreaks) setLineBreaks(new Set(data.readingData.lineBreaks));
                                                if (data.translationEnglish || data.translations?.english)
                                                    setTranslationEnglish(data.translationEnglish || data.translations?.english || '');
                                                if (data.translationArabic || data.translations?.arabic)
                                                    setTranslationArabic(data.translationArabic || data.translations?.arabic || '');
                                                if (data.inscriptionTitle) setInscriptionTitle(data.inscriptionTitle);
                                                if (data.inscriptionNotes) setInscriptionNotes(data.inscriptionNotes);
                                                if (data.inscriptionComplete || data.complete) setInscriptionComplete(data.inscriptionComplete || data.complete);
                                                if (data.inscriptionId) setCurrentInscriptionId(data.inscriptionId);
                                                if (data.accessControl) setAccessControl(data.accessControl);
                                                if (data.visibility) setVisibility(data.visibility);
                                                
                                                setShowUnlockModal(false);
                                                setPendingHkiData(null);
                                                
                                                const detectionCount = data.detections?.length || data.recognitionResults?.length || 0;
                                                
                                                // Auto-switch to reading mode if detections exist
                                                if (detectionCount > 0) {
                                                    setViewMode('reading');
                                                }
                                                
                                                alert(`âœ… Loaded as ${user.name} (${user.role})\n\nðŸ“Š ${detectionCount} detections`);
                                            } else {
                                                alert('âŒ Invalid keyword');
                                            }
                                        }
                                    }}>
                                        <div className="mb-4">
                                            <input
                                                type="password"
                                                name="keyword"
                                                placeholder="Enter your keyword"
                                                className="w-full px-4 py-3 border-2 border-gray-200 rounded-lg focus:border-ancient-purple focus:ring-2 focus:ring-ancient-purple/20 outline-none text-center text-lg"
                                                autoFocus
                                            />
                                        </div>

                                        <div className="flex gap-3">
                                            <button
                                                type="button"
                                                onClick={() => {
                                                    // Load in read-only mode
                                                    const data = pendingHkiData;
                                                    if (data.image) setOriginalImage(data.image);
                                                    if (data.displayImage) setDisplayImage(data.displayImage);
                                                    if (data.images?.original) setOriginalImage(data.images.original);
                                                    if (data.images?.preprocessed) setDisplayImage(data.images.preprocessed);
                                                    if (data.preprocessing || data.images?.preprocessingSettings) 
                                                        setPreprocessing(data.preprocessing || data.images.preprocessingSettings);
                                                    if (data.recognitionResults) setRecognitionResults(data.recognitionResults);
                                                    if (data.detections) setRecognitionResults(data.detections.map(d => ({
                                                        glyph: d.glyph, confidence: d.confidence, position: d.position,
                                                        thumbnail: d.thumbnail, matchType: d.matchType
                                                    })));
                                                    if (data.validations) setValidations(data.validations);
                                                    if (data.changeLog) setChangeLog(data.changeLog);
                                                    if (data.readingOrder) setReadingOrder(data.readingOrder);
                                                    if (data.readingData?.readingOrder) setReadingOrder(data.readingData.readingOrder);
                                                    if (data.wordBoundaries) setWordBoundaries(new Set(data.wordBoundaries));
                                                    if (data.readingData?.wordBoundaries) setWordBoundaries(new Set(data.readingData.wordBoundaries));
                                                    if (data.lineBreaks) setLineBreaks(new Set(data.lineBreaks));
                                                    if (data.readingData?.lineBreaks) setLineBreaks(new Set(data.readingData.lineBreaks));
                                                    if (data.translationEnglish || data.translations?.english)
                                                        setTranslationEnglish(data.translationEnglish || data.translations?.english || '');
                                                    if (data.translationArabic || data.translations?.arabic)
                                                        setTranslationArabic(data.translationArabic || data.translations?.arabic || '');
                                                    if (data.inscriptionTitle) setInscriptionTitle(data.inscriptionTitle);
                                                    if (data.inscriptionNotes) setInscriptionNotes(data.inscriptionNotes);
                                                    if (data.inscriptionComplete || data.complete) setInscriptionComplete(data.inscriptionComplete || data.complete);
                                                    if (data.inscriptionId) setCurrentInscriptionId(data.inscriptionId);
                                                    if (data.accessControl) setAccessControl(data.accessControl);
                                                    if (data.visibility) setVisibility(data.visibility);
                                                    
                                                    setIsReadOnly(true);
                                                    setShowUnlockModal(false);
                                                    setPendingHkiData(null);
                                                    
                                                    const detectionCount = data.detections?.length || data.recognitionResults?.length || 0;
                                                    
                                                    // Auto-switch to reading mode if detections exist
                                                    if (detectionCount > 0) {
                                                        setViewMode('reading');
                                                    }
                                                    
                                                    alert(`âœ… Loaded in read-only mode\n\nðŸ“Š ${detectionCount} detections`);
                                                }}
                                                className="flex-1 px-4 py-3 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 font-medium"
                                            >
                                                View Only
                                            </button>
                                            <button
                                                type="submit"
                                                className="flex-1 px-4 py-3 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3d5a] font-medium"
                                            >
                                                ðŸ”“ Unlock
                                            </button>
                                        </div>
                                    </form>
                                </div>

                                <div className="px-6 py-4 bg-gray-50 rounded-b-xl border-t border-gray-100">
                                    <p className="text-xs text-gray-500 text-center">
                                        ðŸ’¡ Don't have a keyword? Contact the inscription owner to request edit access.
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* ===== QUICK START MODAL ===== */}
                    {showQuickStart && (
                        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-[70] p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col overflow-hidden">
                                {/* Header */}
                                <div className="bg-gradient-to-r from-ancient-purple to-stone p-6 text-white">
                                    <h2 className="text-2xl font-bold mb-1">ðŸº Welcome to Hakli Glyph Recognizer</h2>
                                    <p className="text-white/80 text-sm">A tool for documenting ancient Dhofari script inscriptions</p>
                                </div>
                                
                                {/* Steps */}
                                <div className="flex-1 overflow-y-auto p-6">
                                    {[
                                        {
                                            icon: 'ðŸ“·',
                                            title: '1. Load an Image',
                                            desc: 'Click "Change Image" to upload a photo of an inscription. Works best with clear, well-lit images.',
                                            tip: 'Tip: Crop to just the inscription area for better results.'
                                        },
                                        {
                                            icon: 'ðŸ”§',
                                            title: '2. Preprocess',
                                            desc: 'Adjust rotation to align text horizontally. Use the Eraser Tool to remove noise or unwanted marks.',
                                            tip: 'Tip: The rotation slider helps compensate for camera angle.'
                                        },
                                        {
                                            icon: 'ðŸ”',
                                            title: '3. Recognize Glyphs',
                                            desc: 'Click "Recognize Glyphs" to detect symbols. The system matches against the glyph chart templates.',
                                            tip: 'Tip: Use the confidence slider to filter uncertain matches.'
                                        },
                                        {
                                            icon: 'âœ“',
                                            title: '4. Validate & Correct',
                                            desc: 'Review each detection. Mark correct (âœ“) or incorrect (âœ—). Click "Alts" to see alternative matches.',
                                            tip: 'Tip: Press 1-9 to select detections, Enter to mark correct.'
                                        },
                                        {
                                            icon: 'ðŸ“–',
                                            title: '5. Build the Reading',
                                            desc: 'Switch to Reading mode to arrange glyphs in order. Drag cards to reorder. Add word/line breaks.',
                                            tip: 'Tip: Set reading direction (RTL for Semitic scripts).'
                                        },
                                        {
                                            icon: 'ðŸŽ“',
                                            title: '6. Train the Chart',
                                            desc: 'Open Manage Chart and enable Training mode. Add good detections as templates to improve future recognition.',
                                            tip: 'Tip: Variants capture different writing styles of the same glyph.'
                                        }
                                    ].map((step, idx) => (
                                        <div key={idx} className={`flex gap-4 p-4 rounded-lg mb-3 transition-all ${
                                            quickStartStep === idx ? 'bg-ancient-purple/10 border-2 border-ancient-purple' : 'bg-gray-50 border-2 border-transparent'
                                        }`}
                                        onClick={() => setQuickStartStep(idx)}>
                                            <div className="text-3xl flex-shrink-0">{step.icon}</div>
                                            <div className="flex-1">
                                                <h3 className="font-bold text-gray-800">{step.title}</h3>
                                                <p className="text-sm text-gray-600 mt-1">{step.desc}</p>
                                                <p className="text-xs text-ancient-purple mt-2 italic">{step.tip}</p>
                                            </div>
                                        </div>
                                    ))}
                                    
                                    {/* Keyboard shortcuts summary */}
                                    <div className="mt-4 p-4 bg-gray-100 rounded-lg">
                                        <h4 className="font-bold text-gray-700 mb-2">âŒ¨ï¸ Keyboard Shortcuts</h4>
                                        <div className="grid grid-cols-2 gap-2 text-sm text-gray-600">
                                            <div><kbd className="px-1.5 py-0.5 bg-white rounded border text-xs">1-9</kbd> Select detection</div>
                                            <div><kbd className="px-1.5 py-0.5 bg-white rounded border text-xs">â†/â†’</kbd> Navigate detections</div>
                                            <div><kbd className="px-1.5 py-0.5 bg-white rounded border text-xs">Enter</kbd> Mark correct</div>
                                            <div><kbd className="px-1.5 py-0.5 bg-white rounded border text-xs">Esc</kbd> Close/deselect</div>
                                            <div><kbd className="px-1.5 py-0.5 bg-white rounded border text-xs">Shift+Click</kbd> Range select</div>
                                            <div><kbd className="px-1.5 py-0.5 bg-white rounded border text-xs">+/âˆ’/0</kbd> Zoom in/out/reset</div>
                                            <div><kbd className="px-1.5 py-0.5 bg-white rounded border text-xs">[ / ]</kbd> Toggle panels</div>
                                            <div><kbd className="px-1.5 py-0.5 bg-white rounded border text-xs">Ctrl+Z/Y</kbd> Undo/Redo</div>
                                            <div><kbd className="px-1.5 py-0.5 bg-white rounded border text-xs">P/V/E</kbd> Save templates</div>
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Footer */}
                                <div className="border-t p-4 flex justify-between items-center bg-gray-50">
                                    <label className="flex items-center gap-2 text-sm text-gray-600 cursor-pointer">
                                        <input 
                                            type="checkbox" 
                                            onChange={(e) => {
                                                if (e.target.checked) {
                                                    localStorage.setItem('hakli_seen_quickstart', 'true');
                                                } else {
                                                    localStorage.removeItem('hakli_seen_quickstart');
                                                }
                                            }}
                                            className="rounded"
                                        />
                                        Don't show again
                                    </label>
                                    <div className="flex gap-2">
                                        <button 
                                            onClick={() => window.open('https://github.com/hytra3/hakli-glyph-recognizer', '_blank')}
                                            className="px-4 py-2 text-gray-600 hover:text-gray-800 text-sm"
                                        >
                                            ðŸ“š Full Docs
                                        </button>
                                        <button 
                                            onClick={() => {
                                                setShowQuickStart(false);
                                                localStorage.setItem('hakli_seen_quickstart', 'true');
                                            }}
                                            className="px-6 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3d5a] font-medium"
                                        >
                                            Get Started â†’
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* ===== WAREHOUSE MODAL ===== */}
                    {showWarehouse && (
                        <WarehouseModal
                            isOpen={showWarehouse}
                            onClose={() => setShowWarehouse(false)}
                            currentUserEmail={driveUserEmail}
                            onSignIn={async () => {
                                if (typeof DriveSync !== 'undefined') {
                                    await DriveSync.signIn();
                                    setDriveSignedIn(DriveSync.isSignedIn());
                                    setDriveUserEmail(DriveSync.getUserEmail());
                                }
                            }}
                            onSignOut={() => {
                                if (typeof DriveSync !== 'undefined') {
                                    DriveSync.signOut();
                                    setDriveSignedIn(false);
                                    setDriveUserEmail(null);
                                }
                            }}
                            onLoadHki={(hkiData, fileInfo) => {
                                // Clear ALL state first (fresh start)
                                setOriginalImage(null);  // Clear old image first!
                                setDisplayImage(null);   // Clear old display image!
                                setRecognitionResults([]);
                                setValidations({});
                                setReadingOrder([]);
                                setReadingDirection('rtl');
                                setWordBoundaries(new Set());
                                setLineBreaks(new Set());
                                setColumnBreaks(new Set());
                                setSelectedRegions(new Set());
                                setRecognitionSourceDims(null);
                                setChangeLog([]);
                                setUndoStack([]);
                                setRedoStack([]);
                                setCurrentInscriptionId(null);
                                setInscriptionTitle('');
                                setInscriptionNotes('');
                                setInscriptionComplete(false);
                                setTranslationEnglish('');
                                setTranslationArabic('');
                                setCurrentFileId(null);
                                setFileOwner(null);
                                setIsReadOnly(false);
                                setPreprocessing({ rotation: 0, gaussianBlur: 0, useAdaptiveThreshold: false, blockSize: 11, constantOffset: 2, morphologyOperation: 'none', invertColors: false });
                                setLocalSaveTime(null);
                                setCanvasZoom(1);
                                
                                // Use timeout to ensure React processes the clear before loading new data
                                setTimeout(() => {
                                    // Now load from HKI data
                                    // Load image - MUST set both original and display
                                    const newOriginal = hkiData.image || hkiData.images?.original;
                                    const newDisplay = hkiData.displayImage || hkiData.images?.preprocessed || hkiData.image || hkiData.images?.original;
                                    
                                    console.log('ðŸ“· Loading images:', { hasOriginal: !!newOriginal, hasDisplay: !!newDisplay });
                                    
                                    if (newOriginal) setOriginalImage(newOriginal);
                                    if (newDisplay) setDisplayImage(newDisplay);
                                    
                                    // If neither found, clear images to prevent stale data
                                    if (!newOriginal && !newDisplay) {
                                        console.warn('âš ï¸ No images found in HKI file!');
                                        setOriginalImage(null);
                                        setDisplayImage(null);
                                    }
                                    
                                    // Load preprocessing
                                    if (hkiData.preprocessing || hkiData.images?.preprocessingSettings) 
                                        setPreprocessing(hkiData.preprocessing || hkiData.images.preprocessingSettings);
                                    
                                    // Load detections
                                    if (hkiData.recognitionResults) setRecognitionResults(hkiData.recognitionResults);
                                    if (hkiData.recognitionSourceDims) setRecognitionSourceDims(hkiData.recognitionSourceDims);
                                    if (hkiData.detections) setRecognitionResults(hkiData.detections.map(d => ({
                                        glyph: d.glyph, confidence: d.confidence, position: d.position,
                                        thumbnail: d.thumbnail, matchType: d.matchType,
                                        corrected: d.corrected, originalGlyph: d.originalGlyph
                                    })));
                                    
                                    // Load validations and reading data
                                    if (hkiData.validations) setValidations(hkiData.validations);
                                    if (hkiData.readingOrder) setReadingOrder(hkiData.readingOrder);
                                    if (hkiData.readingData?.readingOrder) setReadingOrder(hkiData.readingData.readingOrder);
                                    if (hkiData.readingDirection) setReadingDirection(hkiData.readingDirection);
                                    if (hkiData.readingData?.direction) setReadingDirection(hkiData.readingData.direction);
                                    if (hkiData.wordBoundaries) setWordBoundaries(new Set(hkiData.wordBoundaries));
                                    if (hkiData.readingData?.wordBoundaries) setWordBoundaries(new Set(hkiData.readingData.wordBoundaries));
                                    if (hkiData.lineBreaks) setLineBreaks(new Set(hkiData.lineBreaks));
                                    if (hkiData.readingData?.lineBreaks) setLineBreaks(new Set(hkiData.readingData.lineBreaks));
                                    if (hkiData.columnBreaks) setColumnBreaks(new Set(hkiData.columnBreaks));
                                    if (hkiData.readingData?.columnBreaks) setColumnBreaks(new Set(hkiData.readingData.columnBreaks));
                                    
                                    // Load translations
                                    if (hkiData.translationEnglish || hkiData.translations?.english)
                                        setTranslationEnglish(hkiData.translationEnglish || hkiData.translations?.english || '');
                                    if (hkiData.translationArabic || hkiData.translations?.arabic)
                                        setTranslationArabic(hkiData.translationArabic || hkiData.translations?.arabic || '');
                                    
                                    // Load metadata
                                    if (hkiData.inscriptionTitle) setInscriptionTitle(hkiData.inscriptionTitle);
                                    if (hkiData.inscriptionNotes) setInscriptionNotes(hkiData.inscriptionNotes);
                                    if (hkiData.inscriptionComplete || hkiData.complete) 
                                        setInscriptionComplete(hkiData.inscriptionComplete || hkiData.complete);
                                    if (hkiData.inscriptionId) setCurrentInscriptionId(hkiData.inscriptionId);
                                    if (hkiData.visibility) setVisibility(hkiData.visibility);
                                    if (hkiData.audioData) setAudioData(hkiData.audioData); // Load audio recording
                                    
                                    // Set file tracking for Save vs Save As New
                                    setCurrentFileId(fileInfo.id);
                                    setFileOwner(fileInfo.owner);
                                    
                                    // Determine if read-only (not owner and not collaborator)
                                    const isOwner = fileInfo.owner === driveUserEmail;
                                    const isCollaborator = fileInfo.collaborators?.includes(driveUserEmail);
                                    setIsReadOnly(!driveUserEmail || (!isOwner && !isCollaborator));
                                    
                                    const count = hkiData.recognitionResults?.length || hkiData.detections?.length || 0;
                                    console.log(`ðŸ“‚ Loaded from warehouse: ${fileInfo.title} (${count} glyphs)`);
                                    
                                    // If file has detections, switch to reading view
                                    if (count > 0) {
                                        setViewMode('reading');
                                    }
                                }, 50);  // Small delay to ensure React processes the clear
                                
                                // Close warehouse modal
                                setShowWarehouse(false);
                            }}
                        />
                    )}
                </div>
            );
        }
        
        // ===== GLYPH EDITOR FORM COMPONENT =====
        function GlyphEditorForm({ mode, glyph, chartData, setChartData, setChartModified, loadedGlyphImages, setLoadedGlyphImages, glyphThumbnails, setGlyphThumbnails, onClose }) {
            const { useState, useRef } = React;
            
            const [formData, setFormData] = useState({
                name: glyph?.name || '',
                arabic: glyph?.arabic || '',
                transliteration: glyph?.transliteration || '',
                description: glyph?.description || ''
            });
            const [uploadedImage, setUploadedImage] = useState(null);
            const [uploadedImagePreview, setUploadedImagePreview] = useState(null);
            const [uploadCategory, setUploadCategory] = useState('primary'); // primary, variant, example
            const [isSaving, setIsSaving] = useState(false);
            const fileInputRef = useRef(null);
            
            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    setUploadedImage(event.target.result);
                    setUploadedImagePreview(event.target.result);
                };
                reader.readAsDataURL(file);
            };
            
            const handleSave = () => {
                if (!formData.name.trim()) {
                    alert('Name is required');
                    return;
                }
                
                setIsSaving(true);
                const updatedChart = { ...chartData };
                
                if (mode === 'add') {
                    const maxId = Math.max(...updatedChart.glyphs.map(g => g.id), 0);
                    const newGlyph = {
                        id: maxId + 1,
                        name: formData.name.trim(),
                        arabic: formData.arabic.trim() || 'x',
                        transliteration: formData.transliteration.trim() || formData.name.trim(),
                        description: formData.description.trim() || '',
                        images: { primary: uploadedImage || '', variants: [], examples: [] }
                    };
                    updatedChart.glyphs.push(newGlyph);
                    
                    if (uploadedImage) {
                        const img = new Image();
                        img.onload = () => {
                            setLoadedGlyphImages(prev => ({ ...prev, [newGlyph.id]: img }));
                            setGlyphThumbnails(prev => ({ ...prev, [newGlyph.id]: img.src }));
                        };
                        img.src = uploadedImage;
                    }
                    alert(`âœ… Added glyph "${newGlyph.name}"`);
                } else {
                    const idx = updatedChart.glyphs.findIndex(g => g.id === glyph.id);
                    if (idx !== -1) {
                        // Update glyph metadata
                        updatedChart.glyphs[idx] = {
                            ...updatedChart.glyphs[idx],
                            name: formData.name.trim(),
                            arabic: formData.arabic.trim() || 'x',
                            transliteration: formData.transliteration.trim() || formData.name.trim(),
                            description: formData.description.trim() || ''
                        };
                        
                        // Handle image upload based on category
                        if (uploadedImage) {
                            const glyphImages = updatedChart.glyphs[idx].images || { primary: null, variants: [], examples: [] };
                            
                            if (uploadCategory === 'primary') {
                                // Move existing primary to variants if it exists
                                if (glyphImages.primary) {
                                    if (!glyphImages.variants) glyphImages.variants = [];
                                    glyphImages.variants.push(glyphImages.primary);
                                }
                                glyphImages.primary = uploadedImage;
                                
                                const img = new Image();
                                img.onload = () => {
                                    setLoadedGlyphImages(prev => ({ ...prev, [glyph.id]: img }));
                                    setGlyphThumbnails(prev => ({ ...prev, [glyph.id]: img.src }));
                                };
                                img.src = uploadedImage;
                            } else if (uploadCategory === 'variant') {
                                if (!glyphImages.variants) glyphImages.variants = [];
                                glyphImages.variants.push(uploadedImage);
                            } else if (uploadCategory === 'example') {
                                if (!glyphImages.examples) glyphImages.examples = [];
                                glyphImages.examples.push(uploadedImage);
                            }
                            
                            updatedChart.glyphs[idx].images = glyphImages;
                        }
                        alert(`âœ… Updated glyph "${formData.name}"${uploadedImage ? ` (added ${uploadCategory})` : ''}`);
                    }
                }
                
                setChartData(updatedChart);
                setChartModified(true);
                setIsSaving(false);
                onClose();
            };
            
            const handleDelete = () => {
                if (!glyph || !confirm(`Delete glyph "${glyph.name}"?`)) return;
                const updatedChart = { ...chartData };
                updatedChart.glyphs = updatedChart.glyphs.filter(g => g.id !== glyph.id);
                setChartData(updatedChart);
                setChartModified(true);
                alert(`ðŸ—‘ï¸ Deleted glyph "${glyph.name}"`);
                onClose();
            };
            
            // Get current template counts for edit mode
            const templateCounts = mode === 'edit' && glyph?.images ? {
                primary: glyph.images.primary ? 1 : 0,
                variants: glyph.images.variants?.length || 0,
                examples: glyph.images.examples?.length || 0
            } : null;
            
            return (
                <>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Name *</label>
                        <input type="text" value={formData.name} onChange={(e) => setFormData(p => ({ ...p, name: e.target.value }))}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="e.g., aleph" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Arabic</label>
                        <input type="text" value={formData.arabic} onChange={(e) => setFormData(p => ({ ...p, arabic: e.target.value }))}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg text-2xl text-center" dir="rtl" placeholder="Ø§" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Transliteration</label>
                        <input type="text" value={formData.transliteration} onChange={(e) => setFormData(p => ({ ...p, transliteration: e.target.value }))}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="Ê¾" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Description</label>
                        <textarea value={formData.description} onChange={(e) => setFormData(p => ({ ...p, description: e.target.value }))}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg" rows={2} />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">
                            {mode === 'add' ? 'Template Image *' : 'Add Template Image'}
                        </label>
                        
                        {/* Category selector - only for edit mode */}
                        {mode === 'edit' && (
                            <div className="mb-2">
                                <div className="flex gap-1 text-xs">
                                    <button
                                        type="button"
                                        onClick={() => setUploadCategory('primary')}
                                        className={`px-2 py-1 rounded ${uploadCategory === 'primary' ? 'bg-stone text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                                    >
                                        ðŸŽ¯ Primary ({templateCounts?.primary || 0})
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => setUploadCategory('variant')}
                                        className={`px-2 py-1 rounded ${uploadCategory === 'variant' ? 'bg-patina text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                                    >
                                        â­ Variant ({templateCounts?.variants || 0})
                                    </button>
                                    <button
                                        type="button"
                                        onClick={() => setUploadCategory('example')}
                                        className={`px-2 py-1 rounded ${uploadCategory === 'example' ? 'bg-ochre text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                                    >
                                        ðŸ“š Example ({templateCounts?.examples || 0})
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        <div className="flex gap-3 items-start">
                            {uploadedImagePreview && (
                                <div className={`w-20 h-20 border-2 rounded bg-gray-100 flex items-center justify-center overflow-hidden ${
                                    mode === 'edit' 
                                        ? uploadCategory === 'primary' ? 'border-stone' : uploadCategory === 'variant' ? 'border-patina' : 'border-ochre'
                                        : 'border-gray-300'
                                }`}>
                                    <img src={uploadedImagePreview} alt="Preview" className="max-w-full max-h-full object-contain" />
                                </div>
                            )}
                            <div>
                                <input ref={fileInputRef} type="file" accept="image/*" onChange={handleImageUpload} className="hidden" />
                                <button onClick={() => fileInputRef.current?.click()} className="px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm">
                                    ðŸ“· {uploadedImagePreview ? 'Change' : 'Upload'}
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div className="flex justify-between pt-4 border-t">
                        {mode === 'edit' && (
                            <button onClick={handleDelete} className="px-4 py-2 bg-rust text-white rounded-lg hover:bg-[#8a574a]">ðŸ—‘ï¸ Delete</button>
                        )}
                        {mode === 'add' && <div />}
                        <div className="flex gap-2">
                            <button onClick={onClose} className="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg">Cancel</button>
                            <button onClick={handleSave} disabled={isSaving} className="px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3d5a] disabled:bg-gray-300">
                                {isSaving ? 'Saving...' : 'Save'}
                            </button>
                        </div>
                    </div>
                </>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<HakliGlyphRecognizer />);
    </script>

    <script>
        // Service Worker with Update Detection (battery-friendly)
        if ('serviceWorker' in navigator) {
            let refreshing = false;
            
            // When a new SW takes over, reload
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                if (refreshing) return;
                refreshing = true;
                window.location.reload();
            });
            
            navigator.serviceWorker.register('sw.js').then((registration) => {
                console.log('âœ… SW registered');
                
                // Only check for updates when:
                // 1. Online
                // 2. On wifi (not cellular/metered connection)
                // 3. Page becomes visible after being hidden
                
                const checkForUpdates = () => {
                    // Skip if offline
                    if (!navigator.onLine) return;
                    
                    // Skip if on metered/cellular connection (battery saver)
                    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                    if (connection && (connection.saveData || connection.type === 'cellular')) {
                        console.log('[SW] Skipping update check - metered connection');
                        return;
                    }
                    
                    console.log('[SW] Checking for updates...');
                    registration.update();
                };
                
                // Check when page becomes visible (user returns to app)
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        checkForUpdates();
                    }
                });
                
                // Check when coming back online
                window.addEventListener('online', checkForUpdates);
                
                // Listen for new service worker
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    console.log('ðŸ”„ New service worker found');
                    
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            // New version available - show update banner
                            showUpdateBanner(newWorker);
                        }
                    });
                });
            }).catch(console.error);
        }
        
        function showUpdateBanner(newWorker) {
            // Create update banner
            const banner = document.createElement('div');
            banner.id = 'update-banner';
            banner.innerHTML = `
                <div style="
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: linear-gradient(135deg, #5d4e6d 0%, #6b8e7f 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    z-index: 10000;
                    font-family: system-ui, sans-serif;
                    font-size: 14px;
                ">
                    <span>ðŸ”„ Update available</span>
                    <button onclick="applyUpdate()" style="
                        background: white;
                        color: #5d4e6d;
                        border: none;
                        padding: 6px 12px;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: 600;
                    ">Refresh</button>
                    <button onclick="dismissUpdate()" style="
                        background: transparent;
                        color: white;
                        border: 1px solid rgba(255,255,255,0.5);
                        padding: 6px 12px;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Later</button>
                </div>
            `;
            document.body.appendChild(banner);
            
            window.pendingWorker = newWorker;
        }
        
        function applyUpdate() {
            if (window.pendingWorker) {
                window.pendingWorker.postMessage({ type: 'SKIP_WAITING' });
            }
        }
        
        function dismissUpdate() {
            const banner = document.getElementById('update-banner');
            if (banner) banner.remove();
        }
    </script>
</body>
</html>
