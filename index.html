<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Glyph Recognizer - Modular</title>
    <meta name="description" content="Ancient South Arabian script recognition tool for field documentation">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#5d4e6d">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Hakli">
    <link rel="apple-touch-icon" href="favicon.svg">
    
    <!-- React & Babel -->
    <!-- DEVELOPMENT MODE (slower, more debugging info): -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- PRODUCTION MODE (faster, optimized - uncomment these and comment out development above to test): -->
    <!-- <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script> -->
    <!-- <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script> -->
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Custom Tailwind configuration with earthy archaeological palette
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Earthy archaeological palette inspired by ancient materials
                        'ancient-purple': '#5d4e6d',  // Tyrian purple (theme color)
                        'stone': '#8b7d6b',           // Weathered sandstone
                        'clay': '#a67c52',            // Terracotta/pottery
                        'patina': '#6b8e7f',          // Aged bronze/copper patina
                        'ochre': '#b8956a',           // Desert sand/ochre pigment
                        'rust': '#a0674f',            // Oxidized iron/rust
                        'stone-light': '#a69988',     // Lighter stone
                        'stone-dark': '#6d6355',      // Darker stone
                    }
                }
            }
        }
    </script>
    
    <!-- OpenCV -->
    <script>
        var isOpenCvReady = false;
        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('‚úÖ OpenCV.js is ready');
        }
    </script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        .detection-box {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
            border: 3px solid;
            border-radius: 4px;
            cursor: pointer;
        }
        .detection-box.validated-correct { border-color: #6b8e7f; background: rgba(107, 142, 127, 0.25); }
        .detection-box.validated-incorrect { border-color: #a0674f; background: rgba(239, 68, 68, 0.25); }
        .detection-box.unvalidated { border-color: #8b7d6b; background: rgba(59, 130, 246, 0.25); }
        .detection-box.selected { border-color: #b8956a; background: rgba(245, 158, 11, 0.3); border-width: 4px; }
        .detection-box.uncertain { border-style: dashed; border-color: #f97316; background: rgba(249, 115, 22, 0.15); }
        .detection-box.uncertain.validated-correct { border-style: dashed; border-color: #6b8e7f; }
        .detection-box.uncertain.validated-incorrect { border-style: dashed; border-color: #a0674f; }

        .detection-label {
            position: absolute;
            top: -25px;
            left: 0;
            padding: 2px 8px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            border-radius: 3px;
            white-space: nowrap;
            opacity: 0.9;
        }
        
        .reading-order-badge {
            position: absolute;
            top: -20px;
            left: -20px;
            width: 28px;
            height: 28px;
            background-color: #b8956a;
            border: 2px solid #8d7350;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
            z-index: 20;
        }
        
        .canvas-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }
        
        .manual-selection-box {
            position: absolute;
            border: 2px dashed #b8956a;
            background: rgba(245, 158, 11, 0.1);
            pointer-events: none;
            z-index: 5;
        }
        
        .region-boundary {
            position: absolute;
            border: 1px solid rgba(156, 163, 175, 0.5);
            background: rgba(156, 163, 175, 0.05);
            pointer-events: none;
            z-index: 3;
        }
        
        .merge-indicator {
            position: absolute;
            border: 3px solid #8b5cf6;
            background: rgba(139, 92, 246, 0.15);
            border-radius: 8px;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- ========================================== -->
    <!-- MODULAR BACKEND - Loads before app        -->
    <!-- ========================================== -->
    
    <!-- Core -->
    <script src="src/core/config.js"></script>
    <script src="src/utils/helpers.js"></script>
    
    <!-- Storage -->
    <script src="src/storage/hki.js"></script>
    <script src="src/storage/cache.js"></script>
    <script src="src/storage/corrections.js"></script>
    <script src="src/storage/export.js"></script>
    
    <!-- Recognition -->
    <script src="src/recognition/preprocessing.js"></script>
    <script src="src/recognition/isolation.js"></script>
    <script src="src/recognition/matching.js"></script>
    <script src="src/recognition/nms.js"></script>
    <script src="src/recognition/validation.js"></script>
    <script src="src/recognition/template-learning.js"></script>
    
    <!-- Reading & Transcription -->
    <script src="src/reading/reading.js"></script>
    <script src="src/reading/transcription.js"></script>
    
    <!-- Cloud Sync -->
    <script src="src/storage/drive-sync.js"></script>
    
    <script>
        // Verify backend
        console.log('üöÄ Hakli Glyph Recognizer - Modular v251217');
        
        // List available TTS voices after they load
        if ('speechSynthesis' in window) {
            // Voices load asynchronously, so we need to wait
            const listVoices = () => {
                const voices = window.speechSynthesis.getVoices();
                const arabicVoices = voices.filter(v => v.lang.startsWith('ar'));
                const englishVoices = voices.filter(v => v.lang.startsWith('en'));
                
                console.log('üîä Text-to-Speech Voices Available:');
                console.log('üìó English voices:', englishVoices.length);
                englishVoices.forEach(v => console.log('  -', v.name, '(' + v.lang + ')'));
                console.log('üìï Arabic voices:', arabicVoices.length);
                if (arabicVoices.length > 0) {
                    arabicVoices.forEach(v => console.log('  -', v.name, '(' + v.lang + ')'));
                } else {
                    console.log('  ‚ö†Ô∏è No Arabic voices found. Install Arabic language pack for better pronunciation.');
                }
            };
            
            // Try immediately (sometimes works)
            if (window.speechSynthesis.getVoices().length > 0) {
                listVoices();
            }
            // Also listen for voices to load (more reliable)
            window.speechSynthesis.onvoiceschanged = listVoices;
        } else {
            console.warn('‚ö†Ô∏è Text-to-speech not supported in this browser');
        }
        const modulesLoaded = {
            config: typeof CONFIG !== 'undefined',
            utils: typeof Utils !== 'undefined',
            hki: typeof HKIStorage !== 'undefined',
            cache: typeof CacheStorage !== 'undefined',
            corrections: typeof CorrectionMemory !== 'undefined',
            export: typeof ExportUtils !== 'undefined',
            isolation: typeof Isolation !== 'undefined',
            matching: typeof Matching !== 'undefined',
            preprocessing: typeof Preprocessing !== 'undefined',
            nms: typeof NMS !== 'undefined',
            validation: typeof Validation !== 'undefined',
            polygonRegion: typeof PolygonRegion !== 'undefined',
            templateLearning: typeof TemplateLearning !== 'undefined',
            readingOrder: typeof ReadingOrder !== 'undefined',
            transcription: typeof Transcription !== 'undefined',
            driveSync: typeof DriveSync !== 'undefined'
        };
        console.log('üì¶ Modular backend:', modulesLoaded);
        const allLoaded = Object.values(modulesLoaded).every(v => v);
        if (allLoaded) {
            console.log('‚úÖ All backend modules loaded - App starting with full modular backend');
        } else {
            const missing = Object.entries(modulesLoaded).filter(([k, v]) => !v).map(([k]) => k);
            console.warn('‚ö†Ô∏è Missing modules:', missing.join(', '));
        }
    </script>

    <!-- ========================================== -->
    <!-- ORIGINAL APPLICATION CODE                  -->
    <!-- ========================================== -->

    <script type="text/babel">
        // Glyph Editor Modal Component
        const GlyphEditorModal = ({ mode, glyph, equivalenceChart, setEquivalenceChart, loadedGlyphImages, setLoadedGlyphImages, glyphThumbnails, setGlyphThumbnails, onClose }) => {
            const [formData, setFormData] = React.useState({
                name: glyph?.name || '',
                arabic: glyph?.arabic || '',
                transliteration: glyph?.transliteration || '',
                description: glyph?.description || ''
            });
            const [primaryImage, setPrimaryImage] = React.useState(null);
            const [primaryImagePreview, setPrimaryImagePreview] = React.useState(glyph?.images?.primary || null);
            const [errors, setErrors] = React.useState({});
            const fileInputRef = React.useRef(null);

            const validateForm = () => {
                const newErrors = {};
                if (!formData.name.trim()) newErrors.name = 'Name is required';
                if (mode === 'add' && !primaryImage && !primaryImagePreview) {
                    newErrors.primaryImage = 'Primary template image is required for new glyphs';
                }
                setErrors(newErrors);
                return Object.keys(newErrors).length === 0;
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const dataUrl = event.target.result;
                    setPrimaryImage(dataUrl);
                    setPrimaryImagePreview(dataUrl);
                };
                reader.readAsDataURL(file);
            };

            const handleSave = () => {
                if (!validateForm()) return;

                const updatedChart = { ...equivalenceChart };
                
                if (mode === 'add') {
                    // Find next available ID
                    const maxId = Math.max(...updatedChart.glyphs.map(g => g.id), 0);
                    const newGlyph = {
                        id: maxId + 1,
                        name: formData.name.trim(),
                        arabic: formData.arabic.trim() || 'x',
                        transliteration: formData.transliteration.trim() || formData.name.trim(),
                        description: formData.description.trim() || 'description',
                        images: {
                            primary: primaryImage,
                            variants: [],
                            examples: []
                        }
                    };
                    
                    updatedChart.glyphs.push(newGlyph);
                    
                    // Load the image into cache
                    const img = new Image();
                    img.onload = () => {
                        setLoadedGlyphImages(prev => ({
                            ...prev,
                            [newGlyph.id]: img
                        }));
                        setGlyphThumbnails(prev => ({
                            ...prev,
                            [newGlyph.id]: img.src
                        }));
                    };
                    img.src = primaryImage;
                    
                    alert(`‚úÖ Added new glyph "${newGlyph.name}" with ID ${newGlyph.id}`);
                } else if (mode === 'edit') {
                    // Update existing glyph
                    const glyphIndex = updatedChart.glyphs.findIndex(g => g.id === glyph.id);
                    if (glyphIndex !== -1) {
                        updatedChart.glyphs[glyphIndex] = {
                            ...updatedChart.glyphs[glyphIndex],
                            name: formData.name.trim(),
                            arabic: formData.arabic.trim() || 'x',
                            transliteration: formData.transliteration.trim() || formData.name.trim(),
                            description: formData.description.trim() || 'description'
                        };
                        
                        // If primary image changed, update it
                        if (primaryImage) {
                            updatedChart.glyphs[glyphIndex].images.primary = primaryImage;
                            
                            const img = new Image();
                            img.onload = () => {
                                setLoadedGlyphImages(prev => ({
                                    ...prev,
                                    [glyph.id]: img
                                }));
                                setGlyphThumbnails(prev => ({
                                    ...prev,
                                    [glyph.id]: img.src
                                }));
                            };
                            img.src = primaryImage;
                        }
                        
                        alert(`‚úÖ Updated glyph "${formData.name}"`);
                    }
                }
                
                setEquivalenceChart(updatedChart);
                onClose();
            };

            const handleDelete = () => {
                if (!confirm(`Are you sure you want to delete glyph "${glyph.name}"? This cannot be undone.`)) {
                    return;
                }
                
                const updatedChart = { ...equivalenceChart };
                updatedChart.glyphs = updatedChart.glyphs.filter(g => g.id !== glyph.id);
                
                // Remove from image caches
                const newLoadedImages = { ...loadedGlyphImages };
                const newThumbnails = { ...glyphThumbnails };
                delete newLoadedImages[glyph.id];
                delete newThumbnails[glyph.id];
                
                // Remove variants and examples too
                if (glyph.images?.variants) {
                    glyph.images.variants.forEach((_, idx) => {
                        delete newLoadedImages[`${glyph.id}_variant_${idx}`];
                        delete newThumbnails[`${glyph.id}_variant_${idx}`];
                    });
                }
                if (glyph.images?.examples) {
                    glyph.images.examples.forEach((_, idx) => {
                        delete newLoadedImages[`${glyph.id}_example_${idx}`];
                        delete newThumbnails[`${glyph.id}_example_${idx}`];
                    });
                }
                
                setLoadedGlyphImages(newLoadedImages);
                setGlyphThumbnails(newThumbnails);
                setEquivalenceChart(updatedChart);
                
                alert(`üóëÔ∏è Deleted glyph "${glyph.name}"`);
                onClose();
            };

            return (
                <>
                    <div className="flex items-center justify-between p-6 pb-4 border-b border-gray-200">
                        <h3 className="text-2xl font-bold text-gray-900">
                            {mode === 'add' ? '‚ûï Add New Glyph' : '‚úèÔ∏è Edit Glyph'}
                        </h3>
                        <button onClick={onClose} className="text-gray-400 hover:text-gray-600 text-3xl leading-none">
                            &times;
                        </button>
                    </div>

                    <div className="overflow-y-auto p-6 flex-1">
                        <div className="space-y-4">
                            {/* Name Field */}
                            <div>
                                <label className="block text-sm font-semibold text-gray-700 mb-1">
                                    Glyph Name * <span className="text-xs font-normal text-gray-500">(e.g., "l", "·∏•", "·∫ì")</span>
                                </label>
                                <input
                                    type="text"
                                    value={formData.name}
                                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                                    className={`w-full px-3 py-2 border rounded-lg ${errors.name ? 'border-red-500' : 'border-gray-300'}`}
                                    placeholder="Enter glyph name"
                                />
                                {errors.name && <p className="text-red-500 text-xs mt-1">{errors.name}</p>}
                            </div>

                            {/* Arabic Field */}
                            <div>
                                <label className="block text-sm font-semibold text-gray-700 mb-1">
                                    Arabic Character <span className="text-xs font-normal text-gray-500">(optional, e.g., "ŸÑ", "ÿ≠")</span>
                                </label>
                                <input
                                    type="text"
                                    value={formData.arabic}
                                    onChange={(e) => setFormData({ ...formData, arabic: e.target.value })}
                                    className="w-full px-3 py-2 border border-gray-300 rounded-lg"
                                    placeholder="Enter Arabic character"
                                    style={{ fontFamily: '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' }}
                                />
                            </div>

                            {/* Transliteration Field */}
                            <div>
                                <label className="block text-sm font-semibold text-gray-700 mb-1">
                                    Transliteration <span className="text-xs font-normal text-gray-500">(optional)</span>
                                </label>
                                <input
                                    type="text"
                                    value={formData.transliteration}
                                    onChange={(e) => setFormData({ ...formData, transliteration: e.target.value })}
                                    className="w-full px-3 py-2 border border-gray-300 rounded-lg"
                                    placeholder="Leave blank to use name"
                                />
                            </div>

                            {/* Description Field */}
                            <div>
                                <label className="block text-sm font-semibold text-gray-700 mb-1">
                                    Description <span className="text-xs font-normal text-gray-500">(optional)</span>
                                </label>
                                <textarea
                                    value={formData.description}
                                    onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                                    className="w-full px-3 py-2 border border-gray-300 rounded-lg"
                                    rows="2"
                                    placeholder="Add notes about this glyph"
                                />
                            </div>

                            {/* Primary Image Upload */}
                            <div>
                                <label className="block text-sm font-semibold text-gray-700 mb-1">
                                    Primary Template Image {mode === 'add' && '*'}
                                </label>
                                <div className="space-y-2">
                                    {primaryImagePreview && (
                                        <div className="flex items-center gap-4 p-3 bg-gray-50 rounded-lg">
                                            <img 
                                                src={primaryImagePreview} 
                                                alt="Primary template preview"
                                                className="h-20 border-2 border-gray-300 rounded bg-white p-1"
                                            />
                                            <div className="text-sm text-gray-600">
                                                {primaryImage ? 'New image selected' : 'Current image'}
                                            </div>
                                        </div>
                                    )}
                                    <input
                                        ref={fileInputRef}
                                        type="file"
                                        accept="image/*"
                                        onChange={handleImageUpload}
                                        className="hidden"
                                    />
                                    <button
                                        onClick={() => fileInputRef.current.click()}
                                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300"
                                    >
                                        üìÅ {primaryImagePreview ? 'Change Image' : 'Upload Image'}
                                    </button>
                                    {errors.primaryImage && <p className="text-red-500 text-xs">{errors.primaryImage}</p>}
                                </div>
                                <p className="text-xs text-gray-500 mt-1">
                                    üí° Tip: Crop to just the glyph shape for best recognition results
                                </p>
                            </div>
                        </div>
                    </div>

                    <div className="p-6 pt-4 border-t border-gray-200 flex gap-3">
                        {mode === 'edit' && (
                            <button
                                onClick={handleDelete}
                                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                            >
                                üóëÔ∏è Delete Glyph
                            </button>
                        )}
                        <div className="flex-1"></div>
                        <button
                            onClick={onClose}
                            className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300"
                        >
                            Cancel
                        </button>
                        <button
                            onClick={handleSave}
                            className="px-4 py-2 bg-emerald-500 text-white rounded hover:bg-emerald-600"
                        >
                            {mode === 'add' ? '‚ûï Add Glyph' : 'üíæ Save Changes'}
                        </button>
                    </div>
                </>
            );
        };

        // Main App Component

        const { useState, useEffect, useRef } = React;

        function HakliGlyphRecognizer() {
            const [image, setImage] = useState(null);
            const [displayImage, setDisplayImage] = useState(null); // The image to display (may be rotated)
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [chartLoadStatus, setChartLoadStatus] = useState('not-loaded');
            const [loadedGlyphImages, setLoadedGlyphImages] = useState({});
            const [glyphThumbnails, setGlyphThumbnails] = useState({}); // Separate cache for thumbnail URLs
            const [manualDetectionMode, setManualDetectionMode] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawStart, setDrawStart] = useState(null);
            const [drawCurrent, setDrawCurrent] = useState(null);
            const [selectedRegions, setSelectedRegions] = useState(new Set());
            const [validations, setValidations] = useState({});
            const [actionHistory, setActionHistory] = useState([]);
            const [isolatedGlyphs, setIsolatedGlyphs] = useState([]);
            const [showRegionBoundaries, setShowRegionBoundaries] = useState(false);
            const [mergeIndicator, setMergeIndicator] = useState(null);
            const [showChartViewer, setShowChartViewer] = useState(false);
            const [showGlyphEditor, setShowGlyphEditor] = useState(null); // { mode: 'add'|'edit', glyph?: {...} }
            const [glyphEditorName, setGlyphEditorName] = useState('');
            const [glyphEditorArabic, setGlyphEditorArabic] = useState('');
            const [glyphEditorTranslit, setGlyphEditorTranslit] = useState('');
            const [glyphEditorImageFile, setGlyphEditorImageFile] = useState(null);
            const [glyphEditorImagePreview, setGlyphEditorImagePreview] = useState(null);
            const [showCorrectionAnalysis, setShowCorrectionAnalysis] = useState(false);
            const [showArabicLabels, setShowArabicLabels] = useState(false);
            const [isChartStatusCollapsed, setIsChartStatusCollapsed] = useState(false);
            const [isRotationCollapsed, setIsRotationCollapsed] = useState(true); // Start collapsed
            const [isBlurCollapsed, setIsBlurCollapsed] = useState(true); // Start collapsed
            const [isThresholdCollapsed, setIsThresholdCollapsed] = useState(false); // Expanded - most used
            const [isMorphCollapsed, setIsMorphCollapsed] = useState(true); // Start collapsed
            const [isControlsCollapsed, setIsControlsCollapsed] = useState(true); // Start collapsed - Recognize button shown in header
            const [isViewModeCollapsed, setIsViewModeCollapsed] = useState(false);
            const [isCorrectionMemoryCollapsed, setIsCorrectionMemoryCollapsed] = useState(true); // Start collapsed
            const [isExportOptionsCollapsed, setIsExportOptionsCollapsed] = useState(true); // Start collapsed
            const [processingProgress, setProcessingProgress] = useState({ current: 0, total: 0 });
            const [imageLoadingProgress, setImageLoadingProgress] = useState({ loaded: 0, total: 0 });

            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);

            const [viewMode, setViewMode] = useState('detection'); // 'detection' or 'reading'
            const [readingDirection, setReadingDirection] = useState('detection'); // 'detection', 'ltr', 'rtl', 'ttb'
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [columnBreaks, setColumnBreaks] = useState(new Set()); // Mark end of column after this glyph
            const [lineBreaks, setLineBreaks] = useState(new Set()); // Mark end of line after this glyph
            const [readingOrder, setReadingOrder] = useState([]); // Array of indices for manual ordering
            const [draggedItem, setDraggedItem] = useState(null);
            const [correctionMode, setCorrectionMode] = useState(null); // Index of detection being corrected, or null
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [stateHistory, setStateHistory] = useState([]);
            const [confidenceThreshold, setConfidenceThreshold] = useState(0);
            const [useConfidenceFilter, setUseConfidenceFilter] = useState(false);
            const [showConfidenceFilter, setShowConfidenceFilter] = useState(false);
            const [imageRotation, setImageRotation] = useState(0);
            const [rotatedImageDimensions, setRotatedImageDimensions] = useState(null); // { width, height } of rotated image used in recognition
            const [showCloudSyncModal, setShowCloudSyncModal] = useState(false);
            const [showCommunityModal, setShowCommunityModal] = useState(false);
            const [customGistUrl, setCustomGistUrl] = useState('');
            const [showFilePickerModal, setShowFilePickerModal] = useState(null); // { files: [], isLoading: boolean }
            const [showTopMatches, setShowTopMatches] = useState(false); // Toggle for showing alternative matches in cards
            const [driveAuthStatus, setDriveAuthStatus] = useState(0); // Counter to force re-render when auth changes
            const [trimMode, setTrimMode] = useState(null); // Index of detection being trimmed, or null
            const [excludeMode, setExcludeMode] = useState(null); // Index of detection being excluded, or null
            const [excludeRegions, setExcludeRegions] = useState([]); // Array of exclusion boxes
            const [selectedIsolatedRegion, setSelectedIsolatedRegion] = useState(null); // to enable delete when show isolated
            const [templateTrainingMode, setTemplateTrainingMode] = useState(false); // add glyph to template 
            const [selectedForTemplate, setSelectedForTemplate] = useState(null);
            const [adjustMode, setAdjustMode] = useState(null); // Index of detection being adjusted, or null
            const [draggingCorner, setDraggingCorner] = useState(null); // Which corner is being dragged: 'tl', 'tr', 'bl', 'br'
            const [dragStartPos, setDragStartPos] = useState(null); // Starting position of drag
            const [transcriptionPosition, setTranscriptionPosition] = useState({ x: 0, y: 0 }); // Position of draggable transcription box
            const [isDraggingTranscription, setIsDraggingTranscription] = useState(false);
            const [transcriptionDragStart, setTranscriptionDragStart] = useState({ x: 0, y: 0 });
            const [showTranscription, setShowTranscription] = useState(true); // Show/hide transcription box
            
            // Preprocessing state
            const [isPreprocessingCollapsed, setIsPreprocessingCollapsed] = useState(false);
            const [showPreprocessPreview, setShowPreprocessPreview] = useState(true);
            const [preprocessing, setPreprocessing] = useState({
                rotation: 0,
                useAdaptiveThreshold: false,
                blockSize: 11,
                constantOffset: 2,
                gaussianBlur: 0,
                morphologyOperation: 'none',
                invertColors: false
            });
            const [originalMat, setOriginalMat] = useState(null);
            const [preprocessedMat, setPreprocessedMat] = useState(null);
            
            // Dismissable tips state
            const [dismissedTips, setDismissedTips] = useState(() => {
                try {
                    const saved = localStorage.getItem('hakli_dismissed_tips');
                    return saved ? JSON.parse(saved) : {};
                } catch { return {}; }
            });
            
            // Dismiss a tip permanently
            const dismissTip = (tipId) => {
                const updated = { ...dismissedTips, [tipId]: true };
                setDismissedTips(updated);
                localStorage.setItem('hakli_dismissed_tips', JSON.stringify(updated));
            };
            
            // Reset all tips (for settings)
            const resetAllTips = () => {
                setDismissedTips({});
                localStorage.removeItem('hakli_dismissed_tips');
            };
            
            // Dismissable tip component
            const DismissableTip = ({ id, children, className = '' }) => {
                if (dismissedTips[id]) return null;
                return (
                    <div className={`relative p-3 bg-[#f7f3ed] border-2 border-[#d4c4a8] rounded-lg ${className}`}>
                        <button
                            onClick={() => dismissTip(id)}
                            className="absolute top-1 right-1 w-6 h-6 flex items-center justify-center text-yellow-600 hover:text-[#6d5d42] hover:bg-yellow-100 rounded-full transition-colors"
                            title="Dismiss this tip"
                        >
                            ‚úï
                        </button>
                        <div className="pr-6 text-sm text-[#6d5d42]">{children}</div>
                    </div>
                );
            };
            
            // Auto-detect reading direction using ReadingOrder module
            const autoDetectReadingOrder = () => {
                if (typeof ReadingOrder !== 'undefined' && recognitionResults.length > 0) {
                    // Use ALL results for reading order (confidence filtering only affects display)
                    const detected = ReadingOrder.detectDirection(recognitionResults);
                    setReadingDirection(detected);
                    const order = ReadingOrder.generateOrder(recognitionResults, detected);
                    setReadingOrder(order);
                    console.log(`üìñ Auto-detected: ${detected}, ordered ${order.length} glyphs`);
                    return detected;
                }
                return null;
            };
            const [adjustmentsApplied, setAdjustmentsApplied] = useState(false);
            const [isImageLoading, setIsImageLoading] = useState(false);
            const [eraserMode, setEraserMode] = useState(false);
            const [brushSize, setBrushSize] = useState(15);
            const [isErasing, setIsErasing] = useState(false);
            const [eraserHistory, setEraserHistory] = useState([]); // Track canvas states for undo
            const [eraserCursorStyle, setEraserCursorStyle] = useState('crosshair');
            const eraserCanvasRef = useRef(null);
            const preprocessCanvasRef = useRef(null);
            const originalCanvasRef = useRef(null);
            
            // Filter function for recognition results
            const getFilteredResults = () => {
                if (!useConfidenceFilter) {
                    return recognitionResults;
                }
                return recognitionResults.filter(r => r.confidence >= (confidenceThreshold / 100));
            };
            
            // Get results in reading order, applying confidence filter
            const getReadingOrderedResults = () => {
                const ordered = readingOrder.length === 0 
                    ? recognitionResults 
                    : readingOrder.map(index => recognitionResults[index]).filter(r => r !== undefined);
                
                // Apply confidence filter
                if (!useConfidenceFilter) {
                    return ordered;
                }
                return ordered.filter(r => r.confidence >= (confidenceThreshold / 100));
            };
            
            // Copy transcription to clipboard
            const copyTranscriptionToClipboard = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';
                
                orderedResults.forEach((result, index) => {
                    transcription += result.glyph.transliteration || result.glyph.name;
                    
                    if (viewMode === 'reading') {
                        if (lineBreaks.has(index)) {
                            transcription += '\n';
                        } else if (columnBreaks.has(index)) {
                            transcription += ' || ';
                        } else if (wordBoundaries.has(index)) {
                            transcription += ' | ';
                        } else if (index < orderedResults.length - 1) {
                            transcription += ' ';
                        }
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });
                
                navigator.clipboard.writeText(transcription).then(() => {
                    alert('‚úÖ Transcription copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    alert('‚ùå Failed to copy to clipboard');
                });
            };
            
            // Text-to-speech for transcription
            const speakTranscription = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let text = '';
                
                orderedResults.forEach((result, index) => {
                    // Use transliteration for English TTS, Arabic for Arabic TTS
                    const content = showArabicLabels 
                        ? (result.glyph.arabic || result.glyph.name)
                        : (result.glyph.transliteration || result.glyph.name);
                    
                    text += content;
                    
                    // Add pauses for breaks (longer pauses help with comprehension)
                    if (viewMode === 'reading') {
                        if (lineBreaks.has(index)) {
                            text += '. ';  // Full stop creates longer pause
                        } else if (columnBreaks.has(index)) {
                            text += ', ';  // Comma creates medium pause
                        } else if (wordBoundaries.has(index)) {
                            text += ' ';   // Space creates short pause
                        } else if (index < orderedResults.length - 1) {
                            text += ' ';
                        }
                    } else if (index < orderedResults.length - 1) {
                        text += ' ';
                    }
                });
                
                // Cancel any ongoing speech
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                    return; // If already speaking, just cancel (toggle behavior)
                }
                
                // Create speech utterance
                const utterance = new SpeechSynthesisUtterance(text);
                
                // Configure voice settings based on language
                if (showArabicLabels) {
                    // Arabic settings
                    utterance.lang = 'ar-SA';  // Arabic (Saudi Arabia) - closest to Omani Arabic
                    utterance.rate = 0.6;      // Slower for Semitic pronunciation
                    utterance.pitch = 1.0;
                } else {
                    // English transliteration settings
                    utterance.lang = 'en-US';
                    utterance.rate = 0.7;
                    utterance.pitch = 1.0;
                }
                
                utterance.volume = 1.0; // Full volume (0-1)
                
                // Try to select the best available voice
                const voices = window.speechSynthesis.getVoices();
                
                if (showArabicLabels) {
                    // Prioritize Arabic voices in this order:
                    // 1. ar-SA (Saudi) - closest to Omani/Jibbali
                    // 2. ar-EG (Egyptian) - widely understood
                    // 3. ar-* (any other Arabic)
                    const preferredVoice = voices.find(voice => voice.lang === 'ar-SA') ||
                                          voices.find(voice => voice.lang === 'ar-EG') ||
                                          voices.find(voice => voice.lang.startsWith('ar-')) ||
                                          voices.find(voice => voice.lang.startsWith('ar'));
                    
                    if (preferredVoice) {
                        utterance.voice = preferredVoice;
                        console.log('üîä Using Arabic voice:', preferredVoice.name, '(' + preferredVoice.lang + ')');
                    } else {
                        console.warn('‚ö†Ô∏è No Arabic voice found. Using system default.');
                        console.log('üí° Tip: Install Arabic language pack on your device for better pronunciation.');
                    }
                } else {
                    // English voice selection
                    const preferredVoice = voices.find(voice => voice.lang === 'en-US') ||
                                          voices.find(voice => voice.lang.startsWith('en'));
                    if (preferredVoice) {
                        utterance.voice = preferredVoice;
                    }
                }
                
                // Error handling
                utterance.onerror = (event) => {
                    console.error('Speech synthesis error:', event);
                    if (event.error === 'not-allowed') {
                        alert('‚ùå Text-to-speech blocked. Please allow audio playback in your browser.');
                    } else if (event.error === 'language-unavailable') {
                        alert('‚ùå Arabic language not available.\n\nüí° Install Arabic language pack on your device:\n\n‚Ä¢ Windows: Settings > Time & Language > Language\n‚Ä¢ macOS: System Preferences > Accessibility > Speech\n‚Ä¢ iOS: Settings > General > Keyboard > Keyboards > Add Arabic\n‚Ä¢ Android: Settings > System > Languages & input > Text-to-speech');
                    } else {
                        alert('‚ùå Text-to-speech failed: ' + event.error);
                    }
                };
                
                // Success callback
                utterance.onend = () => {
                    console.log('‚úÖ Speech synthesis completed');
                };
                
                // Speak the text
                window.speechSynthesis.speak(utterance);
            };
            
            // Action history tracking
            const recordAction = (actionType, actionData) => {
                const action = {
                    type: actionType,
                    data: actionData,
                    timestamp: new Date().toISOString(),
                    id: Date.now()
                };
                setActionHistory(prev => [...prev, action].slice(-50));
                // Only log important actions
                if (['exclude_regions', 'merge_detections', 'upload_to_cloud'].includes(actionType)) {
                    console.log(`‚úì ${actionType}:`, actionData);
                }
                // For modifying actions, snapshot is taken BEFORE the change (in the calling code)
                // This just logs the action for history
            };
            
            // Take snapshot of current state BEFORE making changes
            const takeSnapshotBeforeChange = () => {
                const snapshot = {
                    recognitionResults: [...recognitionResults],
                    validations: { ...validations },
                    selectedRegions: new Set(selectedRegions),
                    wordBoundaries: new Set(wordBoundaries),
                    readingOrder: [...readingOrder],
                    isolatedGlyphs: [...isolatedGlyphs]
                };
                
                // Remove any "future" history if we're not at the end
                const newHistory = stateHistory.slice(0, historyIndex + 1);
                newHistory.push(snapshot);
                
                // Keep only last 50 states
                const trimmedHistory = newHistory.slice(-50);
                
                setStateHistory(trimmedHistory);
                setHistoryIndex(trimmedHistory.length - 1);
                console.log('üì∏ Snapshot taken, history length:', trimmedHistory.length);
            };
            
            // Session save/load functions
            const saveSession = () => {
                const sessionData = {
                    image,
                    recognitionResults,
                    readingOrder,
                    wordBoundaries: Array.from(wordBoundaries),
                    columnBreaks: Array.from(columnBreaks),
                    lineBreaks: Array.from(lineBreaks),
                    translationEnglish,
                    translationArabic,
                    readingDirection,
                    viewMode,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(sessionData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_session_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('‚úÖ Session saved!');
                recordAction('save_session');
            };
            
            const loadSession = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const sessionData = JSON.parse(e.target.result);
                        
                        // Load image and process it through OpenCV
                        if (sessionData.image) {
                            setIsImageLoading(true);
                            const img = new Image();
                            img.onload = () => {
                                // Set the image
                                setImage(sessionData.image);
                                
                                // Create OpenCV Mat from image
                                if (isOpenCvReady) {
                                    const canvas = document.createElement('canvas');
                                    canvas.width = img.width;
                                    canvas.height = img.height;
                                    const ctx = canvas.getContext('2d');
                                    ctx.drawImage(img, 0, 0);
                                    
                                    const mat = cv.imread(canvas);
                                    setOriginalMat(mat);
                                    
                                    // Show original on canvas
                                    if (originalCanvasRef.current) {
                                        cv.imshow(originalCanvasRef.current, mat);
                                    }
                                    
                                    // Process with default or saved preprocessing settings
                                    processImageWithSettings(mat, preprocessing);
                                }
                                
                                setIsImageLoading(false);
                            };
                            img.onerror = () => {
                                setIsImageLoading(false);
                                alert('‚ùå Failed to load image from HKI file.');
                            };
                            img.src = sessionData.image;
                        }
                        
                        // Restore all other data
                        setRecognitionResults(sessionData.recognitionResults || []);
                        setReadingOrder(sessionData.readingOrder || []);
                        setWordBoundaries(new Set(sessionData.wordBoundaries || []));
                        setColumnBreaks(new Set(sessionData.columnBreaks || []));
                        setLineBreaks(new Set(sessionData.lineBreaks || []));
                        setTranslationEnglish(sessionData.translationEnglish || '');
                        setTranslationArabic(sessionData.translationArabic || '');
                        setInscriptionTitle(sessionData.inscriptionTitle || '');
                        setInscriptionNotes(sessionData.inscriptionNotes || '');
                        setReadingDirection(sessionData.readingDirection || 'detection');
                        setViewMode(sessionData.viewMode || 'detection');
                        
                        alert('‚úÖ Session loaded successfully!');
                        recordAction('load_session');
                    } catch (error) {
                        alert('‚ùå Failed to load session: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            // Undo/Redo functions
            const undo = () => {
                if (historyIndex <= 0) return;
                
                const previousState = stateHistory[historyIndex - 1];
                setRecognitionResults(previousState.recognitionResults);
                setValidations(previousState.validations);
                setSelectedRegions(previousState.selectedRegions);
                setWordBoundaries(previousState.wordBoundaries);
                setReadingOrder(previousState.readingOrder);
                setIsolatedGlyphs(previousState.isolatedGlyphs);
                setHistoryIndex(historyIndex - 1);
                
                console.log('Undo to state', historyIndex - 1);
            };

            const redo = () => {
                if (historyIndex >= stateHistory.length - 1) return;
                
                const nextState = stateHistory[historyIndex + 1];
                setRecognitionResults(nextState.recognitionResults);
                setValidations(nextState.validations);
                setSelectedRegions(nextState.selectedRegions);
                setWordBoundaries(nextState.wordBoundaries);
                setReadingOrder(nextState.readingOrder);
                setIsolatedGlyphs(nextState.isolatedGlyphs);
                setHistoryIndex(historyIndex + 1);
                
                console.log('Redo to state', historyIndex + 1);
            };
            
            // Aliases for consistency
            const handleUndo = undo;
            const handleRedo = redo;
            
            // Open JSON viewer in new window
            const openJsonViewer = () => {
                if (!recognitionResults || recognitionResults.length === 0) {
                    alert('‚ùå No data to view. Please detect glyphs first.');
                    return;
                }
                
                // Build current data and save to cache so viewer can access it
                const currentData = {
                    timestamp: new Date().toISOString(),
                    imageData: image || null,
                    viewMode: viewMode,
                    readingDirection: readingDirection,
                    detections: recognitionResults.map((result, index) => ({
                        index: index,
                        glyph: result.glyph.name,
                        transliteration: result.glyph.transliteration,
                        arabic: result.glyph.arabic || result.glyph.transliteration || result.glyph.name,
                        confidence: result.confidence,
                        position: result.position,
                        matchType: result.matchType,
                        isManual: result.isManual || false,
                        isMerged: result.isMerged || false,
                        validated: validations[index] ? validations[index].isCorrect : null
                    })),
                    readingOrder: viewMode === 'reading' ? readingOrder : null,
                    wordBoundaries: Array.from(wordBoundaries),
                    columnBreaks: Array.from(columnBreaks || []),
                    lineBreaks: Array.from(lineBreaks || []),
                    translations: {
                        english: translationEnglish || '',
                        arabic: translationArabic || ''
                    },
                    statistics: {
                        totalGlyphs: recognitionResults.length,
                        uniqueGlyphs: new Set(recognitionResults.map(r => r.glyph.name)).size,
                        averageConfidence: recognitionResults.length > 0 
                            ? (recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length * 100).toFixed(1)
                            : 0
                    }
                };
                
                // Save to cache so viewer can access it
                const filename = `Current_Inscription_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                saveToLocalCache(currentData, filename);
                
                // Open viewer window with autoload parameter
                const viewerUrl = window.location.href.replace('index.html', 'hakli_viewer.html').replace(/\/$/, '') + '/hakli_viewer.html?autoload=' + encodeURIComponent(filename);
                window.open(viewerUrl, 'HakliViewer', 'width=1200,height=800,menubar=no,toolbar=no,location=no,status=no');
            };
            
            // LocalStorage cache for recent exports
            const saveToLocalCache = (jsonData, filename) => {
                try {
                    const cache = JSON.parse(localStorage.getItem('hakliRecentExports') || '[]');
                    const newEntry = {
                        filename: filename,
                        data: jsonData,
                        timestamp: new Date().toISOString(),
                        id: Date.now()
                    };
                    
                    // Add to beginning, keep last 10
                    cache.unshift(newEntry);
                    const trimmedCache = cache.slice(0, 10);
                    
                    localStorage.setItem('hakliRecentExports', JSON.stringify(trimmedCache));
                    console.log('‚úì Saved to local cache');
                } catch (error) {
                    console.warn('Failed to cache locally:', error);
                }
            };
            
            const getLocalCache = () => {
                try {
                    return JSON.parse(localStorage.getItem('hakliRecentExports') || '[]');
                } catch (error) {
                    console.warn('Failed to read local cache:', error);
                    return [];
                }
            };
            
            // Save to Google Drive
            const saveToGoogleDrive = async () => {
                if (!recognitionResults || recognitionResults.length === 0) {
                    alert('‚ùå No data to save. Please detect glyphs first.');
                    return;
                }
                
                // Check if signed in to Google Drive
                if (typeof DriveSync === 'undefined' || !DriveSync.isSignedIn()) {
                    alert('‚ö†Ô∏è Please sign in to Google Drive first.\n\nClick "üîÑ Change Account" below to sign in with your Google account.');
                    setShowCloudSyncModal(true); // Open the modal to sign in
                    return;
                }
                
                // Prepare HKI data format
                // Ensure all results have thumbnails - copy from isolatedGlyphs if missing
                const resultsWithThumbnails = recognitionResults.map((result, index) => {
                    if (result.thumbnail) {
                        return result; // Already has thumbnail
                    }
                    
                    // Try to get thumbnail from isolatedGlyphs using regionIndex
                    if (result.regionIndex !== undefined && isolatedGlyphs[result.regionIndex]?.thumbnail) {
                        console.log(`üì∏ Copying missing thumbnail for result ${index} from isolatedGlyphs[${result.regionIndex}]`);
                        return {
                            ...result,
                            thumbnail: isolatedGlyphs[result.regionIndex].thumbnail
                        };
                    }
                    
                    console.warn(`‚ö†Ô∏è No thumbnail found for result ${index} (regionIndex: ${result.regionIndex})`);
                    return result;
                });
                
                const hkiData = {
                    version: "1.0",
                    timestamp: new Date().toISOString(),
                    inscriptionTitle: inscriptionTitle || `Inscription ${new Date().toLocaleDateString()}`,
                    location: '', // User can add this in metadata
                    image: image, // Base64 image
                    recognitionResults: resultsWithThumbnails,
                    readingOrder: readingOrder,
                    readingDirection: readingDirection,
                    wordBoundaries: Array.from(wordBoundaries),
                    columnBreaks: Array.from(columnBreaks || []),
                    lineBreaks: Array.from(lineBreaks || []),
                    validations: validations,
                    translationEnglish: translationEnglish || '',
                    translationArabic: translationArabic || '',
                    inscriptionNotes: inscriptionNotes || '',
                    actionHistory: actionHistory,
                    statistics: {
                        totalGlyphs: recognitionResults.length,
                        uniqueGlyphs: new Set(recognitionResults.map(r => r.glyph.name)).size,
                        averageConfidence: recognitionResults.length > 0 
                            ? (recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length)
                            : 0
                    }
                };
                
                try {
                    // Generate filename from inscription title
                    const title = inscriptionTitle || 'Inscription';
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    const filename = `${title.replace(/[^a-z0-9]/gi, '_')}_${timestamp}.hki`;
                    
                    const result = await DriveSync.saveToCloud(hkiData, filename);
                    if (result.success) {
                        alert('‚úÖ Saved to Google Drive!\n\nüìÅ File: ' + result.filename);
                        recordAction('save_to_drive', { filename: result.filename });
                    } else {
                        alert('‚ùå Save failed: ' + (result.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Save error:', error);
                    alert('‚ùå Save failed: ' + error.message);
                }
            };
            
            // Enhanced Transcription Display States
            const [showEnhancedTranscription, setShowEnhancedTranscription] = useState(false);
            const [transcriptionFormat, setTranscriptionFormat] = useState('english-ltr'); // english-ltr, arabic-rtl, vertical-rl, vertical-lr
            const [transcriptionScript, setTranscriptionScript] = useState('english'); // english or arabic
            
            // Dismissible tips
            const [showReadingOrderTip, setShowReadingOrderTip] = useState(true);
            const [showDetectionCanvasTip, setShowDetectionCanvasTip] = useState(true);
            const [showCorrectionModalTip, setShowCorrectionModalTip] = useState(true);
            
            // Translation States
            const [translationEnglish, setTranslationEnglish] = useState('');
            const [translationArabic, setTranslationArabic] = useState('');
            const [showTranslationSection, setShowTranslationSection] = useState(false);
            
            // Inscription Metadata
            const [inscriptionNotes, setInscriptionNotes] = useState('');
            const [inscriptionTitle, setInscriptionTitle] = useState('');

            const MASTER_PASTE_URL = ''; // Will update after first upload
            const MASTER_PASTE_RAW_URL = ''; // Will update after first upload

            // ============================================
            // UTILITY FUNCTIONS
            // ============================================
            
            const convertToGitHubUrl = (githubUrl) => {
                if (!githubUrl) return null;
                if (githubUrl.indexOf('http') === 0) {
                    if (githubUrl.indexOf('github.com') !== -1 && githubUrl.indexOf('/blob/') !== -1) {
                        return githubUrl.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                    }
                    return githubUrl;
                }
                if (typeof githubUrl === 'string' && githubUrl.length > 0) {
                    const baseUrl = 'https://raw.githubusercontent.com/hytra3/hakli_glyph_recognizer/main/';
                    const cleanPath = githubUrl.indexOf('/') === 0 ? githubUrl.substring(1) : githubUrl;
                    return baseUrl + cleanPath;
                }
                return null;
            };

            const getImageCoordinates = (event) => {
                if (!imageRef.current) return null;
                const rect = imageRef.current.getBoundingClientRect();
                const scaleX = imageRef.current.naturalWidth / rect.width;
                const scaleY = imageRef.current.naturalHeight / rect.height;
                return {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            };

            const extractRegionThumbnail = (inputImage, region) => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = region.bounds.width;
                    canvas.height = region.bounds.height;

                    ctx.drawImage(
                        inputImage,
                        region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height,
                        0, 0, region.bounds.width, region.bounds.height
                    );

                    return canvas.toDataURL();
                } catch (error) {
                    console.error('Thumbnail extraction error:', error);
                    return null;
                }
            };

            const extractRegionThumbnailWithExclusions = (inputImage, region, exclusions, originalBounds) => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = region.bounds.width;
                    canvas.height = region.bounds.height;

                    // Draw the region
                    ctx.drawImage(
                        inputImage,
                        region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height,
                        0, 0, region.bounds.width, region.bounds.height
                    );

                    // Mask out the excluded regions with white rectangles
                    ctx.fillStyle = 'white';
                    exclusions.forEach(exRegion => {
                        // Convert exclusion region coordinates to thumbnail-relative coordinates
                        const thumbX = exRegion.x - region.bounds.x;
                        const thumbY = exRegion.y - region.bounds.y;
                        const thumbWidth = exRegion.width;
                        const thumbHeight = exRegion.height;

                        // Only draw if the exclusion intersects with the thumbnail region
                        if (thumbX < region.bounds.width && thumbY < region.bounds.height &&
                            thumbX + thumbWidth > 0 && thumbY + thumbHeight > 0) {
                            
                            const drawX = Math.max(0, thumbX);
                            const drawY = Math.max(0, thumbY);
                            const drawWidth = Math.min(region.bounds.width - drawX, thumbX + thumbWidth - drawX);
                            const drawHeight = Math.min(region.bounds.height - drawY, thumbY + thumbHeight - drawY);

                            ctx.fillRect(drawX, drawY, drawWidth, drawHeight);
                        }
                    });

                    return canvas.toDataURL();
                } catch (error) {
                    console.error('Thumbnail extraction with exclusions error:', error);
                    return null;
                }
            };

            const calculateIoU = (box1, box2) => {
                const x1 = Math.max(box1.x, box2.x);
                const y1 = Math.max(box1.y, box2.y);
                const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
                const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

                const intersectionArea = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
                const box1Area = box1.width * box1.height;
                const box2Area = box2.width * box2.height;
                const unionArea = box1Area + box2Area - intersectionArea;

                return unionArea > 0 ? intersectionArea / unionArea : 0;
            };

            // Add this utility function at the top
            const preprocessImageForMatching = (img) => {
                let gray = new cv.Mat();
                const binary = new cv.Mat();
                const processed = new cv.Mat();

                if (img.channels() > 1) {
                    cv.cvtColor(img, gray, cv.COLOR_RGBA2GRAY);
                } else {
                    img.copyTo(gray);
                }

                cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 3);

                // Lighter preprocessing for ancient inscriptions
                const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                cv.morphologyEx(binary, processed, cv.MORPH_CLOSE, kernel);

                // Skip MORPH_OPEN and erosion - they fragment ancient inscriptions
                // cv.morphologyEx(processed, processed, cv.MORPH_OPEN, kernel);
                // const thinKernel = cv.getStructuringElement(cv.MORPH_CROSS, new cv.Size(2, 2));
                // cv.erode(processed, processed, thinKernel, new cv.Point(-1, -1), 1);

                kernel.delete();
                // thinKernel.delete();  // Commented out since we're not creating it
                gray.delete();
                binary.delete();

                return processed;
            };

            // ============================================
            // GLYPH ISOLATION & RECOGNITION
            // ============================================

            const isolateGlyphs = (inputImage) => {
                if (!isOpenCvReady) return [];
                try {
                    const src = cv.imread(inputImage);
                    const gray = new cv.Mat();
                    const binary = new cv.Mat();
                    const denoised = new cv.Mat();
                    const processed = new cv.Mat();

                    // Convert to grayscale
                    if (src.channels() > 1) {
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    } else {
                        src.copyTo(gray);
                    }
                    // Adaptive thresholding
                    cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

                    // Remove noise with opening (erosion then dilation)
                    const smallKernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(2, 2));
                    cv.morphologyEx(binary, denoised, cv.MORPH_OPEN, smallKernel);

                    // Connect broken strokes with closing (dilation then erosion)
                    const largeKernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                    cv.morphologyEx(denoised, processed, cv.MORPH_CLOSE, largeKernel);

                    // Find contours
                    const contours = new cv.MatVector();
                    const hierarchy = new cv.Mat();
                    cv.findContours(processed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    const isolatedRegions = [];

                    // Calculate dynamic thresholds based on image size
                    const imageArea = src.rows * src.cols;
                    // For small images (<50k pixels), use smaller minimum area
                    const isSmallImage = imageArea < 50000;
                    const minArea = isSmallImage ? Math.max(10, imageArea * 0.0005) : imageArea * 0.002;
                    const maxArea = imageArea * 0.15;   // 15% of image (increased for small images)
                    
                    console.log(`üîç Isolation: image ${src.cols}x${src.rows} (${imageArea}px), minArea=${minArea.toFixed(0)}, maxArea=${maxArea.toFixed(0)}, contours=${contours.size()}`);

                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const boundingRect = cv.boundingRect(contour);
                        const area = boundingRect.width * boundingRect.height;
                        const aspectRatio = boundingRect.width / boundingRect.height;

                        // Calculate solidity (ratio of contour area to bounding box area)
                        const contourArea = cv.contourArea(contour);
                        const solidity = contourArea / area;

                        // Filter criteria - more lenient for small images
                        const sizeOk = area >= minArea && area <= maxArea;
                        const aspectOk = aspectRatio >= 0.1 && aspectRatio <= 10.0;  // More lenient
                        const solidityOk = solidity >= 0.15; // More lenient for small regions

                        if (sizeOk && aspectOk && solidityOk) {
                            const padding = 5;
                            isolatedRegions.push({
                                bounds: {
                                    x: Math.max(0, boundingRect.x - padding),
                                    y: Math.max(0, boundingRect.y - padding),
                                    width: Math.min(src.cols - boundingRect.x + padding, boundingRect.width + 2 * padding),
                                    height: Math.min(src.rows - boundingRect.y + padding, boundingRect.height + 2 * padding)
                                },
                                area,
                                aspectRatio,
                                solidity
                            });
                        }
                    }

                    // Sort by position (left to right, top to bottom)
                    isolatedRegions.sort((a, b) => {
                        const rowDiff = a.bounds.y - b.bounds.y;
                        if (Math.abs(rowDiff) > 20) return rowDiff; // Different rows
                        return a.bounds.x - b.bounds.x; // Same row, sort by x
                    });

                    console.log(`‚úì Isolated ${isolatedRegions.length} regions`);

                    // Cleanup
                    src.delete();
                    gray.delete();
                    binary.delete();
                    denoised.delete();
                    processed.delete();
                    smallKernel.delete();
                    largeKernel.delete();
                    contours.delete();
                    hierarchy.delete();

                    return isolatedRegions;
                } catch (error) {
                    console.error('Glyph isolation error:', error);
                    return [];
                }
            };

            const performTemplateMatchingOnRegion = (inputImage, templateImage, region, glyphId) => {
                if (!isOpenCvReady) return [];
                try {
                    const src = cv.imread(inputImage);
                    const regionMat = src.roi(new cv.Rect(region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height));
                    const templ = cv.imread(templateImage);
                    const matches = [];

                    // Enhanced preprocessing - normalize both images
                    const preprocessForShape = (img) => {
                        let gray = new cv.Mat();
                        const binary = new cv.Mat();
                        const processed = new cv.Mat();  // ADD THIS LINE

                        // Convert to grayscale
                        if (img.channels() > 1) {
                            cv.cvtColor(img, gray, cv.COLOR_RGBA2GRAY);
                        } else {
                            img.copyTo(gray);
                        }

                        // Adaptive threshold
                        cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 3);

                        // Lighter preprocessing for ancient inscriptions
                        const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                        cv.morphologyEx(binary, processed, cv.MORPH_CLOSE, kernel);

                        // Skip aggressive erosion that fragments Glyphs
                        // const thinKernel = cv.getStructuringElement(cv.MORPH_CROSS, new cv.Size(3, 3));
                        // cv.erode(processed, processed, thinKernel, new cv.Point(-1, -1), 2);

                        kernel.delete();
                        // thinKernel.delete();  // Commented out
                        gray.delete();
                        binary.delete();

                        return processed;  // CHANGE FROM 'normalized' TO 'processed'
                    };

                    const processedRegion = preprocessForShape(regionMat);
                    const processedTemplate = preprocessForShape(templ);

                    // Method 1: Contour Shape Matching (PRIMARY)
                    let shapeScore = 0;
                    let shapeMethod = 'none';
                    try {
                        const contoursRegion = new cv.MatVector();
                        const contoursTemplate = new cv.MatVector();
                        const hierarchy = new cv.Mat();

                        cv.findContours(processedRegion, contoursRegion, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                        cv.findContours(processedTemplate, contoursTemplate, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                        if (contoursRegion.size() > 0 && contoursTemplate.size() > 0) {
                            // Find largest contour in each
                            let maxAreaRegion = 0;
                            let maxContourRegionIdx = 0;
                            for (let i = 0; i < contoursRegion.size(); i++) {
                                const area = cv.contourArea(contoursRegion.get(i));
                                if (area > maxAreaRegion) {
                                    maxAreaRegion = area;
                                    maxContourRegionIdx = i;
                                }
                            }

                            let maxAreaTemplate = 0;
                            let maxContourTemplateIdx = 0;
                            for (let i = 0; i < contoursTemplate.size(); i++) {
                                const area = cv.contourArea(contoursTemplate.get(i));
                                if (area > maxAreaTemplate) {
                                    maxAreaTemplate = area;
                                    maxContourTemplateIdx = i;
                                }
                            }

                            // Try all 3 shape matching methods
                            const methods = [
                                { method: cv.CONTOURS_MATCH_I1, name: 'I1' },
                                { method: cv.CONTOURS_MATCH_I2, name: 'I2' },
                                { method: cv.CONTOURS_MATCH_I3, name: 'I3' }
                            ];

                            let bestShapeScore = 0;
                            for (const m of methods) {
                                try {
                                    const shapeDiff = cv.matchShapes(
                                        contoursRegion.get(maxContourRegionIdx),
                                        contoursTemplate.get(maxContourTemplateIdx),
                                        m.method,
                                        0
                                    );

                                    // Convert distance to similarity (lower distance = higher score)
                                    // Different methods have different scales
                                    let score = 0;
                                    if (m.method === cv.CONTOURS_MATCH_I1) {
                                        score = Math.max(0, 1 - (shapeDiff / 3)); // I1 tends to give values 0-3
                                    } else if (m.method === cv.CONTOURS_MATCH_I2) {
                                        score = Math.max(0, 1 - (shapeDiff / 5)); // I2 tends to give values 0-5
                                    } else {
                                        score = Math.max(0, 1 - (shapeDiff / 10)); // I3 can give larger values
                                    }

                                    if (score > bestShapeScore) {
                                        bestShapeScore = score;
                                        shapeMethod = m.name;
                                    }
                                } catch (e) {
                                    // Method failed, skip
                                }
                            }

                            shapeScore = bestShapeScore;
                        }

                        contoursRegion.delete();
                        contoursTemplate.delete();
                        hierarchy.delete();
                    } catch (shapeError) {
                        console.log(`Shape matching failed for ${glyphId}:`, shapeError);
                        shapeScore = 0;
                    }

                    // Method 2: Aspect Ratio Similarity
                    let aspectScore = 0;
                    const regionAspect = processedRegion.cols / processedRegion.rows;
                    const templateAspect = processedTemplate.cols / processedTemplate.rows;
                    const aspectDiff = Math.abs(regionAspect - templateAspect);
                    aspectScore = Math.max(0, 1 - aspectDiff);

                    // Method 3: Template Matching (SECONDARY - only best scale)
                    let templateScore = 0;
                    let bestScale = 1.0;
                    let bestRotation = 0;
                    try {
                        // Try fewer scales, focus on likely matches :: added more scales because not matching
                        const scales = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 1.1, 1.2];
                        // Try rotations for in-situ inscriptions (¬±10 degrees in 5-degree increments)
                        const rotations = [-10, -5, 0, 5, 10];

                        for (const rotation of rotations) {
                            // Rotate template if needed
                            let rotatedTemplate = processedTemplate;
                            if (rotation !== 0) {
                                rotatedTemplate = new cv.Mat();
                                const center = new cv.Point(processedTemplate.cols / 2, processedTemplate.rows / 2);
                                const rotMatrix = cv.getRotationMatrix2D(center, rotation, 1.0);
                                cv.warpAffine(processedTemplate, rotatedTemplate, rotMatrix, processedTemplate.size());
                                rotMatrix.delete();
                            }

                            for (const scale of scales) {
                                const scaledTempl = new cv.Mat();
                                const newSize = new cv.Size(
                                    Math.floor(rotatedTemplate.cols * scale),
                                    Math.floor(rotatedTemplate.rows * scale)
                                );

                                if (newSize.width < 10 || newSize.height < 10 ||
                                    newSize.width > processedRegion.cols || newSize.height > processedRegion.rows) {
                                    continue;
                                }

                                cv.resize(rotatedTemplate, scaledTempl, newSize, 0, 0, cv.INTER_AREA);

                                const dst = new cv.Mat();
                                cv.matchTemplate(processedRegion, scaledTempl, dst, cv.TM_CCOEFF_NORMED);
                                const result = cv.minMaxLoc(dst);

                                if (result.maxVal > templateScore) {
                                    templateScore = result.maxVal;
                                    bestScale = scale;
                                    bestRotation = rotation;
                                }

                                dst.delete();
                                scaledTempl.delete();
                            }

                            // Clean up rotated template if we created one
                            if (rotation !== 0) {
                                rotatedTemplate.delete();
                            }
                        }
                    } catch (e) {
                        templateScore = 0;
                    }

                    // Weighted combination - SHAPE is primary
                    const weights = {
                        shape: 0.70,      // Shape matching is most important
                        aspect: 0.15,     // Aspect ratio helps
                        template: 0.15    // Template is just a tiebreaker
                    };

                    const combinedScore = (shapeScore * weights.shape) +
                        (aspectScore * weights.aspect) +
                        (templateScore * weights.template);

                    // Only log low confidence matches (might be wrong) and high confidence (definitely right)
                    if (combinedScore < 0.5 || combinedScore > 0.8) {
                        console.log(`Glyph ${glyphId}: Combined=${(combinedScore * 100).toFixed(1)}% [Shape=${(shapeScore * 100).toFixed(1)}% Aspect=${(aspectScore * 100).toFixed(1)}% Template=${(templateScore * 100).toFixed(1)}%] Scale=${bestScale.toFixed(2)} Rotation=${bestRotation}¬∞`);
                    }

                    // Lower threshold since we're focusing on shape (raised to .4 from .3 : .3 was lower shape)
                    if (combinedScore >= 0.40) {  // Stricter threshold
                        matches.push({
                            confidence: combinedScore,
                            position: region.bounds,
                            scale: bestScale,
                            rotation: bestRotation,
                            debug: {
                                shapeScore: shapeScore,
                                aspectScore: aspectScore,
                                templateScore: templateScore,
                                shapeMethod: shapeMethod,
                                rotation: bestRotation
                            }
                        });
                    }

                    processedRegion.delete();
                    processedTemplate.delete();
                    src.delete();
                    regionMat.delete();
                    templ.delete();

                    return matches;
                } catch (error) {
                    console.error('Shape matching error:', error);
                    return [];
                }
            };

            const applyNonMaximumSuppression = (detections, iouThreshold = 0.3) => {
                if (detections.length === 0) return detections;

                // Sort by confidence (highest first)
                const sorted = [...detections].sort((a, b) => b.confidence - a.confidence);
                const keep = [];

                while (sorted.length > 0) {
                    const current = sorted.shift();
                    keep.push(current);

                    // Remove detections that overlap too much with current
                    for (let i = sorted.length - 1; i >= 0; i--) {
                        const iou = calculateIoU(current.position, sorted[i].position);
                        if (iou > iouThreshold) {
                            sorted.splice(i, 1);
                        }
                    }
                }

                return keep;
            };

            const recognizeGlyphs = () => {
                if (!image || !equivalenceChart || !isOpenCvReady) return;
                setIsProcessing(true);
                setRecognitionResults([]);
                console.log('Starting recognition with', equivalenceChart.glyphs.length, 'Glyphs and', Object.keys(loadedGlyphImages).length, 'loaded images');
                
                // Use preprocessed image if available, otherwise use original
                const sourceForRecognition = preprocessedMat || originalMat;
                
                if (sourceForRecognition) {
                    // Use the OpenCV Mat directly - convert to canvas then to Image
                    console.log('‚úì Using preprocessed image for recognition');
                    const canvas = document.createElement('canvas');
                    cv.imshow(canvas, sourceForRecognition);
                    
                    const tempImg = new Image();
                    tempImg.onload = async () => {
                        try {
                        // The preprocessing already includes rotation, so skip that step
                        let processImg = tempImg;
                        console.log(`‚úì Using preprocessed image: ${processImg.width}x${processImg.height}`);
                        setRotatedImageDimensions({ width: processImg.width, height: processImg.height });
                        
                        // Convert canvas back to data URL for display
                        setDisplayImage(canvas.toDataURL());
                        
                        const isolated = isolateGlyphs(processImg);
                        const isolatedWithThumbnails = isolated.map(region => ({
                            ...region,
                            thumbnail: extractRegionThumbnail(processImg, region)
                        }));
                        setIsolatedGlyphs(isolatedWithThumbnails);
                        console.log('‚úì Isolated', isolated.length, 'regions');
                        if (isolated.length === 0) {
                            console.log('No regions found - check image contrast and size');
                            setIsProcessing(false);
                            return;
                        }

                        const results = [];
                        let totalMatches = 0;
                        const totalRegions = isolated.length;

                        // Loop through each region with progress tracking
                        for (let regionIndex = 0; regionIndex < isolated.length; regionIndex++) {
                            const region = isolated[regionIndex];

                            // Update progress
                            setProcessingProgress({ current: regionIndex + 1, total: totalRegions });
                            console.log('üìä Progress:', regionIndex + 1, 'of', totalRegions);    

                            let topMatches = []; // Track top 3 matches

                            for (const glyph of equivalenceChart.glyphs) {
                                // Check primary image
                                if (loadedGlyphImages[glyph.id]) {
                                    const matches = performTemplateMatchingOnRegion(processImg, loadedGlyphImages[glyph.id], region, glyph.id);
                                    totalMatches += matches.length;
                                    for (const match of matches) {
                                        topMatches.push({
                                            glyph,
                                            confidence: match.confidence,
                                            position: region.bounds,
                                            matchType: 'primary'
                                        });
                                    }
                                }

                                // Check variant images
                                if (glyph.images && glyph.images.variants) {
                                    for (let i = 0; i < glyph.images.variants.length; i++) {
                                        const variantKey = `${glyph.id}_variant_${i}`;
                                        if (loadedGlyphImages[variantKey]) {
                                            const matches = performTemplateMatchingOnRegion(processImg, loadedGlyphImages[variantKey], region, `${glyph.id}_v${i}`);
                                            for (const match of matches) {
                                                const weightedConfidence = match.confidence * 0.95;
                                                topMatches.push({
                                                    glyph,
                                                    confidence: weightedConfidence,
                                                    position: region.bounds,
                                                    matchType: 'variant',
                                                    variantIndex: i
                                                });
                                            }
                                        }
                                    }
                                }

                                // Check example images
                                if (glyph.images && glyph.images.examples) {
                                    for (let i = 0; i < glyph.images.examples.length; i++) {
                                        const exampleKey = `${glyph.id}_example_${i}`;
                                        if (loadedGlyphImages[exampleKey]) {
                                            const matches = performTemplateMatchingOnRegion(processImg, loadedGlyphImages[exampleKey], region, `${glyph.id}_ex${i}`);
                                            for (const match of matches) {
                                                const weightedConfidence = match.confidence * 0.90;
                                                topMatches.push({
                                                    glyph,
                                                    confidence: weightedConfidence,
                                                    position: region.bounds,
                                                    matchType: 'example',
                                                    exampleIndex: i
                                                });
                                            }
                                        }
                                    }
                                }
                            }

                            // Sort by confidence and keep top 3
                            topMatches.sort((a, b) => b.confidence - a.confidence);
                            const top3 = topMatches.slice(0, 3);
                            
                            // Use best match as primary
                            const bestMatch = top3[0];
                            
                            if (bestMatch && bestMatch.confidence > 0.30) {
                                // Check if there's a close second match (within 15%)
                                const hasCloseMatch = top3.length > 1 && 
                                    (bestMatch.confidence - top3[1].confidence) < 0.15;
                                
                                results.push({
                                    ...bestMatch,
                                    regionIndex: regionIndex,
                                    alternatives: top3.slice(1), // Include 2nd and 3rd place
                                    hasCloseMatch: hasCloseMatch,
                                    selectedAlternative: null // Track if user manually selects different option
                                });
                                
                                const altText = hasCloseMatch ? ` (alt: ${top3[1].glyph.name})` : '';
                                console.log(`‚úÖ Region ${regionIndex + 1}: ${bestMatch.glyph.name} (${Math.round(bestMatch.confidence * 100)}%)${altText}`);
                            }
                        }
                        // Reset progress when done
                        setProcessingProgress({ current: 0, total: 0 });

                        // Apply non-maximum suppression to remove overlapping detections
                        const filteredResults = applyNonMaximumSuppression(results, 0.3);
                        console.log(`‚úì Recognition complete: ${filteredResults.length} glyphs detected (${results.length - filteredResults.length} overlapping removed)`);

                        // Apply confidence threshold filter based on slider value
                        const confidenceFilteredResults = filteredResults.filter(r =>
                            r.confidence >= (confidenceThreshold / 100)
                        );

                        console.log(`‚úì After confidence filter (${confidenceThreshold}%): ${confidenceFilteredResults.length} glyphs (${filteredResults.length - confidenceFilteredResults.length} filtered out)`);

                        setRecognitionResults(confidenceFilteredResults);
                        setIsProcessing(false);
                        
                        // Take initial snapshot for undo system
                        setTimeout(() => {
                            takeSnapshotBeforeChange();
                            console.log('üì∏ Initial snapshot taken after recognition');
                        }, 100);
                    } catch (error) {
                        console.error('Recognition error:', error);
                        setIsProcessing(false);
                    }
                };
                tempImg.src = canvas.toDataURL();
            } else {
                // Fallback to original image if no preprocessing
                console.log('‚ö† No preprocessed image available, using original');
                const tempImg = new Image();
                tempImg.onload = async () => {
                    try {
                        let processImg = tempImg;
                        setRotatedImageDimensions({ width: processImg.width, height: processImg.height });
                        setDisplayImage(image);
                        
                        const isolated = isolateGlyphs(processImg);
                        const isolatedWithThumbnails = isolated.map(region => ({
                            ...region,
                            thumbnail: extractRegionThumbnail(processImg, region)
                        }));
                        setIsolatedGlyphs(isolatedWithThumbnails);
                        console.log('‚úì Isolated', isolated.length, 'regions');
                        if (isolated.length === 0) {
                            console.log('No regions found - check image contrast and size');
                            setIsProcessing(false);
                            return;
                        }

                        const results = [];
                        let totalMatches = 0;
                        const totalRegions = isolated.length;

                        for (let regionIndex = 0; regionIndex < isolated.length; regionIndex++) {
                            const region = isolated[regionIndex];
                            setProcessingProgress({ current: regionIndex + 1, total: totalRegions });
                            console.log('üìä Progress:', regionIndex + 1, 'of', totalRegions);    

                            let bestMatch = null;
                            let bestRawConfidence = 0;

                            for (const glyph of equivalenceChart.glyphs) {
                                if (loadedGlyphImages[glyph.id]) {
                                    const matches = performTemplateMatchingOnRegion(processImg, loadedGlyphImages[glyph.id], region, glyph.id);
                                    totalMatches += matches.length;
                                    for (const match of matches) {
                                        if (match.confidence > bestRawConfidence) {
                                            bestRawConfidence = match.confidence;
                                            bestMatch = {
                                                glyph,
                                                confidence: match.confidence,
                                                position: region.bounds,
                                                matchType: 'primary'
                                            };
                                        }
                                    }
                                }
                            }

                            if (bestMatch) {
                                results.push(bestMatch);
                            }
                        }

                        console.log(`‚úì Found ${results.length} glyphs out of ${totalRegions} regions (checked ${totalMatches} template combinations)`);
                        const confidenceFilteredResults = useConfidenceFilter 
                            ? results.filter(r => r.confidence >= (confidenceThreshold / 100))
                            : results;

                        setRecognitionResults(confidenceFilteredResults);
                        setIsProcessing(false);
                    } catch (error) {
                        console.error('Recognition error:', error);
                        setIsProcessing(false);
                    }
                };
                tempImg.src = image;
            }
            };  // end recognizeGlyphs

            // ============================================
            // DETECTION MANIPULATION
            // ============================================

            const validateDetection = (detectionIndex, isCorrect) => {
                recordAction('validation', {
                    detectionIndex,
                    isCorrect,
                    detectionData: recognitionResults[detectionIndex]
                });
                setValidations(prev => ({
                    ...prev,
                    [detectionIndex]: {
                        isCorrect,
                        timestamp: new Date().toISOString(),
                        detectionData: recognitionResults[detectionIndex]
                    }
                }));
            };

            const deleteIsolatedRegion = (regionIndex) => {
                recordAction('delete_isolated_region', {
                    index: regionIndex,
                    region: isolatedGlyphs[regionIndex]
                });

                // Remove the isolated region
                setIsolatedGlyphs(prev => prev.filter((_, i) => i !== regionIndex));

                // Remove any detections that reference this region
                setRecognitionResults(prev => prev.filter(r => r.regionIndex !== regionIndex).map(r => ({
                    ...r,
                    regionIndex: r.regionIndex > regionIndex ? r.regionIndex - 1 : r.regionIndex
                })));

                // Clear selection
                setSelectedIsolatedRegion(null);

                console.log(`‚úì Deleted isolated region ${regionIndex}`);
            };

            const deleteDetection = (detectionIndex) => {
                // Take snapshot BEFORE making changes for undo
                takeSnapshotBeforeChange();
                
                recordAction('delete_detection', {
                    index: detectionIndex,
                    detection: recognitionResults[detectionIndex]
                });
                // Update recognition results
                setRecognitionResults(prev => prev.filter((_, i) => i !== detectionIndex));
                // Update validations with shifted indices
                setValidations(prev => {
                    const newValidations = { ...prev };
                    delete newValidations[detectionIndex];
                    const shifted = {};
                    Object.keys(newValidations).forEach(key => {
                        const numKey = parseInt(key);
                        shifted[numKey > detectionIndex ? numKey - 1 : numKey] = newValidations[key];
                    });
                    return shifted;
                });
                // Update selected regions - remove deleted index and shift others
                setSelectedRegions(prev => {
                    const newSet = new Set();
                    prev.forEach(idx => {
                        if (idx !== detectionIndex) {
                            // Shift down indices that come after the deleted one
                            newSet.add(idx > detectionIndex ? idx - 1 : idx);
                        }
                    });
                    return newSet;
                });
                // Clear merge indicator if it existed
                setMergeIndicator(null);
            };

            const mergeSelectedDetections = () => {
                const selectedIndices = Array.from(selectedRegions).sort((a, b) => a - b);
                if (selectedIndices.length < 2) {
                    alert('Please select at least 2 detections to merge');
                    return;
                }
                
                // Take snapshot BEFORE making changes for undo
                takeSnapshotBeforeChange();

                const detectionsToMerge = selectedIndices.map(i => recognitionResults[i]);
                const minX = Math.min(...detectionsToMerge.map(d => d.position.x));
                const minY = Math.min(...detectionsToMerge.map(d => d.position.y));
                const maxX = Math.max(...detectionsToMerge.map(d => d.position.x + d.position.width));
                const maxY = Math.max(...detectionsToMerge.map(d => d.position.y + d.position.height));

                const baseDetection = detectionsToMerge.reduce((best, current) =>
                    current.confidence > best.confidence ? current : best
                );

                const mergedBounds = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };

                // Extract new thumbnail for merged region
                const mergedThumbnail = extractRegionThumbnail(imageRef.current, { bounds: mergedBounds });

                const mergedDetection = {
                    ...baseDetection,
                    position: mergedBounds,
                    confidence: detectionsToMerge.reduce((sum, d) => sum + d.confidence, 0) / detectionsToMerge.length,
                    mergedFrom: detectionsToMerge.length,
                    isMerged: true,
                    thumbnail: mergedThumbnail,  // Add the new thumbnail
                    regionIndex: isolatedGlyphs.length  // Will be the next index
                };

                recordAction('merge_detections', {
                    indices: selectedIndices,
                    detections: detectionsToMerge,
                    mergedResult: mergedDetection
                });

                // Remove the merged detections
                let newResults = recognitionResults.slice();
                for (let i = selectedIndices.length - 1; i >= 0; i--) {
                    newResults.splice(selectedIndices[i], 1);
                }
                newResults.push(mergedDetection);

                // Add merged region to isolated glyphs
                setIsolatedGlyphs(prev => [...prev, {
                    bounds: mergedBounds,
                    thumbnail: mergedThumbnail,
                    area: mergedBounds.width * mergedBounds.height,
                    aspectRatio: mergedBounds.width / mergedBounds.height
                }]);

                setRecognitionResults(newResults);
                setSelectedRegions(new Set());
                setMergeIndicator(null);
            };

            const applyTrim = (detectionIndex, newBounds) => {
                const detection = recognitionResults[detectionIndex];
                const oldBounds = detection.position;

                // Ensure new bounds are within old bounds
                const trimmedBounds = {
                    x: Math.max(oldBounds.x, newBounds.x),
                    y: Math.max(oldBounds.y, newBounds.y),
                    width: Math.min(newBounds.x + newBounds.width, oldBounds.x + oldBounds.width) - Math.max(oldBounds.x, newBounds.x),
                    height: Math.min(newBounds.y + newBounds.height, oldBounds.y + oldBounds.height) - Math.max(oldBounds.y, newBounds.y)
                };

                if (trimmedBounds.width < 10 || trimmedBounds.height < 10) {
                    alert('‚ùå Trimmed region too small. Try again.');
                    setTrimMode(null);
                    return;
                }

                // Extract new thumbnail
                const thumbnail = extractRegionThumbnail(imageRef.current, { bounds: trimmedBounds });

                // Update the detection
                const updatedDetection = {
                    ...detection,
                    position: trimmedBounds,
                    thumbnail: thumbnail,
                    trimmed: true,
                    originalBounds: oldBounds
                };

                // Update isolated glyph if it exists
                if (detection.regionIndex !== undefined) {
                    setIsolatedGlyphs(prev => {
                        const updated = [...prev];
                        updated[detection.regionIndex] = {
                            bounds: trimmedBounds,
                            thumbnail: thumbnail,
                            area: trimmedBounds.width * trimmedBounds.height,
                            aspectRatio: trimmedBounds.width / trimmedBounds.height
                        };
                        return updated;
                    });
                }

                // Update recognition results
                setRecognitionResults(prev =>
                    prev.map((r, i) => i === detectionIndex ? updatedDetection : r)
                );

                recordAction('trim_detection', {
                    index: detectionIndex,
                    oldBounds,
                    newBounds: trimmedBounds
                });

                setTrimMode(null);
                alert('‚úÖ Detection trimmed! You may want to correct the glyph if recognition changed.');
            };

            const applyExclude = (detectionIndex) => {
                if (excludeRegions.length === 0) {
                    alert('‚ùå No exclusion regions drawn. Draw at least one region to exclude.');
                    return;
                }

                const detection = recognitionResults[detectionIndex];
                const originalBounds = detection.position;
                const oldGlyph = detection.glyph.name;

                try {
                    const tempImg = new Image();
                    tempImg.src = image;

                    tempImg.onload = () => {
                        const src = cv.imread(tempImg);
                        const regionMat = src.roi(new cv.Rect(
                            originalBounds.x,
                            originalBounds.y,
                            originalBounds.width,
                            originalBounds.height
                        ));

                        // Create mask (white = keep, black = exclude)
                        const mask = new cv.Mat(regionMat.rows, regionMat.cols, cv.CV_8UC1, new cv.Scalar(255));

                        // Draw exclusion regions on mask
                        excludeRegions.forEach(exRegion => {
                            const relX = exRegion.x - originalBounds.x;
                            const relY = exRegion.y - originalBounds.y;
                            const relWidth = exRegion.width;
                            const relHeight = exRegion.height;

                            if (relX < regionMat.cols && relY < regionMat.rows &&
                                relX + relWidth > 0 && relY + relHeight > 0) {
                                const point1 = new cv.Point(
                                    Math.max(0, relX),
                                    Math.max(0, relY)
                                );
                                const point2 = new cv.Point(
                                    Math.min(regionMat.cols, relX + relWidth),
                                    Math.min(regionMat.rows, relY + relHeight)
                                );
                                cv.rectangle(mask, point1, point2, new cv.Scalar(0), -1);
                            }
                        });

                        // Apply mask to get only the glyph pixels that should remain
                        const gray = new cv.Mat();
                        const binary = new cv.Mat();
                        
                        // Convert to grayscale
                        if (regionMat.channels() > 1) {
                            cv.cvtColor(regionMat, gray, cv.COLOR_RGBA2GRAY);
                        } else {
                            regionMat.copyTo(gray);
                        }
                        
                        // Use Otsu's method for adaptive thresholding
                        // This automatically finds the best threshold value
                        cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
                        
                        // Apply the exclusion mask
                        const masked = new cv.Mat();
                        cv.bitwise_and(binary, mask, masked);
                        
                        // Add some morphological operations to clean up noise
                        const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                        const cleaned = new cv.Mat();
                        cv.morphologyEx(masked, cleaned, cv.MORPH_CLOSE, kernel);
                        cv.morphologyEx(cleaned, cleaned, cv.MORPH_OPEN, kernel);
                        
                        // Find bounding box of remaining glyph pixels
                        let minX = cleaned.cols, minY = cleaned.rows, maxX = 0, maxY = 0;
                        let hasPixels = false;
                        let pixelCount = 0;

                        for (let y = 0; y < cleaned.rows; y++) {
                            for (let x = 0; x < cleaned.cols; x++) {
                                if (cleaned.ucharAt(y, x) > 0) {
                                    hasPixels = true;
                                    pixelCount++;
                                    minX = Math.min(minX, x);
                                    minY = Math.min(minY, y);
                                    maxX = Math.max(maxX, x);
                                    maxY = Math.max(maxY, y);
                                }
                            }
                        }

                        src.delete();
                        regionMat.delete();
                        mask.delete();
                        gray.delete();
                        binary.delete();
                        masked.delete();
                        cleaned.delete();
                        kernel.delete();
                        
                        console.log(`Exclude: Found ${pixelCount} glyph pixels, bounds: (${minX},${minY}) to (${maxX},${maxY})`);

                        if (!hasPixels) {
                            alert('‚ùå Exclusion removed all content. Canceling.');
                            setExcludeMode(null);
                            setExcludeRegions([]);
                            return;
                        }

                        // Create new bounds
                        const newBounds = {
                            x: originalBounds.x + minX,
                            y: originalBounds.y + minY,
                            width: maxX - minX + 1,
                            height: maxY - minY + 1
                        };

                        if (newBounds.width < 10 || newBounds.height < 10) {
                            alert('‚ùå Remaining region too small after exclusion.');
                            setExcludeMode(null);
                            setExcludeRegions([]);
                            return;
                        }

                        const thumbnail = extractRegionThumbnailWithExclusions(tempImg, { bounds: newBounds }, excludeRegions, originalBounds);

                        const newDetection = {
                            glyph: { id: 'unknown', name: 'Unknown', transliteration: '?' },
                            confidence: 0.5,
                            position: newBounds,
                            matchType: 'excluded',
                            isExcluded: true,
                            thumbnail: thumbnail,
                            regionIndex: isolatedGlyphs.length
                        };

                        setRecognitionResults(prev => {
                            const updated = [...prev];
                            updated.splice(detectionIndex, 1);
                            updated.push(newDetection);
                            return updated;
                        });
                        
                        // Update reading order to account for removed and added detection
                        setReadingOrder(prev => {
                            if (prev.length === 0) return prev;
                            // Remove the deleted index and adjust all indices after it
                            const newOrder = prev
                                .filter(idx => idx !== detectionIndex)
                                .map(idx => idx > detectionIndex ? idx - 1 : idx);
                            // Add the new detection at the end
                            newOrder.push(recognitionResults.length - 1);
                            return newOrder;
                        });

                        setIsolatedGlyphs(prev => [...prev, {
                            bounds: newBounds,
                            thumbnail: thumbnail,
                            area: newBounds.width * newBounds.height,
                            aspectRatio: newBounds.width / newBounds.height
                        }]);

                        recordAction('exclude_regions', {
                            originalIndex: detectionIndex,
                            originalGlyph: oldGlyph,
                            exclusions: excludeRegions,
                            newBounds: newBounds
                        });

                        setExcludeMode(null);
                        setExcludeRegions([]);

                        alert(`‚úÖ Excluded regions from "${oldGlyph}"!\n\nNew detection created with adjusted boundaries.\nOriginal detection removed.\n\nüí° Tip: Correct the new "Unknown" detection using ‚úèÔ∏è`);

                        setTimeout(() => {
                            const cards = document.querySelectorAll('.p-3.bg-white.rounded.border');
                            if (cards.length > 0) cards[cards.length - 1].scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 200);
                    };

                    tempImg.onerror = () => {
                        alert('‚ùå Failed to load image for exclusion');
                        setExcludeMode(null);
                        setExcludeRegions([]);
                    };
                } catch (error) {
                    console.error('Exclude error:', error);
                    alert('‚ùå Failed to apply exclusions.');
                    setExcludeMode(null);
                    setExcludeRegions([]);
                }
            };


            const applyAdjustment = (detectionIndex) => {
                const detection = recognitionResults[detectionIndex];
                if (!detection || !imageRef.current) return;

                try {
                    const corners = detection.corners || {
                        tl: { x: detection.position.x, y: detection.position.y },
                        tr: { x: detection.position.x + detection.position.width, y: detection.position.y },
                        bl: { x: detection.position.x, y: detection.position.y + detection.position.height },
                        br: { x: detection.position.x + detection.position.width, y: detection.position.y + detection.position.height }
                    };

                    // Calculate bounding rectangle from corners
                    const minX = Math.min(corners.tl.x, corners.tr.x, corners.bl.x, corners.br.x);
                    const maxX = Math.max(corners.tl.x, corners.tr.x, corners.bl.x, corners.br.x);
                    const minY = Math.min(corners.tl.y, corners.tr.y, corners.bl.y, corners.br.y);
                    const maxY = Math.max(corners.tl.y, corners.tr.y, corners.bl.y, corners.br.y);

                    const newBounds = {
                        x: Math.round(minX),
                        y: Math.round(minY),
                        width: Math.round(maxX - minX),
                        height: Math.round(maxY - minY)
                    };

                    if (newBounds.width < 5 || newBounds.height < 5) {
                        alert('‚ùå Adjusted region too small.');
                        setAdjustMode(null);
                        return;
                    }

                    // Extract thumbnail using polygon mask (Option 5)
                    // This extracts ONLY pixels inside the quadrilateral, excluding unwanted areas
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas size to bounding box
                    canvas.width = newBounds.width;
                    canvas.height = newBounds.height;
                    
                    // Fill with white background
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Create clipping path from the quadrilateral corners
                    ctx.save();
                    ctx.beginPath();
                    // Convert corners to canvas coordinates (relative to bounding box)
                    ctx.moveTo(corners.tl.x - newBounds.x, corners.tl.y - newBounds.y);
                    ctx.lineTo(corners.tr.x - newBounds.x, corners.tr.y - newBounds.y);
                    ctx.lineTo(corners.br.x - newBounds.x, corners.br.y - newBounds.y);
                    ctx.lineTo(corners.bl.x - newBounds.x, corners.bl.y - newBounds.y);
                    ctx.closePath();
                    ctx.clip();
                    
                    // Draw the image with the clipping mask applied
                    ctx.drawImage(
                        imageRef.current,
                        newBounds.x, newBounds.y, newBounds.width, newBounds.height,
                        0, 0, newBounds.width, newBounds.height
                    );
                    ctx.restore();
                    
                    // Convert to data URL
                    const thumbnail = canvas.toDataURL('image/png');

                    // Update the detection with new position and corners
                    setRecognitionResults(prev => {
                        const updated = [...prev];
                        updated[detectionIndex] = {
                            ...updated[detectionIndex],
                            position: newBounds,
                            corners: corners,
                            thumbnail: thumbnail,
                            isAdjusted: true
                        };
                        return updated;
                    });

                    // Update isolated glyph if it exists
                    if (detection.regionIndex !== undefined && isolatedGlyphs[detection.regionIndex]) {
                        setIsolatedGlyphs(prev => {
                            const updated = [...prev];
                            updated[detection.regionIndex] = {
                                ...updated[detection.regionIndex],
                                bounds: newBounds,
                                thumbnail: thumbnail,
                                area: newBounds.width * newBounds.height,
                                aspectRatio: newBounds.width / newBounds.height
                            };
                            return updated;
                        });
                    }

                    recordAction('adjust_bounds', {
                        detectionIndex: detectionIndex,
                        oldBounds: detection.position,
                        newBounds: newBounds,
                        corners: corners
                    });

                    setAdjustMode(null);
                    alert('‚úÖ Box adjusted successfully!');

                } catch (error) {
                    console.error('Adjustment error:', error);
                    alert('‚ùå Failed to apply adjustment.');
                    setAdjustMode(null);
                }
            };


            const saveAsTemplate = (detectionIndex, templateType) => {
                const detection = recognitionResults[detectionIndex];
                if (!detection || !imageRef.current) return;

                let imageDataUrl;

                // If the detection has been adjusted (polygon-masked), use the existing thumbnail
                // Otherwise, extract from the original image with padding
                if (detection.isAdjusted && detection.thumbnail) {
                    // Use the already-masked thumbnail
                    imageDataUrl = detection.thumbnail;
                } else {
                    // Create canvas to crop the region with padding
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const pos = detection.position;

                    // Add padding around the glyph (10%)
                    const padding = Math.max(pos.width, pos.height) * 0.1;
                    const cropX = Math.max(0, pos.x - padding);
                    const cropY = Math.max(0, pos.y - padding);
                    const cropWidth = Math.min(imageRef.current.naturalWidth - cropX, pos.width + padding * 2);
                    const cropHeight = Math.min(imageRef.current.naturalHeight - cropY, pos.height + padding * 2);

                    canvas.width = cropWidth;
                    canvas.height = cropHeight;

                    // Draw the cropped region
                    ctx.drawImage(
                        imageRef.current,
                        cropX, cropY, cropWidth, cropHeight,
                        0, 0, cropWidth, cropHeight
                    );

                    // Convert to data URL
                    imageDataUrl = canvas.toDataURL('image/png');
                }

                // Update equivalence chart
                const updatedChart = { ...equivalenceChart };
                const glyphIndex = updatedChart.glyphs.findIndex(s => s.id === detection.glyph.id);

                if (glyphIndex === -1) {
                    alert('Glyph not found in chart!');
                    return;
                }

                const glyph = updatedChart.glyphs[glyphIndex];

                // Initialize images object if it doesn't exist
                if (!glyph.images) {
                    glyph.images = { primary: null, variants: [], examples: [] };
                }

                // Add based on template type
                if (templateType === 'primary') {
                    glyph.images.primary = imageDataUrl;
                    alert(`‚úÖ Saved as PRIMARY template for "${glyph.name}"\n\nNote: This replaces the existing primary image.`);
                } else if (templateType === 'variant') {
                    if (!glyph.images.variants) glyph.images.variants = [];
                    glyph.images.variants.push(imageDataUrl);
                    alert(`‚úÖ Saved as VARIANT template for "${glyph.name}"\n\nVariants: ${glyph.images.variants.length}`);
                } else if (templateType === 'example') {
                    if (!glyph.images.examples) glyph.images.examples = [];
                    glyph.images.examples.push(imageDataUrl);
                    alert(`‚úÖ Saved as EXAMPLE template for "${glyph.name}"\n\nExamples: ${glyph.images.examples.length}`);
                }

                setEquivalenceChart(updatedChart);

                // Reload the image in the cache
                const img = new Image();
                img.onload = () => {
                    const newCache = { ...loadedGlyphImages };
                    const newThumbnails = { ...glyphThumbnails };
                    if (templateType === 'primary') {
                        newCache[glyph.id] = img; // For OpenCV
                        newThumbnails[glyph.id] = img.src; // For display
                    } else if (templateType === 'variant') {
                        const key = `${glyph.id}_variant_${glyph.images.variants.length - 1}`;
                        newCache[key] = img;
                        newThumbnails[key] = img.src;
                    } else if (templateType === 'example') {
                        const key = `${glyph.id}_example_${glyph.images.examples.length - 1}`;
                        newCache[key] = img;
                        newThumbnails[key] = img.src;
                    }
                    setLoadedGlyphImages(newCache);
                    setGlyphThumbnails(newThumbnails);
                };
                img.src = imageDataUrl;

                recordAction('save_template', {
                    glyphId: detection.glyph.id,
                    glyphName: detection.glyph.name,
                    templateType: templateType,
                    confidence: detection.confidence
                });

                setSelectedForTemplate(null);
            };

            const exportUpdatedChart = () => {
                const chartJson = JSON.stringify(equivalenceChart, null, 2);
                const blob = new Blob([chartJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Hakli_gylphs_training_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('‚úÖ Updated equivalence chart exported!\n\nYou can now:\n1. Review the new templates\n2. Upload to GitHub to use in future sessions\n3. Share with other users');
            };


            // ============================================
            // CLOUD SYNC
            // ============================================

            const uploadCorrectionsToCloud = async () => {
                    try {
                        const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                        const exportData = {
                            version: '1.0',
                            uploadDate: new Date().toISOString(),
                            corrections: corrections,
                            stats: {
                                totalGlyphs: Object.keys(corrections).length,
                                totalCorrections: Object.values(corrections).reduce((sum, c) =>
                                    sum + c.corrections.reduce((s, cor) => s + cor.count, 0), 0)
                            },
                            source: 'hakli-recognizer-community-contribution'
                        };

                        // Create downloadable JSON file
                        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `hakli_corrections_contribution_${new Date().toISOString().slice(0, 10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        // Show instructions
                        const issueUrl = 'https://github.com/hytra3/hakli_glyph_recognizer/issues/new?title=Community%20Corrections%20Contribution&body=Please%20find%20my%20correction%20memory%20attached.%20Thank%20you!';

                        const message = `‚úÖ Corrections file downloaded!\n\n` +
                            `üì§ To share with the community:\n\n` +
                            `1. The file has been downloaded to your computer\n` +
                            `2. Click OK to open a new GitHub Issue\n` +
                            `3. Attach the downloaded JSON file to the issue\n` +
                            `4. Submit the issue\n\n` +
                            `Your corrections will be reviewed and added to the master collection!\n\n` +
                            `Stats: ${exportData.stats.totalCorrections} corrections for ${exportData.stats.totalGlyphs} glyphs`;

                        if (confirm(message)) {
                            window.open(issueUrl, '_blank');
                        }

                        recordAction('export_for_contribution', { stats: exportData.stats });

                        return { success: true };
                    } catch (error) {
                        console.error('Export failed:', error);
                        alert('‚ùå Failed to export corrections. Check console for details.');
                        return null;
                    }
                };

            const downloadCorrectionsFromCloud = async (url = null) => {
                    try {
                        // Default to master collection
                        const masterUrl = url || 'https://raw.githubusercontent.com/hytra3/hakli_glyph_recognizer/main/community-corrections/master.json';

                        // Fetch the corrections data
                        const response = await fetch(masterUrl);
                        if (!response.ok) {
                            if (response.status === 404) {
                                alert('‚ÑπÔ∏è No master corrections available yet.\n\nBe the first to contribute!');
                                return null;
                            }
                            throw new Error('Failed to download corrections');
                        }

                        const cloudData = await response.json();

                        // Check if there are any corrections
                        if (!cloudData.corrections || Object.keys(cloudData.corrections).length === 0) {
                            alert('‚ÑπÔ∏è The master collection is empty.\n\nContribute your corrections to help the community!');
                            return null;
                        }

                        // Merge with existing corrections
                        const existing = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                        let newCorrections = 0;
                        let updatedCorrections = 0;

                        Object.keys(cloudData.corrections).forEach(key => {
                            if (!existing[key]) {
                                existing[key] = cloudData.corrections[key];
                                newCorrections++;
                            } else {
                                // Merge correction counts
                                cloudData.corrections[key].corrections.forEach(cloudCorr => {
                                    const existingCorr = existing[key].corrections.find(c => c.to.id === cloudCorr.to.id);
                                    if (existingCorr) {
                                        existingCorr.count += cloudCorr.count;
                                        updatedCorrections++;
                                    } else {
                                        existing[key].corrections.push(cloudCorr);
                                        newCorrections++;
                                    }
                                });
                            }
                        });

                        localStorage.setItem('hakliCorrections', JSON.stringify(existing));

                        const contributorInfo = cloudData.stats?.contributors?.length > 0
                            ? `\n\nThanks to ${cloudData.stats.contributors.length} contributor(s)!`
                            : '';

                        alert(`‚úÖ Community corrections downloaded!\n\n` +
                            `${newCorrections} new corrections added\n` +
                            `${updatedCorrections} existing corrections updated\n\n` +
                            `Total glyphs in your memory: ${Object.keys(existing).length}` +
                            contributorInfo);

                        recordAction('download_from_cloud', {
                            source: masterUrl,
                            newCorrections,
                            updatedCorrections
                        });

                        return { newCorrections, updatedCorrections };
                    } catch (error) {
                        console.error('Download from cloud failed:', error);
                        alert('‚ùå Failed to download corrections from cloud.\n\nThe master collection may not exist yet, or there may be a network issue.');
                        return null;
                    }
                };
          
            // ============================================
            // CORRECTION MEMORY
            // ============================================

            const saveCorrectionToMemory = (originalGlyph, correctedGlyph, confidence) => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    const key = originalGlyph.id;

                    if (!corrections[key]) {
                        corrections[key] = {
                            originalGlyph: originalGlyph,
                            corrections: []
                        };
                    }

                    // Find if this correction already exists
                    const existingIndex = corrections[key].corrections.findIndex(c => c.to.id === correctedGlyph.id);

                    if (existingIndex >= 0) {
                        corrections[key].corrections[existingIndex].count++;
                        corrections[key].corrections[existingIndex].lastUsed = new Date().toISOString();
                    } else {
                        corrections[key].corrections.push({
                            to: correctedGlyph,
                            count: 1,
                            firstUsed: new Date().toISOString(),
                            lastUsed: new Date().toISOString(),
                            avgConfidence: confidence
                        });
                    }

                    localStorage.setItem('hakliCorrections', JSON.stringify(corrections));
                    console.log('Correction saved to memory:', originalGlyph.name, '‚Üí', correctedGlyph.name);
                } catch (error) {
                    console.error('Failed to save correction:', error);
                }
            };
            
            // Helper function for tracking corrections by ID
            const trackCorrection = (originalGlyphId, correctedGlyphId) => {
                const originalGlyph = equivalenceChart.glyphs.find(g => g.id === originalGlyphId);
                const correctedGlyph = equivalenceChart.glyphs.find(g => g.id === correctedGlyphId);
                
                if (originalGlyph && correctedGlyph) {
                    saveCorrectionToMemory(originalGlyph, correctedGlyph, 0.85); // Default confidence for swaps
                }
            };

            const getCorrectionSuggestion = (glyphId) => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    if (corrections[glyphId] && corrections[glyphId].corrections.length > 0) {
                        // Return most frequently used correction
                        const sorted = [...corrections[glyphId].corrections].sort((a, b) => b.count - a.count);
                        return sorted[0];
                    }
                    return null;
                } catch (error) {
                    console.error('Failed to get correction suggestion:', error);
                    return null;
                }
            };

            const exportCorrectionMemory = () => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    const exportData = {
                        version: '1.0',
                        exportDate: new Date().toISOString(),
                        corrections: corrections,
                        stats: {
                            totalGlyphs: Object.keys(corrections).length,
                            totalCorrections: Object.values(corrections).reduce((sum, c) => sum + c.corrections.reduce((s, cor) => s + cor.count, 0), 0)
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hakli_corrections_${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    alert(`Exported ${exportData.stats.totalCorrections} corrections for ${exportData.stats.totalGlyphs} glyphs!`);
                } catch (error) {
                    console.error('Export failed:', error);
                    alert('Failed to export corrections');
                }
            };

            const importCorrectionMemory = (jsonData) => {
                try {
                    const imported = JSON.parse(jsonData);
                    const existing = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');

                    // Merge imported with existing
                    Object.keys(imported.corrections).forEach(key => {
                        if (existing[key]) {
                            // Merge correction counts
                            imported.corrections[key].corrections.forEach(importedCorr => {
                                const existingCorr = existing[key].corrections.find(c => c.to.id === importedCorr.to.id);
                                if (existingCorr) {
                                    existingCorr.count += importedCorr.count;
                                } else {
                                    existing[key].corrections.push(importedCorr);
                                }
                            });
                        } else {
                            existing[key] = imported.corrections[key];
                        }
                    });

                    localStorage.setItem('hakliCorrections', JSON.stringify(existing));
                    alert(`Imported corrections successfully! Total glyphs in memory: ${Object.keys(existing).length}`);
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Failed to import corrections - invalid file format');
                }
            };

            // ============================================
            // EXPORT FUNCTIONS
            // ============================================

            // Generate transcription text based on format and script
            const getEnhancedTranscription = () => {
                const layoutStructure = getLayoutStructure(); // Returns array of lines, each containing array of columns
                const orderedResults = getReadingOrderedResults();
                
                // Build text with proper breaks marked
                return layoutStructure.map(line => {
                    return line.map(column => {
                        // For RTL, we need to reverse the column
                        const processedColumn = transcriptionFormat === 'arabic-rtl' 
                            ? [...column].reverse() 
                            : column;
                        
                        let columnText = '';
                        processedColumn.forEach((result, colIndex) => {
                            const text = transcriptionScript === 'arabic' 
                                ? (result.glyph.arabic || result.glyph.name)
                                : (result.glyph.transliteration || result.glyph.name);
                            
                            columnText += text;
                            
                            // Find the index of this result in the ordered results
                            const globalIndex = orderedResults.indexOf(result);
                            
                            // Add space or word boundary marker between glyphs
                            if (colIndex < processedColumn.length - 1) {
                                if (wordBoundaries.has(globalIndex)) {
                                    columnText += ' | '; // Word boundary marker
                                } else {
                                    columnText += ' '; // Normal space
                                }
                            }
                        });
                        return columnText;
                    });
                });
            };

            const exportTranscription = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';

                orderedResults.forEach((result, index) => {
                    transcription += result.glyph.transliteration || result.glyph.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });

                const blob = new Blob([transcription], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_transcription_${new Date().toISOString().slice(0, 10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                recordAction('export_transcription', { transcription });
            };

            const exportDetectionData = () => {
                const data = {
                    timestamp: new Date().toISOString(),
                    imageFile: image ? 'uploaded_image' : null,
                    imageData: image || null,
                    viewMode: viewMode,
                    readingDirection: readingDirection,
                    detections: recognitionResults.map((result, index) => ({
                        index: index,
                        glyph: result.glyph.name,
                        transliteration: result.glyph.transliteration,
                        arabic: result.glyph.arabic || result.glyph.transliteration || result.glyph.name,
                        confidence: result.confidence,
                        position: result.position,
                        matchType: result.matchType,
                        isManual: result.isManual || false,
                        isMerged: result.isMerged || false,
                        validated: validations[index] ? validations[index].isCorrect : null
                    })),
                    readingOrder: viewMode === 'reading' ? readingOrder : null,
                    wordBoundaries: Array.from(wordBoundaries),
                    columnBreaks: Array.from(columnBreaks || []),
                    lineBreaks: Array.from(lineBreaks || []),
                    translations: {
                        english: translationEnglish || '',
                        arabic: translationArabic || ''
                    },
                    statistics: {
                        totalGlyphs: recognitionResults.length,
                        uniqueGlyphs: new Set(recognitionResults.map(r => r.glyph.name)).size,
                        words: Array.from(wordBoundaries).length + 1,
                        lines: Array.from(lineBreaks || []).length + 1,
                        averageConfidence: recognitionResults.length > 0 
                            ? (recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length * 100).toFixed(1)
                            : 0
                    },
                    actionHistory: actionHistory
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_detection_data_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                recordAction('export_detection_data', { detectionCount: recognitionResults.length });
                alert('‚úÖ Detection data exported with translations!');
            };

            const exportAnnotatedImage = () => {
                if (!imageRef.current) return;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;

                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;

                // Draw original image
                ctx.drawImage(img, 0, 0);

                // Draw detection boxes and labels
                recognitionResults.forEach((detection, index) => {
                    const pos = detection.position;

                    // Determine box color based on validation
                    let boxColor = '#8b7d6b'; // blue - unvalidated
                    if (validations[index]) {
                        boxColor = validations[index].isCorrect ? '#6b8e7f' : '#a0674f'; // green or red
                    }

                    // Draw box
                    ctx.strokeStyle = boxColor;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(pos.x, pos.y, pos.width, pos.height);

                    // Draw semi-transparent background for label
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    const labelText = detection.glyph.name;
                    ctx.font = '16px Arial';
                    const textWidth = ctx.measureText(labelText).width;
                    ctx.fillRect(pos.x, pos.y - 25, textWidth + 10, 25);

                    // Draw label text
                    ctx.fillStyle = 'white';
                    ctx.fillText(labelText, pos.x + 5, pos.y - 7);

                    // Draw reading order number if in reading view
                    if (viewMode === 'reading') {
                        const orderNum = getReadingOrderIndex(index);
                        ctx.fillStyle = '#facc15';
                        ctx.beginPath();
                        ctx.arc(pos.x - 15, pos.y - 15, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#ca8a04';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(orderNum.toString(), pos.x - 15, pos.y - 15);
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'alphabetic';
                    }
                });

                // Convert to blob and download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hakli_annotated_${new Date().toISOString().slice(0, 10)}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    recordAction('export_annotated_image', {});
                });
            };

            const exportHtmlReport = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';

                orderedResults.forEach((result, index) => {
                    transcription += result.glyph.transliteration || result.glyph.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });

                // Generate annotated image
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;

                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.drawImage(img, 0, 0);

                // Draw detection boxes
                recognitionResults.forEach((detection, index) => {
                    const pos = detection.position;
                    let boxColor = '#8b7d6b';
                    if (validations[index]) {
                        boxColor = validations[index].isCorrect ? '#6b8e7f' : '#a0674f';
                    }

                    ctx.strokeStyle = boxColor;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(pos.x, pos.y, pos.width, pos.height);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    const labelText = detection.glyph.name;
                    ctx.font = '16px Arial';
                    const textWidth = ctx.measureText(labelText).width;
                    ctx.fillRect(pos.x, pos.y - 25, textWidth + 10, 25);
                    ctx.fillStyle = 'white';
                    ctx.fillText(labelText, pos.x + 5, pos.y - 7);

                    if (viewMode === 'reading') {
                        const orderNum = getReadingOrderIndex(index);
                        ctx.fillStyle = '#facc15';
                        ctx.beginPath();
                        ctx.arc(pos.x - 15, pos.y - 15, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#ca8a04';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(orderNum.toString(), pos.x - 15, pos.y - 15);
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'alphabetic';
                    }
                });

                const annotatedImageDataUrl = canvas.toDataURL();
                const originalImageDataUrl = image;
                
                // Capture original canvas (colored) image if available
                let originalCanvasImageUrl = originalImageDataUrl; // fallback to image state
                if (originalCanvasRef.current && originalMat && !originalMat.isDeleted()) {
                    try {
                        originalCanvasImageUrl = originalCanvasRef.current.toDataURL('image/png');
                    } catch (err) {
                        console.warn('Could not capture original canvas image:', err);
                    }
                }
                
                // Capture preprocessed image if available
                let preprocessedImageDataUrl = null;
                if (preprocessCanvasRef.current && preprocessedMat && !preprocessedMat.isDeleted()) {
                    try {
                        preprocessedImageDataUrl = preprocessCanvasRef.current.toDataURL('image/png');
                    } catch (err) {
                        console.warn('Could not capture preprocessed image:', err);
                    }
                }

                // Calculate statistics
                const totalDetections = recognitionResults.length;
                const validatedCorrect = Object.values(validations).filter(v => v.isCorrect).length;
                const corrected = recognitionResults.filter(r => r.corrected).length;
                const avgConfidence = recognitionResults.length > 0
                    ? (recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length * 100).toFixed(1)
                    : 0;

                // Create iframe to build HTML document
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                document.body.appendChild(iframe);

                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                iframeDoc.open();
                iframeDoc.write('<!DOCTYPE html><html><head><meta charset="UTF-8"><link rel="icon" type="image/webp" href="data:image/webp;base64,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"></head><body></body></html>');
                iframeDoc.close();

                // Build document structure
                const container = iframeDoc.createElement('div');
                container.className = 'container';

                // Add styles
                const style = iframeDoc.createElement('style');
                style.textContent = '* { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; padding: 20px; } .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow: hidden; } .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; } .header h1 { font-size: 28px; margin-bottom: 10px; } .header .date { opacity: 0.9; font-size: 14px; } .section { border-bottom: 1px solid #e5e7eb; } .section:last-child { border-bottom: none; } .section-header { padding: 20px 30px; cursor: pointer; background: #f9fafb; transition: background 0.2s; display: flex; justify-content: space-between; align-items: center; } .section-header:hover { background: #f3f4f6; } .section-title { font-size: 20px; font-weight: 600; color: #1f2937; } .section-content { padding: 10px 30px 30px 30px; } .section-content.collapsed { display: none; } .toggle-icon { font-size: 18px; color: #6b7280; transition: transform 0.2s; } .toggle-icon.collapsed { transform: rotate(-90deg); } .image-container { text-align: center; margin: 20px 0; } .image-container img { max-width: 100%; height: auto; border: 2px solid #e5e7eb; border-radius: 4px; } .source-images-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0; } .source-image-card { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; padding: 10px; } .source-image-card img { max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px; } .source-image-label { font-size: 12px; font-weight: 600; color: #6b7280; text-align: center; margin-top: 8px; } .image-toggle { margin: 20px 0; text-align: center; } .toggle-btn { background: #8b7d6b; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background 0.2s; } .toggle-btn:hover { background: #6d6355; } .toggle-btn.active { background: #6b8e7f; } .transcription-box { background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 6px; padding: 20px; font-family: "Courier New", monospace; font-size: 18px; line-height: 1.8; word-wrap: break-word; margin: 15px 0; } .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; } .stat-card { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; padding: 15px; text-align: center; } .stat-value { font-size: 32px; font-weight: 700; color: #8b7d6b; margin-bottom: 5px; } .stat-label { font-size: 14px; color: #6b7280; } .detection-list { margin: 15px 0; } .detection-item { background: #f9fafb; border-left: 4px solid #8b7d6b; padding: 12px 15px; margin: 8px 0; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; } .detection-item.correct { border-left-color: #6b8e7f; } .detection-item.incorrect { border-left-color: #a0674f; } .detection-glyph { font-weight: 600; font-size: 16px; } .detection-confidence { color: #6b7280; font-size: 14px; } .footer { background: #f9fafb; padding: 20px 30px; text-align: center; color: #6b7280; font-size: 14px; } .legend { display: flex; gap: 20px; justify-content: center; margin: 15px 0; flex-wrap: wrap; } .legend-item { display: flex; align-items: center; gap: 8px; font-size: 14px; } .legend-box { width: 20px; height: 20px; border-radius: 3px; }';
                iframeDoc.head.appendChild(style);

                // Header
                const header = iframeDoc.createElement('div');
                header.className = 'header';
                header.innerHTML = '<h1>üìú Hakli Glyph Recognition Report</h1><div class="date">Generated on ' + new Date().toLocaleString() + '</div>';
                container.appendChild(header);

                // Image section (FIRST)
                const imageSection = iframeDoc.createElement('div');
                imageSection.className = 'section';
                
                // Build source images grid HTML
                let sourceImagesHtml = '<div class="source-images-grid"><div class="source-image-card"><img src="' + originalCanvasImageUrl + '" alt="Original image"><div class="source-image-label">üì∑ Original Image</div></div>';
                if (preprocessedImageDataUrl) {
                    sourceImagesHtml += '<div class="source-image-card"><img src="' + preprocessedImageDataUrl + '" alt="Preprocessed image"><div class="source-image-label">‚öôÔ∏è Preprocessed Image</div></div>';
                }
                sourceImagesHtml += '</div>';
                
                imageSection.innerHTML = '<div class="section-header" onclick="toggleSection(this)"><div class="section-title">üñºÔ∏è Source Image</div><div class="toggle-icon">‚ñº</div></div><div class="section-content">' + sourceImagesHtml + '<div class="image-toggle"><button class="toggle-btn" id="toggleBtn" onclick="toggleImage()">Show Annotated Version</button></div><div class="legend"><div class="legend-item"><div class="legend-box" style="background: #8b7d6b;"></div><span>Unvalidated</span></div><div class="legend-item"><div class="legend-box" style="background: #6b8e7f;"></div><span>Validated Correct</span></div><div class="legend-item"><div class="legend-box" style="background: #a0674f;"></div><span>Validated Incorrect</span></div></div><div class="image-container"><img id="mainImage" src="' + originalImageDataUrl + '" alt="Hakli inscription"></div></div>';
                container.appendChild(imageSection);

                // Transcription section (SECOND)
                const transcriptionSection = iframeDoc.createElement('div');
                transcriptionSection.className = 'section';
                transcriptionSection.innerHTML = '<div class="section-header" onclick="toggleSection(this)"><div class="section-title">üìù Transcription</div><div class="toggle-icon">‚ñº</div></div><div class="section-content"><div class="transcription-box">' + transcription + '</div></div>';
                container.appendChild(transcriptionSection);

                // Translation section (THIRD - NEW!)
                if (translationEnglish || translationArabic || inscriptionNotes) {
                    const translationSection = iframeDoc.createElement('div');
                    translationSection.className = 'section';
                    let translationHtml = '<div class="section-header" onclick="toggleSection(this)"><div class="section-title">üåç Translation & Notes</div><div class="toggle-icon">‚ñº</div></div><div class="section-content">';
                    
                    if (translationEnglish) {
                        translationHtml += '<div style="margin-bottom: 20px;"><div style="font-weight: 600; color: #667eea; margin-bottom: 8px;">English:</div><div class="transcription-box" style="font-family: inherit; font-size: 16px;">' + translationEnglish + '</div></div>';
                    }
                    
                    if (translationArabic) {
                        translationHtml += '<div style="margin-bottom: 20px;"><div style="font-weight: 600; color: #667eea; margin-bottom: 8px;">Arabic (ÿßŸÑÿπÿ±ÿ®Ÿäÿ©):</div><div class="transcription-box" style="font-family: \'Traditional Arabic\', \'Arabic Typesetting\', \'Scheherazade\', serif; font-size: 18px; direction: rtl;">' + translationArabic + '</div></div>';
                    }
                    
                    if (inscriptionNotes) {
                        translationHtml += '<div><div style="font-weight: 600; color: #667eea; margin-bottom: 8px;">üìù Notes:</div><div class="transcription-box" style="font-family: inherit; font-size: 14px; white-space: pre-wrap;">' + inscriptionNotes + '</div></div>';
                    }
                    
                    translationHtml += '</div>';
                    translationSection.innerHTML = translationHtml;
                    container.appendChild(translationSection);
                }

                // Detection details section (FOURTH)
                const detectionSection = iframeDoc.createElement('div');
                detectionSection.className = 'section';
                let detectionHtml = '<div class="section-header" onclick="toggleSection(this)"><div class="section-title">üîç Detection Details</div><div class="toggle-icon">‚ñº</div></div><div class="section-content"><div class="detection-list">';
                orderedResults.forEach((result, index) => {
                    const originalIndex = recognitionResults.indexOf(result);
                    const validation = validations[originalIndex];
                    const validationClass = validation ? (validation.isCorrect ? 'correct' : 'incorrect') : '';
                    const correctedBadge = result.corrected ? '<span style="background: #fef3c7; padding: 2px 8px; border-radius: 3px; font-size: 12px;">‚úèÔ∏è Corrected</span>' : '';
                    const orderPrefix = viewMode === 'reading' ? (index + 1) + '. ' : '';
                    detectionHtml += '<div class="detection-item ' + validationClass + '"><div><span class="detection-glyph">' + orderPrefix + result.glyph.name + '</span><span style="color: #6b7280; margin-left: 10px;">' + (result.glyph.transliteration || '') + '</span>' + correctedBadge + '</div><div class="detection-confidence">' + Math.round(result.confidence * 100) + '%</div></div>';
                });
                detectionHtml += '</div></div>';
                detectionSection.innerHTML = detectionHtml;
                container.appendChild(detectionSection);

                // Statistics section (LAST - MOVED TO BOTTOM)
                const statsSection = iframeDoc.createElement('div');
                statsSection.className = 'section';
                statsSection.innerHTML = '<div class="section-header" onclick="toggleSection(this)"><div class="section-title">üìä Recognition Statistics</div><div class="toggle-icon">‚ñº</div></div><div class="section-content"><div class="stats-grid"><div class="stat-card"><div class="stat-value">' + totalDetections + '</div><div class="stat-label">Total Glyphs</div></div><div class="stat-card"><div class="stat-value">' + avgConfidence + '%</div><div class="stat-label">Avg Confidence</div></div><div class="stat-card"><div class="stat-value">' + validatedCorrect + '</div><div class="stat-label">Validated Correct</div></div><div class="stat-card"><div class="stat-value">' + corrected + '</div><div class="stat-label">Corrected</div></div></div></div>';
                container.appendChild(statsSection);

                // Footer
                const footer = iframeDoc.createElement('div');
                footer.className = 'footer';
                footer.textContent = 'Generated by Hakli Glyph Recognizer (beta v251217) ¬© hoopoe holdings';
                container.appendChild(footer);

                // Add script
                const script = iframeDoc.createElement('script');
                script.textContent = 'let showingAnnotated = false; const originalImage = "' + originalImageDataUrl + '"; const annotatedImage = "' + annotatedImageDataUrl + '"; function toggleImage() { const img = document.getElementById("mainImage"); const btn = document.getElementById("toggleBtn"); showingAnnotated = !showingAnnotated; if (showingAnnotated) { img.src = annotatedImage; btn.textContent = "Show Original"; btn.classList.add("active"); } else { img.src = originalImage; btn.textContent = "Show Annotated Version"; btn.classList.remove("active"); } } function toggleSection(header) { const content = header.nextElementSibling; const icon = header.querySelector(".toggle-icon"); if (content.classList.contains("collapsed")) { content.classList.remove("collapsed"); icon.classList.remove("collapsed"); icon.textContent = "‚ñº"; } else { content.classList.add("collapsed"); icon.classList.add("collapsed"); icon.textContent = "‚ñ∂"; } }';
                iframeDoc.body.appendChild(script);

                iframeDoc.body.appendChild(container);

                // Get HTML and download
                const htmlContent = '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="UTF-8">\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n<title>Hakli Recognition Report</title>\n' + style.outerHTML + '\n</head>\n<body>\n' + container.outerHTML + '\n' + script.outerHTML + '\n</body>\n</html>';

                document.body.removeChild(iframe);

                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'hakli_report_' + new Date().toISOString().slice(0, 10) + '.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                recordAction('export_html_report', {
                    glyphCount: recognitionResults.length,
                    transcriptionLength: transcription.length
                });

                alert('HTML report exported successfully!');
            };

            const handleImageMouseDown = (event) => {
                // Manual detection mode
                if (manualDetectionMode) {
                    const coords = getImageCoordinates(event);
                    if (!coords) return;
                    setIsDrawing(true);
                    setDrawStart(coords);
                    setDrawCurrent(coords);
                    return;
                }

                // Trim mode
                if (trimMode !== null) {
                    const coords = getImageCoordinates(event);
                    if (!coords) return;
                    setIsDrawing(true);
                    setDrawStart(coords);
                    setDrawCurrent(coords);
                    return;
                }

                // Exclude mode
                if (excludeMode !== null) {
                    const coords = getImageCoordinates(event);
                    if (!coords) return;
                    setIsDrawing(true);
                    setDrawStart(coords);
                    setDrawCurrent(coords);
                    return;
                }
            };

            const handleImageMouseMove = (event) => {
                if (!isDrawing) return;

                event.preventDefault();
                const coords = getImageCoordinates(event);
                if (coords) {
                    setDrawCurrent(coords);
                }
            };

            const handleImageMouseUp = (event) => {
                if (!isDrawing || !drawStart) return;

                const coords = getImageCoordinates(event);
                if (!coords) return;

                const bounds = {
                    x: Math.min(drawStart.x, coords.x),
                    y: Math.min(drawStart.y, coords.y),
                    width: Math.abs(coords.x - drawStart.x),
                    height: Math.abs(coords.y - drawStart.y)
                };

                // Manual detection mode
                if (manualDetectionMode && bounds.width > 10 && bounds.height > 10) {
                    const thumbnail = extractRegionThumbnail(imageRef.current, { bounds: bounds });

                    const manualDetection = {
                        glyph: { id: 'unknown', name: 'Unknown', transliteration: '?' },
                        confidence: 0.5,
                        position: bounds,
                        matchType: 'manual',
                        isManual: true,
                        regionIndex: isolatedGlyphs.length,
                        thumbnail: thumbnail
                    };

                    setIsolatedGlyphs(prev => [...prev, {
                        bounds: bounds,
                        thumbnail: thumbnail,
                        area: bounds.width * bounds.height,
                        aspectRatio: bounds.width / bounds.height
                    }]);

                    setRecognitionResults(prev => {
                        const newResults = [...prev, manualDetection];
                        const newIndex = newResults.length - 1;
                        
                        // Add to reading order if we're using it
                        if (readingOrder.length > 0) {
                            setReadingOrder(ro => [...ro, newIndex]);
                        }
                        
                        return newResults;
                    });
                    recordAction('add_manual_detection', { bounds, thumbnail: !!thumbnail });
                }

                // Trim mode
                if (trimMode !== null && bounds.width > 10 && bounds.height > 10) {
                    applyTrim(trimMode, bounds);
                }

                // Exclude mode
                if (excludeMode !== null && bounds.width > 10 && bounds.height > 10) {
                    // Add to exclusion regions
                    setExcludeRegions(prev => [...prev, bounds]);
                }

                setIsDrawing(false);
                setDrawStart(null);
                setDrawCurrent(null);
            };

            const toggleRegionSelection = (regionIndex) => {
                setSelectedRegions(prev => {
                    const newSet = new Set(prev);
                    newSet.has(regionIndex) ? newSet.delete(regionIndex) : newSet.add(regionIndex);
                    // Auto-expand Controls & Options when 2+ regions selected for merge
                    if (newSet.size >= 2) {
                        setIsControlsCollapsed(false);
                    }
                    return newSet;
                });
            };

            const handleDetectionClick = (event, index) => {
                if (event.ctrlKey || event.metaKey) {
                    event.stopPropagation();
                    toggleRegionSelection(index);
                }
            };
            
            const getReadingOrderIndex = (detectionIndex) => {
                const orderedResults = getReadingOrderedResults();
                    return orderedResults.findIndex(result => 
                    recognitionResults.indexOf(result) === detectionIndex
                ) + 1;
            };

            // Transcription box drag handlers
            const transcriptionRef = React.useRef(null);
            
            const handleTranscriptionMouseDown = (e) => {
                // Only drag from the header area
                if (e.target.closest('.transcription-drag-handle')) {
                    setIsDraggingTranscription(true);
                    
                    // Get actual position of the box
                    const rect = transcriptionRef.current?.getBoundingClientRect();
                    if (rect) {
                        setTranscriptionDragStart({
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top
                        });
                    }
                    e.preventDefault();
                }
            };

            const handleTranscriptionMouseMove = (e) => {
                if (isDraggingTranscription) {
                    const newX = e.clientX - transcriptionDragStart.x;
                    const newY = e.clientY - transcriptionDragStart.y;
                    
                    // Allow dragging anywhere - no clamping during drag
                    setTranscriptionPosition({
                        x: newX,
                        y: newY
                    });
                }
            };

            const handleTranscriptionMouseUp = () => {
                setIsDraggingTranscription(false);
                
                // Check if final position is out of bounds and bounce back if needed
                const maxX = window.innerWidth - 300; // Keep at least 300px visible
                const maxY = window.innerHeight - 100; // Keep at least 100px visible
                
                if (transcriptionPosition.x < 0 || transcriptionPosition.x > maxX ||
                    transcriptionPosition.y < 0 || transcriptionPosition.y > maxY) {
                    // Out of bounds - bounce back to safe position
                    setTranscriptionPosition({
                        x: Math.max(0, Math.min(transcriptionPosition.x, maxX)),
                        y: Math.max(0, Math.min(transcriptionPosition.y, maxY))
                    });
                }
            };

            // Add global listeners for transcription dragging
            React.useEffect(() => {
                if (isDraggingTranscription) {
                    window.addEventListener('mousemove', handleTranscriptionMouseMove);
                    window.addEventListener('mouseup', handleTranscriptionMouseUp);
                    return () => {
                        window.removeEventListener('mousemove', handleTranscriptionMouseMove);
                        window.removeEventListener('mouseup', handleTranscriptionMouseUp);
                    };
                }
            }, [isDraggingTranscription, transcriptionDragStart]);

            const applyReadingDirection = (direction) => {
                setReadingDirection(direction);
                
                // Auto-generate reading order based on direction
                const sorted = recognitionResults.map((result, idx) => ({ result, idx }));
                
                if (direction === 'ltr') {
                    sorted.sort((a, b) => 
                        a.result.position.y - b.result.position.y || 
                        a.result.position.x - b.result.position.x
                    );
                } else if (direction === 'rtl') {
                    sorted.sort((a, b) => 
                        a.result.position.y - b.result.position.y || 
                        b.result.position.x - a.result.position.x
                    );
                } else if (direction === 'ttb') {
                    sorted.sort((a, b) => 
                        b.result.position.x - a.result.position.x ||  // Right to left (rightmost column first)
                        a.result.position.y - b.result.position.y     // Top to bottom within column
                    );
                } else {
                    // Detection order - just use original indices
                    setReadingOrder(recognitionResults.map((_, idx) => idx));
                    return;
                }
                
                setReadingOrder(sorted.map(item => item.idx));
            };

            const toggleWordBoundary = (readingOrderIndex) => {
                setWordBoundaries(prev => {
                    const newSet = new Set(prev);
                    newSet.has(readingOrderIndex) ? newSet.delete(readingOrderIndex) : newSet.add(readingOrderIndex);
                    return newSet;
                });
                recordAction('toggle_word_boundary', { readingOrderIndex });
            };

            const toggleColumnBreak = (readingOrderIndex) => {
                setColumnBreaks(prev => {
                    const newSet = new Set(prev);
                    newSet.has(readingOrderIndex) ? newSet.delete(readingOrderIndex) : newSet.add(readingOrderIndex);
                    return newSet;
                });
                recordAction('toggle_column_break', { readingOrderIndex });
            };

            const toggleLineBreak = (readingOrderIndex) => {
                setLineBreaks(prev => {
                    const newSet = new Set(prev);
                    newSet.has(readingOrderIndex) ? newSet.delete(readingOrderIndex) : newSet.add(readingOrderIndex);
                    return newSet;
                });
                recordAction('toggle_line_break', { readingOrderIndex });
            };

            // Build 2D layout structure based on column and line breaks
            const getLayoutStructure = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                const lines = [];
                let currentLine = [];
                let currentColumn = [];

                orderedResults.forEach((result, index) => {
                    currentColumn.push(result);

                    if (columnBreaks.has(index)) {
                        // End of column
                        currentLine.push(currentColumn);
                        currentColumn = [];
                    }

                    if (lineBreaks.has(index)) {
                        // End of line
                        if (currentColumn.length > 0) {
                            currentLine.push(currentColumn);
                            currentColumn = [];
                        }
                        if (currentLine.length > 0) {
                            lines.push(currentLine);
                            currentLine = [];
                        }
                    }
                });

                // Add any remaining glyphs
                if (currentColumn.length > 0) {
                    currentLine.push(currentColumn);
                }
                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }

                // If no breaks were marked, treat as single column in single line
                if (lines.length === 0) {
                    lines.push([orderedResults]);
                }

                return lines;
            };

            const handleDragStart = (e, index) => {
                // Prevent dragging in detection order mode
                if (readingDirection === 'detection') {
                    e.preventDefault();
                    alert('‚ö†Ô∏è Cannot reorder while in Detection Order mode.\n\nüìñ Please select a reading direction:\n‚Ä¢ ‚Üí LTR (Left to Right)\n‚Ä¢ ‚Üê RTL (Right to Left)\n‚Ä¢ ‚Üì TTB (Top to Bottom)\n\nYou\'ll find these buttons in the "Reading Direction" section above.');
                    return;
                }
                setDraggedItem(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = (e, dropIndex) => {
                e.preventDefault();
                if (draggedItem === null || draggedItem === dropIndex) return;
                
                const newOrder = [...readingOrder];
                const draggedValue = newOrder[draggedItem];
                newOrder.splice(draggedItem, 1);
                newOrder.splice(dropIndex, 0, draggedValue);
                
                setReadingOrder(newOrder);
                setDraggedItem(null);
                
                recordAction('reorder_reading', { from: draggedItem, to: dropIndex });
            };

            const handleRecognitionError = (error, context = 'Recognition') => {
                console.error(`‚ùå ${context} error:`, error);
                alert(`‚ùå ${context} failed. Check console for details.`);
            };

            useEffect(() => {
                if (selectedRegions.size >= 2) {
                    const selectedDetections = Array.from(selectedRegions).map(i => recognitionResults[i]);
                    if (selectedDetections.length > 0) {
                        const minX = Math.min(...selectedDetections.map(d => d.position.x));
                        const minY = Math.min(...selectedDetections.map(d => d.position.y));
                        const maxX = Math.max(...selectedDetections.map(d => d.position.x + d.position.width));
                        const maxY = Math.max(...selectedDetections.map(d => d.position.y + d.position.height));
                        setMergeIndicator({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });
                    }
                } else {
                    setMergeIndicator(null);
                }
            }, [selectedRegions, recognitionResults]);


            const startCorrection = (detectionIndex) => {
                setCorrectionMode(detectionIndex);
            };

            const applyCorrection = (detectionIndex, newGlyph) => {
                const oldGlyph = recognitionResults[detectionIndex].glyph;
                const confidence = recognitionResults[detectionIndex].confidence;

                recordAction('correct_glyph', {
                    detectionIndex: detectionIndex,
                    oldGlyph: oldGlyph,
                    newGlyph: newGlyph
                });

                // Save to correction memory
                saveCorrectionToMemory(oldGlyph, newGlyph, confidence);

                setRecognitionResults(prev => prev.map((result, index) => {
                    if (index === detectionIndex) {
                        return {
                            ...result,
                            glyph: newGlyph,
                            corrected: true,
                            originalGlyph: result.glyph
                        };
                    }
                    return result;
                }));

                setCorrectionMode(null);
            };

            const cancelCorrection = () => {
                setCorrectionMode(null);
            };

            const startAdjustMode = (detectionIndex) => {
                setAdjustMode(detectionIndex);
                // Initialize corners if they don't exist
                const detection = recognitionResults[detectionIndex];
                if (!detection.corners) {
                    const pos = detection.position;
                    setRecognitionResults(prev => {
                        const updated = [...prev];
                        updated[detectionIndex] = {
                            ...updated[detectionIndex],
                            corners: {
                                tl: { x: pos.x, y: pos.y },
                                tr: { x: pos.x + pos.width, y: pos.y },
                                bl: { x: pos.x, y: pos.y + pos.height },
                                br: { x: pos.x + pos.width, y: pos.y + pos.height }
                            }
                        };
                        return updated;
                    });
                }
            };

                    
            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file && file.type.indexOf('image/') === 0) {
                    setIsImageLoading(true);
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setImage(e.target.result);
                        setDisplayImage(null); // Clear any rotated display
                        setImageRotation(0); // Reset rotation
                        setRotatedImageDimensions(null); // Clear rotated dimensions
                        setRecognitionResults([]);
                        setValidations({});
                        setActionHistory([]);
                        setIsolatedGlyphs([]);
                        setSelectedRegions(new Set());
                        setMergeIndicator(null);
                        setAdjustmentsApplied(false); // Reset adjustment state
                        
                        // Clear translation/metadata fields for fresh image
                        setTranslationEnglish('');
                        setTranslationArabic('');
                        setInscriptionTitle('');
                        setInscriptionNotes('');
                        setReadingOrder([]);
                        setWordBoundaries(new Set());
                        setColumnBreaks(new Set());
                        setLineBreaks(new Set());
                        
                        // Load image into OpenCV Mat for preprocessing
                        if (isOpenCvReady) {
                            const img = new Image();
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                
                                const mat = cv.imread(canvas);
                                setOriginalMat(mat);
                                
                                // Show original on canvas
                                if (originalCanvasRef.current) {
                                    cv.imshow(originalCanvasRef.current, mat);
                                }
                                
                                // Process immediately
                                processImageWithSettings(mat, preprocessing);
                                setIsImageLoading(false);
                            };
                            img.onerror = () => {
                                setIsImageLoading(false);
                                alert('‚ùå Failed to load image. Please try again.');
                            };
                            img.src = e.target.result;
                        } else {
                            setIsImageLoading(false);
                            alert('‚ö†Ô∏è OpenCV is still loading. Please wait a moment and try again.');
                        }
                    };
                    reader.onerror = () => {
                        setIsImageLoading(false);
                        alert('‚ùå Failed to read file. Please try again.');
                    };
                    reader.readAsDataURL(file);
                }
            };
            
            // Process image with current preprocessing settings
            const processImageWithSettings = (sourceMat, settings) => {
                if (!sourceMat || !isOpenCvReady) return;
                
                // Check if Mat is still valid
                if (sourceMat.isDeleted()) {
                    console.warn('Source Mat already deleted, skipping preprocessing');
                    return;
                }
                
                try {
                    // Clean up previous preprocessed mat
                    if (preprocessedMat && !preprocessedMat.isDeleted()) {
                        preprocessedMat.delete();
                    }
                    
                    let processed = sourceMat.clone();
                    
                    // 1. Rotation
                    if (settings.rotation !== 0) {
                        const center = new cv.Point(processed.cols / 2, processed.rows / 2);
                        const rotMatrix = cv.getRotationMatrix2D(center, settings.rotation, 1.0);
                        
                        const radians = (settings.rotation * Math.PI) / 180;
                        const sin = Math.abs(Math.sin(radians));
                        const cos = Math.abs(Math.cos(radians));
                        const newWidth = Math.round(processed.cols * cos + processed.rows * sin);
                        const newHeight = Math.round(processed.cols * sin + processed.rows * cos);
                        
                        rotMatrix.data64F[2] += (newWidth / 2) - center.x;
                        rotMatrix.data64F[5] += (newHeight / 2) - center.y;
                        
                        const rotated = new cv.Mat();
                        const dsize = new cv.Size(newWidth, newHeight);
                        cv.warpAffine(processed, rotated, rotMatrix, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255, 255, 255, 255));
                        processed.delete();
                        processed = rotated;
                        rotMatrix.delete();
                    }
                    
                    // 2. Convert to grayscale if needed
                    if (processed.channels() > 1) {
                        const gray = new cv.Mat();
                        cv.cvtColor(processed, gray, cv.COLOR_RGBA2GRAY);
                        processed.delete();
                        processed = gray;
                    }
                    
                    // 3. Gaussian blur
                    if (settings.gaussianBlur > 0) {
                        const ksize = new cv.Size(settings.gaussianBlur, settings.gaussianBlur);
                        cv.GaussianBlur(processed, processed, ksize, 0);
                    }
                    
                    // 4. Adaptive threshold
                    if (settings.useAdaptiveThreshold) {
                        const thresholded = new cv.Mat();
                        cv.adaptiveThreshold(
                            processed,
                            thresholded,
                            255,
                            cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                            cv.THRESH_BINARY,
                            settings.blockSize,
                            settings.constantOffset
                        );
                        processed.delete();
                        processed = thresholded;
                    }
                    
                    // 5. Invert colors
                    if (settings.invertColors) {
                        cv.bitwise_not(processed, processed);
                    }
                    
                    // 6. Morphology
                    if (settings.morphologyOperation !== 'none') {
                        const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                        
                        if (settings.morphologyOperation === 'close' || settings.morphologyOperation === 'both') {
                            cv.morphologyEx(processed, processed, cv.MORPH_CLOSE, kernel);
                        }
                        if (settings.morphologyOperation === 'open' || settings.morphologyOperation === 'both') {
                            cv.morphologyEx(processed, processed, cv.MORPH_OPEN, kernel);
                        }
                        
                        kernel.delete();
                    }
                    
                    setPreprocessedMat(processed);
                    
                    // Show on preview canvas
                    if (showPreprocessPreview && preprocessCanvasRef.current) {
                        cv.imshow(preprocessCanvasRef.current, processed);
                    }
                    
                    console.log('‚úì Preprocessing complete:', settings);
                } catch (error) {
                    console.error('Preprocessing error:', error);
                }
            };
            
            // Update preprocessing setting
            const updatePreprocessingSetting = (key, value) => {
                const newSettings = { ...preprocessing, [key]: value };
                setPreprocessing(newSettings);
                setAdjustmentsApplied(false); // Mark as needing reapplication
                if (originalMat) {
                    processImageWithSettings(originalMat, newSettings);
                }
            };
            
            // Reset preprocessing to defaults
            const resetPreprocessing = () => {
                const defaults = {
                    rotation: 0,
                    useAdaptiveThreshold: false,
                    blockSize: 11,
                    constantOffset: 2,
                    gaussianBlur: 0,
                    morphologyOperation: 'none',
                    invertColors: false
                };
                setPreprocessing(defaults);
                setAdjustmentsApplied(false); // Mark as needing reapplication
                if (originalMat) {
                    processImageWithSettings(originalMat, defaults);
                }
            };
            
            // Apply adjustments to main recognition image
            const applyAdjustments = () => {
                if (!preprocessedMat || preprocessedMat.isDeleted()) {
                    alert('‚ö†Ô∏è No preprocessed image available. Please adjust settings first.');
                    return;
                }
                
                try {
                    // Convert preprocessed Mat to canvas then to data URL
                    const canvas = document.createElement('canvas');
                    cv.imshow(canvas, preprocessedMat);
                    const dataURL = canvas.toDataURL();
                    
                    // Force update by adding timestamp to ensure React sees it as new
                    const timestamp = Date.now();
                    
                    // Update the display image
                    setDisplayImage(dataURL);
                    setImage(dataURL); // Also update the base image state
                    setAdjustmentsApplied(true);
                    
                    console.log('‚úì Adjustments applied to recognition image (timestamp:', timestamp, ')');
                } catch (error) {
                    console.error('Error applying adjustments:', error);
                    alert('‚ùå Failed to apply adjustments. Please try again.');
                }
            };
            
            // Eraser mode functions
            const toggleEraserMode = () => {
                const newMode = !eraserMode;
                setEraserMode(newMode);
                
                if (newMode) {
                    // Entering eraser mode - use setTimeout to ensure canvas is rendered
                    setTimeout(() => {
                        if (preprocessedMat && !preprocessedMat.isDeleted() && eraserCanvasRef.current) {
                            cv.imshow(eraserCanvasRef.current, preprocessedMat);
                            
                            // Save initial state for undo
                            const canvas = eraserCanvasRef.current;
                            const imageData = canvas.toDataURL();
                            setEraserHistory([imageData]);
                            
                            console.log('‚úì Eraser canvas loaded with image');
                        }
                    }, 100); // Small delay to ensure canvas is in DOM
                } else {
                    // Exiting eraser mode - apply erased version back to preprocessedMat
                    if (eraserCanvasRef.current) {
                        try {
                            const erasedMat = cv.imread(eraserCanvasRef.current);
                            if (preprocessedMat && !preprocessedMat.isDeleted()) {
                                preprocessedMat.delete();
                            }
                            setPreprocessedMat(erasedMat);
                            
                            // Update the preview canvas
                            if (preprocessCanvasRef.current) {
                                cv.imshow(preprocessCanvasRef.current, erasedMat);
                            }
                            
                            // Mark adjustments as needing reapplication
                            setAdjustmentsApplied(false);
                            
                            // Clear history
                            setEraserHistory([]);
                            
                            console.log('‚úì Eraser changes applied');
                        } catch (error) {
                            console.error('Error applying eraser:', error);
                        }
                    }
                }
            };
            
            // Update eraser cursor style when brush size or canvas changes
            useEffect(() => {
                const updateCursorStyle = () => {
                    const canvas = eraserCanvasRef.current;
                    if (!canvas || !eraserMode) {
                        setEraserCursorStyle('crosshair');
                        return;
                    }
                    
                    const rect = canvas.getBoundingClientRect();
                    if (rect.width === 0 || canvas.width === 0) {
                        setEraserCursorStyle('crosshair');
                        return;
                    }
                    
                    const scaleX = rect.width / canvas.width;
                    const displayBrushSize = Math.round(brushSize * scaleX);
                    
                    // Cap cursor visual size to stay within browser limits (128px max)
                    // but show the actual size up to that limit
                    const maxCursorSize = 60; // Conservative limit to ensure it works across browsers
                    const visualBrushSize = Math.min(displayBrushSize, maxCursorSize);
                    const diameter = visualBrushSize * 2;
                    
                    // If brush is larger than we can show, add a note in the cursor
                    const cursorSvg = displayBrushSize > maxCursorSize
                        ? `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${diameter}" height="${diameter}" viewBox="0 0 ${diameter} ${diameter}"><circle cx="${visualBrushSize}" cy="${visualBrushSize}" r="${visualBrushSize - 1}" fill="none" stroke="white" stroke-width="3"/><circle cx="${visualBrushSize}" cy="${visualBrushSize}" r="${visualBrushSize - 1}" fill="none" stroke="orange" stroke-width="2" stroke-dasharray="4,4"/></svg>') ${visualBrushSize} ${visualBrushSize}, crosshair`
                        : `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${diameter}" height="${diameter}" viewBox="0 0 ${diameter} ${diameter}"><circle cx="${visualBrushSize}" cy="${visualBrushSize}" r="${visualBrushSize - 1}" fill="none" stroke="white" stroke-width="2"/><circle cx="${visualBrushSize}" cy="${visualBrushSize}" r="${visualBrushSize - 1}" fill="none" stroke="black" stroke-width="1"/></svg>') ${visualBrushSize} ${visualBrushSize}, crosshair`;
                    setEraserCursorStyle(cursorSvg);
                };
                
                if (eraserMode) {
                    // Update immediately
                    updateCursorStyle();
                    
                    // Also update on window resize
                    window.addEventListener('resize', updateCursorStyle);
                    return () => window.removeEventListener('resize', updateCursorStyle);
                }
            }, [brushSize, eraserMode]);
            
            const handleEraserMouseDown = (e) => {
                if (!eraserMode || !eraserCanvasRef.current) return;
                setIsErasing(true);
                drawEraser(e);
            };
            
            const handleEraserMouseMove = (e) => {
                if (!eraserMode || !isErasing || !eraserCanvasRef.current) return;
                drawEraser(e);
            };
            
            const handleEraserMouseUp = () => {
                if (isErasing && eraserCanvasRef.current) {
                    // Save current canvas state to history
                    const imageData = eraserCanvasRef.current.toDataURL();
                    setEraserHistory(prev => [...prev, imageData]);
                }
                setIsErasing(false);
            };
            
            // Touch event handlers for mobile
            const handleEraserTouchStart = (e) => {
                if (!eraserMode || !eraserCanvasRef.current) return;
                e.preventDefault(); // Prevent scrolling while erasing
                setIsErasing(true);
                const touch = e.touches[0];
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                drawEraser(mouseEvent);
            };
            
            const handleEraserTouchMove = (e) => {
                if (!eraserMode || !isErasing || !eraserCanvasRef.current) return;
                e.preventDefault(); // Prevent scrolling while erasing
                const touch = e.touches[0];
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                drawEraser(mouseEvent);
            };
            
            const handleEraserTouchEnd = () => {
                if (isErasing && eraserCanvasRef.current) {
                    // Save current canvas state to history
                    const imageData = eraserCanvasRef.current.toDataURL();
                    setEraserHistory(prev => [...prev, imageData]);
                }
                setIsErasing(false);
            };
            
            const drawEraser = (e) => {
                const canvas = eraserCanvasRef.current;
                if (!canvas) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x, y, brushSize, 0, Math.PI * 2);
                ctx.fill();
            };
            
            const undoLastStroke = () => {
                if (!eraserCanvasRef.current || eraserHistory.length <= 1) return;
                
                // Remove last state
                const newHistory = eraserHistory.slice(0, -1);
                setEraserHistory(newHistory);
                
                // Restore previous state
                const previousState = newHistory[newHistory.length - 1];
                const img = new Image();
                img.onload = () => {
                    const canvas = eraserCanvasRef.current;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = previousState;
            };
            
            const clearAllEraser = () => {
                if (!eraserCanvasRef.current) return;
                
                if (window.confirm('Clear all eraser marks and start over?')) {
                    // Restore original preprocessed image
                    if (preprocessedMat && !preprocessedMat.isDeleted()) {
                        cv.imshow(eraserCanvasRef.current, preprocessedMat);
                        
                        // Reset history to just the initial state
                        const imageData = eraserCanvasRef.current.toDataURL();
                        setEraserHistory([imageData]);
                    }
                }
            };
            
            // Export preprocessing settings
            const exportPreprocessingSettings = () => {
                const json = JSON.stringify(preprocessing, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'preprocessing-settings.json';
                a.click();
                URL.revokeObjectURL(url);
            };
            
            // Cleanup effect for OpenCV Mats
            useEffect(() => {
                return () => {
                    if (originalMat && !originalMat.isDeleted()) originalMat.delete();
                    if (preprocessedMat && !preprocessedMat.isDeleted()) preprocessedMat.delete();
                };
            }, []);
            
            // Update original canvas when originalMat changes
            useEffect(() => {
                if (originalMat && originalCanvasRef.current && showPreprocessPreview) {
                    try {
                        console.log('Displaying original mat to canvas');
                        // Use requestAnimationFrame to ensure canvas is fully rendered
                        requestAnimationFrame(() => {
                            if (originalCanvasRef.current && originalMat && !originalMat.isDeleted()) {
                                cv.imshow(originalCanvasRef.current, originalMat);
                            }
                        });
                    } catch (error) {
                        console.error('Error showing original:', error);
                    }
                }
            }, [originalMat, showPreprocessPreview]);
            
            // Redraw preprocessed canvas when preview is shown
            useEffect(() => {
                if (preprocessedMat && preprocessCanvasRef.current && showPreprocessPreview) {
                    try {
                        // Use requestAnimationFrame to ensure canvas is fully rendered
                        requestAnimationFrame(() => {
                            if (preprocessCanvasRef.current && preprocessedMat && !preprocessedMat.isDeleted()) {
                                cv.imshow(preprocessCanvasRef.current, preprocessedMat);
                            }
                        });
                    } catch (error) {
                        console.error('Error showing preprocessed:', error);
                    }
                }
            }, [preprocessedMat, showPreprocessPreview]);
            
            // Re-process when settings change
            useEffect(() => {
                if (originalMat && !originalMat.isDeleted()) {
                    processImageWithSettings(originalMat, preprocessing);
                }
            }, [preprocessing]);

            

            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Escape: Close correction modal or cancel trim/exclude modes
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        if (correctionMode !== null) {
                            cancelCorrection();
                        } else if (trimMode !== null) {
                            setTrimMode(null);
                            setIsDrawing(false);
                            setDrawStart(null);
                            setDrawCurrent(null);
                        } else if (excludeMode !== null) {
                            setExcludeMode(null);
                            setExcludeRegions([]);
                            setIsDrawing(false);
                            setDrawStart(null);
                            setDrawCurrent(null);
                        } else if (adjustMode !== null) {
                            setAdjustMode(null);
                            setDraggingCorner(null);
                            setDragStartPos(null);
                        }
                        return;
                    }

                    // Undo: Ctrl+Z
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        undo();
                    }
                    // Redo: Ctrl+Shift+Z or Ctrl+Y
                    if ((e.ctrlKey || e.metaKey) && (e.shiftKey && e.key === 'z' || e.key === 'y')) {
                        e.preventDefault();
                        redo();
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [historyIndex, stateHistory, correctionMode, trimMode, excludeMode, adjustMode]);

            // Global mouse event handler for corner dragging
            useEffect(() => {
                if (!draggingCorner || adjustMode === null) return;

                const handleMouseMove = (e) => {
                    if (!imageRef.current) return;
                    e.preventDefault();
                    
                    const imageRect = imageRef.current.getBoundingClientRect();
                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                    
                    const newX = (e.clientX - imageRect.left) / scaleX;
                    const newY = (e.clientY - imageRect.top) / scaleY;

                    // Update the corner position
                    setRecognitionResults(prev => {
                        const updated = [...prev];
                        const detection = updated[adjustMode];
                        if (!detection) return prev;
                        
                        const newCorners = { ...detection.corners };
                        newCorners[draggingCorner] = { x: newX, y: newY };
                        
                        // Calculate new bounding box from corners
                        const minX = Math.min(newCorners.tl.x, newCorners.tr.x, newCorners.bl.x, newCorners.br.x);
                        const maxX = Math.max(newCorners.tl.x, newCorners.tr.x, newCorners.bl.x, newCorners.br.x);
                        const minY = Math.min(newCorners.tl.y, newCorners.tr.y, newCorners.bl.y, newCorners.br.y);
                        const maxY = Math.max(newCorners.tl.y, newCorners.tr.y, newCorners.bl.y, newCorners.br.y);
                        
                        updated[adjustMode] = {
                            ...detection,
                            corners: newCorners,
                            position: {
                                x: Math.round(minX),
                                y: Math.round(minY),
                                width: Math.round(maxX - minX),
                                height: Math.round(maxY - minY)
                            }
                        };
                        return updated;
                    });
                };

                const handleMouseUp = () => {
                    setDraggingCorner(null);
                    setDragStartPos(null);
                };

                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
                
                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
            }, [draggingCorner, adjustMode]);

            useEffect(() => {
                if (chartLoadStatus === 'not-loaded') {
                    setChartLoadStatus('loading');
                    const githubJsonUrl = 'https://raw.githubusercontent.com/hytra3/hakli_glyph_recognizer/main/Hakli_glyphs.JSON';
                    fetch(githubJsonUrl)
                        .then(response => response.json())
                        .then(chartData => {
                            setEquivalenceChart(chartData);
                            const imageCache = {}; // For OpenCV (HTMLImageElement objects)
                            const thumbnailCache = {}; // For display (src URLs)
                            const loadPromises = [];

                            // Count total images to load
                            let totalImagesToLoad = 0;

                            for (const glyph of chartData.glyphs) {
                                if (glyph.images && glyph.images.primary) totalImagesToLoad++;
                                if (glyph.images && glyph.images.variants) totalImagesToLoad += glyph.images.variants.length;
                                // Skip examples for initial load - they're only for chart viewing
                            }

                            setImageLoadingProgress({ loaded: 0, total: totalImagesToLoad });
                            console.log(`üì¶ Loading ${totalImagesToLoad} template images for ${chartData.glyphs.length} glyphs (examples will load in background)...`);
                            console.log(`üìä Progress tracking: will update every ${Math.max(1, Math.floor(totalImagesToLoad / 20))} images`);

                            let loadedCount = 0;
                            const updateInterval = Math.max(1, Math.floor(totalImagesToLoad / 20)); // Update progress bar ~20 times

                            const createImageLoader = (url, key) => {
                                return new Promise((resolve) => {
                                    const img = new Image();
                                    img.crossOrigin = 'anonymous';
                                    img.onload = () => {
                                        imageCache[key] = img; // Store HTMLImageElement for OpenCV
                                        thumbnailCache[key] = img.src; // Store src URL for display
                                        loadedCount++;
                                        // Only update progress every N images to reduce re-renders
                                        if (loadedCount % updateInterval === 0 || loadedCount === totalImagesToLoad || loadedCount === 1) {
                                            console.log(`üìä Progress: ${loadedCount}/${totalImagesToLoad}`);
                                            // Use requestAnimationFrame to force browser to paint the update
                                            requestAnimationFrame(() => {
                                                setImageLoadingProgress({ loaded: loadedCount, total: totalImagesToLoad });
                                            });
                                        }
                                        resolve();
                                    };
                                    img.onerror = () => {
                                        loadedCount++;
                                        if (loadedCount % updateInterval === 0 || loadedCount === totalImagesToLoad || loadedCount === 1) {
                                            console.log(`üìä Progress: ${loadedCount}/${totalImagesToLoad} (error)`);
                                            // Use requestAnimationFrame to force browser to paint the update
                                            requestAnimationFrame(() => {
                                                setImageLoadingProgress({ loaded: loadedCount, total: totalImagesToLoad });
                                            });
                                        }
                                        resolve();
                                    };
                                    img.src = url;
                                });
                            };

                            for (const glyph of chartData.glyphs) {
                                // Load primary image
                                if (glyph.images && glyph.images.primary) {
                                    loadPromises.push(createImageLoader(glyph.images.primary, glyph.id));
                                }

                                // Load variant images
                                if (glyph.images && glyph.images.variants) {
                                    for (let i = 0; i < glyph.images.variants.length; i++) {
                                        const variantKey = `${glyph.id}_variant_${i}`;
                                        loadPromises.push(createImageLoader(glyph.images.variants[i], variantKey));
                                    }
                                }

                                // Skip examples initially - load in background
                            }

                            Promise.all(loadPromises).then(() => {
                                console.log(`‚úÖ Loaded ${Object.keys(imageCache).length} images for ${chartData.glyphs.length} glyphs`);
                                setLoadedGlyphImages(imageCache); // For OpenCV
                                setGlyphThumbnails(thumbnailCache); // For display
                                setChartLoadStatus('loaded');
                                setImageLoadingProgress({ loaded: 0, total: 0 }); // Reset
                                
                                // Lazy load ALL examples in background
                                const lazyLoadPromises = [];
                                for (const glyph of chartData.glyphs) {
                                    if (glyph.images && glyph.images.examples) {
                                        for (let i = 0; i < glyph.images.examples.length; i++) {
                                            const exampleKey = `${glyph.id}_example_${i}`;
                                            const lazyPromise = createImageLoader(glyph.images.examples[i], exampleKey);
                                            lazyLoadPromises.push(lazyPromise);
                                        }
                                    }
                                }
                                
                                // Load examples in background
                                if (lazyLoadPromises.length > 0) {
                                    console.log(`üîÑ Loading ${lazyLoadPromises.length} example images in background...`);
                                    Promise.all(lazyLoadPromises).then(() => {
                                        setLoadedGlyphImages(prev => ({...prev, ...imageCache})); // For OpenCV
                                        setGlyphThumbnails(prev => ({...prev, ...thumbnailCache})); // For display
                                        console.log(`‚úÖ All example images loaded`);
                                    });
                                }
                            });
                        })
                        .catch(() => setChartLoadStatus('error'));
                }
            }, [chartLoadStatus]);

            // Initialize glyph editor state when modal opens
            useEffect(() => {
                if (showGlyphEditor) {
                    if (showGlyphEditor.mode === 'edit' && showGlyphEditor.glyph) {
                        setGlyphEditorName(showGlyphEditor.glyph.name || '');
                        setGlyphEditorArabic(showGlyphEditor.glyph.arabic || '');
                        setGlyphEditorTranslit(showGlyphEditor.glyph.transliteration || '');
                    } else {
                        // Clear for add mode
                        setGlyphEditorName('');
                        setGlyphEditorArabic('');
                        setGlyphEditorTranslit('');
                    }
                    setGlyphEditorImageFile(null);
                    setGlyphEditorImagePreview(null);
                }
            }, [showGlyphEditor]);

            return (
                <div className="max-w-6xl mx-auto p-6 bg-white">
                    <div className="mb-8">
                        <div className="flex items-center gap-3 mb-2">
                            <img src="hh-logo.png" alt="Hoopoe Holdings Logo" className="w-12 h-12 rounded-full object-cover" />
                            <h1 className="text-3xl font-bold text-gray-900">Hakli Glyph Recognizer</h1>
                        </div>
                        <p className="text-sm text-gray-500">Based on Ahmad Al-Jallad (2025), <em>The Decipherment of the Dhofari Script</em></p>
                        <p className="text-sm text-gray-500">beta v251217 ¬©hoopoe holdings</p>
                    </div>

                    <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                        <div className="flex items-center justify-between mb-2">
                            <button
                                onClick={() => setIsChartStatusCollapsed(!isChartStatusCollapsed)}
                                className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700"
                            >
                                <span>{isChartStatusCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                <h3>Equivalence Chart Status</h3>
                            </button>
                            {chartLoadStatus === 'loaded' && (
                                <span className="text-sm text-patina">
                                    ‚úÖ {equivalenceChart?.glyphs?.length || 0} glyphs
                                </span>
                            )}
                        </div>
                        
                        {!isChartStatusCollapsed && (
                            <div>
                                <div className="flex items-center gap-2 mt-1">
                                    {chartLoadStatus === 'loading' && (
                                        <div className="flex-1">
                                            <div className="flex items-center gap-2 mb-2">
                                                <span className="text-stone-dark">
                                                    Loading {equivalenceChart?.glyphs?.length || '...'} glyphs...
                                                    {imageLoadingProgress.total > 0 && (
                                                        <span className="ml-2">({imageLoadingProgress.loaded}/{imageLoadingProgress.total} images)</span>
                                                    )}
                                                </span>
                                            </div>
                                            {imageLoadingProgress.total > 0 && (
                                                <div className="w-full bg-gray-200 rounded-full h-2.5">
                                                    <div 
                                                        className="bg-stone-dark h-2.5 rounded-full transition-all duration-300" 
                                                        style={{width: `${(imageLoadingProgress.loaded / imageLoadingProgress.total * 100).toFixed(1)}%`}}
                                                    ></div>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                    {chartLoadStatus === 'loaded' && (
                                        <span className="text-patina">
                                            ‚úÖ Loaded {equivalenceChart?.glyphs?.length || 0} glyphs, {Object.keys(loadedGlyphImages).length} images
                                        </span>
                                    )}
                                    {chartLoadStatus === 'error' && <span className="text-rust">‚ùå Error loading chart</span>}
                                </div>
                                <div className="flex gap-2 mt-3">
                                    <button 
                                        onClick={() => setShowChartViewer(true)} 
                                        className="px-4 py-2 bg-ancient-purple text-white rounded hover:bg-[#4a3e54]" 
                                        disabled={chartLoadStatus !== 'loaded'}
                                    >
                                        üìä View Chart
                                    </button>
                                    <button 
                                        onClick={() => setChartLoadStatus('not-loaded')} 
                                        className="px-4 py-2 bg-stone text-white rounded hover:bg-stone-dark" 
                                        disabled={chartLoadStatus === 'loading'}
                                    >
                                        üîÑ Reload Chart
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Upload Section - Collapsible */}
                    {!image ? (
                        <div className="mb-6">
                            {/* Chart Loading Notice */}
                            {chartLoadStatus !== 'loaded' && (
                                <div className="mb-4 p-4 bg-amber-50 border-2 border-amber-300 rounded-lg">
                                    <div className="flex items-start gap-3">
                                        <div className="text-2xl">‚è≥</div>
                                        <div className="flex-1">
                                            <div className="font-semibold text-amber-900 mb-1">Loading Glyph Recognition Chart...</div>
                                            <div className="text-sm text-amber-800 mb-3">
                                                Please wait a moment while the Hakli glyph database loads. 
                                                You'll be able to upload images once it's ready.
                                            </div>
                                            
                                            {/* Progress Bar */}
                                            <div>
                                                <div className="flex justify-between text-xs text-amber-700 mb-1">
                                                    <span>Loading glyph images...</span>
                                                    <span className="font-mono font-semibold">
                                                        {imageLoadingProgress.total > 0 
                                                            ? `${imageLoadingProgress.loaded}/${imageLoadingProgress.total}`
                                                            : 'Preparing...'
                                                        }
                                                    </span>
                                                </div>
                                                <div className="w-full bg-amber-200 rounded-full h-3 overflow-hidden">
                                                    <div 
                                                        className="bg-amber-600 h-3 transition-all duration-300 ease-out"
                                                        style={{width: imageLoadingProgress.total > 0 
                                                            ? `${(imageLoadingProgress.loaded / imageLoadingProgress.total) * 100}%`
                                                            : '0%'
                                                        }}
                                                    />
                                                </div>
                                                {imageLoadingProgress.total > 0 && (
                                                    <div className="text-xs text-amber-600 mt-1 text-center font-medium">
                                                        {Math.round((imageLoadingProgress.loaded / imageLoadingProgress.total) * 100)}%
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                            
                            <div 
                                className={`p-6 rounded-lg border-2 border-dashed ${!equivalenceChart ? 'border-gray-300 bg-gray-100 opacity-50 cursor-not-allowed' : 'border-gray-400 bg-gray-50'} transition-colors`}
                                onDragOver={(e) => {
                                    if (!equivalenceChart) return;
                                    e.preventDefault();
                                    e.currentTarget.style.backgroundColor = '#e5e7eb';
                                    e.currentTarget.style.borderColor = '#8b7d6b';
                                }}
                                onDragLeave={(e) => {
                                    if (!equivalenceChart) return;
                                    e.currentTarget.style.backgroundColor = '#f9fafb';
                                    e.currentTarget.style.borderColor = '#9ca3af';
                                }}
                                onDrop={(e) => {
                                    if (!equivalenceChart) return;
                                    e.preventDefault();
                                    e.currentTarget.style.backgroundColor = '#f9fafb';
                                    e.currentTarget.style.borderColor = '#9ca3af';
                                    
                                    const file = e.dataTransfer.files[0];
                                    if (file && file.type.indexOf('image/') === 0) {
                                        // Manually trigger the file upload handler
                                        const fakeEvent = { target: { files: [file] } };
                                        handleFileUpload(fakeEvent);
                                    }
                                }}
                            >
                                <div className="text-center">
                                    <div className="text-5xl mb-3">üì∏</div>
                                    <label className="block text-base font-semibold text-gray-800 mb-2">
                                        Upload Inscription Image
                                    </label>
                                    
                                    {/* Hidden file input */}
                                    <input 
                                        id="fileUploadInput"
                                        type="file" 
                                        accept="image/*" 
                                        onChange={handleFileUpload} 
                                        disabled={isImageLoading}
                                        style={{display: 'none'}}
                                    />
                                    
                                    <div className="space-y-2">
                                        <p className="text-sm text-gray-600 font-medium">
                                            Drag & drop your image here
                                        </p>
                                        <p className="text-xs text-gray-500">or</p>
                                        <button
                                            onClick={() => document.getElementById('fileUploadInput').click()}
                                            disabled={isImageLoading || !equivalenceChart}
                                            className="px-4 py-2 bg-stone text-white rounded-lg hover:bg-stone-dark disabled:bg-gray-400 disabled:cursor-not-allowed font-medium text-sm transition-colors"
                                            title={!equivalenceChart ? "‚è≥ Please wait for the glyph chart to load..." : "Select an inscription image"}
                                        >
                                            {isImageLoading ? 'Loading...' : 'Browse Files'}
                                        </button>
                                        
                                        <div className="pt-3 mt-3 border-t border-gray-300">
                                            <p className="text-xs text-gray-500 mb-2">or load a saved session:</p>
                                            <button
                                                onClick={async () => {
                                                    if (typeof DriveSync === 'undefined' || !DriveSync.isSignedIn()) {
                                                        alert('‚ö†Ô∏è Please sign in to Google Drive first.\n\n1. Click OK to close this message\n2. Click the "üîê Sign in with Google" button that appears\n3. After signing in, click "Load from Google Drive" again');
                                                        setShowCloudSyncModal(true);
                                                        return;
                                                    }
                                                    
                                                    try {
                                                        const files = await DriveSync.listFiles();
                                                        console.log('Drive files:', files);
                                                        
                                                        if (files.length === 0) {
                                                            alert('üìÇ No HKI files found in your Hakli_Inscriptions folder.\n\nSave an inscription first to create HKI files.');
                                                            return;
                                                        }
                                                        
                                                        // Load all file thumbnails
                                                        setShowFilePickerModal({ files, isLoading: true });
                                                        
                                                        const filesWithThumbnails = await Promise.all(
                                                            files.map(async (file) => {
                                                                try {
                                                                    const hkiData = await DriveSync.loadFromCloud(file.id);
                                                                    return {
                                                                        ...file,
                                                                        thumbnail: hkiData.image || null,
                                                                        title: hkiData.inscriptionTitle || file.name,
                                                                        location: hkiData.location || null
                                                                    };
                                                                } catch (err) {
                                                                    console.error(`Failed to load thumbnail for ${file.name}:`, err);
                                                                    return { ...file, thumbnail: null, title: file.name, location: null };
                                                                }
                                                            })
                                                        );
                                                        
                                                        setShowFilePickerModal({ files: filesWithThumbnails, isLoading: false });
                                                    } catch (err) {
                                                        console.error('Load error:', err);
                                                        alert('‚ùå Load failed: ' + err.message);
                                                    }
                                                }}
                                                disabled={!equivalenceChart}
                                                className="px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5a7968] disabled:bg-gray-400 disabled:cursor-not-allowed font-medium text-sm transition-colors"
                                                title={!equivalenceChart ? "‚è≥ Please wait for the glyph chart to load..." : "Load a saved inscription from Google Drive"}
                                            >
                                                ‚òÅÔ∏è Load from Google Drive
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            {isImageLoading && (
                                <div className="mt-2 flex items-center gap-2 text-stone-dark">
                                    <div className="w-4 h-4 border-2 border-stone-dark border-t-transparent rounded-full animate-spin"></div>
                                    <span className="text-sm font-medium">Loading image...</span>
                                </div>
                            )}
                        </div>
                    ) : (
                        <div className="mb-6 p-3 bg-[#f0f5f3] border border-[#b5d4c8] rounded-lg flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <span className="text-patina">‚úì</span>
                                <span className="text-sm font-medium text-gray-700">Image loaded</span>
                            </div>
                            <button
                                onClick={() => {
                                    setImage(null);
                                    setOriginalMat(null);
                                    setPreprocessedMat(null);
                                    setRecognitionResults([]);
                                    setDisplayImage(null);
                                }}
                                className="px-3 py-1 text-xs bg-stone text-white rounded hover:bg-stone-dark"
                            >
                                üì§ Upload Different Image
                            </button>
                        </div>
                    )}

                    {/* Preprocessing Panel */}
                    {image && originalMat && (
                        <div className="mb-6 border-2 border-gray-300 rounded-lg bg-gray-50">
                            <div 
                                className="p-4 bg-gray-200 cursor-pointer flex justify-between items-center rounded-t-lg hover:bg-gray-300"
                                onClick={() => setIsPreprocessingCollapsed(!isPreprocessingCollapsed)}
                            >
                                <h3 className="font-semibold text-gray-900 text-lg">
                                    {isPreprocessingCollapsed ? '‚ñ∂' : '‚ñº'} Image Preprocessing
                                    {isPreprocessingCollapsed && preprocessing.useAdaptiveThreshold && (
                                        <span className="text-sm text-stone-dark ml-2">(Active)</span>
                                    )}
                                </h3>
                                <div className="flex gap-2" onClick={(e) => e.stopPropagation()}>
                                    <button 
                                        onClick={resetPreprocessing}
                                        className="px-3 py-1 text-sm bg-white border border-gray-300 rounded hover:bg-gray-100"
                                    >
                                        Reset
                                    </button>
                                    <button 
                                        onClick={exportPreprocessingSettings}
                                        className="px-3 py-1 text-sm bg-white border border-gray-300 rounded hover:bg-gray-100"
                                    >
                                        Export
                                    </button>
                                </div>
                            </div>
                            
                            {/* Compact status bar when collapsed */}
                            {isPreprocessingCollapsed && (preprocessing.useAdaptiveThreshold || preprocessing.gaussianBlur > 0 || preprocessing.rotation !== 0 || preprocessing.morphologyOperation !== 'none' || preprocessing.invertColors) && (
                                <div className="px-4 py-2 bg-[#f5f3f0] border-t border-stone-light flex items-center justify-between">
                                    <div className="text-sm text-stone-dark">
                                        <span className="font-medium">Active: </span>
                                        {preprocessing.gaussianBlur > 0 && <span className="mr-2">Blur:{preprocessing.gaussianBlur}</span>}
                                        {preprocessing.useAdaptiveThreshold && <span className="mr-2">Threshold</span>}
                                        {preprocessing.rotation !== 0 && <span className="mr-2">Rot:{preprocessing.rotation}¬∞</span>}
                                        {preprocessing.morphologyOperation !== 'none' && <span className="mr-2">{preprocessing.morphologyOperation}</span>}
                                        {preprocessing.invertColors && <span className="mr-2">Inverted</span>}
                                    </div>
                                    <button
                                        onClick={applyAdjustments}
                                        disabled={!preprocessedMat}
                                        className={`px-4 py-1 text-sm rounded font-medium ${adjustmentsApplied ? 'bg-patina text-white' : 'bg-ochre text-white animate-pulse'}`}
                                    >
                                        {adjustmentsApplied ? '‚úì Applied' : '‚ö° Apply'}
                                    </button>
                                </div>
                            )}
                            
                            {!isPreprocessingCollapsed && (
                                <div className="p-5">
                                    {/* Preview Canvases */}
                                    {showPreprocessPreview && (
                                        <div className="mb-5 border border-gray-300 rounded-lg p-4 bg-white">
                                            <div className="flex justify-between items-center mb-3">
                                                <span className="font-semibold text-sm">Image Comparison</span>
                                                <button 
                                                    onClick={() => setShowPreprocessPreview(false)}
                                                    className="px-2 py-1 text-xs bg-gray-100 border border-gray-300 rounded hover:bg-gray-200"
                                                >
                                                    Hide Preview
                                                </button>
                                            </div>
                                            <div className="flex gap-5 justify-center flex-wrap">
                                                <div className="flex-1 min-w-[300px] max-w-[500px]">
                                                    <div className="font-semibold text-sm text-gray-600 mb-2">Original</div>
                                                    <canvas ref={originalCanvasRef} className="max-w-full border-2 border-gray-300 rounded bg-gray-100" style={{minHeight: '200px'}} />
                                                </div>
                                                <div className="flex-1 min-w-[300px] max-w-[500px]">
                                                    <div className="font-semibold text-sm text-gray-600 mb-2">Preprocessed</div>
                                                    <canvas ref={preprocessCanvasRef} className="max-w-full border-2 border-gray-300 rounded bg-gray-100" style={{minHeight: '200px'}} />
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    {!showPreprocessPreview && (
                                        <button 
                                            onClick={() => setShowPreprocessPreview(true)}
                                            className="mb-5 px-4 py-2 text-sm bg-patina text-white rounded hover:bg-[#5d7a6d]"
                                        >
                                            Show Preview
                                        </button>
                                    )}
                                    
                                    {!showPreprocessPreview && recognitionResults.length === 0 && (
                                        <div className="mb-4 p-3 bg-gray-50 border border-gray-300 rounded text-xs text-gray-600 text-center">
                                            üí° Tip: Scroll down to <strong>Controls & Options</strong> section to see the preprocessed image and run recognition
                                        </div>
                                    )}
                                    
                                    {/* Rotation Control */}
                                    <div className="mb-3 bg-white rounded-lg border border-gray-200 overflow-hidden">
                                        <div 
                                            className="p-3 flex items-center justify-between cursor-pointer hover:bg-gray-50"
                                            onClick={() => setIsRotationCollapsed(!isRotationCollapsed)}
                                        >
                                            <span className="font-semibold">
                                                {isRotationCollapsed ? '‚ñ∂' : '‚ñº'} Rotation: {preprocessing.rotation}¬∞
                                            </span>
                                            <div className="flex gap-2">
                                                {preprocessing.rotation !== 0 && recognitionResults.length > 0 && (
                                                    <span className="text-xs bg-[#f5e8e4] text-rust px-2 py-1 rounded">‚ö†Ô∏è Boxes won't move</span>
                                                )}
                                                {preprocessing.rotation !== 0 && (
                                                    <span className="text-xs bg-stone-light text-stone-dark px-2 py-1 rounded">Active</span>
                                                )}
                                            </div>
                                        </div>
                                        {!isRotationCollapsed && (
                                            <div className="p-4 pt-0">
                                                <input
                                                    type="range"
                                                    min="-180"
                                                    max="180"
                                                    value={preprocessing.rotation}
                                                    onChange={(e) => {
                                                        const newRotation = parseFloat(e.target.value);
                                                        if (recognitionResults.length > 0 && newRotation !== preprocessing.rotation) {
                                                            if (!confirm('‚ö†Ô∏è Warning: Rotating after recognition will not move detection boxes.\n\nThe boxes will stay in their original positions. You\'ll need to:\n1. Clear all detections\n2. Apply rotation\n3. Run recognition again\n\nContinue with rotation?')) {
                                                                return;
                                                            }
                                                        }
                                                        updatePreprocessingSetting('rotation', newRotation);
                                                    }}
                                                    className="w-full mb-2"
                                                />
                                                <div className="flex gap-2">
                                                    <button 
                                                        onClick={() => {
                                                            if (recognitionResults.length > 0) {
                                                                if (!confirm('‚ö†Ô∏è Warning: Rotating after recognition will not move detection boxes.\n\nThe boxes will stay in their original positions. You\'ll need to:\n1. Clear all detections\n2. Apply rotation\n3. Run recognition again\n\nContinue with rotation?')) {
                                                                    return;
                                                                }
                                                            }
                                                            updatePreprocessingSetting('rotation', preprocessing.rotation - 90);
                                                        }} 
                                                        className="flex-1 px-3 py-2 text-sm bg-white border border-gray-300 rounded hover:bg-gray-100"
                                                    >
                                                        -90¬∞
                                                    </button>
                                                    <button 
                                                        onClick={() => updatePreprocessingSetting('rotation', 0)} 
                                                        className="flex-1 px-3 py-2 text-sm bg-white border border-gray-300 rounded hover:bg-gray-100"
                                                    >
                                                        0¬∞
                                                    </button>
                                                    <button 
                                                        onClick={() => {
                                                            if (recognitionResults.length > 0) {
                                                                if (!confirm('‚ö†Ô∏è Warning: Rotating after recognition will not move detection boxes.\n\nThe boxes will stay in their original positions. You\'ll need to:\n1. Clear all detections\n2. Apply rotation\n3. Run recognition again\n\nContinue with rotation?')) {
                                                                    return;
                                                                }
                                                            }
                                                            updatePreprocessingSetting('rotation', preprocessing.rotation + 90);
                                                        }} 
                                                        className="flex-1 px-3 py-2 text-sm bg-white border border-gray-300 rounded hover:bg-gray-100"
                                                    >
                                                        +90¬∞
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Gaussian Blur */}
                                    <div className="mb-3 bg-white rounded-lg border border-gray-200 overflow-hidden">
                                        <div className="p-3 flex items-center justify-between">
                                            <label className="font-semibold flex items-center cursor-pointer hover:bg-gray-50">
                                                <span 
                                                    className="mr-2 cursor-pointer px-1"
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        setIsBlurCollapsed(!isBlurCollapsed);
                                                    }}
                                                >
                                                    {isBlurCollapsed ? '‚ñ∂' : '‚ñº'}
                                                </span>
                                                <input
                                                    type="checkbox"
                                                    checked={preprocessing.gaussianBlur > 0}
                                                    onChange={(e) => updatePreprocessingSetting('gaussianBlur', e.target.checked ? 5 : 0)}
                                                    className="mr-2"
                                                />
                                                Gaussian Blur {preprocessing.gaussianBlur > 0 ? `(${preprocessing.gaussianBlur}√ó${preprocessing.gaussianBlur})` : ''}
                                            </label>
                                            {preprocessing.gaussianBlur > 0 && (
                                                <span className="text-xs bg-stone-light text-stone-dark px-2 py-1 rounded">Active</span>
                                            )}
                                        </div>
                                        {!isBlurCollapsed && preprocessing.gaussianBlur > 0 && (
                                            <div className="p-4 pt-0">
                                                <select
                                                    value={preprocessing.gaussianBlur}
                                                    onChange={(e) => updatePreprocessingSetting('gaussianBlur', parseInt(e.target.value))}
                                                    className="w-full p-2 text-sm border border-gray-300 rounded"
                                                >
                                                    <option value="3">Light (3√ó3)</option>
                                                    <option value="5">Medium (5√ó5)</option>
                                                    <option value="7">Strong (7√ó7)</option>
                                                    <option value="9">Very Strong (9√ó9)</option>
                                                </select>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Adaptive Threshold */}
                                    <div className="mb-3 bg-white rounded-lg border border-gray-200 overflow-hidden">
                                        <div className="p-3 flex items-center justify-between">
                                            <label className="font-semibold flex items-center cursor-pointer hover:bg-gray-50">
                                                <span 
                                                    className="mr-2 cursor-pointer px-1"
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        setIsThresholdCollapsed(!isThresholdCollapsed);
                                                    }}
                                                >
                                                    {isThresholdCollapsed ? '‚ñ∂' : '‚ñº'}
                                                </span>
                                                <input
                                                    type="checkbox"
                                                    checked={preprocessing.useAdaptiveThreshold}
                                                    onChange={(e) => updatePreprocessingSetting('useAdaptiveThreshold', e.target.checked)}
                                                    className="mr-2"
                                                />
                                                Adaptive Threshold {preprocessing.useAdaptiveThreshold ? `(${preprocessing.blockSize}/${preprocessing.constantOffset})` : ''}
                                            </label>
                                            {preprocessing.useAdaptiveThreshold && (
                                                <span className="text-xs bg-stone-light text-stone-dark px-2 py-1 rounded">Active</span>
                                            )}
                                        </div>
                                        {!isThresholdCollapsed && preprocessing.useAdaptiveThreshold && (
                                            <div className="p-4 pt-0">
                                                <label className="block font-semibold text-sm text-gray-700 mb-1">
                                                    Block Size: {preprocessing.blockSize}
                                                    <span className="font-normal text-xs text-gray-500 ml-2">(larger = smoother)</span>
                                                </label>
                                                <input
                                                    type="range"
                                                    min="3"
                                                    max="99"
                                                    step="2"
                                                    value={preprocessing.blockSize}
                                                    onChange={(e) => updatePreprocessingSetting('blockSize', parseInt(e.target.value))}
                                                    className="w-full mb-3"
                                                />

                                                <label className="block font-semibold text-sm text-gray-700 mb-1">
                                                    Constant Offset: {preprocessing.constantOffset}
                                                    <span className="font-normal text-xs text-gray-500 ml-2">(higher = more white)</span>
                                                </label>
                                                <input
                                                    type="range"
                                                    min="-20"
                                                    max="20"
                                                    value={preprocessing.constantOffset}
                                                    onChange={(e) => updatePreprocessingSetting('constantOffset', parseInt(e.target.value))}
                                                    className="w-full"
                                                />
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Invert Colors */}
                                    <div className="mb-3 bg-white rounded-lg border border-gray-200 overflow-hidden">
                                        <div className="p-3 flex items-center justify-between">
                                            <label className="font-semibold flex items-center cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={preprocessing.invertColors}
                                                    onChange={(e) => updatePreprocessingSetting('invertColors', e.target.checked)}
                                                    className="mr-2"
                                                />
                                                Invert Colors
                                                <span className="font-normal text-xs text-gray-500 ml-2">(light on dark)</span>
                                            </label>
                                            {preprocessing.invertColors && (
                                                <span className="text-xs bg-stone-light text-stone-dark px-2 py-1 rounded">Active</span>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {/* Morphology */}
                                    <div className="mb-3 bg-white rounded-lg border border-gray-200 overflow-hidden">
                                        <div 
                                            className="p-3 flex items-center justify-between cursor-pointer hover:bg-gray-50"
                                            onClick={() => setIsMorphCollapsed(!isMorphCollapsed)}
                                        >
                                            <span className="font-semibold">
                                                {isMorphCollapsed ? '‚ñ∂' : '‚ñº'} Morphology {preprocessing.morphologyOperation !== 'none' ? `(${preprocessing.morphologyOperation})` : ''}
                                            </span>
                                            {preprocessing.morphologyOperation !== 'none' && (
                                                <span className="text-xs bg-stone-light text-stone-dark px-2 py-1 rounded">Active</span>
                                            )}
                                        </div>
                                        {!isMorphCollapsed && (
                                            <div className="p-4 pt-0">
                                                <select
                                                    value={preprocessing.morphologyOperation}
                                                    onChange={(e) => updatePreprocessingSetting('morphologyOperation', e.target.value)}
                                                    className="w-full p-2 text-sm border border-gray-300 rounded"
                                                >
                                                    <option value="none">None</option>
                                                    <option value="close">Close (fill small gaps)</option>
                                                    <option value="open">Open (remove small noise)</option>
                                                    <option value="both">Both (clean thoroughly)</option>
                                                </select>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Manual Eraser */}
                                    <div className="mb-5 p-4 bg-white rounded-lg border border-gray-200">
                                        <label className="block font-semibold mb-3">
                                            üñåÔ∏è Manual Eraser
                                            <span className="font-normal text-xs text-gray-500 ml-2">(remove noise manually)</span>
                                        </label>
                                        
                                        {!eraserMode ? (
                                            <button
                                                onClick={toggleEraserMode}
                                                disabled={!preprocessedMat}
                                                className="w-full px-4 py-3 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3e54] disabled:opacity-50 disabled:cursor-not-allowed font-semibold transition-colors"
                                            >
                                                üñåÔ∏è Enable Eraser Mode
                                            </button>
                                        ) : (
                                            <div>
                                                {/* Eraser Canvas */}
                                                <div className="mb-3 border-2 border-ancient-purple rounded-lg overflow-hidden bg-gray-100">
                                                    <canvas
                                                        ref={eraserCanvasRef}
                                                        onMouseDown={handleEraserMouseDown}
                                                        onMouseMove={handleEraserMouseMove}
                                                        onMouseUp={handleEraserMouseUp}
                                                        onMouseLeave={handleEraserMouseUp}
                                                        onTouchStart={handleEraserTouchStart}
                                                        onTouchMove={handleEraserTouchMove}
                                                        onTouchEnd={handleEraserTouchEnd}
                                                        onTouchCancel={handleEraserTouchEnd}
                                                        className="max-w-full"
                                                        style={{
                                                            cursor: eraserCursorStyle,
                                                            touchAction: 'none' // Prevent default touch behaviors
                                                        }}
                                                    />
                                                </div>
                                                
                                                {/* Brush Size Control */}
                                                <div className="mb-3">
                                                    <label className="block text-sm font-semibold mb-2">
                                                        Brush Size: {brushSize}px
                                                    </label>
                                                    <input
                                                        type="range"
                                                        min="5"
                                                        max="100"
                                                        value={brushSize}
                                                        onChange={(e) => setBrushSize(parseInt(e.target.value))}
                                                        className="w-full"
                                                    />
                                                    <div className="flex justify-between text-xs text-gray-500 mt-1">
                                                        <span>Fine (5px)</span>
                                                        <span>Large (100px)</span>
                                                    </div>
                                                </div>
                                                
                                                {/* Eraser Controls */}
                                                <div className="flex gap-2 mb-2">
                                                    <button
                                                        onClick={undoLastStroke}
                                                        disabled={eraserHistory.length <= 1}
                                                        className="flex-1 px-3 py-2 bg-stone text-white rounded hover:bg-stone-dark disabled:opacity-50 disabled:cursor-not-allowed text-sm font-semibold"
                                                        title="Undo last stroke"
                                                    >
                                                        ‚Ü∂ Undo
                                                    </button>
                                                    <button
                                                        onClick={clearAllEraser}
                                                        className="flex-1 px-3 py-2 bg-ochre text-white rounded hover:bg-[#a18259] text-sm font-semibold"
                                                        title="Clear all strokes"
                                                    >
                                                        üîÑ Reset
                                                    </button>
                                                </div>
                                                <div className="flex gap-2">
                                                    <button
                                                        onClick={toggleEraserMode}
                                                        className="w-full px-3 py-2 bg-patina text-white rounded hover:bg-[#5d7a6d] text-sm font-semibold"
                                                    >
                                                        ‚úì Done Erasing
                                                    </button>
                                                </div>
                                                
                                                <p className="mt-2 text-xs text-gray-600">
                                                    Click and drag to erase noise. Use Undo to remove last stroke. Click "Done" when finished.
                                                </p>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Summary */}
                                    <div className="p-4 bg-[#f5f3f0] border border-stone-light rounded-lg">
                                        <strong className="block mb-2">Active Settings:</strong>
                                        <ul className="list-disc ml-5 text-sm">
                                            {preprocessing.rotation !== 0 && <li>Rotation: {preprocessing.rotation}¬∞</li>}
                                            {preprocessing.gaussianBlur > 0 && <li>Gaussian Blur: {preprocessing.gaussianBlur}√ó{preprocessing.gaussianBlur}</li>}
                                            {preprocessing.useAdaptiveThreshold && <li>Adaptive Threshold (Block: {preprocessing.blockSize}, Offset: {preprocessing.constantOffset})</li>}
                                            {preprocessing.invertColors && <li>Colors Inverted</li>}
                                            {preprocessing.morphologyOperation !== 'none' && <li>Morphology: {preprocessing.morphologyOperation}</li>}
                                            {preprocessing.rotation === 0 && !preprocessing.useAdaptiveThreshold && preprocessing.gaussianBlur === 0 && preprocessing.morphologyOperation === 'none' && !preprocessing.invertColors && (
                                                <li className="italic text-gray-600">No preprocessing active</li>
                                            )}
                                        </ul>
                                    </div>
                                    
                                    {/* Apply Adjustments Button */}
                                    <div className="mt-4 p-4 bg-white border-2 rounded-lg" style={{borderColor: adjustmentsApplied ? '#6b8e7f' : '#b8956a'}}>
                                        <div className="flex items-center justify-between">
                                            <div className="flex items-center gap-3">
                                                {adjustmentsApplied ? (
                                                    <>
                                                        <div className="w-3 h-3 bg-patina rounded-full"></div>
                                                        <span className="font-semibold text-patina">‚úì Adjustments Applied</span>
                                                    </>
                                                ) : (
                                                    <>
                                                        <div className="w-3 h-3 bg-ochre rounded-full animate-pulse"></div>
                                                        <span className="font-semibold text-amber-700">Adjustments Ready</span>
                                                    </>
                                                )}
                                            </div>
                                            <button
                                                onClick={applyAdjustments}
                                                disabled={!preprocessedMat}
                                                className="px-6 py-2 bg-stone text-white rounded-lg hover:bg-stone-dark disabled:opacity-50 disabled:cursor-not-allowed font-semibold transition-colors"
                                            >
                                                {adjustmentsApplied ? 'üîÑ Reapply Adjustments' : '‚ú® Apply Adjustments'}
                                            </button>
                                        </div>
                                        <p className="mt-2 text-xs text-gray-600">
                                            {adjustmentsApplied 
                                                ? 'The preprocessed image is ready for recognition. Click "Recognize Glyphs" below.'
                                                : 'Click "Apply Adjustments" to update the main image with your preprocessing settings before recognition.'}
                                        </p>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                            <button
                                onClick={() => setIsViewModeCollapsed(!isViewModeCollapsed)}
                                className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700 mb-3 w-full text-left"
                            >
                                <span>{isViewModeCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                <h3>View Mode</h3>
                            </button>
                            
                            {!isViewModeCollapsed && (
                            <>
                            <div className="flex items-center justify-between mb-4">
                                <div className="flex gap-2">
                                    <button 
                                        onClick={() => setViewMode('detection')}
                                        className={`px-4 py-2 rounded font-medium ${viewMode === 'detection' ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        üì∑ Detection View
                                    </button>
                                    <button 
                                        onClick={() => {
                                            setViewMode('reading');
                                            if (readingOrder.length === 0) {
                                                setReadingOrder(recognitionResults.map((_, idx) => idx));
                                            }
                                            // Auto-detect reading direction if still in detection mode
                                            if (readingDirection === 'detection') {
                                                autoDetectReadingOrder();
                                            }
                                        }}
                                        className={`px-4 py-2 rounded font-medium ${viewMode === 'reading' ? 'bg-patina text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        üìñ Reading Order View
                                    </button>
                                    <button 
                                        onClick={() => setShowArabicLabels(!showArabicLabels)}
                                        className={`px-4 py-2 rounded font-medium ${showArabicLabels ? 'bg-ancient-purple text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                        title={showArabicLabels ? 'Showing Arabic labels' : 'Showing English labels'}
                                    >
                                        {showArabicLabels ? 'üî§ Arabic' : 'ABC English'}
                                    </button>
                                </div>
                            </div>
                            
                            {viewMode === 'reading' && !showTranscription && (
                                        <button 
                                            onClick={() => setShowTranscription(true)}
                                            className="px-4 py-2 rounded font-medium bg-stone text-white hover:bg-stone-dark"
                                            title="Show transcription box"
                                        >
                                            üìù Show Transcription
                                        </button>
                                    )}
                            
                            {viewMode === 'reading' && (
                                <div className="pt-4 border-t border-gray-300">
                                    <div className="flex items-center justify-between">
                                        <span className="text-sm font-medium text-gray-700">Reading Direction:</span>
                                        <div className="flex gap-2">
                                            <button 
                                                onClick={() => {
                                                    const detected = autoDetectReadingOrder();
                                                    if (detected) {
                                                        alert(`üîÆ Auto-detected: ${detected.toUpperCase()}\n\nReading order has been generated based on glyph positions.`);
                                                    }
                                                }}
                                                className="px-3 py-1 text-sm rounded bg-ancient-purple text-white hover:bg-[#4a3e54]"
                                                title="Auto-detect reading direction based on glyph positions"
                                            >
                                                üîÆ Auto
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('detection')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'detection' ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Original detection order"
                                            >
                                                üî¢ Detection Order
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('ltr')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'ltr' ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Left to Right"
                                            >
                                                ‚Üí LTR
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('rtl')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'rtl' ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Right to Left"
                                            >
                                                ‚Üê RTL
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('ttb')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'ttb' ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Top to Bottom"
                                            >
                                                ‚Üì TTB
                                            </button>
                                        </div>
                                    </div>
                                    {!dismissedTips['reading-order'] && (
                                        <DismissableTip id="reading-order" className="mt-3">
                                            <strong>üí° Tip:</strong> In Reading Order View, drag cards to reorder. Use üîÆ Auto to detect direction from glyph positions.
                                        </DismissableTip>
                                    )}
                                </div>
                            )}
                            
                            {viewMode === 'detection' && (
                                <div className="pt-4 border-t border-gray-300">
                                    <div className="p-3 bg-gray-100 border border-gray-300 rounded text-sm text-gray-700">
                                        üì∑ Detection View shows glyphs in the order they were detected (left-to-right on the image). Use this mode for validation and editing.
                                    </div>
                                </div>
                            )}
                            </>
                            )}
                        </div>
                    )}


                    {image && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <div className="flex items-center justify-between mb-3">
                                <button
                                    onClick={() => setIsControlsCollapsed(!isControlsCollapsed)}
                                    className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700"
                                >
                                    <span>{isControlsCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                    <h3>Controls & Options</h3>
                                </button>
                                
                                {isControlsCollapsed && (
                                    <button 
                                        onClick={recognizeGlyphs} 
                                        disabled={isProcessing || !equivalenceChart} 
                                        className="px-6 py-2 bg-patina text-white rounded hover:bg-[#5d7a6d] disabled:opacity-50 font-semibold"
                                    >
                                        {isProcessing ? 'Processing...' : 'üîç Recognize Glyphs'}
                                    </button>
                                )}
                            </div>
                            
                            {!isControlsCollapsed && (
                                <>
                                <div className="flex flex-wrap gap-3 items-center mb-4">
                                <button onClick={recognizeGlyphs} disabled={isProcessing || !equivalenceChart} className="px-6 py-2 bg-patina text-white rounded hover:bg-[#5d7a6d] disabled:opacity-50">
                                    {isProcessing ? 'Processing...' : 'Recognize Glyphs'}
                                </button>
                                {/* üëá ADD THIS PROGRESS BAR */}
                                {isProcessing && processingProgress.total > 0 && (
                                    <div className="mt-3 p-3 bg-[#f5f3f0] rounded border border-stone-light">
                                        <div className="flex items-center justify-between mb-2">
                                            <span className="text-sm font-medium text-gray-700">
                                                Processing region {processingProgress.current} of {processingProgress.total}
                                            </span>
                                            <span className="text-sm text-gray-600">
                                                {Math.round((processingProgress.current / processingProgress.total) * 100)}%
                                            </span>
                                        </div>
                                        <div className="w-full bg-gray-200 rounded-full h-2.5">
                                            <div
                                                className="bg-stone-dark h-2.5 rounded-full transition-all duration-300"
                                                style={{ width: ((processingProgress.current / processingProgress.total) * 100) + '%' }}
                                            />
                                        </div>
                                    </div>
                                )}

                                <button onClick={() => setManualDetectionMode(!manualDetectionMode)} className={`px-4 py-2 rounded ${manualDetectionMode ? 'bg-orange-500 text-white hover:bg-orange-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>
                                    {manualDetectionMode ? 'Exit Manual Mode' : 'Manual Detection'}
                                </button>
                                
                                <button
                                    onClick={() => setTemplateTrainingMode(!templateTrainingMode)}
                                    className={`px-4 py-2 rounded ${templateTrainingMode ? 'bg-[#4a3e54] text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                >
                                    {templateTrainingMode ? 'üéì Exit Template Training' : 'üéì Template Training Mode'}
                                </button>

                                {templateTrainingMode && (
                                    <div className="mt-4 p-4 bg-[#f3f1f4] border-2 border-ancient-purple rounded-lg">
                                        <h4 className="font-semibold text-ancient-purple mb-2">üéì Template Training Mode Active</h4>
                                        <p className="text-sm text-ancient-purple mb-3">
                                            Click any detection below to save it as a template image. Good templates improve future recognition accuracy!
                                        </p>
                                        <div className="text-xs text-ancient-purple space-y-1">
                                            <div>‚Ä¢ <strong>Primary:</strong> The main reference image (replaces existing)</div>
                                            <div>‚Ä¢ <strong>Variant:</strong> Alternative style of the same glyph (adds to collection)</div>
                                            <div>‚Ä¢ <strong>Example:</strong> Additional training data (adds to collection)</div>
                                            <div> then replace Hakli_glyphs.JSON </div>
                                        </div>
                                        {equivalenceChart && (
                                            <div className="mt-3 flex gap-2">
                                                <button
                                                    onClick={exportUpdatedChart}
                                                    className="px-4 py-2 bg-[#4a3e54] text-white rounded hover:bg-purple-700 text-sm"
                                                >
                                                    üíæ Export Training Chart
                                                </button>
                                                <button
                                                    onClick={() => window.open('merge_hakli_training_glyphs.html', '_blank')}
                                                    className="px-4 py-2 bg-stone-dark text-white rounded hover:bg-stone-dark text-sm"
                                                    title="Open the tool to merge training file with base Hakli_glyphs.JSON"
                                                >
                                                    üîÄ Merge Training File
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                )}
                                                            
                                <button onClick={() => setShowRegionBoundaries(!showRegionBoundaries)} className={`px-4 py-2 rounded ${showRegionBoundaries ? 'bg-ancient-purple text-white hover:bg-[#4a3e54]' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>
                                    Region Boundaries
                                </button>
                                <button
                                    onClick={() => {
                                        if (confirm('üóëÔ∏è Clear all detections and start over?\n\nThis will remove:\n‚Ä¢ All detected glyphs\n‚Ä¢ All validations\n‚Ä¢ Manual selections\n‚Ä¢ Reading order\n\nThis cannot be undone!')) {
                                            setRecognitionResults([]);
                                            setValidations({});
                                            setSelectedRegions(new Set());
                                            setIsolatedGlyphs([]);
                                            setWordBoundaries(new Set());
                                            setReadingOrder([]);
                                            setMergeIndicator(null);
                                            setManualDetectionMode(false);
                                            setTrimMode(null);
                                            setExcludeMode(null);
                                            setExcludeRegions([]);
                                            recordAction('clear_all', { timestamp: new Date().toISOString() });
                                            alert('‚úÖ All detections cleared!');
                                        }
                                    }}
                                    className="px-4 py-2 bg-rust text-white rounded hover:bg-[#8d5d47]"
                                    disabled={recognitionResults.length === 0}
                                >
                                    üóëÔ∏è Clear All
                                </button>
                                {isolatedGlyphs.length > 0 && (
                                    <button
                                        onClick={() => setShowRegionBoundaries(!showRegionBoundaries)}
                                        className="px-4 py-2 bg-patina text-white rounded hover:bg-teal-600"
                                    >
                                        {showRegionBoundaries ? 'Hide' : 'Show'} Isolated Regions ({isolatedGlyphs.length})
                                    </button>
                                )}
                                <span className="text-sm text-gray-600">{recognitionResults.length} detections</span>
                                <button 
                                    onClick={undo}
                                    disabled={historyIndex <= 0}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed"
                                    title="Undo (Ctrl+Z)"
                                >
                                    ‚Ü∂ Undo
                                </button>
                                <button 
                                    onClick={redo}
                                    disabled={historyIndex >= stateHistory.length - 1}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed"
                                    title="Redo (Ctrl+Y)"
                                >
                                    ‚Ü∑ Redo
                                </button>
                            </div>

                            {recognitionResults.length > 0 && (
                                <div className="mt-4 p-4 bg-white border-2 border-gray-300 rounded-lg">
                                    <div className="flex items-center justify-between mb-3">
                                        <div className="flex items-center gap-3">
                                            <button
                                                onClick={() => setShowConfidenceFilter(!showConfidenceFilter)}
                                                className="flex items-center gap-2 text-gray-700 hover:text-gray-900 font-semibold"
                                            >
                                                <span>{showConfidenceFilter ? '‚ñº' : '‚ñ∂'}</span>
                                                <h4 className="text-gray-900">Confidence Filter</h4>
                                            </button>
                                            {!showConfidenceFilter && (
                                                <label className="flex items-center gap-2 cursor-pointer">
                                                    <input
                                                        type="checkbox"
                                                        checked={useConfidenceFilter}
                                                        onChange={(e) => setUseConfidenceFilter(e.target.checked)}
                                                        className="w-4 h-4"
                                                    />
                                                    <span className="text-sm text-gray-700">Enable</span>
                                                </label>
                                            )}
                                        </div>
                                        <div className="text-sm">
                                            {useConfidenceFilter ? (
                                                <span className="text-stone-dark font-semibold">
                                                    Showing {getFilteredResults().length} of {recognitionResults.length} detections
                                                    {recognitionResults.length - getFilteredResults().length > 0 && (
                                                        <span className="text-gray-500 ml-2">
                                                            ({recognitionResults.length - getFilteredResults().length} hidden)
                                                        </span>
                                                    )}
                                                </span>
                                            ) : (
                                                <span className="text-gray-600">Showing all {recognitionResults.length} detections</span>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {showConfidenceFilter && (
                                        <>
                                            <div className="mb-3 pb-3 border-b border-gray-200">
                                                <label className="flex items-center gap-2 cursor-pointer">
                                                    <input
                                                        type="checkbox"
                                                        checked={useConfidenceFilter}
                                                        onChange={(e) => {
                                                            setUseConfidenceFilter(e.target.checked);
                                                            if (e.target.checked) {
                                                                setShowConfidenceFilter(true); // Auto-expand when enabling
                                                            }
                                                        }}
                                                        className="w-4 h-4"
                                                    />
                                                    <span className="text-sm font-medium text-gray-700">Enable Filter</span>
                                                </label>
                                            </div>
                                            <div className="flex items-center gap-4">
                                                <label className="text-sm font-medium text-gray-700 whitespace-nowrap">
                                                    Min Confidence: {confidenceThreshold}%
                                                </label>
                                                <input
                                                    type="range"
                                                    min="0"
                                                    max="100"
                                                    value={confidenceThreshold}
                                                    onChange={(e) => setConfidenceThreshold(parseInt(e.target.value))}
                                                    disabled={!useConfidenceFilter}
                                                    className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed"
                                                    style={{
                                                        background: useConfidenceFilter 
                                                            ? `linear-gradient(to right, #a0674f 0%, #b8956a ${confidenceThreshold / 2}%, #6b8e7f ${confidenceThreshold}%, #e5e7eb ${confidenceThreshold}%, #e5e7eb 100%)`
                                                            : '#e5e7eb'
                                                    }}
                                                />
                                                <span className="text-xs text-gray-500 whitespace-nowrap">
                                                    {confidenceThreshold < 40 && 'üî¥ Low'}
                                                    {confidenceThreshold >= 40 && confidenceThreshold < 70 && 'üü° Medium'}
                                                    {confidenceThreshold >= 70 && 'üü¢ High'}
                                                </span>
                                            </div>
                                        </>
                                    )}
                                </div>
                            )}

                            {selectedRegions.size > 0 && (
                                <div className="flex flex-wrap gap-3 items-center pt-3 border-t border-gray-200">
                                    <span className="text-sm text-gray-600">{selectedRegions.size} selected</span>
                                    {selectedRegions.size >= 2 && (
                                        <>
                                            <button onClick={mergeSelectedDetections} className="px-4 py-2 bg-ancient-purple text-white rounded hover:bg-[#4a3e54] font-semibold">
                                                ‚ö° Merge Selected
                                            </button>
                                            <span className="text-xs text-gray-500">Combines {selectedRegions.size} detections into one</span>
                                        </>
                                    )}
                                    {selectedRegions.size === 1 && (
                                        <span className="text-xs text-stone-dark">Select 1+ more (click ‚ö°) to merge</span>
                                    )}
                                    <button onClick={() => setSelectedRegions(new Set())} className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                                        Clear Selection
                                    </button>
                                </div>
                            )}
                            
                            {manualDetectionMode && (
                                <div className="mt-3 p-3 bg-orange-50 border border-orange-200 rounded text-sm text-orange-800">
                                    Manual Mode: Click and drag to create detections. Ctrl/Cmd+Click to select for merging.
                                </div>
                            )}
                            {recognitionResults.length > 0 && showDetectionCanvasTip && (
                                <div className="mt-3 p-3 bg-[#f7f3ed] border border-[#d4c4a8] rounded text-sm text-[#6d5d42] flex items-center justify-between">
                                    <span>üí° Tip: Ctrl/Cmd+Click any detection box to select it. Delete (‚úï) Merge (‚ö°) and Exclude (üî•) buttons will appear. Click wrench (üîß) to adjust box corners by dragging.</span>
                                    <button 
                                        onClick={() => setShowDetectionCanvasTip(false)}
                                        className="ml-3 text-yellow-600 hover:text-[#6d5d42] font-bold text-lg leading-none flex-shrink-0"
                                        title="Dismiss tip"
                                    >
                                        √ó
                                    </button>
                                </div>
                            )}
                            </>
                            )}
                        </div>
                    )}

                    {image && (
                        <div className="mb-6">
                            <div className="canvas-container relative" ref={imageContainerRef}
                                onMouseMove={handleImageMouseMove}
                                onMouseUp={handleImageMouseUp}
                                onMouseLeave={handleImageMouseUp}
                            >
                                <img
                                    ref={imageRef}
                                    src={displayImage || image}
                                    alt="Uploaded inscription"
                                    className="max-w-full h-auto border border-gray-300 rounded"
                                    onMouseDown={handleImageMouseDown}
                                    style={{ 
                                        cursor: manualDetectionMode ? 'crosshair' : 'default',
                                        userSelect: 'none',
                                        pointerEvents: 'auto',
                                        transform: displayImage ? 'none' : `rotate(${imageRotation}deg)`, // Only rotate preview
                                        transformOrigin: 'center center',
                                        transition: 'transform 0.3s ease'
                                    }}
                                    draggable={false}
                                />

                                {/* Trim mode indicator */}
                                {trimMode !== null && recognitionResults[trimMode] && (() => {
                                    const det = recognitionResults[trimMode];
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const refWidth = rotatedImageDimensions ? rotatedImageDimensions.width : imageRef.current.naturalWidth;
                                    const refHeight = rotatedImageDimensions ? rotatedImageDimensions.height : imageRef.current.naturalHeight;
                                    const scaleX = imageRect.width / refWidth;
                                    const scaleY = imageRect.height / refHeight;
                                    return (
                                        <div
                                            className="absolute border-4 border-dashed border-stone bg-stone-light bg-opacity-20 pointer-events-none"
                                            style={{
                                                left: det.position.x * scaleX + 'px',
                                                top: det.position.y * scaleY + 'px',
                                                width: det.position.width * scaleX + 'px',
                                                height: det.position.height * scaleY + 'px',
                                                zIndex: 20
                                            }}
                                        >
                                            <div className="absolute top-1 left-1 bg-stone text-white text-xs px-2 py-1 rounded">
                                                ‚úÇÔ∏è Draw smaller box to trim
                                            </div>
                                        </div>
                                    );
                                })()}

                                {/* Exclude mode indicator */}
                                {excludeMode !== null && recognitionResults[excludeMode] && (() => {
                                    const det = recognitionResults[excludeMode];
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const refWidth = rotatedImageDimensions ? rotatedImageDimensions.width : imageRef.current.naturalWidth;
                                    const refHeight = rotatedImageDimensions ? rotatedImageDimensions.height : imageRef.current.naturalHeight;
                                    const scaleX = imageRect.width / refWidth;
                                    const scaleY = imageRect.height / refHeight;
                                    return (
                                        <>
                                            {/* Highlight the detection being edited - more visible purple border */}
                                            <div
                                                className="absolute border-4 border-dashed border-ancient-purple pointer-events-none"
                                                style={{
                                                    left: det.position.x * scaleX + 'px',
                                                    top: det.position.y * scaleY + 'px',
                                                    width: det.position.width * scaleX + 'px',
                                                    height: det.position.height * scaleY + 'px',
                                                    zIndex: 20,
                                                    backgroundColor: 'rgba(147, 51, 234, 0.1)'
                                                }}
                                            />

                                            {/* Show exclusion regions drawn by user - more visible */}
                                            {excludeRegions.map((exRegion, idx) => (
                                                <div
                                                    key={`exclude-${idx}`}
                                                    className="absolute border-4 border-red-600 bg-rust pointer-events-none"
                                                    style={{
                                                        left: exRegion.x * scaleX + 'px',
                                                        top: exRegion.y * scaleY + 'px',
                                                        width: exRegion.width * scaleX + 'px',
                                                        height: exRegion.height * scaleY + 'px',
                                                        zIndex: 21,
                                                        opacity: 0.5
                                                    }}
                                                />
                                            ))}
                                        </>
                                    );
                                })()}
                                
                                {showRegionBoundaries && isolatedGlyphs.map((region, index) => {
                                    if (!imageRef.current) return null;
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const refWidth = rotatedImageDimensions ? rotatedImageDimensions.width : imageRef.current.naturalWidth;
                                    const refHeight = rotatedImageDimensions ? rotatedImageDimensions.height : imageRef.current.naturalHeight;
                                    const scaleX = imageRect.width / refWidth;
                                    const scaleY = imageRect.height / refHeight;
                                    const isSelected = selectedIsolatedRegion === index;
                                    return (
                                        <div
                                            key={`region-${index}`}
                                            className={`region-boundary cursor-pointer ${isSelected ? 'ring-2 ring-blue-500' : ''}`}
                                            style={{
                                                left: region.bounds.x * scaleX + 'px',
                                                top: region.bounds.y * scaleY + 'px',
                                                width: region.bounds.width * scaleX + 'px',
                                                height: region.bounds.height * scaleY + 'px',
                                                borderColor: isSelected ? '#8b7d6b' : 'rgba(156, 163, 175, 0.5)'
                                            }}
                                            onClick={() => setSelectedIsolatedRegion(isSelected ? null : index)}
                                        />
                                    );
                                })}
                                
                                {getFilteredResults().map((detection, filteredIndex) => {
                                    if (!imageRef.current) return null;
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    // Use rotated dimensions if available, otherwise fall back to natural dimensions
                                    const refWidth = rotatedImageDimensions ? rotatedImageDimensions.width : imageRef.current.naturalWidth;
                                    const refHeight = rotatedImageDimensions ? rotatedImageDimensions.height : imageRef.current.naturalHeight;
                                    const scaleX = imageRect.width / refWidth;
                                    const scaleY = imageRect.height / refHeight;

                                    // Get the original index from recognitionResults
                                    const index = recognitionResults.indexOf(detection);
                                    let boxColor = '#8b7d6b';
                                    const isSelected = selectedRegions.has(index);
                                    const isValidated = validations[index];
                                    const isAdjusting = adjustMode === index;

                                    if (isValidated) {
                                        boxColor = isValidated.isCorrect ? '#6b8e7f' : '#a0674f';
                                    }

                                    // Get corners (either stored or calculated from position)
                                    const corners = detection.corners || {
                                        tl: { x: detection.position.x, y: detection.position.y },
                                        tr: { x: detection.position.x + detection.position.width, y: detection.position.y },
                                        bl: { x: detection.position.x, y: detection.position.y + detection.position.height },
                                        br: { x: detection.position.x + detection.position.width, y: detection.position.y + detection.position.height }
                                    };

                                    // Check if we're in adjust mode (declare once at the top)
                                    const isInAdjustMode = adjustMode !== null;
                                    const isNotAdjusting = isInAdjustMode && !isAdjusting;

                                    const handleCornerMouseDown = (e, corner) => {
                                        e.stopPropagation();
                                        if (adjustMode !== index) return;
                                        setDraggingCorner(corner);
                                        const rect = imageRef.current.getBoundingClientRect();
                                        const scaleX = rect.width / imageRef.current.naturalWidth;
                                        const scaleY = rect.height / imageRef.current.naturalHeight;
                                        setDragStartPos({
                                            x: (e.clientX - rect.left) / scaleX,
                                            y: (e.clientY - rect.top) / scaleY
                                        });
                                    };

                                    // Render as SVG polygon if:
                                    // 1. Box has been adjusted (isAdjusted flag), OR
                                    // 2. Box is currently being adjusted (isAdjusting)
                                    const hasAdjustedCorners = detection.corners && (detection.isAdjusted || isAdjusting);
                                    
                                    if (hasAdjustedCorners) {
                                        // Use SVG to render the quadrilateral
                                        const points = `${corners.tl.x * scaleX},${corners.tl.y * scaleY} ${corners.tr.x * scaleX},${corners.tr.y * scaleY} ${corners.br.x * scaleX},${corners.br.y * scaleY} ${corners.bl.x * scaleX},${corners.bl.y * scaleY}`;
                                        
                                        return (
                                            <React.Fragment key={`detection-${index}`}>
                                                <svg
                                                    style={{
                                                        position: 'absolute',
                                                        left: 0,
                                                        top: 0,
                                                        width: '100%',
                                                        height: '100%',
                                                        pointerEvents: (templateTrainingMode && selectedForTemplate !== null && selectedForTemplate !== index) ? 'none' : (templateTrainingMode ? 'auto' : 'none'),  // Disable when popup is open on another box
                                                        zIndex: isAdjusting ? 100 : 10,  // Higher when actively adjusting
                                                        opacity: (isNotAdjusting || (templateTrainingMode && selectedForTemplate !== null && selectedForTemplate !== index)) ? 0.2 : 1  // Fade when popup is open or when adjusting
                                                    }}
                                                >
                                                    <polygon
                                                        points={points}
                                                        fill={isAdjusting ? "rgba(251, 146, 60, 0.15)" : `${boxColor}40`}
                                                        stroke={templateTrainingMode && selectedForTemplate === index ? "#a855f7" : (isAdjusting ? "#fb923c" : boxColor)}
                                                        strokeWidth={templateTrainingMode && selectedForTemplate === index ? "4" : (isAdjusting ? "3" : "2")}
                                                        strokeDasharray={detection.hasCloseMatch && !isAdjusting ? "8, 4" : "none"}
                                                        className={templateTrainingMode ? 'cursor-pointer' : ''}
                                                        style={{
                                                            transition: 'stroke 0.2s, stroke-width 0.2s'
                                                        }}
                                                        onMouseEnter={(e) => {
                                                            if (templateTrainingMode && selectedForTemplate !== index) {
                                                                e.target.style.stroke = '#a855f7';
                                                                e.target.style.strokeWidth = '3';
                                                            }
                                                        }}
                                                        onMouseLeave={(e) => {
                                                            if (templateTrainingMode && selectedForTemplate !== index) {
                                                                e.target.style.stroke = boxColor;
                                                                e.target.style.strokeWidth = '2';
                                                            }
                                                        }}
                                                        onClick={(e) => {
                                                            if (templateTrainingMode) {
                                                                e.stopPropagation();
                                                                setSelectedForTemplate(selectedForTemplate === index ? null : index);  // Toggle like rectangles
                                                            }
                                                        }}
                                                    />
                                                </svg>
                                                
                                                {/* Invisible clickable overlay for template training mode - removed, using polygon click instead */}
                                                
                                                {/* Label */}
                                                <div
                                                    className="absolute px-2 py-1 text-xs font-bold text-white rounded"
                                                    style={{
                                                        left: corners.tl.x * scaleX + 'px',
                                                        top: (corners.tl.y * scaleY - 24) + 'px',
                                                        backgroundColor: (isAdjusting ? '#fb923c' : boxColor) + 'e6',
                                                        zIndex: isAdjusting ? 101 : 11,
                                                        pointerEvents: templateTrainingMode ? 'none' : ((isNotAdjusting && !templateTrainingMode) ? 'none' : 'auto')  // Pass through clicks in template mode
                                                    }}
                                                >
                                                    {showArabicLabels ? (detection.glyph.arabic || detection.glyph.name) : detection.glyph.name}
                                                    {detection.corrected && <span className="ml-1">‚úèÔ∏è</span>}
                                                </div>

                                                {viewMode === 'reading' && (
                                                    <div 
                                                        className="absolute w-6 h-6 rounded-full bg-ochre border-2 border-[#8d7350] text-xs font-bold flex items-center justify-center"
                                                        style={{
                                                            left: corners.tl.x * scaleX + 'px',
                                                            top: corners.tl.y * scaleY + 'px',
                                                            zIndex: isAdjusting ? 101 : 11
                                                        }}
                                                    >
                                                        {getReadingOrderIndex(index)}
                                                    </div>
                                                )}

                                                {/* Corner handles - only show when actively adjusting THIS box */}
                                                {isAdjusting && (
                                                    <>
                                                        <div
                                                            onMouseDown={(e) => handleCornerMouseDown(e, 'tl')}
                                                            className="absolute w-4 h-4 bg-orange-500 border-2 border-white rounded-full cursor-nwse-resize hover:scale-125 transition-transform"
                                                            style={{
                                                                left: corners.tl.x * scaleX - 8 + 'px',
                                                                top: corners.tl.y * scaleY - 8 + 'px',
                                                                zIndex: 102
                                                            }}
                                                        />
                                                        <div
                                                            onMouseDown={(e) => handleCornerMouseDown(e, 'tr')}
                                                            className="absolute w-4 h-4 bg-orange-500 border-2 border-white rounded-full cursor-nesw-resize hover:scale-125 transition-transform"
                                                            style={{
                                                                left: corners.tr.x * scaleX - 8 + 'px',
                                                                top: corners.tr.y * scaleY - 8 + 'px',
                                                                zIndex: 102
                                                            }}
                                                        />
                                                        <div
                                                            onMouseDown={(e) => handleCornerMouseDown(e, 'bl')}
                                                            className="absolute w-4 h-4 bg-orange-500 border-2 border-white rounded-full cursor-nesw-resize hover:scale-125 transition-transform"
                                                            style={{
                                                                left: corners.bl.x * scaleX - 8 + 'px',
                                                                top: corners.bl.y * scaleY - 8 + 'px',
                                                                zIndex: 102
                                                            }}
                                                        />
                                                        <div
                                                            onMouseDown={(e) => handleCornerMouseDown(e, 'br')}
                                                            className="absolute w-4 h-4 bg-orange-500 border-2 border-white rounded-full cursor-nwse-resize hover:scale-125 transition-transform"
                                                            style={{
                                                                left: corners.br.x * scaleX - 8 + 'px',
                                                                top: corners.br.y * scaleY - 8 + 'px',
                                                                zIndex: 102
                                                            }}
                                                        />
                                                    </>
                                                )}

                                                {/* Template save menu */}
                                                {templateTrainingMode && selectedForTemplate === index && (
                                                    <div
                                                        className="absolute bg-white rounded-lg shadow-xl border-2 border-ancient-purple p-3"
                                                        style={{ 
                                                            minWidth: '200px',
                                                            left: corners.tl.x * scaleX + 'px',
                                                            top: (corners.br.y * scaleY + 8) + 'px',  // Position below the polygon
                                                            zIndex: 1000  // Very high to ensure it's on top of everything
                                                        }}
                                                        onClick={(e) => e.stopPropagation()}
                                                    >
                                                        <div className="font-semibold text-sm mb-2 text-ancient-purple">
                                                            Save &quot;{detection.glyph.name}&quot; as:
                                                        </div>
                                                        <div className="flex flex-col gap-2">
                                                            <button
                                                                onClick={() => saveAsTemplate(index, 'primary')}
                                                                className="px-3 py-2 bg-stone text-white text-sm rounded hover:bg-stone-dark"
                                                            >
                                                                üéØ Primary Template
                                                            </button>
                                                            <button
                                                                onClick={() => saveAsTemplate(index, 'variant')}
                                                                className="px-3 py-2 bg-patina text-white text-sm rounded hover:bg-[#5d7a6d]"
                                                            >
                                                                ‚≠ê Variant
                                                            </button>
                                                            <button
                                                                onClick={() => saveAsTemplate(index, 'example')}
                                                                className="px-3 py-2 bg-ochre text-white text-sm rounded hover:bg-[#a18259]"
                                                            >
                                                                üìö Example
                                                            </button>
                                                            <button
                                                                onClick={() => setSelectedForTemplate(null)}
                                                                className="px-3 py-2 bg-gray-300 text-gray-700 text-sm rounded hover:bg-gray-400"
                                                            >
                                                                ‚úï Cancel
                                                            </button>
                                                        </div>
                                                    </div>
                                                )}
                                            </React.Fragment>
                                        );
                                    }

                                    return (
                                        <div
                                            key={`detection-${index}`}
                                            className={`detection-box ${detection.hasCloseMatch ? 'uncertain' : ''} ${isSelected ? 'selected' : ''} ${isAdjusting ? 'ring-4 ring-orange-400' : ''} ${templateTrainingMode ? 'cursor-pointer hover:ring-4 hover:ring-purple-400' : ''}`}
                                            style={{
                                                left: detection.position.x * scaleX + 'px',
                                                top: detection.position.y * scaleY + 'px',
                                                width: detection.position.width * scaleX + 'px',
                                                height: detection.position.height * scaleY + 'px',
                                                borderColor: isAdjusting ? '#fb923c' : boxColor,
                                                opacity: (isNotAdjusting || (templateTrainingMode && selectedForTemplate !== null && selectedForTemplate !== index)) ? 0.2 : 1,  // Fade when popup is open or when adjusting
                                                pointerEvents: (isNotAdjusting && !templateTrainingMode) || (templateTrainingMode && selectedForTemplate !== null && selectedForTemplate !== index) ? 'none' : 'auto',  // Disable when popup is open on another box
                                                zIndex: isAdjusting ? 100 : 10  // Higher z-index for adjusting box
                                            }}
                                            onClick={() => {
                                                if (templateTrainingMode) {
                                                    // Toggle selection - if clicking same box, deselect. If different box, select it.
                                                    setSelectedForTemplate(selectedForTemplate === index ? null : index);
                                                } else if (!isAdjusting) {
                                                    toggleRegionSelection(index);
                                                }
                                            }}
                                        >
                                            <div className="detection-label" style={{ backgroundColor: (isAdjusting ? '#fb923c' : boxColor) + 'e6' }}>
                                                {showArabicLabels ? (detection.glyph.arabic || detection.glyph.name) : detection.glyph.name}
                                                {detection.corrected && <span className="ml-1">‚úèÔ∏è</span>}
                                            </div>

                                            {viewMode === 'reading' && (
                                                <div className="reading-order-badge">
                                                    {getReadingOrderIndex(index)}
                                                </div>
                                            )}

                                            {templateTrainingMode && selectedForTemplate === index && (
                                                <div
                                                    className="absolute top-full left-0 mt-2 bg-white rounded-lg shadow-xl border-2 border-ancient-purple p-3"
                                                    style={{ minWidth: '200px', zIndex: 1000 }}
                                                    onClick={(e) => e.stopPropagation()}
                                                >
                                                    <div className="font-semibold text-sm mb-2 text-ancient-purple">
                                                        Save &quot;{detection.glyph.name}&quot; as:
                                                    </div>
                                                    <div className="flex flex-col gap-2">
                                                        <button
                                                            onClick={() => saveAsTemplate(index, 'primary')}
                                                            className="px-3 py-2 bg-stone text-white text-sm rounded hover:bg-stone-dark"
                                                        >
                                                            üéØ Primary Template
                                                        </button>
                                                        <button
                                                            onClick={() => saveAsTemplate(index, 'variant')}
                                                            className="px-3 py-2 bg-patina text-white text-sm rounded hover:bg-[#5d7a6d]"
                                                        >
                                                            ‚≠ê Variant
                                                        </button>
                                                        <button
                                                            onClick={() => saveAsTemplate(index, 'example')}
                                                            className="px-3 py-2 bg-ochre text-white text-sm rounded hover:bg-[#a18259]"
                                                        >
                                                            üìö Example
                                                        </button>
                                                        <button
                                                            onClick={() => setSelectedForTemplate(null)}
                                                            className="px-3 py-2 bg-gray-300 text-gray-700 text-sm rounded hover:bg-gray-400"
                                                        >
                                                            ‚úï Cancel
                                                        </button>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                                
                                {isDrawing && drawStart && drawCurrent && imageRef.current && (() => {
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    
                                    // Use red for exclude mode, orange for manual mode
                                    const boxStyle = excludeMode !== null ? {
                                        border: '3px dashed #dc2626',
                                        background: 'rgba(220, 38, 38, 0.2)'
                                    } : {
                                        border: '3px dashed #b8956a',
                                        background: 'rgba(245, 158, 11, 0.2)'
                                    };
                                    
                                    return (
                                        <div style={{
                                            position: 'absolute',
                                            left: Math.min(drawStart.x, drawCurrent.x) * scaleX + 'px',
                                            top: Math.min(drawStart.y, drawCurrent.y) * scaleY + 'px',
                                            width: Math.abs(drawCurrent.x - drawStart.x) * scaleX + 'px',
                                            height: Math.abs(drawCurrent.y - drawStart.y) * scaleY + 'px',
                                            ...boxStyle,
                                            pointerEvents: 'none',
                                            zIndex: 25
                                        }} />
                                    );
                                })()}
                                
                                {mergeIndicator && imageRef.current && (() => {
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div className="merge-indicator" style={{
                                            left: mergeIndicator.x * scaleX + 'px',
                                            top: mergeIndicator.y * scaleY + 'px',
                                            width: mergeIndicator.width * scaleX + 'px',
                                            height: mergeIndicator.height * scaleY + 'px'
                                        }} />
                                    );
                                })()}
                            </div>
                        </div>
                    )}
                        {isolatedGlyphs.length > 0 && showRegionBoundaries && (
                        <div className="mt-4 p-4 bg-gray-50 border-2 border-teal-300 rounded-lg">
                            <h4 className="font-semibold text-gray-900 mb-3">Isolated Glyph Regions ({isolatedGlyphs.length})</h4>
                            <div className="mb-2 text-sm text-gray-600">
                                üí° Hover over a region to see the delete button
                            </div>
                            <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-2">
                                {isolatedGlyphs.map((region, index) => {
                                    const letter = String.fromCharCode(65 + index);
                                    return (
                                        <div
                                            key={`thumb-${index}`}
                                            className="relative flex flex-col items-center p-2 bg-white border-2 border-gray-300 rounded hover:border-stone-light hover:shadow-lg transition-all group"
                                        >
                                            {region.thumbnail && (
                                                <img src={region.thumbnail} alt={`Region ${letter}`} className="w-full h-auto border border-gray-200" />
                                            )}
                                            <div className="text-xs font-bold text-teal-600 mt-1">{letter}</div>
                                            <div className="text-xs text-gray-500">{region.bounds.width}√ó{region.bounds.height}</div>

                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (confirm(`Delete region ${letter}?\n\nThis will remove the isolated region and any detection associated with it.`)) {
                                                        deleteIsolatedRegion(index);
                                                    }
                                                }}
                                                className="absolute -top-2 -right-2 w-6 h-6 bg-rust text-white rounded-full hover:bg-[#8d5d47] flex items-center justify-center text-sm font-bold shadow-lg opacity-0 group-hover:opacity-100 transition-opacity"
                                                title="Delete this region"
                                            >
                                                √ó
                                            </button>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    {correctionMode !== null && equivalenceChart && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={cancelCorrection}>
                            <div className="bg-white rounded-lg p-6 max-w-5xl w-full max-h-[85vh] overflow-y-auto shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900">Select Correct Glyph</h3>
                                    <button 
                                        onClick={cancelCorrection} 
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none w-8 h-8 flex items-center justify-center"
                                        title="Close (Esc)"
                                    >
                                        &times;
                                    </button>
                                </div>
                                
                                <div className="mb-4 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-stone-light rounded-lg">
                                    <div className="flex items-center justify-between gap-4">
                                        <div className="flex-1">
                                            <span className="text-sm text-gray-600">Currently detected as:</span>
                                            <div className="text-xl font-bold text-gray-900 mt-1">
                                                {recognitionResults[correctionMode].glyph.name}
                                                <span className="ml-3 text-base font-normal text-gray-600">
                                                    ({recognitionResults[correctionMode].glyph.transliteration || recognitionResults[correctionMode].glyph.name})
                                                </span>
                                            </div>
                                            <div className="text-sm text-gray-500 mt-1">
                                                {Math.round(recognitionResults[correctionMode].confidence * 100)}% confidence
                                            </div>
                                        </div>
                                        {recognitionResults[correctionMode].regionIndex !== undefined &&
                                            isolatedGlyphs[recognitionResults[correctionMode].regionIndex]?.thumbnail && (
                                                <div className="flex-shrink-0">
                                                    <div className="text-xs text-gray-600 mb-1 text-center">Detected Region:</div>
                                                    <img
                                                        src={isolatedGlyphs[recognitionResults[correctionMode].regionIndex].thumbnail}
                                                        alt="Isolated region"
                                                        className="w-32 h-auto border-2 border-stone rounded"
                                                    />
                                                </div>
                                            )}
                                    </div>
                                </div>                          
                                <div className="mb-4">
                                    <input
                                        type="text"
                                        placeholder="Search glyphs by name or transliteration..."
                                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-stone focus:outline-none"
                                        onChange={(e) => {
                                            const searchTerm = e.target.value.toLowerCase();
                                            const glyphGrid = e.target.parentElement.nextElementSibling;
                                            const buttons = glyphGrid.querySelectorAll('button');
                                            buttons.forEach(btn => {
                                                const text = btn.textContent.toLowerCase();
                                                btn.style.display = text.includes(searchTerm) ? '' : 'none';
                                            });
                                        }}
                                    />
                                </div>
                                
                                {(() => {
                                    const suggestion = getCorrectionSuggestion(recognitionResults[correctionMode].glyph.id);
                                    if (suggestion) {
                                        return (
                                            <div className="mb-4 p-3 bg-[#f0f5f3] border-2 border-patina rounded-lg">
                                                <div className="flex items-center justify-between">
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-patina font-semibold">üí° Suggestion:</span>
                                                        <span className="text-gray-700">
                                                            You've corrected this to <strong>{suggestion.to.name}</strong> {suggestion.count} time{suggestion.count > 1 ? 's' : ''} before
                                                        </span>
                                                    </div>
                                                    <button
                                                        onClick={() => applyCorrection(correctionMode, suggestion.to)}
                                                        className="px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5d7a6d] font-semibold"
                                                    >
                                                        Apply Suggestion
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    }
                                    return null;
                                })()}

                                <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2">
                                    {equivalenceChart.glyphs.map((glyph, index) => {
                                        const isCurrentGlyph = glyph.id === recognitionResults[correctionMode].glyph.id;
                                        return (
                                            <button
                                                key={`glyph-${glyph.id}-${index}`}
                                                onClick={() => applyCorrection(correctionMode, glyph)}
                                                className={`p-3 border-2 rounded-lg flex flex-col items-center gap-1 transition-all hover:scale-105 ${
                                                    isCurrentGlyph 
                                                        ? 'border-stone bg-[#f5f3f0] ring-2 ring-blue-300' 
                                                        : 'border-gray-200 hover:border-stone-light hover:bg-[#f5f3f0]'
                                                }`}
                                                title={`${glyph.name} (${glyph.transliteration || glyph.name})`}
                                            >
                                                <div className="font-bold text-xl">{glyph.name}</div>
                                                <div className="text-xs text-gray-600 text-center leading-tight">
                                                    {glyph.transliteration || glyph.name}
                                                </div>
                                                {isCurrentGlyph && (
                                                    <div className="text-xs text-stone-dark font-semibold mt-1">Current</div>
                                                )}
                                            </button>
                                        );
                                    })}
                                </div>
                                
                                {showCorrectionModalTip && (
                                    <div className="mt-6 pt-4 border-t border-gray-200 flex items-center justify-between">
                                        <div className="text-sm text-gray-500 flex items-center">
                                            üí° Tip: You can also search glyphs above to find them quickly
                                        </div>
                                        <div className="flex gap-2">
                                            <button 
                                                onClick={() => setShowCorrectionModalTip(false)}
                                                className="text-gray-400 hover:text-gray-600 font-bold text-xl leading-none"
                                                title="Dismiss tip"
                                            >
                                                √ó
                                            </button>
                                            <button 
                                                onClick={cancelCorrection}
                                                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    </div>
                                )}
                                {!showCorrectionModalTip && (
                                    <div className="mt-6 pt-4 border-t border-gray-200 flex justify-end">
                                        <button 
                                            onClick={cancelCorrection}
                                            className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                        >
                                            Cancel
                                        </button>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Exclude Mode Modal */}
                    {excludeMode !== null && recognitionResults[excludeMode] && (
                        <div className="fixed right-4 top-20 z-50 w-96 max-h-[calc(100vh-6rem)] overflow-y-auto">
                            <div className="bg-white rounded-lg p-6 shadow-2xl border-4 border-ancient-purple" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900 flex items-center gap-2">
                                        <span>üî•</span> Exclude Regions
                                    </h3>
                                    <button 
                                        onClick={() => {
                                            setExcludeMode(null);
                                            setExcludeRegions([]);
                                        }} 
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none w-8 h-8 flex items-center justify-center"
                                        title="Close (Esc)"
                                    >
                                        &times;
                                    </button>
                                </div>
                                
                                <div className="mb-4 p-4 bg-gradient-to-r from-[#f3f1f4] to-[#fef1f4] border-2 border-[#c9bfd4] rounded-lg">
                                    <div className="flex items-center gap-4">
                                        <div className="flex-1">
                                            <span className="text-sm text-gray-600">Cleaning detection:</span>
                                            <div className="text-xl font-bold text-gray-900 mt-1">
                                                {recognitionResults[excludeMode].glyph.name}
                                            </div>
                                            <div className="text-sm text-gray-500 mt-1">
                                                Remove unwanted portions from this detection
                                            </div>
                                        </div>
                                        {recognitionResults[excludeMode].regionIndex !== undefined &&
                                            isolatedGlyphs[recognitionResults[excludeMode].regionIndex]?.thumbnail && (
                                                <div className="flex-shrink-0">
                                                    <div className="text-xs text-gray-600 mb-1 text-center">Current Region:</div>
                                                    <img
                                                        src={isolatedGlyphs[recognitionResults[excludeMode].regionIndex].thumbnail}
                                                        alt="Current region"
                                                        className="w-24 h-auto border-2 border-ancient-purple rounded"
                                                    />
                                                </div>
                                            )}
                                    </div>
                                </div>

                                <div className="mb-4 p-4 bg-[#f5f3f0] border border-stone-light rounded-lg">
                                    <h4 className="font-semibold text-stone-dark mb-2">üìù How to Exclude Regions:</h4>
                                    <ol className="text-sm text-gray-700 space-y-2 list-decimal list-inside">
                                        <li><strong className="text-stone-dark">DRAW BOXES on the inscription image</strong> - Click and drag to create red boxes around unwanted portions</li>
                                        <li>The <strong>purple dashed border</strong> shows which detection you're editing</li>
                                        <li><strong>Draw multiple boxes</strong> if you need to exclude several areas</li>
                                        <li>When done drawing, click <strong className="text-patina">"‚úì Apply Exclusions"</strong> below</li>
                                    </ol>
                                </div>

                                <div className="mb-4 p-3 bg-[#f7f3ed] border border-[#d4c4a8] rounded">
                                    <div className="text-sm text-[#6d5d42]">
                                        <strong>Status:</strong> {excludeRegions.length === 0 ? 
                                            '‚ö†Ô∏è No boxes drawn yet - Draw red boxes on the image above!' : 
                                            `‚úì ${excludeRegions.length} exclusion region${excludeRegions.length > 1 ? 's' : ''} drawn - Ready to apply!`}
                                    </div>
                                </div>

                                <div className="flex gap-3">
                                    {excludeRegions.length > 0 && (
                                        <button
                                            onClick={() => applyExclude(excludeMode)}
                                            className="flex-1 px-4 py-3 bg-patina text-white rounded-lg hover:bg-[#5d7a6d] font-semibold text-lg"
                                        >
                                            ‚úì Apply Exclusions
                                        </button>
                                    )}
                                    <button
                                        onClick={() => {
                                            setExcludeMode(null);
                                            setExcludeRegions([]);
                                        }}
                                        className={`${excludeRegions.length > 0 ? 'flex-1' : 'w-full'} px-4 py-3 bg-gray-500 text-white rounded-lg hover:bg-gray-600 font-semibold text-lg`}
                                    >
                                        ‚úï Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Adjust Mode Modal */}
                    {adjustMode !== null && recognitionResults[adjustMode] && (
                        <div className="fixed right-4 top-20 z-50 w-96 max-h-[calc(100vh-6rem)] overflow-y-auto">
                            <div className="bg-white rounded-lg p-6 shadow-2xl border-4 border-teal-400" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900 flex items-center gap-2">
                                        <span>üîß</span> Adjust Box Corners
                                    </h3>
                                    <button 
                                        onClick={() => {
                                            setAdjustMode(null);
                                            setDraggingCorner(null);
                                            setDragStartPos(null);
                                        }} 
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none w-8 h-8 flex items-center justify-center"
                                        title="Close (Esc)"
                                    >
                                        &times;
                                    </button>
                                </div>
                                
                                <div className="mb-4 p-4 bg-gradient-to-r from-teal-50 to-cyan-50 border-2 border-teal-200 rounded-lg">
                                    <div className="flex items-center gap-4">
                                        <div className="flex-1">
                                            <span className="text-sm text-gray-600">Adjusting detection:</span>
                                            <div className="text-xl font-bold text-gray-900 mt-1">
                                                {recognitionResults[adjustMode].glyph.name}
                                            </div>
                                            <div className="text-sm text-gray-500 mt-1">
                                                Drag corners to fit the glyph perfectly
                                            </div>
                                        </div>
                                        {recognitionResults[adjustMode].regionIndex !== undefined &&
                                            isolatedGlyphs[recognitionResults[adjustMode].regionIndex]?.thumbnail && (
                                                <div className="flex-shrink-0">
                                                    <div className="text-xs text-gray-600 mb-1 text-center">Current Region:</div>
                                                    <img
                                                        src={isolatedGlyphs[recognitionResults[adjustMode].regionIndex].thumbnail}
                                                        alt="Current region"
                                                        className="w-24 h-auto border-2 border-teal-300 rounded"
                                                    />
                                                </div>
                                            )}
                                    </div>
                                </div>

                                <div className="mb-4 p-4 bg-[#f5f3f0] border border-stone-light rounded-lg">
                                    <h4 className="font-semibold text-stone-dark mb-2">üìù How to Adjust Corners:</h4>
                                    <ol className="text-sm text-gray-700 space-y-2 list-decimal list-inside">
                                        <li><strong className="text-stone-dark">DRAG the corner circles</strong> on the detection box to adjust each corner independently</li>
                                        <li>The <strong>teal border</strong> shows which detection you're adjusting</li>
                                        <li>Create <strong>trapezoids or parallelograms</strong> to handle perspective or angled glyphs</li>
                                        <li>When done adjusting, click <strong className="text-patina">"‚úì Apply Adjustment"</strong> below</li>
                                    </ol>
                                </div>

                                <div className="mb-4 p-3 bg-[#f7f3ed] border border-ochre rounded-lg text-sm">
                                    <strong className="text-[#6d5d42]">Status:</strong>
                                    <span className="text-gray-700 ml-2">Adjustment mode active - drag the corner handles on the image</span>
                                </div>

                                <div className="flex gap-3">
                                    <button
                                        onClick={() => applyAdjustment(adjustMode)}
                                        className="flex-1 px-4 py-3 bg-patina text-white rounded-lg hover:bg-[#5d7a6d] font-semibold text-lg"
                                    >
                                        ‚úì Apply Adjustment
                                    </button>
                                    <button
                                        onClick={() => {
                                            setAdjustMode(null);
                                            setDraggingCorner(null);
                                            setDragStartPos(null);
                                        }}
                                        className="flex-1 px-4 py-3 bg-gray-500 text-white rounded-lg hover:bg-gray-600 font-semibold text-lg"
                                    >
                                        ‚úï Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <h3 className="font-semibold text-gray-900 mb-3">
                                {viewMode === 'detection' ? 'Detection Results' : 'Reading Order Results'}
                                {viewMode === 'reading' && <span className="ml-2 text-sm text-gray-600">(drag cards to reorder)</span>}
                            </h3>
                            
                            {/* Validation Statistics */}
                            <div className="mb-4 flex flex-wrap gap-4 text-sm items-center">
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-600">Total:</span>
                                    <span className="font-semibold text-gray-900">{recognitionResults.length}</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-patina">‚úì Validated Correct:</span>
                                    <span className="font-semibold text-patina">
                                        {Object.values(validations).filter(v => v.isCorrect).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-rust">‚úó Validated Incorrect:</span>
                                    <span className="font-semibold text-rust">
                                        {Object.values(validations).filter(v => !v.isCorrect).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-orange-600">‚úèÔ∏è Corrected:</span>
                                    <span className="font-semibold text-orange-700">
                                        {recognitionResults.filter(r => r.corrected).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-600">Unvalidated:</span>
                                    <span className="font-semibold text-gray-700">
                                        {recognitionResults.length - Object.keys(validations).length}
                                    </span>
                                </div>
                                
                                {/* Top Matches Toggle */}
                                <button
                                    onClick={() => setShowTopMatches(!showTopMatches)}
                                    className={`ml-auto px-3 py-1 rounded text-xs font-semibold transition-colors ${
                                        showTopMatches 
                                            ? 'bg-orange-500 text-white hover:bg-orange-600' 
                                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                    }`}
                                    title={showTopMatches ? "Hide alternative matches" : "Show alternative matches in cards"}
                                >
                                    {showTopMatches ? 'üîΩ Hide Alternatives' : 'üîº Show Alternatives'}
                                </button>
                            </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                        {(viewMode === 'detection' ? getFilteredResults() : getReadingOrderedResults()).map((result, displayIndex) => {
                            const originalIndex = viewMode === 'detection' ? displayIndex : recognitionResults.indexOf(result);
                            const readingOrderNum = viewMode === 'reading' ? displayIndex + 1 : null;
                            
                            return (
                                <div 
                                    key={`result-${originalIndex}`} 
                                    className={`p-3 bg-white rounded border ${selectedRegions.has(originalIndex) ? 'ring-2 ring-ochre' : ''} ${validations[originalIndex] ? (validations[originalIndex].isCorrect ? 'border-patina' : 'border-rust') : 'border-gray-200'} ${viewMode === 'reading' ? 'cursor-move' : ''}`}
                                    draggable={viewMode === 'reading'}
                                    onDragStart={(e) => viewMode === 'reading' && handleDragStart(e, displayIndex)}
                                    onDragOver={(e) => viewMode === 'reading' && handleDragOver(e, displayIndex)}
                                    onDrop={(e) => viewMode === 'reading' && handleDrop(e, displayIndex)}
                                >
                                    <div className="flex items-start justify-between mb-2">
                                        <div className="flex-1">
                                            <div className="flex items-center gap-2">
                                                {viewMode === 'reading' && (
                                                    <div className="flex-shrink-0 w-6 h-6 rounded-full bg-ochre border-2 border-[#8d7350] text-xs font-bold flex items-center justify-center">
                                                        {readingOrderNum}
                                                    </div>
                                                )}
                                                <div className="flex-1">
                                                    <div className="font-medium text-gray-900 flex items-center gap-2">
                                                        {/* Glyph thumbnail */}
                                                        {glyphThumbnails[result.glyph.id] && (
                                                            <img 
                                                                src={glyphThumbnails[result.glyph.id]} 
                                                                alt={result.glyph.name}
                                                                className="w-10 h-10 object-contain border-2 border-stone rounded bg-white flex-shrink-0"
                                                                title={`Template for ${result.glyph.name}`}
                                                            />
                                                        )}
                                                        {/* Show prominent language based on showArabicLabels toggle */}
                                                        {showArabicLabels ? (
                                                            <span className="text-2xl" style={{ fontFamily: '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' }}>
                                                                {result.glyph.arabic || result.glyph.name}
                                                            </span>
                                                        ) : (
                                                            <span>{result.glyph.name}</span>
                                                        )}
                                                        {result.corrected && (
                                                            <span className="text-xs bg-orange-100 text-orange-700 px-2 py-0.5 rounded border border-orange-300">
                                                                ‚úèÔ∏è Corrected
                                                            </span>
                                                        )}
                                                        {result.isMerged && <span className="text-xs text-gray-500">(merged)</span>}
                                                        {result.isManual && <span className="text-xs text-gray-500">(manual)</span>}
                                                    </div>
                                                    {/* Show alternate language below */}
                                                    <div className="text-sm text-gray-600 mt-1">
                                                        {showArabicLabels ? (
                                                            // If showing Arabic prominently, show English below
                                                            <span>{result.glyph.name} ({result.glyph.transliteration || result.glyph.name})</span>
                                                        ) : (
                                                            // If showing English prominently, show Arabic below
                                                            result.glyph.arabic && (
                                                                <span style={{ fontFamily: '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' }}>
                                                                    {result.glyph.arabic}
                                                                </span>
                                                            )
                                                        )}
                                                    </div>
                                                    {result.corrected && result.originalGlyph && (
                                                        <div className="text-xs text-gray-500 mt-0.5">
                                                            Originally: <span className="line-through">{result.originalGlyph.name}</span>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="text-xs text-gray-500">Confidence: {Math.round(result.confidence * 100)}%</div>
                                            
                                            {/* Top Matches - show alternatives if they exist AND toggle is on */}
                                            {showTopMatches && result.alternatives && result.alternatives.length > 0 && (
                                                <div className="mt-2 p-2 bg-orange-50 border border-orange-200 rounded">
                                                    <div className="text-xs font-semibold text-orange-700 mb-1">Top matches:</div>
                                                    <div className="space-y-1">
                                                        {/* Debug: Log glyph IDs and available images */}
                                                        {(() => {
                                                            if (!glyphThumbnails[result.glyph.id]) {
                                                                console.warn(`Missing thumbnail for ${result.glyph.name} (ID: ${result.glyph.id})`);
                                                                console.log('Available thumbnail IDs:', Object.keys(glyphThumbnails).slice(0, 10));
                                                            }
                                                            return null;
                                                        })()}
                                                        {/* Show current selection */}
                                                        <button
                                                            className="flex items-center gap-2 text-xs w-full hover:bg-orange-100 p-1 rounded"
                                                            disabled
                                                        >
                                                            <span className="text-green-600">‚úì</span>
                                                            {glyphThumbnails[result.glyph.id] ? (
                                                                <img 
                                                                    src={glyphThumbnails[result.glyph.id]} 
                                                                    alt={result.glyph.name}
                                                                    className="w-8 h-8 object-contain border border-green-500 rounded bg-white flex-shrink-0"
                                                                />
                                                            ) : (
                                                                <div className="w-8 h-8 border border-gray-300 rounded bg-gray-50 flex items-center justify-center text-xs text-gray-400 flex-shrink-0">
                                                                    ?
                                                                </div>
                                                            )}
                                                            <span className="font-semibold">{result.glyph.name}</span>
                                                            <span className="text-gray-500">({Math.round(result.confidence * 100)}%)</span>
                                                            <span className="text-xs text-gray-400 ml-auto">‚Üê selected</span>
                                                        </button>
                                                        
                                                        {/* Show alternatives as clickable options */}
                                                        {result.alternatives.slice(0, 2).map((alt, altIndex) => (
                                                            <button
                                                                key={altIndex}
                                                                onClick={() => {
                                                                    // Swap alternative with primary
                                                                    const updatedResults = [...recognitionResults];
                                                                    const resultIndex = updatedResults.findIndex(r => r.regionIndex === result.regionIndex);
                                                                    
                                                                    if (resultIndex !== -1) {
                                                                        // Store original for tracking
                                                                        const original = { ...updatedResults[resultIndex] };
                                                                        
                                                                        // Swap: alternative becomes primary
                                                                        updatedResults[resultIndex] = {
                                                                            ...alt,
                                                                            regionIndex: result.regionIndex,
                                                                            alternatives: [
                                                                                { glyph: original.glyph, confidence: original.confidence, matchType: original.matchType },
                                                                                ...result.alternatives.filter((_, i) => i !== altIndex)
                                                                            ],
                                                                            hasCloseMatch: true,
                                                                            selectedAlternative: alt.glyph.name,
                                                                            corrected: true,
                                                                            originalGlyph: result.originalGlyph || result.glyph
                                                                        };
                                                                        
                                                                        // Track as correction
                                                                        trackCorrection(result.glyph.id, alt.glyph.id);
                                                                        
                                                                        setRecognitionResults(updatedResults);
                                                                        console.log(`üîÑ Swapped ${result.glyph.name} ‚Üí ${alt.glyph.name}`);
                                                                    }
                                                                }}
                                                                className="flex items-center gap-2 text-xs w-full hover:bg-orange-100 p-1 rounded cursor-pointer"
                                                            >
                                                                <span className="text-gray-400">‚óã</span>
                                                                {glyphThumbnails[alt.glyph.id] ? (
                                                                    <img 
                                                                        src={glyphThumbnails[alt.glyph.id]} 
                                                                        alt={alt.glyph.name}
                                                                        className="w-8 h-8 object-contain border border-gray-300 rounded bg-white flex-shrink-0"
                                                                    />
                                                                ) : (
                                                                    <div className="w-8 h-8 border border-gray-300 rounded bg-gray-50 flex items-center justify-center text-xs text-gray-400 flex-shrink-0">
                                                                        ?
                                                                    </div>
                                                                )}
                                                                <span>{alt.glyph.name}</span>
                                                                <span className="text-gray-500">({Math.round(alt.confidence * 100)}%)</span>
                                                                <span className="text-xs text-blue-500 ml-auto">tap to select</span>
                                                            </button>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {(result.thumbnail || (result.regionIndex !== undefined && isolatedGlyphs[result.regionIndex]?.thumbnail)) && (
                                                <div className="mt-2 flex items-center gap-2">
                                                    <span className="text-xs text-gray-500">Region:</span>
                                                    <img
                                                        src={result.thumbnail || (isolatedGlyphs[result.regionIndex]?.thumbnail)}
                                                        alt="Isolated region"
                                                        className="w-16 h-auto border border-gray-300 rounded"
                                                        onError={(e) => {
                                                            console.warn(`Thumbnail failed to load for index ${originalIndex}`, {
                                                                hasResultThumbnail: !!result.thumbnail,
                                                                regionIndex: result.regionIndex,
                                                                hasIsolatedGlyph: !!isolatedGlyphs[result.regionIndex],
                                                                hasIsolatedThumbnail: !!isolatedGlyphs[result.regionIndex]?.thumbnail
                                                            });
                                                            e.target.style.display = 'none';
                                                        }}
                                                    />
                                                </div>
                                            )}
                                        </div>
                                        <div className="flex gap-1">
                                            <button 
                                                onClick={() => startCorrection(originalIndex)} 
                                                className="text-orange-500 hover:text-orange-700 text-sm"
                                                title="Change glyph"
                                            >
                                                ‚úèÔ∏è
                                            </button>
                                            <button 
                                                onClick={() => {
                                                    setExcludeMode(originalIndex);
                                                    setExcludeRegions([]);
                                                }} 
                                                className="text-ancient-purple hover:text-ancient-purple text-sm"
                                                title="Exclude regions from this detection"
                                            >
                                                üî•
                                            </button>
                                            <button 
                                                onClick={() => startAdjustMode(originalIndex)} 
                                                className="text-teal-500 hover:text-teal-700 text-sm"
                                                title="Adjust box corners independently"
                                            >
                                                üîß
                                            </button>
                                            <button 
                                                onClick={() => toggleRegionSelection(originalIndex)} 
                                                className={`text-sm ${selectedRegions.has(originalIndex) ? 'text-stone-dark' : 'text-blue-400 hover:text-stone-dark'}`}
                                                title="Select for merging (select 2+ then click Merge)"
                                            >
                                                ‚ö°
                                            </button>
                                            <button 
                                                onClick={() => deleteDetection(originalIndex)} 
                                                className="text-red-500 hover:text-rust text-sm"
                                                title="Delete detection"
                                            >
                                                ‚úï
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex gap-2 flex-wrap">
                                        <button 
                                            onClick={() => validateDetection(originalIndex, true)} 
                                            className={`px-3 py-1 text-xs rounded ${validations[originalIndex]?.isCorrect ? 'bg-patina text-white' : 'bg-green-100 text-patina hover:bg-green-200'}`}
                                        >
                                            ‚úì Correct
                                        </button>
                                        <button 
                                            onClick={() => validateDetection(originalIndex, false)} 
                                            className={`px-3 py-1 text-xs rounded ${validations[originalIndex] && !validations[originalIndex].isCorrect ? 'bg-rust text-white' : 'bg-[#f5e8e4] text-rust hover:bg-red-200'}`}
                                        >
                                            ‚úó Incorrect
                                        </button>
                                        {viewMode === 'reading' && (
                                            <>
                                                <button 
                                                    onClick={() => toggleWordBoundary(displayIndex)} 
                                                    className={`px-3 py-1 text-xs rounded ${wordBoundaries.has(displayIndex) ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                    title="Mark word boundary after this glyph"
                                                >
                                                    | Word Break
                                                </button>
                                                <button 
                                                    onClick={() => toggleColumnBreak(displayIndex)} 
                                                    className={`px-3 py-1 text-xs rounded ${columnBreaks.has(displayIndex) ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                    title="Mark column break after this glyph"
                                                >
                                                    || Column Break
                                                </button>
                                                <button 
                                                    onClick={() => toggleLineBreak(displayIndex)} 
                                                    className={`px-3 py-1 text-xs rounded ${lineBreaks.has(displayIndex) ? 'bg-ancient-purple text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                    title="Mark line break after this glyph"
                                                >
                                                    --- Line Break
                                                </button>
                                            </>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                    </div>
                    )}


                    {viewMode === 'reading' && recognitionResults.length > 0 && showTranscription && (
                        <div
                            ref={transcriptionRef} 
                            className="mb-6 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border-2 border-stone-light"
                            style={{
                                position: transcriptionPosition.x !== 0 || transcriptionPosition.y !== 0 ? 'fixed' : 'relative',
                                left: transcriptionPosition.x !== 0 ? `${transcriptionPosition.x}px` : 'auto',
                                top: transcriptionPosition.y !== 0 ? `${transcriptionPosition.y}px` : 'auto',
                                zIndex: isDraggingTranscription ? 1000 : transcriptionPosition.x !== 0 || transcriptionPosition.y !== 0 ? 100 : 'auto',
                                cursor: isDraggingTranscription ? 'grabbing' : 'auto',
                                maxWidth: transcriptionPosition.x !== 0 || transcriptionPosition.y !== 0 ? '600px' : 'none',
                                boxShadow: transcriptionPosition.x !== 0 || transcriptionPosition.y !== 0 ? '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)' : 'none'
                            }}
                        >
                            <div 
                                className="flex items-center justify-between mb-3 transcription-drag-handle"
                                onMouseDown={handleTranscriptionMouseDown}
                                style={{ cursor: 'grab' }}
                                title="Drag to reposition transcription box"
                            >
                                <h3 className="font-semibold text-gray-900 flex items-center gap-2">
                                    <span style={{ cursor: 'grab' }}>‚ãÆ‚ãÆ</span> Transcription
                                </h3>
                                <div className="flex gap-2">
                                    {(transcriptionPosition.x !== 0 || transcriptionPosition.y !== 0) && (
                                        <button 
                                            onClick={() => setTranscriptionPosition({ x: 0, y: 0 })}
                                            className="px-3 py-1 bg-gray-500 text-white text-sm rounded hover:bg-gray-600"
                                            title="Reset position"
                                        >
                                            ‚Ü∫ Reset
                                        </button>
                                    )}
                                    {/* TTS DISABLED - Vowels not identified in Semitic languages
                                    <button 
                                        onClick={() => speakTranscription()}
                                        className="px-3 py-1 bg-ancient-purple text-white text-sm rounded hover:bg-[#4a3d56] flex items-center gap-1"
                                        title="Listen to pronunciation"
                                    >
                                        üîä Listen
                                    </button>
                                    */}
                                    <button 
                                        onClick={copyTranscriptionToClipboard}
                                        className="px-3 py-1 bg-stone text-white text-sm rounded hover:bg-stone-dark flex items-center gap-1"
                                        title="Copy transcription to clipboard"
                                    >
                                        üìã Copy
                                    </button>
                                    <button 
                                        onClick={exportTranscription}
                                        className="px-3 py-1 bg-patina text-white text-sm rounded hover:bg-[#5d7a6d] flex items-center gap-1"
                                        title="Download transcription as text file"
                                    >
                                        üíæ Export TXT
                                    </button>
                                    <button 
                                        onClick={() => setShowTranscription(false)}
                                        className="px-3 py-1 bg-rust text-white text-sm rounded hover:bg-[#8d5d47] font-bold"
                                        title="Close transcription box"
                                    >
                                        ‚úï
                                    </button>
                                </div>
                            </div>
                            <div className="p-4 bg-white rounded border-2 border-stone shadow-inner">
                                <div 
                                    className="font-mono text-lg leading-relaxed"
                                    style={{
                                        fontFamily: showArabicLabels 
                                            ? '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' 
                                            : '"Courier New", monospace'
                                    }}
                                >
                                    {getReadingOrderedResults().map((result, index) => (
                                        <span key={index}>
                                            <span className="text-gray-900">
                                                {showArabicLabels 
                                                    ? (result.glyph.arabic || result.glyph.name)
                                                    : (result.glyph.transliteration || result.glyph.name)
                                                }
                                            </span>
                                            {lineBreaks.has(index) && <span className="text-ancient-purple font-bold mx-2">---</span>}
                                            {!lineBreaks.has(index) && columnBreaks.has(index) && <span className="text-stone-dark font-bold mx-1">||</span>}
                                            {!lineBreaks.has(index) && !columnBreaks.has(index) && wordBoundaries.has(index) && <span className="text-stone-dark font-bold mx-1">|</span>}
                                            {!lineBreaks.has(index) && !columnBreaks.has(index) && !wordBoundaries.has(index) && index < getReadingOrderedResults().length - 1 && <span className="text-gray-400">¬∑</span>}
                                        </span>
                                    ))}
                                </div>
                            </div>

                            <div className="mt-3 text-xs text-gray-600">
                                <span className="text-ancient-purple font-bold">---</span> = line break &middot; 
                                <span className="text-stone-dark font-bold">||</span> = column break &middot; 
                                <span className="text-stone-dark font-bold">|</span> = word boundary &middot; 
                                <span className="text-gray-400">&middot;</span> = glyph separator
                            </div>
                        </div>
                    )}

                    {/* Enhanced Transcription Display */}
                    {viewMode === 'reading' && recognitionResults.length > 0 && (
                        <div className="mt-6 p-4 bg-[#f3f1f4] rounded-lg border-2 border-ancient-purple">
                            <button
                                onClick={() => setShowEnhancedTranscription(!showEnhancedTranscription)}
                                className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700 mb-3"
                            >
                                <span>{showEnhancedTranscription ? '‚ñº' : '‚ñ∂'}</span>
                                <h3>üìú Enhanced Transcription Display</h3>
                            </button>
                            
                            {showEnhancedTranscription && (
                                <>
                                    <DismissableTip id="breaks-howto" className="mb-4">
                                        <div className="font-semibold mb-1">üí° How to use breaks:</div>
                                        <div className="text-xs">
                                            Use the break buttons on each glyph card (in reading mode) to mark the layout:
                                            <span className="ml-2 text-stone-dark font-bold">|</span> Word boundary
                                            <span className="ml-2 text-stone-dark font-bold">||</span> End of column
                                            <span className="ml-2 text-ancient-purple font-bold">---</span> End of line
                                            <br/>
                                            The <span className="inline-block w-4 h-4 rounded-full bg-ochre border border-[#8d7350] text-xs text-center text-white">N</span> numbers show reading order.
                                        </div>
                                    </DismissableTip>
                                    <div className="mb-4 p-4 bg-white rounded-lg border border-[#c9bfd4]">
                                        <div className="grid grid-cols-2 gap-4">
                                            {/* Script Selection */}
                                            <div>
                                                <label className="block text-sm font-semibold text-gray-700 mb-2">Script:</label>
                                                <div className="flex gap-2">
                                                    <button
                                                        onClick={() => setTranscriptionScript('english')}
                                                        className={`px-4 py-2 rounded text-sm font-medium ${
                                                            transcriptionScript === 'english' 
                                                                ? 'bg-ancient-purple text-white' 
                                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                        }`}
                                                    >
                                                        English (abc)
                                                    </button>
                                                    <button
                                                        onClick={() => setTranscriptionScript('arabic')}
                                                        className={`px-4 py-2 rounded text-sm font-medium ${
                                                            transcriptionScript === 'arabic' 
                                                                ? 'bg-ancient-purple text-white' 
                                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                        }`}
                                                    >
                                                        Arabic (ÿπ ÿ® ÿ™)
                                                    </button>
                                                </div>
                                            </div>

                                            {/* Format Selection */}
                                            <div>
                                                <label className="block text-sm font-semibold text-gray-700 mb-2">Direction:</label>
                                                <select
                                                    value={transcriptionFormat}
                                                    onChange={(e) => setTranscriptionFormat(e.target.value)}
                                                    className="w-full px-3 py-2 border border-gray-300 rounded text-sm"
                                                >
                                                    <option value="english-ltr">‚Üí Left to Right</option>
                                                    <option value="arabic-rtl">‚Üê Right to Left</option>
                                                    <option value="vertical-rl">‚Üì Top to Bottom (columns ‚Üí)</option>
                                                    <option value="vertical-lr">‚Üì Top to Bottom (columns ‚Üê)</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Transcription Display */}
                                    <div className="p-6 bg-white rounded-lg border-2 border-ancient-purple shadow-inner">
                                        {transcriptionFormat.startsWith('vertical') ? (
                                            // Vertical display - each line becomes a row of columns
                                            <div className="flex flex-col gap-8">
                                                {getEnhancedTranscription().map((line, lineIndex) => (
                                                    <div 
                                                        key={lineIndex} 
                                                        className={`flex gap-8 justify-center ${transcriptionFormat === 'vertical-rl' ? 'flex-row-reverse' : ''}`}
                                                    >
                                                        {line.map((columnText, colIndex) => (
                                                            <div 
                                                                key={colIndex}
                                                                className="font-mono leading-relaxed"
                                                                style={{
                                                                    writingMode: transcriptionFormat === 'vertical-rl' ? 'vertical-rl' : 'vertical-lr',
                                                                    textOrientation: 'upright',
                                                                    minHeight: '200px',
                                                                    fontSize: transcriptionScript === 'arabic' ? '2rem' : '1.5rem',
                                                                    fontFamily: transcriptionScript === 'arabic' 
                                                                        ? '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' 
                                                                        : '"Courier New", monospace'
                                                                }}
                                                            >
                                                                {columnText}
                                                            </div>
                                                        ))}
                                                    </div>
                                                ))}
                                            </div>
                                        ) : (
                                            // Horizontal display (LTR or RTL) - show lines stacked vertically
                                            <div className="flex flex-col gap-4">
                                                {getEnhancedTranscription().map((line, lineIndex) => (
                                                    <div 
                                                        key={lineIndex}
                                                        className="flex gap-6"
                                                        style={{
                                                            direction: transcriptionFormat === 'arabic-rtl' ? 'rtl' : 'ltr',
                                                            justifyContent: transcriptionFormat === 'arabic-rtl' ? 'flex-end' : 'flex-start'
                                                        }}
                                                    >
                                                        {line.map((columnText, colIndex) => (
                                                            <div 
                                                                key={colIndex}
                                                                className="font-mono leading-relaxed"
                                                                style={{
                                                                    fontSize: transcriptionScript === 'arabic' ? '2rem' : '1.5rem',
                                                                    fontFamily: transcriptionScript === 'arabic' 
                                                                        ? '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' 
                                                                        : '"Courier New", monospace'
                                                                }}
                                                            >
                                                                {columnText}
                                                            </div>
                                                        ))}
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </div>

                                    <div className="mt-3 flex gap-2 justify-end">
                                        <button
                                            onClick={() => {
                                                const layoutStructure = getEnhancedTranscription();
                                                let text = '';
                                                
                                                if (transcriptionFormat === 'english-ltr') {
                                                    // LTR: Simple left-to-right with spaces
                                                    text = layoutStructure.map(line => 
                                                        line.join(' ')  // Columns as continuous text
                                                    ).join(' ');  // Lines as continuous text
                                                } else if (transcriptionFormat === 'arabic-rtl') {
                                                    // RTL: Right-to-left with spaces (text editors will handle RTL)
                                                    text = layoutStructure.map(line => 
                                                        line.join(' ')
                                                    ).join(' ');
                                                } else if (transcriptionFormat === 'vertical-rl') {
                                                    // Vertical RL: Show columns right-to-left, separated by ||
                                                    text = layoutStructure.map(line => 
                                                        line.reverse().join(' || ')  // Reverse for right-to-left reading
                                                    ).join('\n---\n');
                                                } else if (transcriptionFormat === 'vertical-lr') {
                                                    // Vertical LR: Show columns left-to-right, separated by ||
                                                    text = layoutStructure.map(line => 
                                                        line.join(' || ')
                                                    ).join('\n---\n');
                                                }
                                                
                                                navigator.clipboard.writeText(text);
                                                alert('Transcription copied to clipboard!');
                                            }}
                                            className="px-4 py-2 bg-stone text-white text-sm rounded hover:bg-stone-dark"
                                        >
                                            üìã Copy Text
                                        </button>
                                        <button
                                            onClick={() => {
                                                const layoutStructure = getEnhancedTranscription();
                                                let text = '';
                                                
                                                if (transcriptionFormat === 'english-ltr') {
                                                    // LTR: Simple left-to-right with spaces
                                                    text = layoutStructure.map(line => 
                                                        line.join(' ')
                                                    ).join(' ');
                                                } else if (transcriptionFormat === 'arabic-rtl') {
                                                    // RTL: Right-to-left with spaces
                                                    text = layoutStructure.map(line => 
                                                        line.join(' ')
                                                    ).join(' ');
                                                } else if (transcriptionFormat === 'vertical-rl') {
                                                    // Vertical RL: Show columns right-to-left, separated by ||
                                                    text = layoutStructure.map(line => 
                                                        line.reverse().join(' || ')
                                                    ).join('\n---\n');
                                                } else if (transcriptionFormat === 'vertical-lr') {
                                                    // Vertical LR: Show columns left-to-right, separated by ||
                                                    text = layoutStructure.map(line => 
                                                        line.join(' || ')
                                                    ).join('\n---\n');
                                                }
                                                
                                                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                                                const url = URL.createObjectURL(blob);
                                                const a = document.createElement('a');
                                                a.href = url;
                                                a.download = `hakli_transcription_${transcriptionScript}_${transcriptionFormat}_${new Date().toISOString().slice(0, 10)}.txt`;
                                                document.body.appendChild(a);
                                                a.click();
                                                document.body.removeChild(a);
                                                URL.revokeObjectURL(url);
                                            }}
                                            className="px-4 py-2 bg-patina text-white text-sm rounded hover:bg-[#5d7a6d]"
                                        >
                                            üíæ Export TXT
                                        </button>
                                    </div>
                                </>
                            )}
                        </div>
                    )}

                    {/* Translation Section */}
                    {viewMode === 'reading' && recognitionResults.length > 0 && (
                        <div className="mt-6 p-4 bg-[#f0f5f3] rounded-lg border-2 border-patina">
                            <button
                                onClick={() => setShowTranslationSection(!showTranslationSection)}
                                className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700 mb-3"
                            >
                                <span>{showTranslationSection ? '‚ñº' : '‚ñ∂'}</span>
                                <h3>üåç Translation</h3>
                            </button>
                            
                            {showTranslationSection && (
                                <>
                                    {!dismissedTips['translation-section'] && (
                                        <DismissableTip id="translation-section" className="mb-4">
                                            <strong>üí° Add your translation:</strong> Enter translations in English and/or Arabic. Toggle between languages below. Both will appear in the exported HTML report.
                                        </DismissableTip>
                                    )}

                                    <div className="space-y-4">
                                        {/* Inscription Title Field */}
                                        <div className="mb-4 pb-4 border-b border-[#b5d4c8]">
                                            <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                üè∑Ô∏è Inscription Title (optional):
                                            </label>
                                            <input
                                                type="text"
                                                value={inscriptionTitle}
                                                onChange={(e) => setInscriptionTitle(e.target.value)}
                                                className="w-full px-3 py-2 border border-gray-300 rounded text-sm"
                                                placeholder="e.g., Salalah Temple Inscription, Site A Fragment 3..."
                                            />
                                            <p className="text-xs text-gray-500 mt-1">This title will be used in the filename and Drive listing</p>
                                        </div>

                                        {/* Language Toggle */}
                                        <div className="flex gap-2">
                                            <button
                                                onClick={() => setTranscriptionScript('english')}
                                                className={`px-4 py-2 rounded text-sm font-medium ${
                                                    transcriptionScript === 'english' 
                                                        ? 'bg-patina text-white' 
                                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                }`}
                                            >
                                                English Translation
                                            </button>
                                            <button
                                                onClick={() => setTranscriptionScript('arabic')}
                                                className={`px-4 py-2 rounded text-sm font-medium ${
                                                    transcriptionScript === 'arabic' 
                                                        ? 'bg-patina text-white' 
                                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                }`}
                                            >
                                                Arabic Translation (ÿ™ÿ±ÿ¨ŸÖÿ©)
                                            </button>
                                        </div>

                                        {/* Translation Input */}
                                        {transcriptionScript === 'english' ? (
                                            <div>
                                                <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                    English Translation:
                                                </label>
                                                <textarea
                                                    value={translationEnglish}
                                                    onChange={(e) => setTranslationEnglish(e.target.value)}
                                                    className="w-full px-3 py-2 border border-gray-300 rounded text-sm"
                                                    rows="4"
                                                    placeholder="Enter English translation here..."
                                                />
                                            </div>
                                        ) : (
                                            <div>
                                                <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                    Arabic Translation (ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ©):
                                                </label>
                                                <textarea
                                                    value={translationArabic}
                                                    onChange={(e) => setTranslationArabic(e.target.value)}
                                                    className="w-full px-3 py-2 border border-gray-300 rounded text-lg"
                                                    style={{
                                                        direction: 'rtl',
                                                        fontFamily: '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif'
                                                    }}
                                                    rows="4"
                                                    placeholder="ÿ£ÿØÿÆŸÑ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ŸáŸÜÿß..."
                                                />
                                            </div>
                                        )}

                                        {/* Notes Field */}
                                        <div className="mt-4 pt-4 border-t border-[#b5d4c8]">
                                            <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                üìù Inscription Notes:
                                            </label>
                                            <textarea
                                                value={inscriptionNotes}
                                                onChange={(e) => setInscriptionNotes(e.target.value)}
                                                className="w-full px-3 py-2 border border-gray-300 rounded text-sm"
                                                rows="3"
                                                placeholder="Add any notes, observations, or context about this inscription..."
                                            />
                                        </div>

                                        {/* Preview */}
                                        {(translationEnglish || translationArabic) && (
                                            <div className="p-4 bg-white rounded border-2 border-patina">
                                                <div className="text-sm font-semibold text-gray-700 mb-2">Preview:</div>
                                                {translationEnglish && (
                                                    <div className="mb-2">
                                                        <span className="text-xs text-gray-500">English:</span>
                                                        <div className="text-base">{translationEnglish}</div>
                                                    </div>
                                                )}
                                                {translationArabic && (
                                                    <div>
                                                        <span className="text-xs text-gray-500">Arabic:</span>
                                                        <div 
                                                            className="text-lg" 
                                                            style={{
                                                                direction: 'rtl',
                                                                fontFamily: '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif'
                                                            }}
                                                        >
                                                            {translationArabic}
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                </>
                            )}
                        </div>
                    )}

                    <div className="mt-8 p-4 bg-gray-50 rounded-lg">
                        <div className="text-sm text-gray-600">
                            <div className="flex items-center gap-2">
                                <span className={`w-2 h-2 rounded-full ${isOpenCvReady ? 'bg-patina' : 'bg-rust'}`} />
                                OpenCV Status: {isOpenCvReady ? 'Ready' : 'Loading...'}
                                {actionHistory.length > 0 && <span className="ml-4 text-xs text-gray-500">{actionHistory.length} actions recorded</span>}
                            </div>
                        </div>
                    </div>

                    {/* Cloud Storage & Sharing - Always visible */}
                    <div className="mt-6 p-4 bg-[#f7f3ed] rounded-lg border-2 border-ochre">
                        <button
                            onClick={() => setIsCorrectionMemoryCollapsed(!isCorrectionMemoryCollapsed)}
                            className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700 mb-3"
                        >
                                <span>{isCorrectionMemoryCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                <h3>‚òÅÔ∏è Cloud Storage & Sharing</h3>
                            </button>
                            
                            {!isCorrectionMemoryCollapsed && (
                            <>
                            {/* YOUR INSCRIPTIONS (Private Work) - Section 1 */}
                            <div className="mb-4">
                                <h4 className="text-xs font-semibold text-gray-600 uppercase mb-2">Your Inscriptions (Private Work)</h4>
                                <div className="flex flex-wrap gap-3">
                                    <button 
                                        onClick={saveToGoogleDrive}
                                        className="px-4 py-2 bg-stone-dark text-white rounded hover:bg-stone flex items-center gap-2 font-semibold"
                                        title="Save your work-in-progress (auto-backup, only you can access)"
                                    >
                                        üíæ Save to Drive
                                    </button>
                                    <button
                                        onClick={async () => {
                                            if (typeof DriveSync === 'undefined' || !DriveSync.isSignedIn()) {
                                                alert('‚ö†Ô∏è Please sign in to Google Drive first.\n\nClick "üîÑ Change Account" to sign in with your Google account.');
                                                return;
                                            }
                                            
                                            try {
                                                const files = await DriveSync.listFiles();
                                                console.log('Drive files:', files);
                                                
                                                if (files.length === 0) {
                                                    alert('üìÇ No HKI files found in your Hakli_Inscriptions folder.\n\nSave an inscription first using "üíæ Save to Drive" above.');
                                                    return;
                                                }
                                                
                                                // Load all file thumbnails
                                                setShowFilePickerModal({ files, isLoading: true });
                                                
                                                const filesWithThumbnails = await Promise.all(
                                                    files.map(async (file) => {
                                                        try {
                                                            const hkiData = await DriveSync.loadFromCloud(file.id);
                                                            console.log('üì∏ Thumbnail debug for', file.name, ':', {
                                                                hasImage: !!hkiData.image,
                                                                imageLength: hkiData.image ? hkiData.image.length : 0,
                                                                imageStart: hkiData.image ? hkiData.image.substring(0, 50) : null,
                                                                hasLocation: !!hkiData.location
                                                            });
                                                            return {
                                                                ...file,
                                                                thumbnail: hkiData.image || null,
                                                                title: hkiData.inscriptionTitle || file.name,
                                                                location: hkiData.location || null
                                                            };
                                                        } catch (err) {
                                                            console.error(`Failed to load thumbnail for ${file.name}:`, err);
                                                            return { ...file, thumbnail: null, title: file.name, location: null };
                                                        }
                                                    })
                                                );
                                                
                                                setShowFilePickerModal({ files: filesWithThumbnails, isLoading: false });
                                            } catch (err) {
                                                console.error('Load error:', err);
                                                alert('‚ùå Load failed: ' + err.message);
                                            }
                                        }}
                                        className="px-4 py-2 bg-stone text-white rounded hover:bg-stone-dark flex items-center gap-2"
                                        title="Load saved inscriptions to resume editing"
                                    >
                                        üìÇ Load from Drive
                                    </button>
                                    <button
                                        onClick={() => {
                                            // Export full HKI file for sharing with collaborators
                                            const hkiData = {
                                                version: '1.0',
                                                created: new Date().toISOString(),
                                                source: 'Hakli Glyph Recognizer v251217',
                                                inscriptionTitle: inscriptionTitle || 'Untitled Inscription',
                                                inscriptionNotes: inscriptionNotes || '',
                                                image: image,
                                                preprocessing: preprocessing,
                                                recognitionResults: recognitionResults,
                                                readingOrder: readingOrder,
                                                readingDirection: readingDirection,
                                                wordBoundaries: Array.from(wordBoundaries),
                                                columnBreaks: Array.from(columnBreaks),
                                                lineBreaks: Array.from(lineBreaks),
                                                validations: validations,
                                                translationEnglish: translationEnglish,
                                                translationArabic: translationArabic
                                            };
                                            
                                            const blob = new Blob([JSON.stringify(hkiData, null, 2)], { type: 'application/json' });
                                            const url = URL.createObjectURL(blob);
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.download = `hakli_export_${new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5)}.hki.json`;
                                            document.body.appendChild(a);
                                            a.click();
                                            document.body.removeChild(a);
                                            URL.revokeObjectURL(url);
                                            
                                            alert('üì• Full HKI file downloaded!\n\n‚ö†Ô∏è This file contains the complete inscription including the photo.\nShare only with trusted collaborators.');
                                        }}
                                        className="px-4 py-2 bg-ancient-purple text-white rounded hover:bg-[#4a3d56] flex items-center gap-2"
                                        title="Download complete file to share with trusted collaborators"
                                    >
                                        üì• Export Full HKI
                                    </button>
                                    <button
                                        onClick={async () => {
                                            if (typeof DriveSync === 'undefined') {
                                                alert('‚ùå DriveSync module not loaded');
                                                return;
                                            }
                                            
                                            // If signed in, sign out
                                            if (DriveSync.isSignedIn()) {
                                                try {
                                                    await DriveSync.signOut();
                                                    setDriveAuthStatus(prev => prev + 1); // Force re-render
                                                    alert('‚úÖ Signed out from Google Drive.\n\nClick "üîÑ Change Account" again to sign in with a different Google account.');
                                                } catch (err) {
                                                    console.error('Sign-out error:', err);
                                                    alert('‚ùå Sign-out failed: ' + err.message);
                                                }
                                            } else {
                                                // If signed out, open the Cloud Sync modal to sign in
                                                setShowCloudSyncModal(true);
                                            }
                                        }}
                                        className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 flex items-center gap-2"
                                        title={DriveSync && DriveSync.isSignedIn() ? "Sign out and switch to a different Google account" : "Sign in to Google Drive"}
                                    >
                                        üîÑ Change Account
                                    </button>
                                </div>
                            </div>

                            {/* GLYPH CORRECTIONS (Public-Safe Templates) - Section 2 */}
                            <div className="mb-4">
                                <h4 className="text-xs font-semibold text-gray-600 uppercase mb-2">Glyph Corrections (Public-Safe Templates)</h4>
                                <div className="flex flex-wrap gap-3 items-center">
                                    <input
                                        type="file"
                                        accept=".json"
                                        onChange={(e) => {
                                            const file = e.target.files[0];
                                            if (file) {
                                                    const reader = new FileReader();
                                                    reader.onload = (event) => importCorrectionMemory(event.target.result);
                                                    reader.readAsText(file);
                                                }
                                            }}
                                            id="import-corrections"
                                             className="block text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-yellow-100 file:text-yellow-700 hover:file:bg-yellow-200"
                                     />
                                        <button
                                            onClick={() => setShowCommunityModal(true)}
                                            className="px-4 py-2 bg-patina text-white rounded hover:bg-[#5d7a6d] flex items-center gap-2"
                                            title="Download community template improvements"
                                            >
                                            ‚¨áÔ∏è Import from Community
                                        </button>
                                        <button
                                            onClick={() => {
                                                if (confirm('Clear ALL glyph corrections permanently? This cannot be undone. Consider exporting first.')) {
                                                    localStorage.removeItem('hakliCorrections');
                                                    alert('‚úÖ All glyph corrections cleared!');
                                                }
                                            }}
                                            className="px-4 py-2 bg-rust text-white rounded hover:bg-[#8d5d47]"
                                            title="Clear all correction data"
                                        >
                                            üóëÔ∏è Clear All
                                        </button>
                                        <button
                                            onClick={exportCorrectionMemory}
                                            className="px-4 py-2 bg-ochre text-white rounded hover:bg-[#a18259] flex items-center gap-2"
                                            title="Share your template improvements (no photos/locations)"
                                        >
                                            ‚¨ÜÔ∏è Share Corrections Only
                                        </button>
                                        <button
                                            onClick={() => setShowCorrectionAnalysis(true)}
                                            className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 flex items-center gap-2"
                                            title="View statistics on your correction patterns"
                                        >
                                            üìä View Stats
                                        </button>
                                </div>
                            </div>

                            <DismissableTip id="cloud-storage-tip">
                                <strong>üí° Three ways to share:</strong>
                                <ul className="mt-2 space-y-1 text-sm">
                                    <li><strong>üíæ Save to Drive</strong> - Your personal backup (only you can access)</li>
                                    <li><strong>üì• Export Full HKI</strong> - Share complete inscription with trusted collaborators (includes photos - use carefully!)</li>
                                    <li><strong>‚¨ÜÔ∏è Share Corrections Only</strong> - Contribute template improvements to community (public-safe: no photos, no locations)</li>
                                </ul>
                            </DismissableTip>
                            </>
                            )}
                    </div>
                    
                    {/* Export Options - Always visible */}
                    <div className="mt-6 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                        <button
                            onClick={() => setIsExportOptionsCollapsed(!isExportOptionsCollapsed)}
                            className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700 mb-3"
                        >
                                <span>{isExportOptionsCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                <h3>Export Options</h3>
                            </button>
                            
                            {!isExportOptionsCollapsed && (
                            <>
                            {/* ESSENTIAL EXPORTS - Row 1 */}
                            <div className="mb-4">
                                <h4 className="text-xs font-semibold text-gray-600 uppercase mb-2">Reports & Documents</h4>
                                <div className="flex flex-wrap gap-3">
                                    <button
                                        onClick={exportHtmlReport}
                                        className="px-4 py-2 bg-emerald-500 text-white rounded hover:bg-emerald-600 flex items-center gap-2"
                                        title="Generate beautiful bilingual report"
                                    >
                                        üìÑ Export HTML Report
                                    </button>
                                </div>
                            </div>

                            {/* TEXT & IMAGES - Row 2 */}
                            <div className="mb-4">
                                <h4 className="text-xs font-semibold text-gray-600 uppercase mb-2">Text & Images</h4>
                                <div className="flex flex-wrap gap-3">
                                    {viewMode === 'reading' && (
                                        <button 
                                            onClick={exportTranscription}
                                            className="px-4 py-2 bg-patina text-white rounded hover:bg-[#5d7a6d] flex items-center gap-2"
                                            title="Export transcription as plain text file"
                                        >
                                            üìã Export Transcription (TXT)
                                        </button>
                                    )}
                                    <button 
                                        onClick={exportAnnotatedImage}
                                        className="px-4 py-2 bg-stone text-white rounded hover:bg-stone-dark flex items-center gap-2"
                                        title="Export image with glyph boxes and labels"
                                    >
                                        üñºÔ∏è Export Annotated Image
                                    </button>
                                </div>
                            </div>

                            {/* COMMUNITY SHARING - Row 3 */}
                            <div className="mb-4">
                                <h4 className="text-xs font-semibold text-gray-600 uppercase mb-2">Advanced</h4>
                                <div className="flex flex-wrap gap-3">
                                    <button
                                        onClick={openJsonViewer}
                                        className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 flex items-center gap-2"
                                        title="View current inscription data (HKI format)"
                                    >
                                        üîç View HKI Data
                                    </button>
                                </div>
                            </div>

                            <DismissableTip id="export-options-tip" className="mt-3">
                                <strong>üí° Tip:</strong> For saving your work and sharing inscriptions, see <strong>‚òÅÔ∏è Cloud Storage & Sharing</strong> section above.
                            </DismissableTip>
                            </>
                            )}
                    </div>
                    
                    {showChartViewer && equivalenceChart && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setShowChartViewer(false)}>
                            <div className="bg-white rounded-lg max-w-7xl w-full max-h-[90vh] flex flex-col shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                {/* Sticky Header - Outside scrollable area */}
                                <div className="flex items-center justify-between p-6 pb-4 border-b border-gray-200 flex-shrink-0">
                                    <h3 className="text-2xl font-bold text-gray-900">üìä Glyph Equivalence Chart</h3>
                                    <div className="flex items-center gap-3">
                                        <button
                                            onClick={() => setShowGlyphEditor({ mode: 'add' })}
                                            className="px-4 py-2 bg-emerald-500 text-white rounded hover:bg-emerald-600 flex items-center gap-2"
                                            title="Add a new glyph to the database"
                                        >
                                            ‚ûï Add New Glyph
                                        </button>
                                        <button
                                            onClick={() => setShowChartViewer(false)}
                                            className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                        >
                                            &times;
                                        </button>
                                    </div>
                                </div>

                                {/* Scrollable Content */}
                                <div className="overflow-y-auto p-6 pt-4 flex-1">

                                <div className="mb-4 p-3 bg-[#f5f3f0] rounded-lg">
                                    <div className="text-sm text-gray-700">
                                        <strong>{equivalenceChart.glyphs.length}</strong> glyphs loaded with <strong>{Object.keys(loadedGlyphImages).length}</strong> total images
                                    </div>
                                </div>

                                <div className="space-y-6">
                                    {equivalenceChart.glyphs.map((glyph) => {
                                        const primaryLoaded = loadedGlyphImages[glyph.id]; // Primary uses just the glyph.id
                                        const variantCount = glyph.images.variants?.length || 0;
                                        const exampleCount = glyph.images.examples?.length || 0;
                                        const variantsLoaded = glyph.images.variants?.filter((_, idx) => 
                                            loadedGlyphImages[`${glyph.id}_variant_${idx}`]
                                        ).length || 0;
                                        const examplesLoaded = glyph.images.examples?.filter((_, idx) => 
                                            loadedGlyphImages[`${glyph.id}_example_${idx}`]
                                        ).length || 0;
                                        
                                        return (
                                            <div key={glyph.id} className="border-2 border-gray-200 rounded-lg p-4 hover:border-ancient-purple transition-colors">
                                                <div className="flex items-start gap-4">
                                                    {/* Glyph Info */}
                                                    <div className="flex-shrink-0 text-center">
                                                        <div className="text-4xl font-bold text-ancient-purple mb-1">
                                                            {glyph.arabic || '?'}
                                                        </div>
                                                        <div className="text-sm font-mono text-gray-600">
                                                            {glyph.name}
                                                        </div>
                                                        <div className="text-xs text-gray-500 mt-1">
                                                            ID: {glyph.id}
                                                        </div>
                                                        {/* Edit/Delete Buttons */}
                                                        <div className="flex gap-1 mt-3">
                                                            <button
                                                                onClick={() => setShowGlyphEditor({ mode: 'edit', glyph })}
                                                                className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200"
                                                                title="Edit glyph metadata"
                                                            >
                                                                ‚úèÔ∏è
                                                            </button>
                                                            <button
                                                                onClick={() => {
                                                                    if (confirm(`Delete "${glyph.name}"?`)) {
                                                                        const updated = { ...equivalenceChart };
                                                                        updated.glyphs = updated.glyphs.filter(g => g.id !== glyph.id);
                                                                        setEquivalenceChart(updated);
                                                                        alert(`üóëÔ∏è Deleted "${glyph.name}"`);
                                                                    }
                                                                }}
                                                                className="px-2 py-1 text-xs bg-red-100 text-red-700 rounded hover:bg-red-200"
                                                                title="Delete glyph"
                                                            >
                                                                üóëÔ∏è
                                                            </button>
                                                        </div>
                                                    </div>

                                                    {/* Images Grid */}
                                                    <div className="flex-1">
                                                        {/* Primary Image */}
                                                        <div className="mb-3">
                                                            <div className="flex items-center gap-2 mb-2">
                                                                <h4 className="text-sm font-semibold text-gray-700">Primary</h4>
                                                                {primaryLoaded ? (
                                                                    <span className="text-xs text-patina">‚úÖ Loaded</span>
                                                                ) : (
                                                                    <span className="text-xs text-rust">‚ùå Not loaded</span>
                                                                )}
                                                                {/* Replace Primary Button */}
                                                                <label 
                                                                    htmlFor={`replace-primary-${glyph.id}`}
                                                                    className="ml-auto px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 cursor-pointer"
                                                                    title="Replace primary template"
                                                                >
                                                                    üîÑ Replace
                                                                </label>
                                                                <input
                                                                    type="file"
                                                                    id={`replace-primary-${glyph.id}`}
                                                                    accept="image/*"
                                                                    className="hidden"
                                                                    onChange={(e) => {
                                                                        const file = e.target.files[0];
                                                                        if (file) {
                                                                            const reader = new FileReader();
                                                                            reader.onload = (ev) => {
                                                                                const dataUrl = ev.target.result;
                                                                                const updated = { ...equivalenceChart };
                                                                                const glyphIndex = updated.glyphs.findIndex(g => g.id === glyph.id);
                                                                                if (glyphIndex >= 0) {
                                                                                    updated.glyphs[glyphIndex].images.primary = dataUrl;
                                                                                    setEquivalenceChart(updated);
                                                                                    
                                                                                    // Update caches
                                                                                    const img = new Image();
                                                                                    img.onload = () => {
                                                                                        setLoadedGlyphImages(prev => ({...prev, [glyph.id]: img}));
                                                                                        setGlyphThumbnails(prev => ({...prev, [glyph.id]: img.src}));
                                                                                    };
                                                                                    img.src = dataUrl;
                                                                                    
                                                                                    alert(`‚úÖ Replaced primary template for "${glyph.name}"`);
                                                                                }
                                                                            };
                                                                            reader.readAsDataURL(file);
                                                                        }
                                                                    }}
                                                                />
                                                            </div>
                                                            <div className="flex flex-wrap gap-2">
                                                                {primaryLoaded ? (
                                                                    <div className="relative group">
                                                                        <img 
                                                                            src={primaryLoaded.src} 
                                                                            alt={`Primary: ${glyph.name}`}
                                                                            className="h-16 border-2 border-gray-300 rounded hover:border-ancient-purple transition-colors bg-white p-1"
                                                                        />
                                                                        <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-10 transition-opacity rounded"></div>
                                                                    </div>
                                                                ) : (
                                                                    <div className="h-16 w-16 border-2 border-dashed border-gray-300 rounded flex items-center justify-center text-gray-400 text-xs">
                                                                        No image
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>

                                                        {/* Variants */}
                                                        <div className="mb-3">
                                                            <div className="flex items-center gap-2 mb-2">
                                                                <h4 className="text-sm font-semibold text-gray-700">
                                                                    Variants ({variantCount})
                                                                </h4>
                                                                {variantsLoaded === variantCount && variantCount > 0 ? (
                                                                    <span className="text-xs text-patina">‚úÖ All loaded</span>
                                                                ) : variantCount > 0 ? (
                                                                    <span className="text-xs text-orange-600">‚ö†Ô∏è {variantCount - variantsLoaded} missing</span>
                                                                ) : null}
                                                                {/* Add Variant Button */}
                                                                <label 
                                                                    htmlFor={`add-variant-${glyph.id}`}
                                                                    className="ml-auto px-2 py-1 text-xs bg-green-100 text-green-700 rounded hover:bg-green-200 cursor-pointer"
                                                                    title="Add a variant template"
                                                                >
                                                                    ‚ûï Add Variant
                                                                </label>
                                                                <input
                                                                    type="file"
                                                                    id={`add-variant-${glyph.id}`}
                                                                    accept="image/*"
                                                                    className="hidden"
                                                                    onChange={(e) => {
                                                                        const file = e.target.files[0];
                                                                        if (file) {
                                                                            const reader = new FileReader();
                                                                            reader.onload = (ev) => {
                                                                                const dataUrl = ev.target.result;
                                                                                const updated = { ...equivalenceChart };
                                                                                const glyphIndex = updated.glyphs.findIndex(g => g.id === glyph.id);
                                                                                if (glyphIndex >= 0) {
                                                                                    if (!updated.glyphs[glyphIndex].images.variants) {
                                                                                        updated.glyphs[glyphIndex].images.variants = [];
                                                                                    }
                                                                                    updated.glyphs[glyphIndex].images.variants.push(dataUrl);
                                                                                    const newIdx = updated.glyphs[glyphIndex].images.variants.length - 1;
                                                                                    setEquivalenceChart(updated);
                                                                                    
                                                                                    // Update caches
                                                                                    const img = new Image();
                                                                                    img.onload = () => {
                                                                                        const key = `${glyph.id}_variant_${newIdx}`;
                                                                                        setLoadedGlyphImages(prev => ({...prev, [key]: img}));
                                                                                        setGlyphThumbnails(prev => ({...prev, [key]: img.src}));
                                                                                    };
                                                                                    img.src = dataUrl;
                                                                                    
                                                                                    alert(`‚úÖ Added variant to "${glyph.name}"`);
                                                                                }
                                                                            };
                                                                            reader.readAsDataURL(file);
                                                                        }
                                                                        e.target.value = ''; // Reset input
                                                                    }}
                                                                />
                                                            </div>
                                                            {variantCount > 0 && (
                                                                <div className="flex flex-wrap gap-2">
                                                                    {glyph.images.variants.map((_, idx) => {
                                                                        const variantImg = loadedGlyphImages[`${glyph.id}_variant_${idx}`];
                                                                        return (
                                                                            <div key={idx} className="relative group">
                                                                                {variantImg ? (
                                                                                    <>
                                                                                        <img 
                                                                                            src={variantImg.src} 
                                                                                            alt={`Variant ${idx + 1}: ${glyph.name}`}
                                                                                            className="h-16 border-2 border-gray-300 rounded hover:border-ancient-purple transition-colors bg-white p-1"
                                                                                        />
                                                                                        {/* Action buttons on hover */}
                                                                                        <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-50 transition-opacity rounded flex items-center justify-center gap-1 opacity-0 group-hover:opacity-100">
                                                                                            <button
                                                                                                onClick={() => {
                                                                                                    if (confirm(`Set variant ${idx + 1} as primary template for "${glyph.name}"?`)) {
                                                                                                        const updated = { ...equivalenceChart };
                                                                                                        const glyphIndex = updated.glyphs.findIndex(g => g.id === glyph.id);
                                                                                                        if (glyphIndex >= 0) {
                                                                                                            // Swap: variant becomes primary, old primary becomes variant
                                                                                                            const oldPrimary = updated.glyphs[glyphIndex].images.primary;
                                                                                                            updated.glyphs[glyphIndex].images.primary = updated.glyphs[glyphIndex].images.variants[idx];
                                                                                                            updated.glyphs[glyphIndex].images.variants[idx] = oldPrimary;
                                                                                                            setEquivalenceChart(updated);
                                                                                                            
                                                                                                            // Update caches
                                                                                                            const primaryImg = new Image();
                                                                                                            primaryImg.onload = () => {
                                                                                                                setLoadedGlyphImages(prev => ({...prev, [glyph.id]: primaryImg}));
                                                                                                                setGlyphThumbnails(prev => ({...prev, [glyph.id]: primaryImg.src}));
                                                                                                            };
                                                                                                            primaryImg.src = updated.glyphs[glyphIndex].images.primary;
                                                                                                            
                                                                                                            const variantImg = new Image();
                                                                                                            variantImg.onload = () => {
                                                                                                                const key = `${glyph.id}_variant_${idx}`;
                                                                                                                setLoadedGlyphImages(prev => ({...prev, [key]: variantImg}));
                                                                                                                setGlyphThumbnails(prev => ({...prev, [key]: variantImg.src}));
                                                                                                            };
                                                                                                            variantImg.src = updated.glyphs[glyphIndex].images.variants[idx];
                                                                                                            
                                                                                                            alert(`‚≠ê Set as primary template`);
                                                                                                        }
                                                                                                    }
                                                                                                }}
                                                                                                className="px-1.5 py-0.5 bg-amber-500 text-white text-xs rounded hover:bg-amber-600"
                                                                                                title="Set as primary"
                                                                                            >
                                                                                                ‚≠ê
                                                                                            </button>
                                                                                            <button
                                                                                                onClick={() => {
                                                                                                    if (confirm(`Delete variant ${idx + 1}?`)) {
                                                                                                        const updated = { ...equivalenceChart };
                                                                                                        const glyphIndex = updated.glyphs.findIndex(g => g.id === glyph.id);
                                                                                                        if (glyphIndex >= 0) {
                                                                                                            updated.glyphs[glyphIndex].images.variants.splice(idx, 1);
                                                                                                            setEquivalenceChart(updated);
                                                                                                            
                                                                                                            // Remove from caches
                                                                                                            const key = `${glyph.id}_variant_${idx}`;
                                                                                                            setLoadedGlyphImages(prev => {
                                                                                                                const newCache = {...prev};
                                                                                                                delete newCache[key];
                                                                                                                return newCache;
                                                                                                            });
                                                                                                            setGlyphThumbnails(prev => {
                                                                                                                const newCache = {...prev};
                                                                                                                delete newCache[key];
                                                                                                                return newCache;
                                                                                                            });
                                                                                                            
                                                                                                            alert(`üóëÔ∏è Deleted variant`);
                                                                                                        }
                                                                                                    }
                                                                                                }}
                                                                                                className="px-1.5 py-0.5 bg-red-500 text-white text-xs rounded hover:bg-red-600"
                                                                                                title="Delete variant"
                                                                                            >
                                                                                                üóëÔ∏è
                                                                                            </button>
                                                                                        </div>
                                                                                    </>
                                                                                ) : (
                                                                                    <div className="h-16 w-16 border-2 border-dashed border-gray-300 rounded flex items-center justify-center text-gray-400 text-xs">
                                                                                        V{idx + 1}
                                                                                    </div>
                                                                                )}
                                                                            </div>
                                                                        );
                                                                    })}
                                                                </div>
                                                            )}
                                                        </div>

                                                        {/* Examples */}
                                                        <div>
                                                            <div className="flex items-center gap-2 mb-2">
                                                                <h4 className="text-sm font-semibold text-gray-700">
                                                                    Examples ({exampleCount})
                                                                </h4>
                                                                {examplesLoaded === exampleCount && exampleCount > 0 ? (
                                                                    <span className="text-xs text-patina">‚úÖ All loaded</span>
                                                                ) : exampleCount > 0 ? (
                                                                    <span className="text-xs text-orange-600">‚ö†Ô∏è {exampleCount - examplesLoaded} missing</span>
                                                                ) : null}
                                                                {/* Add Example Button */}
                                                                <label 
                                                                    htmlFor={`add-example-${glyph.id}`}
                                                                    className="ml-auto px-2 py-1 text-xs bg-purple-100 text-purple-700 rounded hover:bg-purple-200 cursor-pointer"
                                                                    title="Add an example from inscription"
                                                                >
                                                                    ‚ûï Add Example
                                                                </label>
                                                                <input
                                                                    type="file"
                                                                    id={`add-example-${glyph.id}`}
                                                                    accept="image/*"
                                                                    className="hidden"
                                                                    onChange={(e) => {
                                                                        const file = e.target.files[0];
                                                                        if (file) {
                                                                            const reader = new FileReader();
                                                                            reader.onload = (ev) => {
                                                                                const dataUrl = ev.target.result;
                                                                                const updated = { ...equivalenceChart };
                                                                                const glyphIndex = updated.glyphs.findIndex(g => g.id === glyph.id);
                                                                                if (glyphIndex >= 0) {
                                                                                    if (!updated.glyphs[glyphIndex].images.examples) {
                                                                                        updated.glyphs[glyphIndex].images.examples = [];
                                                                                    }
                                                                                    updated.glyphs[glyphIndex].images.examples.push(dataUrl);
                                                                                    const newIdx = updated.glyphs[glyphIndex].images.examples.length - 1;
                                                                                    setEquivalenceChart(updated);
                                                                                    
                                                                                    // Update caches
                                                                                    const img = new Image();
                                                                                    img.onload = () => {
                                                                                        const key = `${glyph.id}_example_${newIdx}`;
                                                                                        setLoadedGlyphImages(prev => ({...prev, [key]: img}));
                                                                                        setGlyphThumbnails(prev => ({...prev, [key]: img.src}));
                                                                                    };
                                                                                    img.src = dataUrl;
                                                                                    
                                                                                    alert(`‚úÖ Added example to "${glyph.name}"`);
                                                                                }
                                                                            };
                                                                            reader.readAsDataURL(file);
                                                                        }
                                                                        e.target.value = ''; // Reset input
                                                                    }}
                                                                />
                                                            </div>
                                                            {exampleCount > 0 && (
                                                                <div className="flex flex-wrap gap-2">
                                                                    {glyph.images.examples.map((_, idx) => {
                                                                        const exampleImg = loadedGlyphImages[`${glyph.id}_example_${idx}`];
                                                                        return (
                                                                            <div key={idx} className="relative group">
                                                                                {exampleImg ? (
                                                                                    <>
                                                                                        <img 
                                                                                            src={exampleImg.src} 
                                                                                            alt={`Example ${idx + 1}: ${glyph.name}`}
                                                                                            className="h-16 border-2 border-gray-300 rounded hover:border-ancient-purple transition-colors bg-white p-1"
                                                                                        />
                                                                                        {/* Delete button on hover */}
                                                                                        <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-50 transition-opacity rounded flex items-center justify-center opacity-0 group-hover:opacity-100">
                                                                                            <button
                                                                                                onClick={() => {
                                                                                                    if (confirm(`Delete example ${idx + 1}?`)) {
                                                                                                        const updated = { ...equivalenceChart };
                                                                                                        const glyphIndex = updated.glyphs.findIndex(g => g.id === glyph.id);
                                                                                                        if (glyphIndex >= 0) {
                                                                                                            updated.glyphs[glyphIndex].images.examples.splice(idx, 1);
                                                                                                            setEquivalenceChart(updated);
                                                                                                            
                                                                                                            // Remove from caches
                                                                                                            const key = `${glyph.id}_example_${idx}`;
                                                                                                            setLoadedGlyphImages(prev => {
                                                                                                                const newCache = {...prev};
                                                                                                                delete newCache[key];
                                                                                                                return newCache;
                                                                                                            });
                                                                                                            setGlyphThumbnails(prev => {
                                                                                                                const newCache = {...prev};
                                                                                                                delete newCache[key];
                                                                                                                return newCache;
                                                                                                            });
                                                                                                            
                                                                                                            alert(`üóëÔ∏è Deleted example`);
                                                                                                        }
                                                                                                    }
                                                                                                }}
                                                                                                className="px-1.5 py-0.5 bg-red-500 text-white text-xs rounded hover:bg-red-600"
                                                                                                title="Delete example"
                                                                                            >
                                                                                                üóëÔ∏è
                                                                                            </button>
                                                                                        </div>
                                                                                    </>
                                                                                ) : (
                                                                                    <div className="h-16 w-16 border-2 border-dashed border-gray-300 rounded flex items-center justify-center text-gray-400 text-xs">
                                                                                        E{idx + 1}
                                                                                    </div>
                                                                                )}
                                                                            </div>
                                                                        );
                                                                    })}
                                                                </div>
                                                            )}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                                </div>
                                {/* End of Scrollable Content */}

                                {/* Sticky Footer - Outside scrollable area */}
                                <div className="p-6 pt-4 border-t border-gray-200 flex-shrink-0">
                                    <div className="flex gap-3">
                                        <button
                                            onClick={() => {
                                                const jsonStr = JSON.stringify(equivalenceChart, null, 2);
                                                const blob = new Blob([jsonStr], { type: 'application/json' });
                                                const url = URL.createObjectURL(blob);
                                                const a = document.createElement('a');
                                                a.href = url;
                                                a.download = `Hakli_glyphs_${new Date().toISOString().split('T')[0]}.json`;
                                                a.click();
                                                URL.revokeObjectURL(url);
                                                alert('üì• Downloaded updated equivalence chart JSON');
                                            }}
                                            className="px-4 py-2 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600 font-semibold"
                                        >
                                            üíæ Download Updated JSON
                                        </button>
                                        <button
                                            onClick={() => setShowChartViewer(false)}
                                            className="flex-1 px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3e54] font-semibold"
                                        >
                                            Close Chart Viewer
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* Glyph Editor Modal */}
                    {showGlyphEditor && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60] p-4" onClick={() => setShowGlyphEditor(null)}>
                            <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                {(() => {
                                    const isEditMode = showGlyphEditor.mode === 'edit';
                                    
                                    const handleImageUpload = (e) => {
                                        const file = e.target.files[0];
                                        if (file) {
                                            setGlyphEditorImageFile(file);
                                            const reader = new FileReader();
                                            reader.onload = (e) => setGlyphEditorImagePreview(e.target.result);
                                            reader.readAsDataURL(file);
                                        }
                                    };
                                    
                                    const handleSave = () => {
                                        if (!glyphEditorName.trim()) {
                                            alert('‚ö†Ô∏è Please enter a glyph name');
                                            return;
                                        }
                                        
                                        const updated = { ...equivalenceChart };
                                        
                                        if (isEditMode) {
                                            // Edit existing glyph
                                            const glyphIndex = updated.glyphs.findIndex(g => g.id === showGlyphEditor.glyph.id);
                                            if (glyphIndex >= 0) {
                                                updated.glyphs[glyphIndex] = {
                                                    ...updated.glyphs[glyphIndex],
                                                    name: glyphEditorName.trim(),
                                                    arabic: glyphEditorArabic.trim() || undefined,
                                                    transliteration: glyphEditorTranslit.trim() || undefined
                                                };
                                                
                                                // Update primary image if new image uploaded
                                                if (glyphEditorImagePreview) {
                                                    updated.glyphs[glyphIndex].images.primary = glyphEditorImagePreview;
                                                    
                                                    // Update image caches
                                                    const img = new Image();
                                                    img.onload = () => {
                                                        setLoadedGlyphImages(prev => ({
                                                            ...prev,
                                                            [showGlyphEditor.glyph.id]: img
                                                        }));
                                                        setGlyphThumbnails(prev => ({
                                                            ...prev,
                                                            [showGlyphEditor.glyph.id]: img.src
                                                        }));
                                                    };
                                                    img.src = glyphEditorImagePreview;
                                                }
                                            }
                                            setEquivalenceChart(updated);
                                            alert(`‚úÖ Updated "${glyphEditorName}"`);
                                        } else {
                                            // Add new glyph
                                            if (!glyphEditorImagePreview) {
                                                alert('‚ö†Ô∏è Please upload a template image for the new glyph');
                                                return;
                                            }
                                            
                                            // Generate new ID (highest existing + 1)
                                            const maxId = Math.max(...updated.glyphs.map(g => g.id), 0);
                                            const newId = maxId + 1;
                                            
                                            const newGlyph = {
                                                id: newId,
                                                name: glyphEditorName.trim(),
                                                arabic: glyphEditorArabic.trim() || undefined,
                                                transliteration: glyphEditorTranslit.trim() || undefined,
                                                images: {
                                                    primary: glyphEditorImagePreview,
                                                    variants: [],
                                                    examples: []
                                                },
                                                description: "description"
                                            };
                                            
                                            updated.glyphs.push(newGlyph);
                                            setEquivalenceChart(updated);
                                            
                                            // Load into image caches
                                            const img = new Image();
                                            img.onload = () => {
                                                setLoadedGlyphImages(prev => ({
                                                    ...prev,
                                                    [newId]: img
                                                }));
                                                setGlyphThumbnails(prev => ({
                                                    ...prev,
                                                    [newId]: img.src
                                                }));
                                            };
                                            img.src = glyphEditorImagePreview;
                                            
                                            alert(`‚úÖ Added new glyph "${glyphEditorName}"`);
                                        }
                                        
                                        setShowGlyphEditor(null);
                                    };
                                    
                                    return (
                                        <>
                                            {/* Header */}
                                            <div className="flex items-center justify-between p-6 border-b border-gray-200">
                                                <h3 className="text-2xl font-bold text-gray-900">
                                                    {isEditMode ? '‚úèÔ∏è Edit Glyph' : '‚ûï Add New Glyph'}
                                                </h3>
                                                <button
                                                    onClick={() => setShowGlyphEditor(null)}
                                                    className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                                >
                                                    &times;
                                                </button>
                                            </div>
                                            
                                            {/* Content */}
                                            <div className="overflow-y-auto p-6 space-y-4">
                                                {/* Name Field */}
                                                <div>
                                                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                        Glyph Name (Transliteration) *
                                                    </label>
                                                    <input
                                                        type="text"
                                                        value={glyphEditorName}
                                                        onChange={(e) => setGlyphEditorName(e.target.value)}
                                                        className="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-ancient-purple focus:border-transparent"
                                                        placeholder="e.g., h, l, ·∏•, ·∫ì"
                                                    />
                                                    <p className="text-xs text-gray-500 mt-1">
                                                        Latin transliteration (use special characters: ·∏• ·π≠ ·∏ç ·∏è ·πØ ƒ° ·∫ì ·∏´)
                                                    </p>
                                                </div>
                                                
                                                {/* Arabic Field */}
                                                <div>
                                                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                        Arabic Character
                                                    </label>
                                                    <input
                                                        type="text"
                                                        value={glyphEditorArabic}
                                                        onChange={(e) => setGlyphEditorArabic(e.target.value)}
                                                        className="w-full px-3 py-2 border border-gray-300 rounded text-2xl text-center"
                                                        style={{ fontFamily: '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' }}
                                                        placeholder="ÿ≠"
                                                        dir="rtl"
                                                    />
                                                </div>
                                                
                                                {/* Transliteration Field */}
                                                <div>
                                                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                        Alternative Transliteration (Optional)
                                                    </label>
                                                    <input
                                                        type="text"
                                                        value={glyphEditorTranslit}
                                                        onChange={(e) => setGlyphEditorTranslit(e.target.value)}
                                                        className="w-full px-3 py-2 border border-gray-300 rounded"
                                                        placeholder="e.g., h, ·∏•"
                                                    />
                                                </div>
                                                
                                                {/* Image Upload */}
                                                <div>
                                                    <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                        Template Image {!isEditMode && '*'}
                                                    </label>
                                                    <div className="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center hover:border-ancient-purple transition-colors">
                                                        {glyphEditorImagePreview ? (
                                                            <div className="space-y-3">
                                                                <img 
                                                                    src={glyphEditorImagePreview} 
                                                                    alt="Preview" 
                                                                    className="max-h-40 mx-auto border border-gray-200 rounded bg-white p-2"
                                                                />
                                                                <button
                                                                    onClick={() => {
                                                                        setGlyphEditorImageFile(null);
                                                                        setGlyphEditorImagePreview(null);
                                                                    }}
                                                                    className="text-sm text-red-600 hover:text-red-800"
                                                                >
                                                                    üóëÔ∏è Remove Image
                                                                </button>
                                                            </div>
                                                        ) : isEditMode && showGlyphEditor.glyph?.images?.primary ? (
                                                            <div className="space-y-3">
                                                                <img 
                                                                    src={glyphThumbnails[showGlyphEditor.glyph.id]} 
                                                                    alt="Current" 
                                                                    className="max-h-40 mx-auto border border-gray-200 rounded bg-white p-2"
                                                                />
                                                                <p className="text-sm text-gray-600">Current template (upload new to replace)</p>
                                                            </div>
                                                        ) : (
                                                            <p className="text-gray-500 mb-2">No image selected</p>
                                                        )}
                                                        
                                                        <input
                                                            type="file"
                                                            accept="image/*"
                                                            onChange={handleImageUpload}
                                                            className="hidden"
                                                            id="glyph-image-upload"
                                                        />
                                                        <label
                                                            htmlFor="glyph-image-upload"
                                                            className="inline-block px-4 py-2 bg-ancient-purple text-white rounded cursor-pointer hover:bg-[#4a3e54] mt-2"
                                                        >
                                                            üìÅ Choose Image
                                                        </label>
                                                        <p className="text-xs text-gray-500 mt-2">
                                                            Upload a clear image of the glyph shape (PNG, JPG)
                                                        </p>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            {/* Footer */}
                                            <div className="flex gap-3 p-6 border-t border-gray-200 bg-gray-50">
                                                <button
                                                    onClick={() => setShowGlyphEditor(null)}
                                                    className="flex-1 px-4 py-2 border border-gray-300 text-gray-700 rounded hover:bg-gray-100"
                                                >
                                                    Cancel
                                                </button>
                                                <button
                                                    onClick={handleSave}
                                                    className="flex-1 px-4 py-2 bg-emerald-500 text-white rounded hover:bg-emerald-600 font-semibold"
                                                >
                                                    {isEditMode ? 'üíæ Save Changes' : '‚ûï Add Glyph'}
                                                </button>
                                            </div>
                                        </>
                                    );
                                })()}
                            </div>
                        </div>
                    )}
                    
                    {showCorrectionAnalysis && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setShowCorrectionAnalysis(false)}>
                            <div className="bg-white rounded-lg max-w-5xl w-full max-h-[90vh] flex flex-col shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                {/* Header */}
                                <div className="flex items-center justify-between p-6 pb-4 border-b border-gray-200 flex-shrink-0">
                                    <h3 className="text-2xl font-bold text-gray-900">üìä Correction Analysis</h3>
                                    <button
                                        onClick={() => setShowCorrectionAnalysis(false)}
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                    >
                                        &times;
                                    </button>
                                </div>

                                {/* Scrollable Content */}
                                <div className="overflow-y-auto p-6 pt-4 flex-1">
                                    {(() => {
                                        const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                                        const correctionKeys = Object.keys(corrections);
                                        
                                        if (correctionKeys.length === 0) {
                                            return (
                                                <div className="text-center py-12">
                                                    <div className="text-6xl mb-4">üì≠</div>
                                                    <h4 className="text-xl font-semibold text-gray-700 mb-2">No Corrections Yet</h4>
                                                    <p className="text-gray-600">
                                                        Start correcting misidentified glyphs to build up your correction memory.
                                                        This analysis will help you identify which glyphs need better template images.
                                                    </p>
                                                </div>
                                            );
                                        }

                                        // Calculate statistics
                                        const stats = correctionKeys.map(key => {
                                            const data = corrections[key];
                                            
                                            // Safety check: ensure data structure is valid
                                            if (!data || !data.corrections || !Array.isArray(data.corrections) || data.corrections.length === 0) {
                                                return null;
                                            }
                                            
                                            // Safety check: ensure originalGlyph exists
                                            if (!data.originalGlyph || !data.originalGlyph.id) {
                                                return null;
                                            }
                                            
                                            const totalCorrections = data.corrections.reduce((sum, c) => sum + (c.count || 0), 0);
                                            const uniqueCorrections = data.corrections.length;
                                            const mostCommon = [...data.corrections].sort((a, b) => (b.count || 0) - (a.count || 0))[0];
                                            
                                            return {
                                                originalGlyph: data.originalGlyph,
                                                totalCorrections,
                                                uniqueCorrections,
                                                mostCommon,
                                                allCorrections: data.corrections
                                            };
                                        }).filter(s => s !== null).sort((a, b) => b.totalCorrections - a.totalCorrections);

                                        const totalAllCorrections = stats.reduce((sum, s) => sum + s.totalCorrections, 0);

                                        return (
                                            <>
                                                {/* Summary Stats */}
                                                <div className="grid grid-cols-3 gap-4 mb-6">
                                                    <div className="bg-[#f5f3f0] border-2 border-stone-light rounded-lg p-4">
                                                        <div className="text-3xl font-bold text-stone-dark">{correctionKeys.length}</div>
                                                        <div className="text-sm text-gray-600">Glyphs Corrected</div>
                                                    </div>
                                                    <div className="bg-[#f0f5f3] border-2 border-[#b5d4c8] rounded-lg p-4">
                                                        <div className="text-3xl font-bold text-patina">{totalAllCorrections}</div>
                                                        <div className="text-sm text-gray-600">Total Corrections</div>
                                                    </div>
                                                    <div className="bg-[#f3f1f4] border-2 border-[#c9bfd4] rounded-lg p-4">
                                                        <div className="text-3xl font-bold text-ancient-purple">
                                                            {stats.length > 0 ? Math.round(totalAllCorrections / stats.length) : 0}
                                                        </div>
                                                        <div className="text-sm text-gray-600">Avg per Glyph</div>
                                                    </div>
                                                </div>

                                                {/* Priority List */}
                                                <div className="mb-4">
                                                    <h4 className="text-lg font-semibold text-gray-900 mb-2">
                                                        üéØ Priority: Glyphs Needing Better Templates
                                                    </h4>
                                                    <p className="text-sm text-gray-600 mb-4">
                                                        Sorted by frequency of corrections. High correction counts indicate template images may need improvement.
                                                    </p>
                                                </div>

                                                {/* Detailed List */}
                                                <div className="space-y-4">
                                                    {stats.map((stat, idx) => {
                                                        const priority = stat.totalCorrections >= 10 ? 'high' : 
                                                                       stat.totalCorrections >= 5 ? 'medium' : 'low';
                                                        const priorityColors = {
                                                            high: 'border-rust bg-red-50',
                                                            medium: 'border-orange-300 bg-orange-50',
                                                            low: 'border-gray-300 bg-gray-50'
                                                        };
                                                        const priorityBadges = {
                                                            high: 'bg-rust',
                                                            medium: 'bg-orange-500',
                                                            low: 'bg-gray-500'
                                                        };

                                                        return (
                                                            <div key={stat.originalGlyph.id} className={`border-2 rounded-lg p-4 ${priorityColors[priority]}`}>
                                                                <div className="flex items-start gap-4">
                                                                    {/* Rank & Priority */}
                                                                    <div className="flex-shrink-0 text-center">
                                                                        <div className="text-2xl font-bold text-gray-600">#{idx + 1}</div>
                                                                        <div className={`mt-1 px-2 py-1 ${priorityBadges[priority]} text-white text-xs rounded uppercase font-semibold`}>
                                                                            {priority}
                                                                        </div>
                                                                    </div>

                                                                    {/* Glyph Info */}
                                                                    <div className="flex-shrink-0">
                                                                        <div className="text-4xl font-bold text-ancient-purple mb-1">
                                                                            {stat.originalGlyph.arabic || '?'}
                                                                        </div>
                                                                        <div className="text-sm font-mono text-gray-600">
                                                                            {stat.originalGlyph.name}
                                                                        </div>
                                                                        <div className="text-xs text-gray-500">
                                                                            ID: {stat.originalGlyph.id}
                                                                        </div>
                                                                    </div>

                                                                    {/* Statistics */}
                                                                    <div className="flex-1">
                                                                        <div className="mb-3">
                                                                            <div className="text-sm font-semibold text-gray-700 mb-1">
                                                                                Correction Statistics:
                                                                            </div>
                                                                            <div className="flex gap-4 text-sm">
                                                                                <div>
                                                                                    <span className="font-semibold text-gray-900">{stat.totalCorrections}</span>
                                                                                    <span className="text-gray-600"> total corrections</span>
                                                                                </div>
                                                                                <div>
                                                                                    <span className="font-semibold text-gray-900">{stat.uniqueCorrections}</span>
                                                                                    <span className="text-gray-600"> unique targets</span>
                                                                                </div>
                                                                            </div>
                                                                        </div>

                                                                        <div className="mb-2">
                                                                            <div className="text-sm font-semibold text-gray-700 mb-2">
                                                                                Most Often Corrected To:
                                                                            </div>
                                                                            {stat.mostCommon && stat.mostCommon.to ? (
                                                                            <div className="flex items-center gap-3 p-2 bg-white rounded border border-gray-200">
                                                                                <div className="text-2xl font-bold text-patina">
                                                                                    {stat.mostCommon.to.arabic || stat.mostCommon.to.name || '?'}
                                                                                </div>
                                                                                <div className="flex-1">
                                                                                    <div className="text-sm font-mono text-gray-700">
                                                                                        {stat.mostCommon.to.name || 'Unknown'}
                                                                                    </div>
                                                                                    <div className="text-xs text-gray-500">
                                                                                        {stat.mostCommon.count || 0} times 
                                                                                        ({Math.round((stat.mostCommon.count || 0) / stat.totalCorrections * 100)}% of corrections)
                                                                                    </div>
                                                                                </div>
                                                                            </div>
                                                                            ) : (
                                                                                <div className="p-2 bg-gray-100 rounded text-sm text-gray-600">
                                                                                    No correction data available
                                                                                </div>
                                                                            )}
                                                                        </div>

                                                                        {stat.allCorrections.length > 1 && (
                                                                            <div className="mt-2">
                                                                                <div className="text-xs text-gray-600 mb-1">Other corrections:</div>
                                                                                <div className="flex flex-wrap gap-2">
                                                                                    {stat.allCorrections.slice(1).map((c, i) => (
                                                                                        <div key={i} className="px-2 py-1 bg-white border border-gray-200 rounded text-xs">
                                                                                            <span className="font-bold">{c.to.arabic || c.to.name}</span>
                                                                                            <span className="text-gray-500 ml-1">√ó{c.count}</span>
                                                                                        </div>
                                                                                    ))}
                                                                                </div>
                                                                            </div>
                                                                        )}

                                                                        <div className="mt-3 p-2 bg-[#f7f3ed] border border-[#d4c4a8] rounded">
                                                                            <div className="text-xs font-semibold text-[#6d5d42] mb-1">üí° Recommendation:</div>
                                                                            <div className="text-xs text-gray-700">
                                                                                {priority === 'high' && 
                                                                                    `High priority! This glyph is frequently misidentified. Add clearer template images or more variants to Hakli_glyphs.JSON.`
                                                                                }
                                                                                {priority === 'medium' && 
                                                                                    `Consider reviewing this glyph's template images. Add variants if different inscription styles exist.`
                                                                                }
                                                                                {priority === 'low' && 
                                                                                    `Low correction frequency suggests templates are working reasonably well.`
                                                                                }
                                                                            </div>
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>

                                                {/* Action Tips */}
                                                <div className="mt-6 p-4 bg-[#f5f3f0] border-2 border-stone-light rounded-lg">
                                                    <h4 className="font-semibold text-stone-dark mb-2">üìù Next Steps:</h4>
                                                    <ul className="text-sm text-gray-700 space-y-1 list-disc list-inside">
                                                        <li>Focus on high-priority glyphs (10+ corrections) first</li>
                                                        <li>Add clearer <strong>primary</strong> images to Hakli_glyphs.JSON</li>
                                                        <li>Add <strong>variants</strong> for different carving styles</li>
                                                        <li>Add <strong>examples</strong> from actual inscriptions where confusion occurs</li>
                                                        <li>Re-test with problematic inscriptions after updating templates</li>
                                                    </ul>
                                                </div>
                                            </>
                                        );
                                    })()}
                                </div>

                                {/* Footer */}
                                <div className="p-6 pt-4 border-t border-gray-200 flex-shrink-0">
                                    <button
                                        onClick={() => setShowCorrectionAnalysis(false)}
                                        className="w-full px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3e54] font-semibold"
                                    >
                                        Close Analysis
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {showCloudSyncModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setShowCloudSyncModal(false)}>
                            <div className="bg-white rounded-lg p-6 max-w-2xl w-full shadow-2xl max-h-[90vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900">‚òÅÔ∏è Cloud Sync</h3>
                                    <button
                                        onClick={() => setShowCloudSyncModal(false)}
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                    >
                                        &times;
                                    </button>
                                </div>

                                <div className="space-y-4">
                                    {/* Google Drive Section - Just Auth Status */}
                                    <div className="p-4 bg-[#f3f1f4] border-2 border-[#c9bfd4] rounded-lg">
                                        <h4 className="font-semibold text-ancient-purple mb-2">üíæ Google Drive Authentication</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Connect to Google Drive to save and load your HKI inscription files
                                        </p>
                                        
                                        {/* Sign In/Out */}
                                        <div className="flex gap-2 flex-wrap items-center">
                                            {(() => {
                                                try {
                                                    const isSignedIn = typeof DriveSync !== 'undefined' && DriveSync.isSignedIn && DriveSync.isSignedIn();
                                                    
                                                    if (isSignedIn) {
                                                        // Show Sign Out button when signed in
                                                        return (
                                                            <>
                                                                <button
                                                                    onClick={async () => {
                                                                        if (typeof DriveSync !== 'undefined') {
                                                                            try {
                                                                                await DriveSync.signOut();
                                                                                setDriveAuthStatus(prev => prev + 1); // Force re-render
                                                                                alert('‚úÖ Signed out from Google Drive.\n\nClose this window and click "üîÑ Change Account" to sign in again.');
                                                                            } catch (err) {
                                                                                console.error('Sign-out error:', err);
                                                                                alert('‚ùå Sign-out failed: ' + err.message);
                                                                            }
                                                                        }
                                                                    }}
                                                                    className="px-4 py-2 bg-rust text-white rounded-lg hover:bg-[#8d5d47] font-semibold"
                                                                >
                                                                    üö™ Sign Out
                                                                </button>
                                                                <span className="text-sm text-green-600 font-medium">
                                                                    ‚úì Connected to Google Drive
                                                                </span>
                                                            </>
                                                        );
                                                    } else {
                                                        // Show Sign In button when not signed in
                                                        return (
                                                            <button
                                                                onClick={async () => {
                                                                    if (typeof DriveSync !== 'undefined') {
                                                                        try {
                                                                            const success = await DriveSync.initialize();
                                                                            if (success) {
                                                                                const signedIn = await DriveSync.signIn();
                                                                                if (signedIn) {
                                                                                    alert('‚úÖ Connected to Google Drive!');
                                                                                    setShowCloudSyncModal(false); // Close modal after sign-in
                                                                                }
                                                                            } else {
                                                                                alert('‚ö†Ô∏è Drive sync initialization failed. Check console.');
                                                                            }
                                                                        } catch (err) {
                                                                            console.error('Drive sign-in error:', err);
                                                                            alert('‚ùå Sign-in failed: ' + err.message);
                                                                        }
                                                                    } else {
                                                                        alert('‚ùå DriveSync module not loaded');
                                                                    }
                                                                }}
                                                                className="px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3e54] font-semibold"
                                                            >
                                                                üîê Sign in with Google
                                                            </button>
                                                        );
                                                    }
                                                } catch {
                                                    return (
                                                        <button
                                                            onClick={async () => {
                                                                if (typeof DriveSync !== 'undefined') {
                                                                    try {
                                                                        const success = await DriveSync.initialize();
                                                                        if (success) {
                                                                            const signedIn = await DriveSync.signIn();
                                                                            if (signedIn) {
                                                                                setDriveAuthStatus(prev => prev + 1); // Force re-render
                                                                                alert('‚úÖ Connected to Google Drive!');
                                                                                setShowCloudSyncModal(false); // Close modal after sign-in
                                                                            }
                                                                        } else {
                                                                            alert('‚ö†Ô∏è Drive sync initialization failed. Check console.');
                                                                        }
                                                                    } catch (err) {
                                                                        console.error('Drive sign-in error:', err);
                                                                        alert('‚ùå Sign-in failed: ' + err.message);
                                                                    }
                                                                } else {
                                                                    alert('‚ùå DriveSync module not loaded');
                                                                }
                                                            }}
                                                            className="px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3e54] font-semibold"
                                                        >
                                                            üîê Sign in with Google
                                                        </button>
                                                    );
                                                }
                                            })()}
                                        </div>
                                        
                                        {/* Save/Load Row */}
                                        <div className="flex gap-4 flex-wrap mt-4" style={{rowGap: '12px'}}>
                                            <button
                                                onClick={async () => {
                                                    if (typeof DriveSync === 'undefined' || !DriveSync.isSignedIn()) {
                                                        alert('‚ö†Ô∏è Please sign in to Google Drive first');
                                                        return;
                                                    }
                                                    if (!recognitionResults || recognitionResults.length === 0) {
                                                        alert('‚ö†Ô∏è No recognition results to save. Run recognition first.');
                                                        return;
                                                    }
                                                    
                                                    // Generate HKI data
                                                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                                                    const inscriptionId = `hakli_${timestamp}`;
                                                    const filename = inscriptionTitle 
                                                        ? `${inscriptionTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${timestamp}.hki.json`
                                                        : `${inscriptionId}.hki.json`;
                                                    
                                                    // Optionally capture GPS location
                                                    let locationData = null;
                                                    if (navigator.geolocation) {
                                                        const captureLocation = confirm('üìç Include GPS location?\n\n‚Ä¢ Helps organize inscriptions by area\n‚Ä¢ Stays private in your Google Drive\n‚Ä¢ Optional - click Cancel to skip');
                                                        
                                                        if (captureLocation) {
                                                            try {
                                                                const position = await new Promise((resolve, reject) => {
                                                                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                                                                        enableHighAccuracy: true,
                                                                        timeout: 10000,
                                                                        maximumAge: 0
                                                                    });
                                                                });
                                                                
                                                                locationData = {
                                                                    latitude: position.coords.latitude,
                                                                    longitude: position.coords.longitude,
                                                                    accuracy: position.coords.accuracy,
                                                                    timestamp: new Date().toISOString(),
                                                                    manual: false
                                                                };
                                                                console.log('üìç Location captured:', locationData);
                                                            } catch (err) {
                                                                console.warn('Failed to get location:', err);
                                                                alert('‚ö†Ô∏è Could not get GPS location. Saving without location data.');
                                                            }
                                                        }
                                                    }
                                                    
                                                    // Capture preprocessed image if available
                                                    let preprocessedImage = null;
                                                    if (preprocessCanvasRef.current && preprocessedMat && !preprocessedMat.isDeleted()) {
                                                        try {
                                                            preprocessedImage = preprocessCanvasRef.current.toDataURL('image/png');
                                                        } catch (err) {
                                                            console.warn('Could not capture preprocessed image:', err);
                                                        }
                                                    }
                                                    
                                                    const hkiData = {
                                                        version: '1.0',
                                                        created: new Date().toISOString(),
                                                        source: 'Hakli Glyph Recognizer v251217',
                                                        inscriptionId: inscriptionId,
                                                        inscriptionTitle: inscriptionTitle || '',
                                                        inscriptionNotes: inscriptionNotes || '',
                                                        location: locationData,
                                                        image: image,
                                                        preprocessedImage: preprocessedImage,
                                                        preprocessing: preprocessing,
                                                        recognitionResults: recognitionResults,
                                                        readingOrder: readingOrder,
                                                        readingDirection: readingDirection,
                                                        wordBoundaries: Array.from(wordBoundaries),
                                                        columnBreaks: Array.from(columnBreaks),
                                                        lineBreaks: Array.from(lineBreaks),
                                                        validations: validations,
                                                        translationEnglish: translationEnglish,
                                                        translationArabic: translationArabic
                                                    };
                                                    
                                                    try {
                                                        const result = await DriveSync.saveToCloud(hkiData, filename);
                                                        console.log('Saved to Drive:', result);
                                                        alert(`‚úÖ Saved to Google Drive!\n\nFilename: ${filename}\nFolder: Hakli_Inscriptions`);
                                                    } catch (err) {
                                                        console.error('Save error:', err);
                                                        alert('‚ùå Save failed: ' + err.message);
                                                    }
                                                }}
                                                className="px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5d7a6d] font-semibold"
                                            >
                                                üíæ Save to Drive
                                            </button>
                                            <button
                                                onClick={async () => {
                                                    if (typeof DriveSync === 'undefined' || !DriveSync.isSignedIn()) {
                                                        alert('‚ö†Ô∏è Please sign in to Google Drive first');
                                                        return;
                                                    }
                                                    
                                                    try {
                                                        const files = await DriveSync.listFiles();
                                                        console.log('Drive files:', files);
                                                        
                                                        if (files.length === 0) {
                                                            alert('üìÇ No HKI files found in your Hakli_Inscriptions folder.');
                                                            return;
                                                        }
                                                        
                                                        // Load all file thumbnails
                                                        setShowCloudSyncModal(false);
                                                        setShowFilePickerModal({ files, isLoading: true });
                                                        
                                                        const filesWithThumbnails = await Promise.all(
                                                            files.map(async (file) => {
                                                                try {
                                                                    const hkiData = await DriveSync.loadFromCloud(file.id);
                                                                    console.log('üì∏ Thumbnail debug for', file.name, ':', {
                                                                        hasImage: !!hkiData.image,
                                                                        imageLength: hkiData.image ? hkiData.image.length : 0,
                                                                        imageStart: hkiData.image ? hkiData.image.substring(0, 50) : null,
                                                                        hasLocation: !!hkiData.location
                                                                    });
                                                                    return {
                                                                        ...file,
                                                                        thumbnail: hkiData.image || null,
                                                                        title: hkiData.inscriptionTitle || file.name,
                                                                        location: hkiData.location || null
                                                                    };
                                                                } catch (err) {
                                                                    console.error(`Failed to load thumbnail for ${file.name}:`, err);
                                                                    return { ...file, thumbnail: null, title: file.name, location: null };
                                                                }
                                                            })
                                                        );
                                                        
                                                        setShowFilePickerModal({ files: filesWithThumbnails, isLoading: false });
                                                    } catch (err) {
                                                        console.error('Load error:', err);
                                                        alert('‚ùå Load failed: ' + err.message);
                                                    }
                                                }}
                                                className="px-4 py-2 bg-stone text-white rounded-lg hover:bg-stone-dark font-semibold"
                                            >
                                                üìÇ Load from Drive
                                            </button>
                                        </div>
                                        
                                        <p className="text-xs text-ancient-purple">
                                            üîí Files saved to "Hakli_Inscriptions" folder in your Drive
                                        </p>
                                    </div>
                                </div>

                                <div className="mt-4 pt-4 border-t border-gray-200">
                                    <button
                                        onClick={() => setShowCloudSyncModal(false)}
                                        className="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                    >
                                        Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Community Corrections Modal */}
                    {showCommunityModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
                             onClick={() => setShowCommunityModal(false)}>
                            <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto shadow-2xl"
                                 onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4 p-6 pb-4 border-b border-gray-200">
                                    <h3 className="text-2xl font-bold text-gray-900">üåê Community Corrections</h3>
                                    <button
                                        onClick={() => setShowCommunityModal(false)}
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                    >
                                        &times;
                                    </button>
                                </div>

                                <div className="space-y-4 px-6">
                                    {/* Download from Master */}
                                    <div className="p-4 bg-[#f5f3f0] border-2 border-stone-light rounded-lg">
                                        <h4 className="font-semibold text-stone-dark mb-2">üì• Download Community Corrections</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Get the latest corrections from the community master collection
                                        </p>
                                        <button
                                            onClick={async () => {
                                                setShowCommunityModal(false);
                                                await downloadCorrectionsFromCloud(MASTER_PASTE_RAW_URL);
                                            }}
                                            className="w-full px-4 py-2 bg-stone text-white rounded-lg hover:bg-stone-dark font-semibold"
                                        >
                                            Download from Master Collection
                                        </button>
                                    </div>

                                    {/* Download from Custom URL */}
                                    <div className="p-4 bg-gray-50 border-2 border-gray-200 rounded-lg">
                                        <h4 className="font-semibold text-gray-900 mb-2">üîó Download from Custom URL</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Import corrections from a specific GitHub raw URL or other source
                                        </p>
                                        <div className="flex gap-2">
                                            <input
                                                type="text"
                                                placeholder="Paste raw JSON URL here..."
                                                value={customGistUrl}
                                                onChange={(e) => setCustomGistUrl(e.target.value)}
                                                className="flex-1 px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-stone focus:outline-none"
                                            />
                                            <button
                                                onClick={async () => {
                                                    if (customGistUrl) {
                                                        setShowCommunityModal(false);
                                                        await downloadCorrectionsFromCloud(customGistUrl);
                                                        setCustomGistUrl('');
                                                    }
                                                }}
                                                disabled={!customGistUrl}
                                                className="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                            >
                                                Download
                                            </button>
                                        </div>
                                    </div>

                                    {/* Upload Your Corrections */}
                                    <div className="p-4 bg-[#f0f5f3] border-2 border-[#b5d4c8] rounded-lg">
                                        <h4 className="font-semibold text-green-900 mb-2">üì§ Share Your Corrections</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Export your corrections and submit them to the community via GitHub Issue
                                        </p>
                                        <button
                                            onClick={async () => {
                                                setShowCommunityModal(false);
                                                await uploadCorrectionsToCloud();
                                            }}
                                            className="w-full px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5d7a6d] font-semibold"
                                        >
                                            üì• Export & Create Issue
                                        </button>
                                        <div className="mt-3 text-xs text-gray-600 bg-white p-2 rounded border border-patina">
                                            <p className="font-semibold mb-1">How it works:</p>
                                            <ol className="list-decimal list-inside space-y-1">
                                                <li>Downloads your corrections as a JSON file</li>
                                                <li>Opens a GitHub Issue template</li>
                                                <li>You attach the file and submit</li>
                                                <li>Corrections are reviewed and added to master</li>
                                            </ol>
                                        </div>
                                    </div>
                                </div>

                                <div className="mt-4 pt-4 border-t border-gray-200 px-6 pb-6">
                                    <button
                                        onClick={() => setShowCommunityModal(false)}
                                        className="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                    >
                                        Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* File Picker Modal with Image Thumbnails */}
                    {showFilePickerModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
                             onClick={() => setShowFilePickerModal(null)}>
                            <div className="bg-white rounded-2xl shadow-2xl max-w-5xl w-full max-h-[90vh] overflow-hidden flex flex-col"
                                 onClick={(e) => e.stopPropagation()}>
                                
                                {/* Header */}
                                <div className="bg-gradient-to-r from-ancient-purple to-stone p-6 text-white">
                                    <div className="flex items-center justify-between mb-3">
                                        <div>
                                            <h3 className="text-2xl font-bold">üìÇ Select Inscription</h3>
                                            <p className="text-sm opacity-90 mt-1">
                                                {showFilePickerModal.files?.length || 0} inscription{(showFilePickerModal.files?.length !== 1) ? 's' : ''} in your collection
                                            </p>
                                        </div>
                                        <button
                                            onClick={() => setShowFilePickerModal(null)}
                                            className="text-white hover:bg-white hover:bg-opacity-20 rounded-full p-2 transition-all"
                                        >
                                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                            </svg>
                                        </button>
                                    </div>
                                    
                                    {/* Sort Controls */}
                                    {!showFilePickerModal.isLoading && showFilePickerModal.files?.length > 1 && (
                                        <div className="flex items-center gap-2 text-sm">
                                            <span className="opacity-90">Sort by:</span>
                                            <button
                                                onClick={() => {
                                                    const sorted = [...showFilePickerModal.files].sort((a, b) => 
                                                        new Date(b.modifiedTime) - new Date(a.modifiedTime)
                                                    );
                                                    setShowFilePickerModal({ ...showFilePickerModal, files: sorted, groupBy: null });
                                                }}
                                                className="px-3 py-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded transition-all"
                                            >
                                                üìÖ Newest
                                            </button>
                                            <button
                                                onClick={() => {
                                                    const sorted = [...showFilePickerModal.files].sort((a, b) => 
                                                        new Date(a.modifiedTime) - new Date(b.modifiedTime)
                                                    );
                                                    setShowFilePickerModal({ ...showFilePickerModal, files: sorted, groupBy: null });
                                                }}
                                                className="px-3 py-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded transition-all"
                                            >
                                                üìÖ Oldest
                                            </button>
                                            <button
                                                onClick={() => {
                                                    const sorted = [...showFilePickerModal.files].sort((a, b) => 
                                                        (a.title || a.name).localeCompare(b.title || b.name)
                                                    );
                                                    setShowFilePickerModal({ ...showFilePickerModal, files: sorted, groupBy: null });
                                                }}
                                                className="px-3 py-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded transition-all"
                                            >
                                                üî§ A-Z
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setShowFilePickerModal({ ...showFilePickerModal, groupBy: 'location' });
                                                }}
                                                className="px-3 py-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded transition-all"
                                            >
                                                üìç Location
                                            </button>
                                        </div>
                                    )}
                                </div>

                                {/* File Grid */}
                                <div className="flex-1 overflow-y-auto p-6 bg-gray-50">
                                    {showFilePickerModal.isLoading ? (
                                        <div className="flex flex-col items-center justify-center py-16">
                                            <div className="animate-spin rounded-full h-16 w-16 border-4 border-ancient-purple border-t-transparent mb-4"></div>
                                            <p className="text-gray-600 text-lg">Loading inscription previews...</p>
                                            <p className="text-gray-400 text-sm mt-2">This may take a moment</p>
                                        </div>
                                    ) : (
                                        <>
                                        {(() => {
                                            // Helper function to calculate distance between two points (Haversine formula)
                                            const getDistance = (lat1, lon1, lat2, lon2) => {
                                                const R = 6371; // Earth's radius in km
                                                const dLat = (lat2 - lat1) * Math.PI / 180;
                                                const dLon = (lon2 - lon1) * Math.PI / 180;
                                                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                                                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                                                    Math.sin(dLon/2) * Math.sin(dLon/2);
                                                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                                                return R * c;
                                            };
                                            
                                            // Group files by location if enabled
                                            if (showFilePickerModal.groupBy === 'location') {
                                                const CLUSTER_RADIUS_KM = 5; // Group inscriptions within 5km
                                                const groups = [];
                                                const filesWithLocation = showFilePickerModal.files.filter(f => f.location);
                                                const filesWithoutLocation = showFilePickerModal.files.filter(f => !f.location);
                                                
                                                // Cluster files by proximity
                                                filesWithLocation.forEach(file => {
                                                    let addedToGroup = false;
                                                    
                                                    for (let group of groups) {
                                                        const centerLat = group.files.reduce((sum, f) => sum + f.location.latitude, 0) / group.files.length;
                                                        const centerLon = group.files.reduce((sum, f) => sum + f.location.longitude, 0) / group.files.length;
                                                        const distance = getDistance(centerLat, centerLon, file.location.latitude, file.location.longitude);
                                                        
                                                        if (distance < CLUSTER_RADIUS_KM) {
                                                            group.files.push(file);
                                                            addedToGroup = true;
                                                            break;
                                                        }
                                                    }
                                                    
                                                    if (!addedToGroup) {
                                                        groups.push({
                                                            files: [file],
                                                            centerLat: file.location.latitude,
                                                            centerLon: file.location.longitude
                                                        });
                                                    }
                                                });
                                                
                                                // Add files without location as separate group
                                                if (filesWithoutLocation.length > 0) {
                                                    groups.push({
                                                        files: filesWithoutLocation,
                                                        noLocation: true
                                                    });
                                                }
                                                
                                                // Render grouped files
                                                return groups.map((group, groupIndex) => (
                                                    <div key={groupIndex} className="mb-8">
                                                        <h4 className="text-lg font-bold text-gray-900 mb-4 flex items-center gap-2">
                                                            {group.noLocation ? (
                                                                <>üìç Unknown Location</>
                                                            ) : (
                                                                <>
                                                                    üìç Near {group.centerLat.toFixed(3)}¬∞N, {group.centerLon.toFixed(3)}¬∞E
                                                                    <span className="text-sm font-normal text-gray-500">
                                                                        ({group.files.length} inscription{group.files.length !== 1 ? 's' : ''})
                                                                    </span>
                                                                </>
                                                            )}
                                                        </h4>
                                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                                            {group.files.map((file) => renderFileCard(file))}
                                                        </div>
                                                    </div>
                                                ));
                                            } else {
                                                // Normal grid view (no grouping)
                                                return (
                                                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                                        {showFilePickerModal.files?.map((file) => renderFileCard(file))}
                                                    </div>
                                                );
                                            }
                                            
                                            // Helper function to render a file card
                                            function renderFileCard(file) {
                                                return (
                                                    <div
                                                        key={file.id}
                                                        onClick={async () => {
                                                            try {
                                                                setShowFilePickerModal(null);
                                                                const hkiData = await DriveSync.loadFromCloud(file.id);
                                                            console.log('Loaded from Drive:', hkiData);
                                                            
                                                            // Restore image with OpenCV processing
                                                            if (hkiData.image) {
                                                                setIsImageLoading(true);
                                                                
                                                                // Clear old display states
                                                                setDisplayImage(null);
                                                                setPreprocessedMat(null);
                                                                setImageRotation(0);
                                                                setRotatedImageDimensions(null);
                                                                
                                                                const img = new Image();
                                                                img.onload = () => {
                                                                    setImage(hkiData.image);
                                                                    
                                                                    if (imageRef.current) {
                                                                        imageRef.current.src = hkiData.image;
                                                                    }
                                                                    
                                                                    if (isOpenCvReady) {
                                                                        const canvas = document.createElement('canvas');
                                                                        canvas.width = img.width;
                                                                        canvas.height = img.height;
                                                                        const ctx = canvas.getContext('2d');
                                                                        ctx.drawImage(img, 0, 0);
                                                                        
                                                                        const mat = cv.imread(canvas);
                                                                        setOriginalMat(mat);
                                                                        
                                                                        if (originalCanvasRef.current) {
                                                                            cv.imshow(originalCanvasRef.current, mat);
                                                                        }
                                                                        
                                                                        processImageWithSettings(mat, preprocessing);
                                                                    }
                                                                    
                                                                    setIsImageLoading(false);
                                                                };
                                                                img.onerror = () => {
                                                                    setIsImageLoading(false);
                                                                    alert('‚ùå Failed to load image from HKI file.');
                                                                };
                                                                img.src = hkiData.image;
                                                            }
                                                            
                                                            // Restore all other data
                                                            if (hkiData.recognitionResults) setRecognitionResults(hkiData.recognitionResults);
                                                            if (hkiData.readingOrder) setReadingOrder(hkiData.readingOrder);
                                                            if (hkiData.readingDirection) setReadingDirection(hkiData.readingDirection);
                                                            if (hkiData.wordBoundaries) setWordBoundaries(new Set(hkiData.wordBoundaries));
                                                            if (hkiData.columnBreaks) setColumnBreaks(new Set(hkiData.columnBreaks));
                                                            if (hkiData.lineBreaks) setLineBreaks(new Set(hkiData.lineBreaks));
                                                            if (hkiData.validations) setValidations(hkiData.validations);
                                                            if (hkiData.translationEnglish) setTranslationEnglish(hkiData.translationEnglish);
                                                            if (hkiData.translationArabic) setTranslationArabic(hkiData.translationArabic);
                                                            if (hkiData.inscriptionTitle) setInscriptionTitle(hkiData.inscriptionTitle);
                                                            if (hkiData.inscriptionNotes) setInscriptionNotes(hkiData.inscriptionNotes);
                                                            
                                                            alert(`‚úÖ Loaded: ${file.name}`);
                                                        } catch (err) {
                                                            console.error('Load error:', err);
                                                            alert('‚ùå Load failed: ' + err.message);
                                                        }
                                                    }}
                                                    className="bg-white rounded-xl border-2 border-gray-200 hover:border-ancient-purple hover:shadow-xl transition-all cursor-pointer overflow-hidden group relative"
                                                >
                                                    {/* Delete Button (appears on hover) */}
                                                    <button
                                                        onClick={async (e) => {
                                                            e.stopPropagation(); // Prevent card click
                                                            if (!confirm(`üóëÔ∏è Delete "${file.title || file.name}"?\n\nThis will permanently remove it from Google Drive.`)) {
                                                                return;
                                                            }
                                                            
                                                            try {
                                                                // Delete from Google Drive
                                                                if (typeof DriveSync !== 'undefined' && DriveSync.deleteFile) {
                                                                    await DriveSync.deleteFile(file.id);
                                                                } else {
                                                                    // Fallback: Use gapi directly
                                                                    await window.gapi.client.drive.files.delete({
                                                                        fileId: file.id
                                                                    });
                                                                }
                                                                
                                                                // Remove from list
                                                                const updatedFiles = showFilePickerModal.files.filter(f => f.id !== file.id);
                                                                setShowFilePickerModal({ ...showFilePickerModal, files: updatedFiles });
                                                                
                                                                alert(`‚úÖ Deleted: ${file.name}`);
                                                            } catch (err) {
                                                                console.error('Delete error:', err);
                                                                alert('‚ùå Delete failed: ' + err.message);
                                                            }
                                                        }}
                                                        className="absolute top-2 right-2 z-10 bg-rust text-white rounded-full p-2 opacity-0 group-hover:opacity-100 hover:bg-red-600 transition-all shadow-lg"
                                                        title="Delete inscription"
                                                    >
                                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                                        </svg>
                                                    </button>
                                                    
                                                    {/* Thumbnail */}
                                                    <div className="aspect-video bg-gradient-to-br from-stone-light to-gray-300 relative overflow-hidden">
                                                        {file.thumbnail ? (
                                                            <img 
                                                                src={file.thumbnail} 
                                                                alt={file.title || file.name}
                                                                className="w-full h-full object-contain group-hover:scale-105 transition-transform duration-300"
                                                            />
                                                        ) : (
                                                            <div className="w-full h-full flex items-center justify-center text-gray-400">
                                                                <svg className="w-16 h-16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                                                </svg>
                                                            </div>
                                                        )}
                                                    </div>
                                                    
                                                    {/* File Info */}
                                                    <div className="p-4">
                                                        <h4 className="font-bold text-gray-900 truncate mb-1 group-hover:text-ancient-purple transition-colors">
                                                            {file.title || file.name}
                                                        </h4>
                                                        <div className="flex items-center justify-between text-xs text-gray-500">
                                                            <span className="truncate flex-1 pr-2">{file.name}</span>
                                                        </div>
                                                        <div className="text-xs text-gray-400 mt-1">
                                                            üìÖ {new Date(file.modifiedTime).toLocaleDateString('en-US', { 
                                                                year: 'numeric', 
                                                                month: 'short', 
                                                                day: 'numeric',
                                                                hour: '2-digit',
                                                                minute: '2-digit'
                                                            })}
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                            }
                                        })()}
                                        </>
                                    )}
                                </div>

                                {/* Footer */}
                                <div className="border-t border-gray-200 p-4 bg-white">
                                    <button
                                        onClick={() => setShowFilePickerModal(null)}
                                        className="w-full px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-semibold transition-colors"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<HakliGlyphRecognizer />);
    </script>

    <!-- Service Worker Registration -->
    <script>
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/hakli_glyph_recognizer/sw.js')
                    .then((registration) => {
                        console.log('‚úÖ Service Worker registered:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            console.log('üîÑ New service worker found, installing...');
                            
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('‚ú® New version available! Refresh to update.');
                                    // Could show a toast notification here
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.error('‚ùå Service Worker registration failed:', error);
                    });
            });
        } else {
            console.warn('‚ö†Ô∏è Service Workers not supported in this browser');
        }
    </script>
</body>

</html>
