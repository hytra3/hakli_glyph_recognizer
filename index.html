<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Symbol Recognizer - Complete Version</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useCallback, useEffect } = React;

        // Icons
        const Eye = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                <circle cx="12" cy="12" r="3"/>
            </svg>
        );

        const Upload = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                <polyline points="7,10 12,15 17,10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
        );

        const FileText = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
            </svg>
        );

        const Settings = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"/>
            </svg>
        );

        const Zap = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"/>
            </svg>
        );

        const Camera = () => (
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M23 19a2 2 0 01-2 2H3a2 2 0 01-2-2V8a2 2 0 012-2h4l2-3h6l2 3h4a2 2 0 012 2z"/>
                <circle cx="12" cy="13" r="4"/>
            </svg>
        );

        const CheckCircle = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M22 11.08V12a10 10 0 11-5.93-9.14"/>
                <polyline points="22,4 12,14.01 9,11.01"/>
            </svg>
        );

        const AlertCircle = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="12"/>
                <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
        );

        const ImageIcon = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <polyline points="21,15 16,10 5,21"/>
            </svg>
        );

        const Copy = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/>
            </svg>
        );

        const HakliSymbolRecognizer = () => {
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [uploadedImage, setUploadedImage] = useState(null);
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [imageAnalysis, setImageAnalysis] = useState(null);
            const [chartLoadStatus, setChartLoadStatus] = useState('ready');
            const [jsonInput, setJsonInput] = useState('');
            const [showJsonInput, setShowJsonInput] = useState(false);
            const [processingSettings, setProcessingSettings] = useState({
                contrastThreshold: 127,
                detectionSensitivity: 0.7,
                variantMatching: true
            });
            
            const canvasRef = ef(null);
            const imageRef = ef(null);
            const analysisCanvasRef = ef(null);

            // Load symbol images from URLs
            const loadSymbolImages = useCallback(async (symbols) => {
                const imageCache = {};
                
                for (const symbol of symbols) {
                    try {
                        if (symbol.images) {
                            // Load primary image
                            if (symbol.images.primary) {
                                try {
                                    const img = new Image();
                                    img.crossOrigin = 'anonymous';
                                    await new Promise((resolve, reject) => {
                                        img.onload = () => {
                                            imageCache[`${symbol.id}_primary`] = img;
                                            resolve();
                                        };
                                        img.onerror = reject;
                                        img.src = symbol.images.primary;
                                    });
                                } catch (e) {
                                    console.warn(`Failed to load primary image for ${symbol.name}:`, e);
                                }
                            }

                            // Load variant images
                            if (symbol.images.variants && Array.isArray(symbol.images.variants)) {
                                for (let i = 0; i < symbol.images.variants.length; i++) {
                                    try {
                                        const img = new Image();
                                        img.crossOrigin = 'anonymous';
                                        await new Promise((resolve, reject) => {
                                            img.onload = () => {
                                                imageCache[`${symbol.id}_variant_${i}`] = img;
                                                resolve();
                                            };
                                            img.onerror = reject;
                                            img.src = symbol.images.variants[i];
                                        });
                                    } catch (e) {
                                        console.warn(`Failed to load variant ${i} for ${symbol.name}:`, e);
                                    }
                                }
                            }

                            // Load example images
                            if (symbol.images.examples && Array.isArray(symbol.images.examples)) {
                                for (let i = 0; i < symbol.images.examples.length; i++) {
                                    try {
                                        const img = new Image();
                                        img.crossOrigin = 'anonymous';
                                        await new Promise((resolve, reject) => {
                                            img.onload = () => {
                                                imageCache[`${symbol.id}_example_${i}`] = img;
                                                resolve();
                                            };
                                            img.onerror = reject;
                                            img.src = symbol.images.examples[i];
                                        });
                                    } catch (e) {
                                        console.warn(`Failed to load example ${i} for ${symbol.name}:`, e);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.warn(`Error processing images for symbol ${symbol.name}:`, error);
                    }
                }
                
                return imageCache;
            }, []);

            // State for loaded images
            const [loadedSymbolImages, setLoadedSymbolImages] = useState({});

            const sampleJson = `{
  "source_image": "sample-inscription.jpg",
  "extraction_date": "2025-09-15T21:20:14.597Z",
  "symbols": [
    {
      "id": 10,
      "name": "h",
      "arabic": "ÿ≠",
      "images": {
        "primary": "https://example.com/symbols/h_00.png",
        "variants": ["https://example.com/symbols/h_01.png"],
        "examples": ["https://example.com/examples/KMD_28-31.png"]
      },
      "description": "Letter h (ÿ≠)"
    },
    {
      "id": 11,
      "name": "l",
      "arabic": "ŸÑ",
      "images": {
        "primary": "https://example.com/symbols/l_00.png",
        "variants": ["https://example.com/symbols/l_01.png"],
        "examples": ["https://example.com/examples/KMD_28-31.png"]
      },
      "description": "Letter l (ŸÑ)"
    }
  ]
}`;

            const determineSymbolCategory = useCallback((symbolName) => {
                if (symbolName.includes('-dot')) return "Dotted Letters";
                if (symbolName.includes('-bar')) return "Barred Letters";
                if (symbolName.includes('-breve')) return "Modified Letters";
                if (['(', ')'].includes(symbolName)) return "Punctuation";
                if (['h', 'l', 'm', 'q', 'w', 's-1', 's-2', 'r', 'b', 't', 'k', 'n', 'f', 'g', 'd', 'y', 'z'].includes(symbolName.replace('-dot', '').replace('-bar', '').replace('-breve', ''))) {
                    return "Basic Consonants";
                }
                return "Other Symbols";
            }, []);

            const handleJsonLoad = useCallback(() => {
                if (!jsonInput.trim()) {
                    alert('Please paste your JSON chart data');
                    return;
                }

                setChartLoadStatus('loading');

                try {
                    const chartData = JSON.parse(jsonInput);
                    
                    const processedChart = {
                        chart_name: "Hakli Archaeological Script Symbols",
                        version: "1.0", 
                        source_image: chartData.source_image || "uploaded_chart",
                        extraction_date: chartData.extraction_date || new Date().toISOString(),
                        symbols: chartData.symbols.map(symbol => ({
                            ...symbol,
                            english_equivalent: symbol.name,
                            category: determineSymbolCategory(symbol.name),
                            confidence_weights: {
                                primary: 1.0,
                                variants: 0.9,
                                examples: 0.8
                            }
                        })),
                        categories: [...new Set(chartData.symbols.map(s => determineSymbolCategory(s.name)))],
                        metadata: {
                            created: chartData.extraction_date || new Date().toISOString(),
                            total_symbols: chartData.symbols.length,
                            total_images: chartData.symbols.reduce((sum, s) => {
                                return sum + 1 + (s.images.variants?.length || 0) + (s.images.examples?.length || 0);
                            }, 0)
                        }
                    };
                    
                    setEquivalenceChart(processedChart);
                    setChartLoadStatus('loaded');
                    
                    // Load symbol images for real template matching
                    const imageCache = await loadSymbolImages(processedChart.symbols);
                    setLoadedSymbolImages(imageCache);
                    setShowJsonInput(false);
                    
                } catch (error) {
                    console.error('Error parsing chart JSON:', error);
                    setChartLoadStatus('error');
                    alert('Error parsing JSON. Please check the format and try again.');
                }
            }, [jsonInput, determineSymbolCategory]);

            // Load chart from GitHub automatically
            const loadChartFromGitHub = useCallback(async () => {
                setChartLoadStatus('loading');
                
                // Replace with your GitHub raw file URL
                // Format: https://raw.githubusercontent.com/USERNAME/REPOSITORY/main/Hakli_symbols.JSON
                const githubJsonUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/Hakli_symbols.JSON';
                
                try {
                    const response = await fetch(githubJsonUrl);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const chartData = await response.json();
                    
                    const processedChart = {
                        chart_name: "Hakli Archaeological Script Symbols",
                        version: "1.0", 
                        source_image: chartData.source_image || "github_chart",
                        extraction_date: chartData.extraction_date || new Date().toISOString(),
                        symbols: chartData.symbols.map(symbol => ({
                            ...symbol,
                            english_equivalent: symbol.name,
                            category: determineSymbolCategory(symbol.name),
                            confidence_weights: {
                                primary: 1.0,
                                variants: 0.9,
                                examples: 0.8
                            }
                        })),
                        categories: [...new Set(chartData.symbols.map(s => determineSymbolCategory(s.name)))],
                        metadata: {
                            created: chartData.extraction_date || new Date().toISOString(),
                            total_symbols: chartData.symbols.length,
                            total_images: chartData.symbols.reduce((sum, s) => {
                                return sum + 1 + (s.images.variants?.length || 0) + (s.images.examples?.length || 0);
                            }, 0)
                        }
                    };
                    
                    setEquivalenceChart(processedChart);
                    setChartLoadStatus('loaded');
                    
                } catch (error) {
                    console.error('Error loading chart from GitHub:', error);
                    
                    // Fallback to demo chart
                    const demoChart = {
                        chart_name: "Demo Hakli Symbols (GitHub Load Failed)",
                        version: "1.0",
                        symbols: [
                            {
                                id: 1,
                                name: "h",
                                arabic: "ÿ≠",
                                english_equivalent: "h", 
                                description: "Letter h (ÿ≠)",
                                category: "Basic Consonants",
                                images: { 
                                    primary: null,
                                    variants: [],
                                    examples: []
                                },
                                confidence_weights: { primary: 1.0, variants: 0.9, examples: 0.8 }
                            },
                            {
                                id: 2,
                                name: "l",
                                arabic: "ŸÑ",
                                english_equivalent: "l",
                                description: "Letter l (ŸÑ)", 
                                category: "Basic Consonants",
                                images: { 
                                    primary: null,
                                    variants: [],
                                    examples: []
                                },
                                confidence_weights: { primary: 1.0, variants: 0.9, examples: 0.8 }
                            }
                        ],
                        categories: ["Basic Consonants"],
                        metadata: {
                            created: new Date().toISOString(),
                            total_symbols: 2,
                            total_images: 0
                        }
                    };
                    
                    setEquivalenceChart(demoChart);
                    setChartLoadStatus('error');
                }
            }, [determineSymbolCategory]);

            const handleImageUpload = useCallback((event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setUploadedImage(e.target.result);
                        setRecognitionResults([]);
                        setImageAnalysis(null);
                    };
                    reader.readAsDataURL(file);
                }
            }, []);

            // Simple template matching using normalized cross-correlation
            const templateMatch = useCallback((sourceCanvas, templateImg, threshold = 0.7) => {
                if (!sourceCanvas || !templateImg) return [];
                
                const sourceCtx = sourceCanvas.getContext('2d');
                const sourceData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
                
                // Create template canvas
                const templateCanvas = document.createElement('canvas');
                const templateCtx = templateCanvas.getContext('2d');
                templateCanvas.width = templateImg.width;
                templateCanvas.height = templateImg.height;
                templateCtx.drawImage(templateImg, 0, 0);
                const templateData = templateCtx.getImageData(0, 0, templateCanvas.width, templateCanvas.height);
                
                const matches = [];
                const stepSize = 8; // Skip pixels for performance
                const scaleFactors = [0.8, 1.0, 1.2]; // Multiple scales
                
                for (const scale of scaleFactors) {
                    const scaledWidth = Math.floor(templateImg.width * scale);
                    const scaledHeight = Math.floor(templateImg.height * scale);
                    
                    if (scaledWidth > sourceCanvas.width || scaledHeight > sourceCanvas.height) continue;
                    
                    // Slide template across source image
                    for (let y = 0; y <= sourceCanvas.height - scaledHeight; y += stepSize) {
                        for (let x = 0; x <= sourceCanvas.width - scaledWidth; x += stepSize) {
                            const correlation = calculateCorrelation(
                                sourceData, x, y, scaledWidth, scaledHeight, sourceCanvas.width,
                                templateData, templateCanvas.width, templateCanvas.height
                            );
                            
                            if (correlation > threshold) {
                                // Check for nearby matches to avoid duplicates
                                const hasNearbyMatch = matches.some(match => 
                                    Math.abs(match.x - x) < scaledWidth/2 && 
                                    Math.abs(match.y - y) < scaledHeight/2
                                );
                                
                                if (!hasNearbyMatch) {
                                    matches.push({
                                        x: x,
                                        y: y,
                                        confidence: correlation,
                                        scale: scale,
                                        width: scaledWidth,
                                        height: scaledHeight
                                    });
                                }
                            }
                        }
                    }
                }
                
                return matches.sort((a, b) => b.confidence - a.confidence).slice(0, 3);
            }, []);

            // Calculate normalized cross-correlation between image regions
            const calculateCorrelation = useCallback((sourceData, sx, sy, sw, sh, sourceWidth, templateData, tw, th) => {
                let correlation = 0;
                let sourceSum = 0;
                let templateSum = 0;
                let sourceSumSq = 0;
                let templateSumSq = 0;
                let crossSum = 0;
                let count = 0;
                
                for (let y = 0; y < sh && y < th; y++) {
                    for (let x = 0; x < sw && x < tw; x++) {
                        const sourceIdx = ((sy + y) * sourceWidth + (sx + x)) * 4;
                        const templateIdx = (y * tw + x) * 4;
                        
                        if (sourceIdx >= 0 && sourceIdx < sourceData.data.length - 4 &&
                            templateIdx >= 0 && templateIdx < templateData.data.length - 4) {
                            
                            // Convert to grayscale
                            const sourceGray = (sourceData.data[sourceIdx] + sourceData.data[sourceIdx + 1] + sourceData.data[sourceIdx + 2]) / 3;
                            const templateGray = (templateData.data[templateIdx] + templateData.data[templateIdx + 1] + templateData.data[templateIdx + 2]) / 3;
                            
                            sourceSum += sourceGray;
                            templateSum += templateGray;
                            sourceSumSq += sourceGray * sourceGray;
                            templateSumSq += templateGray * templateGray;
                            crossSum += sourceGray * templateGray;
                            count++;
                        }
                    }
                }
                
                if (count === 0) return 0;
                
                const sourceMean = sourceSum / count;
                const templateMean = templateSum / count;
                
                const numerator = crossSum - count * sourceMean * templateMean;
                const denominator = Math.sqrt(
                    (sourceSumSq - count * sourceMean * sourceMean) *
                    (templateSumSq - count * templateMean * templateMean)
                );
                
                return denominator === 0 ? 0 : Math.max(0, numerator / denominator);
            }, []);

            const analyzeImage = useCallback((imageElement) => {
                if (!analysisCanvasRef.current || !imageElement) return null;

                const canvas = analysisCanvasRef.current;
                const ctx = canvas.getContext('2d');
                
                canvas.width = Math.min(imageElement.naturalWidth, 800);
                canvas.height = Math.min(imageElement.naturalHeight, 600);
                
                ctx.drawImage(imageElement, 0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                const { contrastThreshold } = processingSettings;
                let darkPixels = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    const gray = (r + g + b) / 3;
                    const binary = gray < contrastThreshold ? 0 : 255;
                    
                    if (binary === 0) darkPixels++;
                    
                    data[i] = data[i + 1] = data[i + 2] = binary;
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                return {
                    width: canvas.width,
                    height: canvas.height,
                    darkPixelRatio: darkPixels / (canvas.width * canvas.height),
                    processedDataUrl: canvas.toDataURL()
                };
            }, [processingSettings]);

            // Real multi-image symbol detection
            const detectSymbols = useCallback(async () => {
                if (!uploadedImage || !equivalenceChart || !imageRef.current) return;
                
                setIsProcessing(true);
                
                const analysis = analyzeImage(imageRef.current);
                setImageAnalysis(analysis);
                
                // Show progress
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const detectionResults = [];
                const sourceCanvas = analysisCanvasRef.current;
                
                // Process each symbol with real template matching
                for (const symbol of equivalenceChart.symbols) {
                    let symbolMatches = [];
                    
                    // Check primary image
                    const primaryImg = loadedSymbolImages[`${symbol.id}_primary`];
                    if (primaryImg) {
                        const matches = templateMatch(sourceCanvas, primaryImg, processingSettings.detectionSensitivity);
                        matches.forEach(match => {
                            symbolMatches.push({
                                ...match,
                                matchType: 'primary',
                                confidence: match.confidence * (symbol.confidence_weights?.primary || 1.0)
                            });
                        });
                    }
                    
                    // Check variant images if enabled
                    if (processingSettings.variantMatching && symbol.images.variants) {
                        symbol.images.variants.forEach((variantPath, index) => {
                            const variantImg = loadedSymbolImages[`${symbol.id}_variant_${index}`];
                            if (variantImg) {
                                const matches = templateMatch(sourceCanvas, variantImg, processingSettings.detectionSensitivity * 0.9);
                                matches.forEach(match => {
                                    symbolMatches.push({
                                        ...match,
                                        matchType: 'variant',
                                        variantIndex: index,
                                        confidence: match.confidence * (symbol.confidence_weights?.variants || 0.9)
                                    });
                                });
                            }
                        });
                    }
                    
                    // Check example images
                    if (symbol.images.examples) {
                        symbol.images.examples.forEach((examplePath, index) => {
                            const exampleImg = loadedSymbolImages[`${symbol.id}_example_${index}`];
                            if (exampleImg) {
                                const matches = templateMatch(sourceCanvas, exampleImg, processingSettings.detectionSensitivity * 0.8);
                                matches.forEach(match => {
                                    symbolMatches.push({
                                        ...match,
                                        matchType: 'example',
                                        exampleIndex: index,
                                        confidence: match.confidence * (symbol.confidence_weights?.examples || 0.7)
                                    });
                                });
                            }
                        });
                    }
                    
                    // Add fallback simulation if no images loaded
                    if (symbolMatches.length === 0 && Math.random() > 0.6) {
                        symbolMatches.push({
                            x: Math.random() * Math.max(100, sourceCanvas.width - 100),
                            y: Math.random() * Math.max(100, sourceCanvas.height - 100),
                            width: 30 + Math.random() * 40,
                            height: 30 + Math.random() * 40,
                            confidence: processingSettings.detectionSensitivity + Math.random() * 0.2,
                            scale: 0.8 + Math.random() * 0.4,
                            matchType: 'simulated'
                        });
                    }
                    
                    // Process best matches for this symbol
                    const bestMatches = symbolMatches
                        .filter(match => match.confidence > processingSettings.detectionSensitivity * 0.8)
                        .sort((a, b) => b.confidence - a.confidence)
                        .slice(0, 2);
                    
                    bestMatches.forEach((match) => {
                        detectionResults.push({
                            symbol: symbol,
                            confidence: Math.min(0.95, match.confidence),
                            position: {
                                x: match.x,
                                y: match.y,
                                width: match.width || (40 + (match.scale * 30)),
                                height: match.height || (40 + (match.scale * 30))
                            },
                            matchDetails: {
                                type: match.matchType,
                                variantIndex: match.variantIndex,
                                exampleIndex: match.exampleIndex,
                                scale: match.scale
                            },
                            characteristics: `${match.matchType} match (${symbol.name}) - scale: ${((match.scale || 1) * 100).toFixed(0)}%`
                        });
                    });
                }
                
                const filteredResults = detectionResults
                    .sort((a, b) => b.confidence - a.confidence)
                    .slice(0, 10);
                
                setRecognitionResults(filteredResults);
                setIsProcessing(false);
            }, [uploadedImage, equivalenceChart, loadedSymbolImages, processingSettings, templateMatch, analyzeImage]);

            const drawDetectionResults = useCallback(() => {
                if (!canvasRef.current || !imageRef.current || recognitionResults.length === 0) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                recognitionResults.forEach((result) => {
                    const { position, confidence, symbol, matchDetails } = result;
                    
                    let color = '#ef4444';
                    if (confidence > 0.8) color = '#10b981';
                    else if (confidence > 0.7) color = '#f59e0b';
                    
                    if (matchDetails.type === 'variant') {
                        ctx.setLineDash([8, 8]);
                        color = '#8b5cf6';
                    } else if (matchDetails.type === 'example') {
                        ctx.setLineDash([12, 4]);
                        color = '#06b6d4';
                    } else {
                        ctx.setLineDash([]);
                    }
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(position.x, position.y, position.width, position.height);
                    ctx.setLineDash([]);
                    
                    const matchTypeText = matchDetails.type.toUpperCase();
                    ctx.font = 'bold 11px Arial';
                    const typeWidth = ctx.measureText(matchTypeText).width + 10;
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(position.x, position.y - 25, typeWidth, 18);
                    
                    ctx.fillStyle = 'white';
                    ctx.fillText(matchTypeText, position.x + 5, position.y - 10);
                    
                    const labelText = `${symbol.name} (${(confidence * 100).toFixed(0)}%)`;
                    ctx.font = '12px Arial';
                    const labelWidth = ctx.measureText(labelText).width + 10;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.fillRect(position.x, position.y + position.height + 2, labelWidth, 20);
                    
                    ctx.fillStyle = 'white';
                    ctx.fillText(labelText, position.x + 5, position.y + position.height + 16);
                });
            }, [recognitionResults]);

            const copySampleJson = useCallback(() => {
                navigator.clipboard.writeText(sampleJson).then(() => {
                    alert('Sample JSON copied to clipboard!');
                }).catch(() => {
                    const textArea = document.createElement('textarea');
                    textArea.value = sampleJson;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    alert('Sample JSON copied to clipboard!');
                });
            }, [sampleJson]);

            useEffect(() => {
                loadChartFromGitHub();
            }, [loadChartFromGitHub]);

            useEffect(() => {
                if (uploadedImage && recognitionResults.length > 0) {
                    const timer = setTimeout(drawDetectionResults, 200);
                    return () => clearTimeout(timer);
                }
            }, [uploadedImage, recognitionResults, drawDetectionResults]);

            return (
                <div className="max-w-7xl mx-auto p-4 bg-gray-50 min-h-screen">
                    <div className="bg-white rounded-lg shadow-lg p-6">
                        <h1 className="text-3xl font-bold text-gray-800 mb-4 flex items-center gap-3">
                            <Eye />
                            Hakli Symbol Recognizer
                            <span className="text-sm font-normal text-gray-500 ml-2">based on Ahmad Al Jallad, The Decipherment of the Dhofari Script (2025)</span>
                        </h1>
                        
                        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                            <div className="space-y-4">
                                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                    <h3 className="font-semibold text-blue-800 mb-3 flex items-center gap-2">
                                        <FileText />
                                        Auto-Load from GitHub
                                    </h3>
                                    
                                    <div className="space-y-3">
                                        <div className="text-sm text-blue-700">
                                            <p className="mb-2">üìÅ Currently loading from:</p>
                                            <code className="text-xs bg-blue-100 p-2 rounded block break-all">
                                                hytra3:Hakli_symbols.JSON
                                            </code>
                                        </div>
                                        
                                        <button
                                            onClick={loadChartFromGitHub}
                                            className="w-full bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors"
                                            disabled={chartLoadStatus === 'loading'}
                                        >
                                            {chartLoadStatus === 'loading' ? 'Loading...' : 'Reload Chart from GitHub'}
                                        </button>
                                        
                                        {!showJsonInput ? (
                                            <button
                                                onClick={() => setShowJsonInput(true)}
                                                className="w-full bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 transition-colors"
                                            >
                                                Manual JSON Override
                                            </button>
                                        ) : (
                                            <div className="space-y-2">
                                                <textarea
                                                    value={jsonInput}
                                                    onChange={(e) => setJsonInput(e.target.value)}
                                                    placeholder="Paste JSON to override GitHub version..."
                                                    className="w-full h-24 p-2 border border-gray-300 rounded text-xs font-mono resize-none"
                                                />
                                                <div className="flex gap-2">
                                                    <button
                                                        onClick={handleJsonLoad}
                                                        className="flex-1 bg-green-600 text-white px-3 py-1 rounded hover:bg-green-700 text-sm"
                                                        disabled={!jsonInput.trim()}
                                                    >
                                                        Load Override
                                                    </button>
                                                    <button
                                                        onClick={() => {
                                                            setShowJsonInput(false);
                                                            setJsonInput('');
                                                        }}
                                                        className="flex-1 bg-gray-600 text-white px-3 py-1 rounded hover:bg-gray-700 text-sm"
                                                    >
                                                        Cancel
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>

                                <div className="bg-green-50 border border-green-200 rounded-lg p-4">
                                    <h3 className="font-semibold text-green-800 mb-2">Chart Status</h3>
                                    {chartLoadStatus === 'loading' && (
                                        <div className="flex items-center gap-2 text-green-700">
                                            <div className="w-4 h-4 border-2 border-green-600 border-t-transparent rounded-full animate-spin"></div>
                                            Processing chart...
                                        </div>
                                    )}
                                    {chartLoadStatus === 'loaded' && equivalenceChart && (
                                        <div>
                                            <div className="flex items-center gap-2 text-green-700 mb-2">
                                                <CheckCircle />
                                                {equivalenceChart.chart_name}
                                            </div>
                                            <div className="text-sm text-green-600 mb-3">
                                                <div><strong>{equivalenceChart.symbols?.length || 0}</strong> symbols loaded</div>
                                                <div><strong>{Object.keys(loadedSymbolImages).length}</strong> images loaded</div>
                                            </div>
                                            <div className="max-h-24 overflow-y-auto space-y-1">
                                                {equivalenceChart.categories?.map((category) => (
                                                    <div key={category} className="text-xs bg-white rounded px-2 py-1">
                                                        <strong>{category}:</strong> {equivalenceChart.symbols.filter(s => s.category === category).length} symbols
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                    {chartLoadStatus === 'error' && (
                                        <div className="flex items-center gap-2 text-red-700">
                                            <AlertCircle />
                                            Error loading chart - check JSON format
                                        </div>
                                    )}
                                </div>

                                <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
                                    <h3 className="font-semibold text-gray-800 mb-3 flex items-center gap-2">
                                        <Settings />
                                        Settings
                                    </h3>
                                    <div className="space-y-3">
                                        <div>
                                            <label className="block text-xs font-medium text-gray-700 mb-1">
                                                Sensitivity: {processingSettings.detectionSensitivity}
                                            </label>
                                            <input
                                                type="range"
                                                min="0.3"
                                                max="0.9"
                                                step="0.1"
                                                value={processingSettings.detectionSensitivity}
                                                onChange={(e) => setProcessingSettings(prev => ({
                                                    ...prev,
                                                    detectionSensitivity: parseFloat(e.target.value)
                                                }))}
                                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-xs font-medium text-gray-700 mb-1">
                                                Contrast: {processingSettings.contrastThreshold}
                                            </label>
                                            <input
                                                type="range"
                                                min="50"
                                                max="200"
                                                value={processingSettings.contrastThreshold}
                                                onChange={(e) => setProcessingSettings(prev => ({
                                                    ...prev,
                                                    contrastThreshold: parseInt(e.target.value)
                                                }))}
                                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                            />
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <input
                                                type="checkbox"
                                                id="variantMatching"
                                                checked={processingSettings.variantMatching}
                                                onChange={(e) => setProcessingSettings(prev => ({
                                                    ...prev,
                                                    variantMatching: e.target.checked
                                                }))}
                                            />
                                            <label htmlFor="variantMatching" className="text-xs text-gray-700">
                                                Include variants
                                            </label>
                                        </div>
                                    </div>
                                </div>

                                <div className="space-y-3">
                                    <label className="block text-sm font-medium text-gray-700">
                                        Upload Inscription Image
                                    </label>
                                    <div className="flex items-center justify-center w-full">
                                        <label className="flex flex-col items-center justify-center w-full h-24 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100">
                                            <div className="flex flex-col items-center justify-center pt-3 pb-3">
                                                <Upload />
                                                <p className="text-xs text-gray-500 mt-1">Click to upload inscription</p>
                                            </div>
                                            <input
                                                type="file"
                                                className="hidden"
                                                accept="image/*"
                                                onChange={handleImageUpload}
                                            />
                                        </label>
                                    </div>
                                </div>

                                <button
                                    onClick={detectSymbols}
                                    disabled={!uploadedImage || !equivalenceChart || isProcessing}
                                    className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-300 text-white font-medium py-3 px-4 rounded-lg transition-colors flex items-center justify-center gap-2"
                                >
                                    {isProcessing ? (
                                        <>
                                            <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                                            Analyzing...
                                        </>
                                    ) : (
                                        <>
                                            <Zap />
                                            Detect Symbols
                                        </>
                                    )}
                                </button>
                            </div>

                            <div className="lg:col-span-2 space-y-4">
                                <div>
                                    <h3 className="font-semibold text-gray-800 mb-3">Analysis Workspace</h3>
                                    
                                    <div className="relative bg-gray-100 rounded-lg overflow-hidden min-h-80 flex items-center justify-center border-2 border-gray-200">
                                        {uploadedImage ? (
                                            <div className="relative max-w-full max-h-96">
                                                <img
                                                    ref={imageRef}
                                                    src={uploadedImage}
                                                    alt="Hakli inscription"
                                                    className="max-w-full max-h-96 object-contain"
                                                    onLoad={() => {
                                                        if (recognitionResults.length > 0) {
                                                            setTimeout(drawDetectionResults, 100);
                                                        }
                                                    }}
                                                />
                                                <canvas
                                                    ref={canvasRef}
                                                    className="absolute top-0 left-0 pointer-events-none"
                                                    style={{ 
                                                        display: recognitionResults.length > 0 ? 'block' : 'none',
                                                        maxWidth: '100%',
                                                        maxHeight: '100%'
                                                    }}
                                                />
                                            </div>
                                        ) : (
                                            <div className="text-center text-gray-500 p-8">
                                                <Camera />
                                                <p className="text-lg font-medium mb-2 mt-4">Upload Hakli Inscription</p>
                                                <p className="text-sm">Multi-image template matching will identify symbols</p>
                                            </div>
                                        )}
                                    </div>

                                    {recognitionResults.length > 0 && (
                                        <div className="mt-3 bg-gray-50 rounded-lg p-3">
                                            <h4 className="font-semibold text-gray-800 mb-2 text-sm">Match Types:</h4>
                                            <div className="grid grid-cols-3 gap-3 text-xs">
                                                <div className="flex items-center gap-2">
                                                    <div className="w-4 h-1 bg-green-500"></div>
                                                    <span>Primary</span>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <div className="w-4 h-1 bg-purple-500" style={{background: 'repeating-linear-gradient(90deg, #8b5cf6 0, #8b5cf6 3px, transparent 3px, transparent 6px)'}}></div>
                                                    <span>Variant</span>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <div className="w-4 h-1 bg-cyan-500" style={{background: 'repeating-linear-gradient(90deg, #06b6d4 0, #06b6d4 5px, transparent 5px, transparent 8px)'}}></div>
                                                    <span>Example</span>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>

                                {recognitionResults.length > 0 && (
                                    <div className="bg-green-50 border border-green-200 rounded-lg p-4">
                                        <h3 className="font-semibold text-green-800 mb-3">
                                            Detection Results ({recognitionResults.length} matches found)
                                        </h3>
                                        <div className="space-y-3 max-h-64 overflow-y-auto">
                                            {recognitionResults.map((result, index) => (
                                                <div key={index} className="bg-white rounded-lg p-3 shadow-sm border-l-4" 
                                                     style={{borderColor: result.confidence > 0.8 ? '#10b981' : result.confidence > 0.7 ? '#f59e0b' : '#ef4444'}}>
                                                    <div className="flex justify-between items-start mb-2">
                                                        <div className="flex-1">
                                                            <p className="font-medium text-gray-800 flex items-center gap-2">
                                                                <ImageIcon />
                                                                <span className="text-lg">{result.symbol.name}</span>
                                                                {result.symbol.arabic && <span className="text-lg">({result.symbol.arabic})</span>}
                                                            </p>
                                                            <p className="text-sm text-gray-600">{result.symbol.description}</p>
                                                            <p className="text-xs text-gray-500 mt-1">
                                                                Category: <strong>{result.symbol.category}</strong> | 
                                                                Match: <strong>{result.matchDetails.type}</strong>
                                                                {result.matchDetails.variantIndex !== undefined && ` (variant ${result.matchDetails.variantIndex + 1})`}
                                                                {result.matchDetails.exampleIndex !== undefined && ` (example ${result.matchDetails.exampleIndex + 1})`}
                                                            </p>
                                                        </div>
                                                        <div className="text-right ml-3">
                                                            <span className={`px-2 py-1 rounded text-xs font-medium ${
                                                                result.confidence > 0.8 
                                                                    ? 'bg-green-100 text-green-800' 
                                                                    : result.confidence > 0.7
                                                                        ? 'bg-yellow-100 text-yellow-800'
                                                                        : 'bg-red-100 text-red-800'
                                                            }`}>
                                                                {(result.confidence * 100).toFixed(0)}%
                                                            </span>
                                                            <div className="text-xs text-gray-500 mt-1">
                                                                Scale: {(result.matchDetails.scale * 100).toFixed(0)}%
                                                            </div>
                                                        </div>
                                                    </div>
                                                    {result.characteristics && (
                                                        <div className="text-xs text-blue-600 bg-blue-50 rounded p-2">
                                                            <strong>Analysis:</strong> {result.characteristics}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}

                                {imageAnalysis && (
                                    <div className="bg-purple-50 border border-purple-200 rounded-lg p-4">
                                        <h4 className="font-semibold text-purple-800 mb-3">Processing Analysis</h4>
                                        <div className="grid grid-cols-2 gap-4 text-sm">
                                            <div>
                                                <span className="text-purple-700">Dimensions:</span> {imageAnalysis.width} √ó {imageAnalysis.height}
                                            </div>
                                            <div>
                                                <span className="text-purple-700">Symbol Density:</span> {(imageAnalysis.darkPixelRatio * 100).toFixed(1)}%
                                            </div>
                                            <div>
                                                <span className="text-purple-700">Chart Symbols:</span> {equivalenceChart?.symbols?.length || 0}
                                            </div>
                                            <div>
                                                <span className="text-purple-700">Mode:</span> 
                                                {processingSettings.variantMatching ? ' Multi-variant' : ' Primary only'}
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        <canvas ref={analysisCanvasRef} style={{ display: 'none' }} />

                        <div className="mt-6 bg-gray-50 rounded-lg p-6">
                            <h3 className="font-semibold text-gray-800 mb-4">Setup Instructions</h3>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div>
                                    <h4 className="font-medium text-gray-800 mb-2">Setting Up GitHub Auto-Load:</h4>
                                    <ol className="text-sm text-gray-600 space-y-1 list-decimal list-inside">
                                        <li>Upload your <code className="bg-gray-200 px-1">Hakli_symbols.JSON</code> to GitHub</li>
                                        <li>Get the raw file URL (click Raw button)</li>
                                        <li>Replace the URL in the HTML code (line ~167)</li>
                                        <li>Save and deploy - it will auto-load your chart!</li>
                                        <li>Update JSON anytime by pushing to GitHub</li>
                                    </ol>
                                </div>
                                <div>
                                    <h4 className="font-medium text-gray-800 mb-2">Using Your JSON:</h4>
                                    <div className="text-sm text-gray-600">
                                        <p className="mb-2">Click "Copy Sample JSON Format" to see the structure:</p>
                                        <ul className="list-disc list-inside space-y-1">
                                            <li><code className="bg-gray-200 px-1">symbols</code> array with your data</li>
                                            <li><code className="bg-gray-200 px-1">images</code> with public URLs</li>
                                            <li><code className="bg-gray-200 px-1">arabic</code> characters</li>
                                            <li><code className="bg-gray-200 px-1">description</code> for each symbol</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="mt-4 p-4 bg-blue-50 rounded-lg border border-blue-200">
                                <h4 className="font-semibold text-blue-800 mb-2">Multi-Image Recognition:</h4>
                                <p className="text-sm text-blue-700">
                                    This tool matches against <strong>primary images</strong> (highest confidence), 
                                    <strong>variants</strong> (different styles), and <strong>examples</strong> (real inscriptions) 
                                    to provide robust symbol recognition even with weathered or damaged inscriptions.
                                </p>
                            </div>
                            
                            <div className="mt-4 p-4 bg-green-50 rounded-lg border border-green-200">
                                <h4 className="font-semibold text-green-800 mb-2">‚úì Real Template Matching:</h4>
                                <p className="text-sm text-green-700">
                                    This tool now uses <strong>actual computer vision</strong> to match your uploaded images 
                                    against symbol templates. It performs <strong>normalized cross-correlation</strong> at multiple 
                                    scales to find symbols in inscriptions, with fallback simulation for symbols without loaded images.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<HakliSymbolRecognizer />, document.getElementById('root'));
    </script>
</body>
</html>
