<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Symbol Recognizer - OpenCV Enhanced</title>
    <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useCallback, useEffect } = React;

        const Eye = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                <circle cx="12" cy="12" r="3"/>
            </svg>
        );

        const Upload = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                <polyline points="7,10 12,15 17,10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
        );

        const Zap = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="13,2 3,14 12,14 11,22 21,10 12,10 13,2"/>
            </svg>
        );

        const Camera = () => (
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M23 19a2 2 0 01-2 2H3a2 2 0 01-2-2V8a2 2 0 012-2h4l2-3h6l2 3h4a2 2 0 012 2z"/>
                <circle cx="12" cy="13" r="4"/>
            </svg>
        );

        const HakliSymbolRecognizer = () => {
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [uploadedImage, setUploadedImage] = useState(null);
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [chartLoadStatus, setChartLoadStatus] = useState('ready');
            const [loadedSymbolImages, setLoadedSymbolImages] = useState({});
            const [isOpenCVReady, setIsOpenCVReady] = useState(false);
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [processingSettings, setProcessingSettings] = useState({
                detectionSensitivity: 0.4,
                variantMatching: true
            });
            
            const canvasRef = useRef(null);
            const imageRef = useRef(null);

            // Format inscription with word boundaries
            const formatInscriptionWithBoundaries = (results) => {
                const sortedResults = results.sort((a, b) => a.position.x - b.position.x);
                const parts = [];
                
                sortedResults.forEach((result, index) => {
                    if (index === 0 || wordBoundaries.has(index)) {
                        if (parts.length > 0) parts.push(' | ');
                    }
                    parts.push(result.symbol.name);
                    if (index < sortedResults.length - 1 && !wordBoundaries.has(index + 1)) {
                        parts.push('-');
                    }
                });
                
                return parts.join('');
            };

            // Format Arabic with word boundaries
            const formatArabicWithBoundaries = (results) => {
                const sortedResults = results.sort((a, b) => a.position.x - b.position.x);
                const parts = [];
                
                sortedResults.forEach((result, index) => {
                    if (index === 0 || wordBoundaries.has(index)) {
                        if (parts.length > 0) parts.push(' ');
                    }
                    parts.push(result.symbol.arabic || result.symbol.name);
                });
                
                return parts.join('');
            };

            // Toggle word boundary before a symbol
            const toggleWordBoundary = (symbolIndex) => {
                setWordBoundaries(prev => {
                    const newBoundaries = new Set(prev);
                    if (newBoundaries.has(symbolIndex)) {
                        newBoundaries.delete(symbolIndex);
                    } else {
                        newBoundaries.add(symbolIndex);
                    }
                    return newBoundaries;
                });
            };

            // Check if OpenCV is ready
            useEffect(() => {
                const checkOpenCV = () => {
                    if (typeof cv !== 'undefined' && cv.Mat) {
                        console.log('âœ… OpenCV.js loaded successfully');
                        setIsOpenCVReady(true);
                    } else {
                        console.log('â³ Waiting for OpenCV.js...');
                        setTimeout(checkOpenCV, 100);
                    }
                };
                checkOpenCV();
            }, []);

            // Convert relative paths to full GitHub URLs
            const convertToGitHubUrl = useCallback((relativePath) => {
                if (!relativePath) return null;
                if (relativePath.startsWith('http')) return relativePath;
                
                const baseUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/';
                const fullUrl = baseUrl + relativePath;
                return fullUrl;
            }, []);

            // Load symbol images from URLs
            const loadSymbolImages = useCallback(async (symbols) => {
                const imageCache = {};
                
                for (const symbol of symbols) {
                    try {
                        if (symbol.images) {
                            // Load primary image
                            if (symbol.images.primary) {
                                try {
                                    const fullUrl = convertToGitHubUrl(symbol.images.primary);
                                    if (fullUrl) {
                                        const img = new Image();
                                        img.crossOrigin = 'anonymous';
                                        await new Promise((resolve, reject) => {
                                            img.onload = () => {
                                                imageCache[`${symbol.id}_primary`] = img;
                                                resolve();
                                            };
                                            img.onerror = reject;
                                            img.src = fullUrl;
                                        });
                                    }
                                } catch (e) {
                                    console.warn(`Failed to load primary image for ${symbol.name}:`, e);
                                }
                            }

                            // Load variant images
                            if (symbol.images.variants && Array.isArray(symbol.images.variants)) {
                                for (let i = 0; i < symbol.images.variants.length; i++) {
                                    try {
                                        const fullUrl = convertToGitHubUrl(symbol.images.variants[i]);
                                        if (fullUrl) {
                                            const img = new Image();
                                            img.crossOrigin = 'anonymous';
                                            await new Promise((resolve, reject) => {
                                                img.onload = () => {
                                                    imageCache[`${symbol.id}_variant_${i}`] = img;
                                                    resolve();
                                                };
                                                img.onerror = reject;
                                                img.src = fullUrl;
                                            });
                                        }
                                    } catch (e) {
                                        console.warn(`Failed to load variant ${i} for ${symbol.name}:`, e);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.warn(`Error processing images for symbol ${symbol.name}:`, error);
                    }
                }
                
                return imageCache;
            }, [convertToGitHubUrl]);

            // Load chart from GitHub
            const loadChart = useCallback(() => {
                const loadChartInternal = async () => {
                    setChartLoadStatus('loading');
                    
                    const githubJsonUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/Hakli_symbols.JSON';
                    
                    try {
                        console.log('ðŸ“¡ Fetching JSON from:', githubJsonUrl);
                        const response = await fetch(githubJsonUrl);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const chartData = await response.json();
                        console.log('âœ… JSON loaded successfully');
                        
                        const processedChart = {
                            symbols: chartData.symbols.map(symbol => ({
                                ...symbol,
                                confidence_weights: {
                                    primary: 1.0,
                                    variants: 0.9
                                }
                            }))
                        };
                        
                        setEquivalenceChart(processedChart);
                        setChartLoadStatus('loaded');
                        
                        console.log('ðŸ–¼ï¸ Loading symbol images...');
                        const imageCache = await loadSymbolImages(processedChart.symbols);
                        console.log('âœ… Image loading complete. Loaded count:', Object.keys(imageCache).length);
                        setLoadedSymbolImages(imageCache);
                        
                    } catch (error) {
                        console.error('âŒ Error loading chart from GitHub:', error);
                        setChartLoadStatus('error');
                    }
                };
                
                loadChartInternal();
            }, [loadSymbolImages]);

            // Auto-load chart on startup
            useEffect(() => {
                loadChart();
            }, [loadChart]);

            // Handle image upload
            const handleImageUpload = useCallback((event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setUploadedImage(e.target.result);
                        setRecognitionResults([]);
                    };
                    reader.readAsDataURL(file);
                }
            }, []);

            // Template matching function with better error handling
            const templateMatchIsolated = useCallback((imageElement, templateImg) => {
                if (!isOpenCVReady || !templateImg) return null;

                try {
                    // Validate image dimensions
                    if (templateImg.width === 0 || templateImg.height === 0) {
                        console.warn('Template image has invalid dimensions');
                        return null;
                    }

                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = imageElement.naturalWidth;
                    canvas.height = imageElement.naturalHeight;
                    ctx.drawImage(imageElement, 0, 0);

                    const imageMat = cv.imread(canvas);
                    
                    const templateCanvas = document.createElement('canvas');
                    const templateCtx = templateCanvas.getContext('2d');
                    templateCanvas.width = templateImg.width;
                    templateCanvas.height = templateImg.height;
                    templateCtx.drawImage(templateImg, 0, 0);
                    const templateMat = cv.imread(templateCanvas);

                    // Check if template is smaller than image
                    if (templateMat.rows > imageMat.rows || templateMat.cols > imageMat.cols) {
                        console.warn('Template larger than source image, skipping');
                        imageMat.delete();
                        templateMat.delete();
                        return null;
                    }

                    const result = new cv.Mat();
                    cv.matchTemplate(imageMat, templateMat, result, cv.TM_CCOEFF_NORMED);
                    
                    const minMaxLoc = cv.minMaxLoc(result);
                    const confidence = minMaxLoc.maxVal;
                    const location = minMaxLoc.maxLoc;

                    imageMat.delete();
                    templateMat.delete();
                    result.delete();

                    return {
                        confidence: confidence,
                        position: {
                            x: location.x,
                            y: location.y,
                            width: templateImg.width,
                            height: templateImg.height
                        }
                    };

                } catch (error) {
                    console.error('Template matching error:', error.message || error);
                    return null;
                }
            }, [isOpenCVReady]);

            // Improved symbol detection with position filtering
            const detectSymbols = useCallback(async () => {
                if (!uploadedImage || !equivalenceChart || !imageRef.current) {
                    console.log('Missing requirements for detection');
                    return;
                }
                
                setIsProcessing(true);
                console.log('ðŸ” Starting symbol detection...');
                console.log(`ðŸ“Š Available symbols: ${equivalenceChart.symbols.length}`);
                console.log(`ðŸ–¼ï¸ Available images: ${Object.keys(loadedSymbolImages).length}`);
                
                const allMatches = [];
                
                for (const symbol of equivalenceChart.symbols) {
                    // Check primary image
                    const primaryImg = loadedSymbolImages[`${symbol.id}_primary`];
                    if (primaryImg) {
                        const match = templateMatchIsolated(imageRef.current, primaryImg);
                        
                        if (match && match.confidence > processingSettings.detectionSensitivity) {
                            console.log(`${symbol.name} (primary): ${match.confidence.toFixed(4)} âœ…`);
                            allMatches.push({
                                symbol: symbol,
                                confidence: match.confidence,
                                position: match.position,
                                matchType: 'primary'
                            });
                        } else {
                            console.log(`${symbol.name} (primary): ${match ? match.confidence.toFixed(4) : '0.0000'} âŒ`);
                        }
                    }
                    
                    // Check variants if enabled
                    if (processingSettings.variantMatching && symbol.images.variants) {
                        symbol.images.variants.forEach((variantPath, index) => {
                            const variantImg = loadedSymbolImages[`${symbol.id}_variant_${index}`];
                            if (variantImg) {
                                const match = templateMatchIsolated(imageRef.current, variantImg);
                                const threshold = processingSettings.detectionSensitivity * 0.9;
                                
                                if (match && match.confidence > threshold) {
                                    console.log(`${symbol.name} (variant ${index + 1}): ${match.confidence.toFixed(4)} âœ…`);
                                    allMatches.push({
                                        symbol: symbol,
                                        confidence: match.confidence * 0.9,
                                        position: match.position,
                                        matchType: 'variant',
                                        variantIndex: index
                                    });
                                } else {
                                    console.log(`${symbol.name} (variant ${index + 1}): ${match ? match.confidence.toFixed(4) : '0.0000'} âŒ`);
                                }
                            }
                        });
                    }
                }
                
                // Filter overlapping matches - keep highest confidence
                const filteredMatches = [];
                const overlapThreshold = 30; // pixels
                
                allMatches.sort((a, b) => b.confidence - a.confidence);
                
                for (const match of allMatches) {
                    let isOverlapping = false;
                    
                    for (const existing of filteredMatches) {
                        const dx = Math.abs(match.position.x - existing.position.x);
                        const dy = Math.abs(match.position.y - existing.position.y);
                        
                        if (dx < overlapThreshold && dy < overlapThreshold) {
                            isOverlapping = true;
                            break;
                        }
                    }
                    
                    if (!isOverlapping) {
                        filteredMatches.push(match);
                    }
                }
                
                console.log(`âœ… Detection complete: ${allMatches.length} total matches, ${filteredMatches.length} after filtering`);
                setRecognitionResults(filteredMatches);
                setIsProcessing(false);
            }, [uploadedImage, equivalenceChart, loadedSymbolImages, processingSettings, templateMatchIsolated, isOpenCVReady]);

            // Draw simplified detection results on canvas overlay
            const drawDetectionResults = useCallback(() => {
                if (!canvasRef.current || !imageRef.current || recognitionResults.length === 0) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;
                
                // Wait for image to be fully loaded and rendered
                if (img.naturalWidth === 0 || img.naturalHeight === 0 || img.offsetWidth === 0 || img.offsetHeight === 0) {
                    setTimeout(drawDetectionResults, 100);
                    return;
                }

                // Get the actual displayed image dimensions and position
                const imgRect = img.getBoundingClientRect();
                const containerRect = img.parentElement.getBoundingClientRect();
                
                // Calculate the actual displayed size of the image (respecting aspect ratio)
                const imgAspectRatio = img.naturalWidth / img.naturalHeight;
                const containerAspectRatio = img.offsetWidth / img.offsetHeight;
                
                let displayWidth, displayHeight, offsetX, offsetY;
                
                if (imgAspectRatio > containerAspectRatio) {
                    // Image is wider - constrained by width
                    displayWidth = img.offsetWidth;
                    displayHeight = img.offsetWidth / imgAspectRatio;
                    offsetX = 0;
                    offsetY = (img.offsetHeight - displayHeight) / 2;
                } else {
                    // Image is taller - constrained by height
                    displayWidth = img.offsetHeight * imgAspectRatio;
                    displayHeight = img.offsetHeight;
                    offsetX = (img.offsetWidth - displayWidth) / 2;
                    offsetY = 0;
                }
                
                // Set canvas size to match the actual image display area
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                
                canvas.style.width = displayWidth + 'px';
                canvas.style.height = displayHeight + 'px';
                canvas.style.left = offsetX + 'px';
                canvas.style.top = offsetY + 'px';
                
                // Calculate scaling factors from natural to display size
                const scaleX = displayWidth / img.naturalWidth;
                const scaleY = displayHeight / img.naturalHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                console.log('Drawing detection boxes:', {
                    naturalSize: `${img.naturalWidth}x${img.naturalHeight}`,
                    displaySize: `${displayWidth}x${displayHeight}`,
                    scale: `${scaleX.toFixed(3)}x${scaleY.toFixed(3)}`,
                    offset: `${offsetX},${offsetY}`,
                    results: recognitionResults.length
                });
                
                recognitionResults.forEach((result, index) => {
                    const { position, matchType, symbol } = result;
                    
                    // Scale coordinates from natural image size to display size
                    const x = position.x * scaleX;
                    const y = position.y * scaleY;
                    const width = position.width * scaleX;
                    const height = position.height * scaleY;
                    
                    console.log(`Symbol ${index + 1} (${result.symbol.name}):`, {
                        original: `${position.x},${position.y} ${position.width}x${position.height}`,
                        scaled: `${x.toFixed(1)},${y.toFixed(1)} ${width.toFixed(1)}x${height.toFixed(1)}`
                    });
                    
                    // Simple color coding: Primary = solid, Variant = dashed
                    let color = '#10b981'; // green for primary
                    if (matchType === 'variant') {
                        ctx.setLineDash([4, 4]); // dashed line for variants
                        color = '#8b5cf6'; // purple for variants
                    } else {
                        ctx.setLineDash([]);
                    }
                    
                    // Draw simple bounding box
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, width, height);
                    ctx.setLineDash([]);
                    
                    // Add character label
                    const character = symbol.arabic || symbol.name;
                    const labelText = character.length > 3 ? symbol.name : character;
                    
                    ctx.font = 'bold 14px Arial';
                    const textWidth = ctx.measureText(labelText).width + 8;
                    const textHeight = 18;
                    
                    // Position label above the box (or below if too close to top)
                    const labelX = x;
                    const labelY = y - textHeight > 0 ? y - 2 : y + height + textHeight;
                    
                    // Draw label background
                    ctx.fillStyle = color;
                    ctx.fillRect(labelX, labelY - textHeight + 2, textWidth, textHeight);
                    
                    // Draw label text
                    ctx.fillStyle = 'white';
                    ctx.fillText(labelText, labelX + 4, labelY - 4);
                });
            }, [recognitionResults]);

            // Trigger drawing when results change
            useEffect(() => {
                if (uploadedImage && recognitionResults.length > 0) {
                    const timer = setTimeout(drawDetectionResults, 200);
                    return () => clearTimeout(timer);
                }
            }, [uploadedImage, recognitionResults, drawDetectionResults]);

            return (
                <div className="max-w-6xl mx-auto p-4 bg-gray-50 min-h-screen">
                    <div className="bg-white rounded-lg shadow-lg p-6">
                        <h1 className="text-3xl font-bold text-gray-800 mb-4 flex items-center gap-3">
                            <Eye />
                            Hakli Symbol Recognizer
                            <span className="text-sm font-normal text-gray-500 ml-2">based on Ahmad Al-Jallad (2025), The Decipherment of the Dhofari Script</span>
                        </h1>
                        
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            {/* Controls */}
                            <div className="space-y-4">
                                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                    <h3 className="font-semibold text-blue-800 mb-2">Chart Status</h3>
                                    <button
                                        onClick={loadChart}
                                        className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
                                        disabled={chartLoadStatus === 'loading'}
                                    >
                                        {chartLoadStatus === 'loading' ? 'Loading...' : 'Reload Chart'}
                                    </button>
                                    
                                    {equivalenceChart && (
                                        <div className="mt-3 text-sm text-green-600">
                                            âœ… Loaded {equivalenceChart.symbols?.length || 0} symbols, {Object.keys(loadedSymbolImages).length} images
                                        </div>
                                    )}
                                </div>

                                <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
                                    <h3 className="font-semibold text-gray-800 mb-2">Detection Settings</h3>
                                    <div className="space-y-2">
                                        <div>
                                            <label className="text-sm">Sensitivity: {processingSettings.detectionSensitivity}</label>
                                            <input
                                                type="range"
                                                min="0.1"
                                                max="0.9"
                                                step="0.1"
                                                value={processingSettings.detectionSensitivity}
                                                onChange={(e) => setProcessingSettings(prev => ({
                                                    ...prev,
                                                    detectionSensitivity: parseFloat(e.target.value)
                                                }))}
                                                className="w-full"
                                            />
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <input
                                                type="checkbox"
                                                id="variantMatching"
                                                checked={processingSettings.variantMatching}
                                                onChange={(e) => setProcessingSettings(prev => ({
                                                    ...prev,
                                                    variantMatching: e.target.checked
                                                }))}
                                            />
                                            <label htmlFor="variantMatching" className="text-sm">Include variants</label>
                                        </div>
                                    </div>
                                </div>

                                <div className="space-y-3">
                                    <label className="block text-sm font-medium">Upload Inscription Image</label>
                                    <div className="flex items-center justify-center w-full">
                                        <label className="flex flex-col items-center justify-center w-full h-24 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100">
                                            <div className="flex flex-col items-center justify-center pt-3 pb-3">
                                                <Upload />
                                                <p className="text-xs text-gray-500 mt-1">Click to upload</p>
                                            </div>
                                            <input
                                                type="file"
                                                className="hidden"
                                                accept="image/*"
                                                onChange={handleImageUpload}
                                            />
                                        </label>
                                    </div>
                                </div>

                                <button
                                    onClick={detectSymbols}
                                    disabled={!uploadedImage || !equivalenceChart || isProcessing || !isOpenCVReady}
                                    className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-300 text-white font-medium py-3 px-4 rounded-lg flex items-center justify-center gap-2"
                                >
                                    {isProcessing ? (
                                        <>
                                            <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                                            Processing...
                                        </>
                                    ) : (
                                        <>
                                            <Zap />
                                            Detect Symbols
                                        </>
                                    )}
                                </button>
                            </div>

                            {/* Image Display */}
                            <div className="space-y-4">
                                <h3 className="font-semibold text-gray-800">Analysis</h3>
                                
                                <div className="relative bg-gray-100 rounded-lg overflow-hidden border-2 border-gray-200" style={{minHeight: '400px'}}>
                                    {uploadedImage ? (
                                        <div className="relative p-4">
                                            <img
                                                ref={imageRef}
                                                src={uploadedImage}
                                                alt="Hakli inscription"
                                                className="max-w-full h-auto"
                                                onLoad={() => {
                                                    if (recognitionResults.length > 0) {
                                                        setTimeout(drawDetectionResults, 100);
                                                    }
                                                }}
                                            />
                                            <canvas
                                                ref={canvasRef}
                                                className="absolute pointer-events-none"
                                                style={{ 
                                                    display: recognitionResults.length > 0 ? 'block' : 'none',
                                                    left: '16px',
                                                    top: '16px'
                                                }}
                                            />
                                        </div>
                                    ) : (
                                        <div className="text-center text-gray-500 p-8">
                                            <Camera />
                                            <p className="text-lg font-medium mb-2 mt-4">Upload Image</p>
                                            <p className="text-sm">Upload an inscription to analyze</p>
                                        </div>
                                    )}
                                </div>

                                {recognitionResults.length > 0 && (
                                    <div className="bg-green-50 border border-green-200 rounded-lg p-4">
                                        <h3 className="font-semibold text-green-800 mb-3">
                                            Detection Results ({recognitionResults.length} matches found)
                                        </h3>
                                        
                                        {/* Reconstructed Inscription */}
                                        <div className="mb-4 p-4 bg-white rounded-lg border">
                                            <div className="flex justify-between items-center mb-2">
                                                <h4 className="font-semibold text-gray-800">Reconstructed Inscription:</h4>
                                                <button
                                                    onClick={() => setWordBoundaries(new Set())}
                                                    className="text-xs bg-gray-500 text-white px-2 py-1 rounded hover:bg-gray-600"
                                                >
                                                    Clear Boundaries
                                                </button>
                                            </div>
                                            <div className="space-y-2">
                                                <div>
                                                    <span className="text-sm text-gray-600 mr-2">Latin:</span>
                                                    <span className="text-lg font-mono text-blue-800">
                                                        {formatInscriptionWithBoundaries(recognitionResults)}
                                                    </span>
                                                </div>
                                                
                                                <div dir="rtl">
                                                    <span className="text-sm text-gray-600 ml-2">Arabic:</span>
                                                    <span className="text-lg text-green-800">
                                                        {formatArabicWithBoundaries(recognitionResults)}
                                                    </span>
                                                </div>
                                                
                                                <div className="text-xs text-gray-500">
                                                    Average confidence: {(recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length * 100).toFixed(0)}%
                                                    | Reading direction: Left â†’ Right
                                                    | {recognitionResults.length} symbols detected
                                                    {wordBoundaries.size > 0 && ` | ${wordBoundaries.size} word boundaries`}
                                                </div>
                                            </div>
                                        </div>

                                        {/* Detection Feedback */}
                                        <div className="mb-4 p-3 bg-blue-50 rounded-lg">
                                            <h4 className="font-medium text-blue-800 mb-2 text-sm">Detection Summary:</h4>
                                            <div className="grid grid-cols-2 gap-3 text-xs">
                                                <div>
                                                    <span className="text-blue-700">Symbols Found:</span> {recognitionResults.length}
                                                </div>
                                                <div>
                                                    <span className="text-blue-700">Avg Confidence:</span> {(recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length * 100).toFixed(0)}%
                                                </div>
                                                <div>
                                                    <span className="text-blue-700">High Confidence:</span> {recognitionResults.filter(r => r.confidence > 0.7).length} symbols
                                                </div>
                                                <div>
                                                    <span className="text-blue-700">Match Types:</span> {recognitionResults.filter(r => r.matchType === 'primary').length}P / {recognitionResults.filter(r => r.matchType === 'variant').length}V
                                                </div>
                                            </div>
                                            
                                            {/* Quality Assessment */}
                                            <div className="mt-2 pt-2 border-t border-blue-200">
                                                <div className="text-xs">
                                                    <span className="text-blue-700">Quality Assessment:</span>
                                                    <span className={`ml-2 px-2 py-1 rounded ${
                                                        recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length > 0.7
                                                            ? 'bg-green-100 text-green-800'
                                                            : recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length > 0.5
                                                                ? 'bg-yellow-100 text-yellow-800'
                                                                : 'bg-red-100 text-red-800'
                                                    }`}>
                                                        {recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length > 0.7
                                                            ? 'High Quality'
                                                            : recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length > 0.5
                                                                ? 'Medium Quality'
                                                                : 'Low Quality'}
                                                    </span>
                                                </div>
                                                
                                                {/* Detection Tips */}
                                                {recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length < 0.6 && (
                                                    <div className="mt-2 text-xs text-gray-600">
                                                        ðŸ’¡ Try adjusting sensitivity or check image quality for better results
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                        <div className="mb-4 p-3 bg-gray-50 rounded-lg">
                                            <h4 className="font-medium text-gray-800 mb-2 text-sm">Visual Legend:</h4>
                                            <div className="flex gap-4 text-xs">
                                                <div className="flex items-center gap-2">
                                                    <div className="w-4 h-3 border-2 border-green-500"></div>
                                                    <span>Primary Match</span>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <div className="w-4 h-3 border-2 border-purple-500 border-dashed"></div>
                                                    <span>Variant Match</span>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Debug: Show Template Matching Regions */}
                                {recognitionResults.length > 0 && (
                                    <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                                        <h4 className="font-semibold text-yellow-800 mb-3">Template Matching Debug</h4>
                                        <div className="text-sm text-yellow-700 mb-3">
                                            These show the exact regions used for template matching:
                                        </div>
                                        <div className="grid grid-cols-4 gap-3 max-h-60 overflow-y-auto">
                                            {recognitionResults.map((result, index) => {
                                                // Create a debug canvas showing the matched region
                                                const debugCanvas = document.createElement('canvas');
                                                const debugCtx = debugCanvas.getContext('2d');
                                                debugCanvas.width = result.position.width;
                                                debugCanvas.height = result.position.height;
                                                
                                                // Draw the region from the source image
                                                if (imageRef.current) {
                                                    debugCtx.drawImage(
                                                        imageRef.current,
                                                        result.position.x, result.position.y, result.position.width, result.position.height,
                                                        0, 0, result.position.width, result.position.height
                                                    );
                                                }
                                                
                                                const debugDataUrl = debugCanvas.toDataURL();
                                                
                                                return (
                                                    <div key={index} className="bg-white rounded p-2 border">
                                                        <img 
                                                            src={debugDataUrl} 
                                                            alt={`Match #${index + 1}: ${result.symbol.name}`}
                                                            className="w-full h-auto border rounded mb-1"
                                                            style={{minHeight: '40px', maxHeight: '80px', objectFit: 'contain'}}
                                                        />
                                                        <div className="text-xs text-center">
                                                            <div className="font-medium">{result.symbol.name}</div>
                                                            <div className="text-gray-600">
                                                                {(result.confidence * 100).toFixed(0)}% â€¢ {result.matchType}
                                                            </div>
                                                            <div className="text-gray-500">
                                                                {result.position.width}Ã—{result.position.height}px
                                                            </div>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                        <div className="text-xs text-gray-600 mt-2">
                                            If these regions don't contain clear symbols, the template matching algorithm is working on the wrong areas.
                                        </div>
                                    </div>
                                )}
                                        <div className="space-y-2">
                                            <div className="flex justify-between items-center">
                                                <h4 className="font-medium text-gray-800">Individual Matches:</h4>
                                                <div className="text-xs text-gray-600">
                                                    Sorted by position (left â†’ right)
                                                </div>
                                            </div>
                                            {recognitionResults
                                                .sort((a, b) => a.position.x - b.position.x)
                                                .map((result, index) => (
                                                <div key={index} className={`bg-white rounded p-3 border-l-4 ${
                                                    result.confidence > 0.7 ? 'border-green-500' : 
                                                    result.confidence > 0.5 ? 'border-yellow-500' : 'border-red-500'
                                                }`}>
                                                    <div className="flex justify-between items-center">
                                                        <div className="flex items-center gap-3">
                                                            <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
                                                                #{index + 1}
                                                            </span>
                                                            <div>
                                                                <div className="flex items-center gap-2">
                                                                    <span className="font-medium">{result.symbol.name}</span>
                                                                    {result.symbol.arabic && (
                                                                        <span className="text-lg">({result.symbol.arabic})</span>
                                                                    )}
                                                                    <span className={`text-xs px-2 py-1 rounded ${
                                                                        result.matchType === 'primary' ? 'bg-green-100 text-green-700' : 'bg-purple-100 text-purple-700'
                                                                    }`}>
                                                                        {result.matchType}{result.variantIndex !== undefined && ` v${result.variantIndex + 1}`}
                                                                    </span>
                                                                </div>
                                                                <div className="text-xs text-gray-500 mt-1">
                                                                    Position: ({result.position.x}, {result.position.y}) â€¢ 
                                                                    Size: {result.position.width}Ã—{result.position.height}px
                                                                </div>
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-2">
                                                            <button
                                                                onClick={() => toggleWordBoundary(index)}
                                                                className={`text-xs px-2 py-1 rounded transition-colors ${
                                                                    wordBoundaries.has(index)
                                                                        ? 'bg-purple-500 text-white'
                                                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                                }`}
                                                                title={wordBoundaries.has(index) ? "Remove word boundary" : "Add word boundary before this symbol"}
                                                            >
                                                                {wordBoundaries.has(index) ? '| Word' : '+ Word'}
                                                            </button>
                                                            <div className="text-right">
                                                                <div className={`px-2 py-1 rounded text-sm font-medium ${
                                                                    result.confidence > 0.7 
                                                                        ? 'bg-green-100 text-green-800' 
                                                                        : result.confidence > 0.5
                                                                            ? 'bg-yellow-100 text-yellow-800'
                                                                            : 'bg-red-100 text-red-800'
                                                                }`}>
                                                                    {(result.confidence * 100).toFixed(0)}%
                                                                </div>
                                                                <div className="text-xs text-gray-500 mt-1">
                                                                    {result.confidence > 0.8 ? 'Excellent' :
                                                                     result.confidence > 0.6 ? 'Good' :
                                                                     result.confidence > 0.4 ? 'Fair' : 'Poor'}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<HakliSymbolRecognizer />);
    </script>
</body>
</html>