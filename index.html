<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Glyph Recognizer</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        var isOpenCvReady = false;
        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('OpenCV.js is ready');
        }
    </script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        .detection-box {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
            border: 3px solid;
            border-radius: 4px;
            cursor: pointer;
        }
        .detection-box.validated-correct { border-color: #10b981; background: rgba(16, 185, 129, 0.25); }
        .detection-box.validated-incorrect { border-color: #ef4444; background: rgba(239, 68, 68, 0.25); }
        .detection-box.unvalidated { border-color: #3b82f6; background: rgba(59, 130, 246, 0.25); }
        .detection-box.selected { border-color: #f59e0b; background: rgba(245, 158, 11, 0.3); border-width: 4px; }

        .detection-label {
            position: absolute;
            top: -25px;
            left: 0;
            padding: 2px 8px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            border-radius: 3px;
            white-space: nowrap;
            opacity: 0.9;
        }
        
        .canvas-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }
        
        .manual-selection-box {
            position: absolute;
            border: 2px dashed #f59e0b;
            background: rgba(245, 158, 11, 0.1);
            pointer-events: none;
            z-index: 5;
        }
        
        .region-boundary {
            position: absolute;
            border: 1px solid rgba(156, 163, 175, 0.5);
            background: rgba(156, 163, 175, 0.05);
            pointer-events: none;
            z-index: 3;
        }
        
        .merge-indicator {
            position: absolute;
            border: 3px solid #8b5cf6;
            background: rgba(139, 92, 246, 0.15);
            border-radius: 8px;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function HakliGlyphRecognizer() {
            const [image, setImage] = useState(null);
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [chartLoadStatus, setChartLoadStatus] = useState('not-loaded');
            const [loadedGlyphImages, setLoadedGlyphImages] = useState({});
            const [manualDetectionMode, setManualDetectionMode] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawStart, setDrawStart] = useState(null);
            const [drawCurrent, setDrawCurrent] = useState(null);
            const [selectedRegions, setSelectedRegions] = useState(new Set());
            const [validations, setValidations] = useState({});
            const [actionHistory, setActionHistory] = useState([]);
            const [isolatedGlyphs, setIsolatedGlyphs] = useState([]);
            const [showRegionBoundaries, setShowRegionBoundaries] = useState(false);
            const [mergeIndicator, setMergeIndicator] = useState(null);
            const [processingProgress, setProcessingProgress] = useState({ current: 0, total: 0 });
            const [imageLoadingProgress, setImageLoadingProgress] = useState({ loaded: 0, total: 0 });

            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);

            const [viewMode, setViewMode] = useState('detection'); // 'detection' or 'reading'
            const [readingDirection, setReadingDirection] = useState('detection'); // 'detection', 'ltr', 'rtl', 'ttb'
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [readingOrder, setReadingOrder] = useState([]); // Array of indices for manual ordering
            const [draggedItem, setDraggedItem] = useState(null);
            const [correctionMode, setCorrectionMode] = useState(null); // Index of detection being corrected, or null
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [stateHistory, setStateHistory] = useState([]);
            const [confidenceThreshold, setConfidenceThreshold] = useState(0);
            const [useConfidenceFilter, setUseConfidenceFilter] = useState(false);
            const [showCloudSyncModal, setShowCloudSyncModal] = useState(false);
            const [customGistUrl, setCustomGistUrl] = useState('');
            const [trimMode, setTrimMode] = useState(null); // Index of detection being trimmed, or null
            const [excludeMode, setExcludeMode] = useState(null); // Index of detection being excluded, or null
            const [excludeRegions, setExcludeRegions] = useState([]); // Array of exclusion boxes
            const [selectedIsolatedRegion, setSelectedIsolatedRegion] = useState(null); // to enable delete when show isolated
            const [templateTrainingMode, setTemplateTrainingMode] = useState(false); // add glyph to template 
            const [selectedForTemplate, setSelectedForTemplate] = useState(null);

            const MASTER_PASTE_URL = ''; // Will update after first upload
            const MASTER_PASTE_RAW_URL = ''; // Will update after first upload

            // ============================================
            // UTILITY FUNCTIONS
            // ============================================
            
            const convertToGitHubUrl = (githubUrl) => {
                if (!githubUrl) return null;
                if (githubUrl.indexOf('http') === 0) {
                    if (githubUrl.indexOf('github.com') !== -1 && githubUrl.indexOf('/blob/') !== -1) {
                        return githubUrl.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                    }
                    return githubUrl;
                }
                if (typeof githubUrl === 'string' && githubUrl.length > 0) {
                    const baseUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/';
                    const cleanPath = githubUrl.indexOf('/') === 0 ? githubUrl.substring(1) : githubUrl;
                    return baseUrl + cleanPath;
                }
                return null;
            };

            const getImageCoordinates = (event) => {
                if (!imageRef.current) return null;
                const rect = imageRef.current.getBoundingClientRect();
                const scaleX = imageRef.current.naturalWidth / rect.width;
                const scaleY = imageRef.current.naturalHeight / rect.height;
                return {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            };

            const extractRegionThumbnail = (inputImage, region) => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = region.bounds.width;
                    canvas.height = region.bounds.height;

                    ctx.drawImage(
                        inputImage,
                        region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height,
                        0, 0, region.bounds.width, region.bounds.height
                    );

                    return canvas.toDataURL();
                } catch (error) {
                    console.error('Thumbnail extraction error:', error);
                    return null;
                }
            };

            const calculateIoU = (box1, box2) => {
                const x1 = Math.max(box1.x, box2.x);
                const y1 = Math.max(box1.y, box2.y);
                const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
                const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

                const intersectionArea = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
                const box1Area = box1.width * box1.height;
                const box2Area = box2.width * box2.height;
                const unionArea = box1Area + box2Area - intersectionArea;

                return unionArea > 0 ? intersectionArea / unionArea : 0;
            };

            // Add this utility function at the top
            const preprocessImageForMatching = (img) => {
                let gray = new cv.Mat();
                const binary = new cv.Mat();
                const processed = new cv.Mat();

                if (img.channels() > 1) {
                    cv.cvtColor(img, gray, cv.COLOR_RGBA2GRAY);
                } else {
                    img.copyTo(gray);
                }

                cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 3);

                // Lighter preprocessing for ancient inscriptions
                const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                cv.morphologyEx(binary, processed, cv.MORPH_CLOSE, kernel);

                // Skip MORPH_OPEN and erosion - they fragment ancient inscriptions
                // cv.morphologyEx(processed, processed, cv.MORPH_OPEN, kernel);
                // const thinKernel = cv.getStructuringElement(cv.MORPH_CROSS, new cv.Size(2, 2));
                // cv.erode(processed, processed, thinKernel, new cv.Point(-1, -1), 1);

                kernel.delete();
                // thinKernel.delete();  // Commented out since we're not creating it
                gray.delete();
                binary.delete();

                return processed;
            };

            // ============================================
            // GLYPH ISOLATION & RECOGNITION
            // ============================================

            const isolateGlyphs = (inputImage) => {
                if (!isOpenCvReady) return [];
                try {
                    const src = cv.imread(inputImage);
                    const gray = new cv.Mat();
                    const binary = new cv.Mat();
                    const denoised = new cv.Mat();
                    const processed = new cv.Mat();

                    // Convert to grayscale
                    if (src.channels() > 1) {
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    } else {
                        src.copyTo(gray);
                    }
                    // Adaptive thresholding
                    cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

                    // Remove noise with opening (erosion then dilation)
                    const smallKernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(2, 2));
                    cv.morphologyEx(binary, denoised, cv.MORPH_OPEN, smallKernel);

                    // Connect broken strokes with closing (dilation then erosion)
                    const largeKernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                    cv.morphologyEx(denoised, processed, cv.MORPH_CLOSE, largeKernel);

                    // Find contours
                    const contours = new cv.MatVector();
                    const hierarchy = new cv.Mat();
                    cv.findContours(processed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    const isolatedRegions = [];

                    // Calculate dynamic thresholds based on image size
                    const imageArea = src.rows * src.cols;
                    const minArea = imageArea * 0.002;  // 20x larger - will filter out small noise
                    const maxArea = imageArea * 0.05;   // 5% of image

                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const boundingRect = cv.boundingRect(contour);
                        const area = boundingRect.width * boundingRect.height;
                        const aspectRatio = boundingRect.width / boundingRect.height;

                        // Calculate solidity (ratio of contour area to bounding box area)
                        const contourArea = cv.contourArea(contour);
                        const solidity = contourArea / area;

                        // Filter criteria
                        const sizeOk = area >= minArea && area <= maxArea;
                        const aspectOk = aspectRatio >= 0.2 && aspectRatio <= 5.0;
                        const solidityOk = solidity >= 0.3; // Reject very sparse/noisy regions

                        if (sizeOk && aspectOk && solidityOk) {
                            const padding = 5;
                            isolatedRegions.push({
                                bounds: {
                                    x: Math.max(0, boundingRect.x - padding),
                                    y: Math.max(0, boundingRect.y - padding),
                                    width: Math.min(src.cols - boundingRect.x + padding, boundingRect.width + 2 * padding),
                                    height: Math.min(src.rows - boundingRect.y + padding, boundingRect.height + 2 * padding)
                                },
                                area,
                                aspectRatio,
                                solidity
                            });
                        }
                    }

                    // Sort by position (left to right, top to bottom)
                    isolatedRegions.sort((a, b) => {
                        const rowDiff = a.bounds.y - b.bounds.y;
                        if (Math.abs(rowDiff) > 20) return rowDiff; // Different rows
                        return a.bounds.x - b.bounds.x; // Same row, sort by x
                    });

                    console.log(`‚úì Isolated ${isolatedRegions.length} regions`);

                    // Cleanup
                    src.delete();
                    gray.delete();
                    binary.delete();
                    denoised.delete();
                    processed.delete();
                    smallKernel.delete();
                    largeKernel.delete();
                    contours.delete();
                    hierarchy.delete();

                    return isolatedRegions;
                } catch (error) {
                    console.error('Glyph isolation error:', error);
                    return [];
                }
            };

            const performTemplateMatchingOnRegion = (inputImage, templateImage, region, glyphId) => {
                if (!isOpenCvReady) return [];
                try {
                    const src = cv.imread(inputImage);
                    const regionMat = src.roi(new cv.Rect(region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height));
                    const templ = cv.imread(templateImage);
                    const matches = [];

                    // Enhanced preprocessing - normalize both images
                    const preprocessForShape = (img) => {
                        let gray = new cv.Mat();
                        const binary = new cv.Mat();
                        const processed = new cv.Mat();  // ADD THIS LINE

                        // Convert to grayscale
                        if (img.channels() > 1) {
                            cv.cvtColor(img, gray, cv.COLOR_RGBA2GRAY);
                        } else {
                            img.copyTo(gray);
                        }

                        // Adaptive threshold
                        cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 3);

                        // Lighter preprocessing for ancient inscriptions
                        const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                        cv.morphologyEx(binary, processed, cv.MORPH_CLOSE, kernel);

                        // Skip aggressive erosion that fragments Glyphs
                        // const thinKernel = cv.getStructuringElement(cv.MORPH_CROSS, new cv.Size(3, 3));
                        // cv.erode(processed, processed, thinKernel, new cv.Point(-1, -1), 2);

                        kernel.delete();
                        // thinKernel.delete();  // Commented out
                        gray.delete();
                        binary.delete();

                        return processed;  // CHANGE FROM 'normalized' TO 'processed'
                    };

                    const processedRegion = preprocessForShape(regionMat);
                    const processedTemplate = preprocessForShape(templ);

                    // Method 1: Contour Shape Matching (PRIMARY)
                    let shapeScore = 0;
                    let shapeMethod = 'none';
                    try {
                        const contoursRegion = new cv.MatVector();
                        const contoursTemplate = new cv.MatVector();
                        const hierarchy = new cv.Mat();

                        cv.findContours(processedRegion, contoursRegion, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                        cv.findContours(processedTemplate, contoursTemplate, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                        if (contoursRegion.size() > 0 && contoursTemplate.size() > 0) {
                            // Find largest contour in each
                            let maxAreaRegion = 0;
                            let maxContourRegionIdx = 0;
                            for (let i = 0; i < contoursRegion.size(); i++) {
                                const area = cv.contourArea(contoursRegion.get(i));
                                if (area > maxAreaRegion) {
                                    maxAreaRegion = area;
                                    maxContourRegionIdx = i;
                                }
                            }

                            let maxAreaTemplate = 0;
                            let maxContourTemplateIdx = 0;
                            for (let i = 0; i < contoursTemplate.size(); i++) {
                                const area = cv.contourArea(contoursTemplate.get(i));
                                if (area > maxAreaTemplate) {
                                    maxAreaTemplate = area;
                                    maxContourTemplateIdx = i;
                                }
                            }

                            // Try all 3 shape matching methods
                            const methods = [
                                { method: cv.CONTOURS_MATCH_I1, name: 'I1' },
                                { method: cv.CONTOURS_MATCH_I2, name: 'I2' },
                                { method: cv.CONTOURS_MATCH_I3, name: 'I3' }
                            ];

                            let bestShapeScore = 0;
                            for (const m of methods) {
                                try {
                                    const shapeDiff = cv.matchShapes(
                                        contoursRegion.get(maxContourRegionIdx),
                                        contoursTemplate.get(maxContourTemplateIdx),
                                        m.method,
                                        0
                                    );

                                    // Convert distance to similarity (lower distance = higher score)
                                    // Different methods have different scales
                                    let score = 0;
                                    if (m.method === cv.CONTOURS_MATCH_I1) {
                                        score = Math.max(0, 1 - (shapeDiff / 3)); // I1 tends to give values 0-3
                                    } else if (m.method === cv.CONTOURS_MATCH_I2) {
                                        score = Math.max(0, 1 - (shapeDiff / 5)); // I2 tends to give values 0-5
                                    } else {
                                        score = Math.max(0, 1 - (shapeDiff / 10)); // I3 can give larger values
                                    }

                                    if (score > bestShapeScore) {
                                        bestShapeScore = score;
                                        shapeMethod = m.name;
                                    }
                                } catch (e) {
                                    // Method failed, skip
                                }
                            }

                            shapeScore = bestShapeScore;
                        }

                        contoursRegion.delete();
                        contoursTemplate.delete();
                        hierarchy.delete();
                    } catch (shapeError) {
                        console.log(`Shape matching failed for ${glyphId}:`, shapeError);
                        shapeScore = 0;
                    }

                    // Method 2: Aspect Ratio Similarity
                    let aspectScore = 0;
                    const regionAspect = processedRegion.cols / processedRegion.rows;
                    const templateAspect = processedTemplate.cols / processedTemplate.rows;
                    const aspectDiff = Math.abs(regionAspect - templateAspect);
                    aspectScore = Math.max(0, 1 - aspectDiff);

                    // Method 3: Template Matching (SECONDARY - only best scale)
                    let templateScore = 0;
                    let bestScale = 1.0;
                    try {
                        // Try fewer scales, focus on likely matches :: added more scales because not matching
                        const scales = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 1.1, 1.2];  

                        for (const scale of scales) {
                            const scaledTempl = new cv.Mat();
                            const newSize = new cv.Size(
                                Math.floor(processedTemplate.cols * scale),
                                Math.floor(processedTemplate.rows * scale)
                            );

                            if (newSize.width < 10 || newSize.height < 10 ||
                                newSize.width > processedRegion.cols || newSize.height > processedRegion.rows) {
                                continue;
                            }

                            cv.resize(processedTemplate, scaledTempl, newSize, 0, 0, cv.INTER_AREA);

                            const dst = new cv.Mat();
                            cv.matchTemplate(processedRegion, scaledTempl, dst, cv.TM_CCOEFF_NORMED);
                            const result = cv.minMaxLoc(dst);

                            if (result.maxVal > templateScore) {
                                templateScore = result.maxVal;
                                bestScale = scale;
                            }

                            dst.delete();
                            scaledTempl.delete();
                        }
                    } catch (e) {
                        templateScore = 0;
                    }

                    // Weighted combination - SHAPE is primary
                    const weights = {
                        shape: 0.70,      // Shape matching is most important
                        aspect: 0.15,     // Aspect ratio helps
                        template: 0.15    // Template is just a tiebreaker
                    };

                    const combinedScore = (shapeScore * weights.shape) +
                        (aspectScore * weights.aspect) +
                        (templateScore * weights.template);

                    // Only log low confidence matches (might be wrong) and high confidence (definitely right)
                    if (combinedScore < 0.5 || combinedScore > 0.8) {
                        console.log(`Glyph ${glyphId}: Combined=${(combinedScore * 100).toFixed(1)}% [Shape=${(shapeScore * 100).toFixed(1)}% Aspect=${(aspectScore * 100).toFixed(1)}% Template=${(templateScore * 100).toFixed(1)}%]`);
                    }

                    // Lower threshold since we're focusing on shape (raised to .4 from .3 : .3 was lower shape)
                    if (combinedScore >= 0.40) {  // Stricter threshold
                        matches.push({
                            confidence: combinedScore,
                            position: region.bounds,
                            scale: bestScale,
                            debug: {
                                shapeScore: shapeScore,
                                aspectScore: aspectScore,
                                templateScore: templateScore,
                                shapeMethod: shapeMethod
                            }
                        });
                    }

                    processedRegion.delete();
                    processedTemplate.delete();
                    src.delete();
                    regionMat.delete();
                    templ.delete();

                    return matches;
                } catch (error) {
                    console.error('Shape matching error:', error);
                    return [];
                }
            };

            const applyNonMaximumSuppression = (detections, iouThreshold = 0.3) => {
                if (detections.length === 0) return detections;

                // Sort by confidence (highest first)
                const sorted = [...detections].sort((a, b) => b.confidence - a.confidence);
                const keep = [];

                while (sorted.length > 0) {
                    const current = sorted.shift();
                    keep.push(current);

                    // Remove detections that overlap too much with current
                    for (let i = sorted.length - 1; i >= 0; i--) {
                        const iou = calculateIoU(current.position, sorted[i].position);
                        if (iou > iouThreshold) {
                            sorted.splice(i, 1);
                        }
                    }
                }

                return keep;
            };

            const recognizeGlyphs = () => {
                if (!image || !equivalenceChart || !isOpenCvReady) return;
                setIsProcessing(true);
                setRecognitionResults([]);
                console.log('Starting recognition with', equivalenceChart.glyphs.length, 'Glyphs and', Object.keys(loadedGlyphImages).length, 'loaded images');
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        try {
                        const isolated = isolateGlyphs(tempImg);
                        const isolatedWithThumbnails = isolated.map(region => ({
                            ...region,
                            thumbnail: extractRegionThumbnail(tempImg, region)
                        }));
                        setIsolatedGlyphs(isolatedWithThumbnails);
                        console.log('‚úì Isolated', isolated.length, 'regions');
                        if (isolated.length === 0) {
                            console.log('No regions found - check image contrast and size');
                            setIsProcessing(false);
                            return;
                        }

                        const results = [];
                        let totalMatches = 0;
                        const totalRegions = isolated.length;

                        // Loop through each region with progress tracking
                        for (let regionIndex = 0; regionIndex < isolated.length; regionIndex++) {
                            const region = isolated[regionIndex];

                            // Update progress
                            setProcessingProgress({ current: regionIndex + 1, total: totalRegions });
                            console.log('üìä Progress:', regionIndex + 1, 'of', totalRegions);    

                            let bestMatch = null;
                            let bestRawConfidence = 0; // Track unweighted confidence for fair comparison

                            for (const glyph of equivalenceChart.glyphs) {
                                // Check primary image
                                if (loadedGlyphImages[glyph.id]) {
                                    const matches = performTemplateMatchingOnRegion(tempImg, loadedGlyphImages[glyph.id], region, glyph.id);
                                    totalMatches += matches.length;
                                    for (const match of matches) {
                                        if (match.confidence > bestRawConfidence) {
                                            bestRawConfidence = match.confidence;
                                            bestMatch = {
                                                glyph,
                                                confidence: match.confidence,
                                                position: region.bounds,
                                                matchType: 'primary'
                                            };
                                        }
                                    }
                                }

                                // Check variant images
                                if (glyph.images && glyph.images.variants) {
                                    for (let i = 0; i < glyph.images.variants.length; i++) {
                                        const variantKey = `${glyph.id}_variant_${i}`;
                                        if (loadedGlyphImages[variantKey]) {
                                            const matches = performTemplateMatchingOnRegion(tempImg, loadedGlyphImages[variantKey], region, `${glyph.id}_v${i}`);
                                            for (const match of matches) {
                                                const weightedConfidence = match.confidence * 0.95; // Less penalty
                                                if (match.confidence > bestRawConfidence) { // Compare UNWEIGHTED
                                                    bestRawConfidence = match.confidence;
                                                    bestMatch = {
                                                        glyph,
                                                        confidence: weightedConfidence, // Store weighted
                                                        position: region.bounds,
                                                        matchType: 'variant',
                                                        variantIndex: i
                                                    };
                                                }
                                            }
                                        }
                                    }
                                }

                                // Check example images
                                if (glyph.images && glyph.images.examples) {
                                    for (let i = 0; i < glyph.images.examples.length; i++) {
                                        const exampleKey = `${glyph.id}_example_${i}`;
                                        if (loadedGlyphImages[exampleKey]) {
                                            const matches = performTemplateMatchingOnRegion(tempImg, loadedGlyphImages[exampleKey], region, `${glyph.id}_ex${i}`);
                                            for (const match of matches) {
                                                const weightedConfidence = match.confidence * 0.90; // Less penalty
                                                if (match.confidence > bestRawConfidence) { // Compare UNWEIGHTED
                                                    bestRawConfidence = match.confidence;
                                                    bestMatch = {
                                                        glyph,
                                                        confidence: weightedConfidence, // Store weighted
                                                        position: region.bounds,
                                                        matchType: 'example',
                                                        exampleIndex: i
                                                    };
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            if (bestMatch && bestMatch.confidence > 0.30) {
                                results.push({
                                    ...bestMatch,
                                    regionIndex: regionIndex
                                });
                                console.log(`‚úÖ Region ${regionIndex + 1}: ${bestMatch.glyph.name} (${Math.round(bestMatch.confidence * 100)}%)`);
                            }
                        }
                        // Reset progress when done
                        setProcessingProgress({ current: 0, total: 0 });

                        // Apply non-maximum suppression to remove overlapping detections
                        const filteredResults = applyNonMaximumSuppression(results, 0.3);
                        console.log(`‚úì Recognition complete: ${filteredResults.length} glyphs detected (${results.length - filteredResults.length} overlapping removed)`);

                        // Apply confidence threshold filter based on slider value
                        const confidenceFilteredResults = filteredResults.filter(r =>
                            r.confidence >= (confidenceThreshold / 100)
                        );

                        console.log(`‚úì After confidence filter (${confidenceThreshold}%): ${confidenceFilteredResults.length} glyphs (${filteredResults.length - confidenceFilteredResults.length} filtered out)`);

                        setRecognitionResults(confidenceFilteredResults);
                        setIsProcessing(false);
                    } catch (error) {
                        console.error('Recognition error:', error);
                        setIsProcessing(false);
                    }
                };
                tempImg.src = image;
            };  // end recognizeGlyphs

            // ============================================
            // DETECTION MANIPULATION
            // ============================================

            const validateDetection = (detectionIndex, isCorrect) => {
                recordAction('validation', {
                    detectionIndex,
                    isCorrect,
                    detectionData: recognitionResults[detectionIndex]
                });
                setValidations(prev => ({
                    ...prev,
                    [detectionIndex]: {
                        isCorrect,
                        timestamp: new Date().toISOString(),
                        detectionData: recognitionResults[detectionIndex]
                    }
                }));
            };

            const deleteIsolatedRegion = (regionIndex) => {
                recordAction('delete_isolated_region', {
                    index: regionIndex,
                    region: isolatedGlyphs[regionIndex]
                });

                // Remove the isolated region
                setIsolatedGlyphs(prev => prev.filter((_, i) => i !== regionIndex));

                // Remove any detections that reference this region
                setRecognitionResults(prev => prev.filter(r => r.regionIndex !== regionIndex).map(r => ({
                    ...r,
                    regionIndex: r.regionIndex > regionIndex ? r.regionIndex - 1 : r.regionIndex
                })));

                // Clear selection
                setSelectedIsolatedRegion(null);

                console.log(`‚úì Deleted isolated region ${regionIndex}`);
            };

            const deleteDetection = (detectionIndex) => {
                recordAction('delete_detection', {
                    index: detectionIndex,
                    detection: recognitionResults[detectionIndex]
                });
                // Update recognition results
                setRecognitionResults(prev => prev.filter((_, i) => i !== detectionIndex));
                // Update validations with shifted indices
                setValidations(prev => {
                    const newValidations = { ...prev };
                    delete newValidations[detectionIndex];
                    const shifted = {};
                    Object.keys(newValidations).forEach(key => {
                        const numKey = parseInt(key);
                        shifted[numKey > detectionIndex ? numKey - 1 : numKey] = newValidations[key];
                    });
                    return shifted;
                });
                // Update selected regions - remove deleted index and shift others
                setSelectedRegions(prev => {
                    const newSet = new Set();
                    prev.forEach(idx => {
                        if (idx !== detectionIndex) {
                            // Shift down indices that come after the deleted one
                            newSet.add(idx > detectionIndex ? idx - 1 : idx);
                        }
                    });
                    return newSet;
                });
                // Clear merge indicator if it existed
                setMergeIndicator(null);
            };

            const mergeSelectedDetections = () => {
                const selectedIndices = Array.from(selectedRegions).sort((a, b) => a - b);
                if (selectedIndices.length < 2) {
                    alert('Please select at least 2 detections to merge');
                    return;
                }

                const detectionsToMerge = selectedIndices.map(i => recognitionResults[i]);
                const minX = Math.min(...detectionsToMerge.map(d => d.position.x));
                const minY = Math.min(...detectionsToMerge.map(d => d.position.y));
                const maxX = Math.max(...detectionsToMerge.map(d => d.position.x + d.position.width));
                const maxY = Math.max(...detectionsToMerge.map(d => d.position.y + d.position.height));

                const baseDetection = detectionsToMerge.reduce((best, current) =>
                    current.confidence > best.confidence ? current : best
                );

                const mergedBounds = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };

                // Extract new thumbnail for merged region
                const mergedThumbnail = extractRegionThumbnail(imageRef.current, { bounds: mergedBounds });

                const mergedDetection = {
                    ...baseDetection,
                    position: mergedBounds,
                    confidence: detectionsToMerge.reduce((sum, d) => sum + d.confidence, 0) / detectionsToMerge.length,
                    mergedFrom: detectionsToMerge.length,
                    isMerged: true,
                    thumbnail: mergedThumbnail,  // Add the new thumbnail
                    regionIndex: isolatedGlyphs.length  // Will be the next index
                };

                recordAction('merge_detections', {
                    indices: selectedIndices,
                    detections: detectionsToMerge,
                    mergedResult: mergedDetection
                });

                // Remove the merged detections
                let newResults = recognitionResults.slice();
                for (let i = selectedIndices.length - 1; i >= 0; i--) {
                    newResults.splice(selectedIndices[i], 1);
                }
                newResults.push(mergedDetection);

                // Add merged region to isolated glyphs
                setIsolatedGlyphs(prev => [...prev, {
                    bounds: mergedBounds,
                    thumbnail: mergedThumbnail,
                    area: mergedBounds.width * mergedBounds.height,
                    aspectRatio: mergedBounds.width / mergedBounds.height
                }]);

                setRecognitionResults(newResults);
                setSelectedRegions(new Set());
                setMergeIndicator(null);
            };

            const applyTrim = (detectionIndex, newBounds) => {
                const detection = recognitionResults[detectionIndex];
                const oldBounds = detection.position;

                // Ensure new bounds are within old bounds
                const trimmedBounds = {
                    x: Math.max(oldBounds.x, newBounds.x),
                    y: Math.max(oldBounds.y, newBounds.y),
                    width: Math.min(newBounds.x + newBounds.width, oldBounds.x + oldBounds.width) - Math.max(oldBounds.x, newBounds.x),
                    height: Math.min(newBounds.y + newBounds.height, oldBounds.y + oldBounds.height) - Math.max(oldBounds.y, newBounds.y)
                };

                if (trimmedBounds.width < 10 || trimmedBounds.height < 10) {
                    alert('‚ùå Trimmed region too small. Try again.');
                    setTrimMode(null);
                    return;
                }

                // Extract new thumbnail
                const thumbnail = extractRegionThumbnail(imageRef.current, { bounds: trimmedBounds });

                // Update the detection
                const updatedDetection = {
                    ...detection,
                    position: trimmedBounds,
                    thumbnail: thumbnail,
                    trimmed: true,
                    originalBounds: oldBounds
                };

                // Update isolated glyph if it exists
                if (detection.regionIndex !== undefined) {
                    setIsolatedGlyphs(prev => {
                        const updated = [...prev];
                        updated[detection.regionIndex] = {
                            bounds: trimmedBounds,
                            thumbnail: thumbnail,
                            area: trimmedBounds.width * trimmedBounds.height,
                            aspectRatio: trimmedBounds.width / trimmedBounds.height
                        };
                        return updated;
                    });
                }

                // Update recognition results
                setRecognitionResults(prev =>
                    prev.map((r, i) => i === detectionIndex ? updatedDetection : r)
                );

                recordAction('trim_detection', {
                    index: detectionIndex,
                    oldBounds,
                    newBounds: trimmedBounds
                });

                setTrimMode(null);
                alert('‚úÖ Detection trimmed! You may want to correct the glyph if recognition changed.');
            };

            const applyExclude = (detectionIndex) => {
                if (excludeRegions.length === 0) {
                    alert('‚ùå No exclusion regions drawn. Draw at least one region to exclude.');
                    return;
                }

                const detection = recognitionResults[detectionIndex];
                const originalBounds = detection.position;

                try {
                    // Create a mask of the original region
                    const tempImg = new Image();
                    tempImg.src = image;

                    tempImg.onload = () => {
                        const src = cv.imread(tempImg);
                        const regionMat = src.roi(new cv.Rect(
                            originalBounds.x,
                            originalBounds.y,
                            originalBounds.width,
                            originalBounds.height
                        ));

                        // Create mask (white = keep, black = exclude)
                        const mask = new cv.Mat(regionMat.rows, regionMat.cols, cv.CV_8UC1, new cv.Scalar(255));

                        // Draw exclusion regions on mask
                        excludeRegions.forEach(exRegion => {
                            // Convert absolute coords to relative coords within detection
                            const relX = exRegion.x - originalBounds.x;
                            const relY = exRegion.y - originalBounds.y;
                            const relWidth = exRegion.width;
                            const relHeight = exRegion.height;

                            // Only process if exclusion overlaps with detection
                            if (relX < regionMat.cols && relY < regionMat.rows &&
                                relX + relWidth > 0 && relY + relHeight > 0) {
                                const point1 = new cv.Point(
                                    Math.max(0, relX),
                                    Math.max(0, relY)
                                );
                                const point2 = new cv.Point(
                                    Math.min(regionMat.cols, relX + relWidth),
                                    Math.min(regionMat.rows, relY + relHeight)
                                );
                                cv.rectangle(mask, point1, point2, new cv.Scalar(0), -1); // Fill with black
                            }
                        });

                        // Apply mask to find remaining contours
                        const gray = new cv.Mat();
                        const binary = new cv.Mat();

                        if (regionMat.channels() > 1) {
                            cv.cvtColor(regionMat, gray, cv.COLOR_RGBA2GRAY);
                        } else {
                            regionMat.copyTo(gray);
                        }

                        cv.threshold(gray, binary, 127, 255, cv.THRESH_BINARY);

                        // Apply mask
                        const masked = new cv.Mat();
                        cv.bitwise_and(binary, mask, masked);

                        // Find contours in masked region
                        const contours = new cv.MatVector();
                        const hierarchy = new cv.Mat();
                        cv.findContours(masked, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                        // Cleanup function defined BEFORE use
                        const cleanupMats = () => {
                            src.delete();
                            regionMat.delete();
                            mask.delete();
                            gray.delete();
                            binary.delete();
                            masked.delete();
                            contours.delete();
                            hierarchy.delete();
                        };

                        if (contours.size() === 0) {
                            alert('‚ùå Exclusion removed all content. Canceling.');
                            cleanupMats();
                            setExcludeMode(null);
                            setExcludeRegions([]);
                            return;
                        }

                        // Get bounding boxes of remaining contours
                        const newDetections = [];
                        for (let i = 0; i < contours.size(); i++) {
                            const boundingRect = cv.boundingRect(contours.get(i));
                            const area = boundingRect.width * boundingRect.height;

                            if (area > 100) { // Minimum size
                                const absoluteBounds = {
                                    x: originalBounds.x + boundingRect.x,
                                    y: originalBounds.y + boundingRect.y,
                                    width: boundingRect.width,
                                    height: boundingRect.height
                                };

                                const thumbnail = extractRegionThumbnail(tempImg, { bounds: absoluteBounds });

                                newDetections.push({
                                    glyph: { id: 'unknown', name: 'Unknown', transliteration: '?' },
                                    confidence: 0.5,
                                    position: absoluteBounds,
                                    matchType: 'excluded',
                                    isExcluded: true,
                                    thumbnail: thumbnail,
                                    regionIndex: isolatedGlyphs.length + newDetections.length
                                });
                            }
                        }

                        cleanupMats();

                        if (newDetections.length === 0) {
                            alert('‚ùå No valid regions remained after exclusion.');
                            setExcludeMode(null);
                            setExcludeRegions([]);
                            return;
                        }

                        const oldGlyph = detection.glyph.name;

                        // Remove old detection and add new ones
                        setRecognitionResults(prev => {
                            const updated = [...prev];
                            updated.splice(detectionIndex, 1); // Remove original
                            return [...updated, ...newDetections]; // Add new ones
                        });

                        // Add to isolated glyphs
                        newDetections.forEach(det => {
                            setIsolatedGlyphs(prev => [...prev, {
                                bounds: det.position,
                                thumbnail: det.thumbnail,
                                area: det.position.width * det.position.height,
                                aspectRatio: det.position.width / det.position.height
                            }]);
                        });

                        recordAction('exclude_regions', {
                            originalIndex: detectionIndex,
                            originalGlyph: oldGlyph,
                            exclusions: excludeRegions,
                            newDetections: newDetections.length
                        });

                        setExcludeMode(null);
                        setExcludeRegions([]);

                        alert(`‚úÖ Excluded regions from "${oldGlyph}"!\n\n` +
                            `Created ${newDetections.length} new detection(s).\n` +
                            `Original detection removed.\n\n` +
                            `üí° Tip: The new detections are marked as "Unknown" - correct them using the ‚úèÔ∏è button.`);

                        // Optional: Auto-scroll to show new detections
                        setTimeout(() => {
                            const detectionCards = document.querySelectorAll('.p-3.bg-white.rounded.border');
                            if (detectionCards.length > 0) {
                                detectionCards[detectionCards.length - 1].scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'center'
                                });
                            }
                        }, 200);
                    };

                    tempImg.onerror = () => {
                        console.error('‚ùå Failed to load image');
                        alert('‚ùå Failed to load image for exclusion');
                        setExcludeMode(null);
                        setExcludeRegions([]);
                    };
                } catch (error) {
                    console.error('Exclude error:', error);
                    alert('‚ùå Failed to apply exclusions. Check console for details.');
                    setExcludeMode(null);
                    setExcludeRegions([]);
                }
            };

            const saveAsTemplate = (detectionIndex, templateType) => {
                const detection = recognitionResults[detectionIndex];
                if (!detection || !imageRef.current) return;

                // Create canvas to crop the region
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const pos = detection.position;

                // Add padding around the glyph (10%)
                const padding = Math.max(pos.width, pos.height) * 0.1;
                const cropX = Math.max(0, pos.x - padding);
                const cropY = Math.max(0, pos.y - padding);
                const cropWidth = Math.min(imageRef.current.naturalWidth - cropX, pos.width + padding * 2);
                const cropHeight = Math.min(imageRef.current.naturalHeight - cropY, pos.height + padding * 2);

                canvas.width = cropWidth;
                canvas.height = cropHeight;

                // Draw the cropped region
                ctx.drawImage(
                    imageRef.current,
                    cropX, cropY, cropWidth, cropHeight,
                    0, 0, cropWidth, cropHeight
                );

                // Convert to data URL
                const imageDataUrl = canvas.toDataURL('image/png');

                // Update equivalence chart
                const updatedChart = { ...equivalenceChart };
                const glyphIndex = updatedChart.glyphs.findIndex(s => s.id === detection.glyph.id);

                if (glyphIndex === -1) {
                    alert('Glyph not found in chart!');
                    return;
                }

                const glyph = updatedChart.glphys[glyphIndex];

                // Initialize images object if it doesn't exist
                if (!glyph.images) {
                    glyph.images = { primary: null, variants: [], examples: [] };
                }

                // Add based on template type
                if (templateType === 'primary') {
                    glyph.images.primary = imageDataUrl;
                    alert(`‚úÖ Saved as PRIMARY template for "${glyph.name}"\n\nNote: This replaces the existing primary image.`);
                } else if (templateType === 'variant') {
                    if (!glyph.images.variants) glyph.images.variants = [];
                    glyph.images.variants.push(imageDataUrl);
                    alert(`‚úÖ Saved as VARIANT template for "${glyph.name}"\n\nVariants: ${glyph.images.variants.length}`);
                } else if (templateType === 'example') {
                    if (!glyph.images.examples) glyph.images.examples = [];
                    glyph.images.examples.push(imageDataUrl);
                    alert(`‚úÖ Saved as EXAMPLE template for "${glyph.name}"\n\nExamples: ${glyph.images.examples.length}`);
                }

                setEquivalenceChart(updatedChart);

                // Reload the image in the cache
                const img = new Image();
                img.onload = () => {
                    const newCache = { ...loadedGlyphImages };
                    if (templateType === 'primary') {
                        newCache[glyph.id] = img;
                    } else if (templateType === 'variant') {
                        newCache[`${glyph.id}_variant_${glyph.images.variants.length - 1}`] = img;
                    } else if (templateType === 'example') {
                        newCache[`${glyph.id}_example_${glyph.images.examples.length - 1}`] = img;
                    }
                    setLoadedGlyphImages(newCache);
                };
                img.src = imageDataUrl;

                recordAction('save_template', {
                    glyphId: detection.glyph.id,
                    glyphName: detection.glyph.name,
                    templateType: templateType,
                    confidence: detection.confidence
                });

                setSelectedForTemplate(null);
            };

            const exportUpdatedChart = () => {
                const chartJson = JSON.stringify(equivalenceChart, null, 2);
                const blob = new Blob([chartJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Hakli_gylphs_training_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('‚úÖ Updated equivalence chart exported!\n\nYou can now:\n1. Review the new templates\n2. Upload to GitHub to use in future sessions\n3. Share with other users');
            };


            // ============================================
            // CLOUD SYNC
            // ============================================

            const uploadCorrectionsToCloud = async () => {
                    try {
                        const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                        const exportData = {
                            version: '1.0',
                            uploadDate: new Date().toISOString(),
                            corrections: corrections,
                            stats: {
                                totalGlyphs: Object.keys(corrections).length,
                                totalCorrections: Object.values(corrections).reduce((sum, c) =>
                                    sum + c.corrections.reduce((s, cor) => s + cor.count, 0), 0)
                            },
                            source: 'hakli-recognizer-community-contribution'
                        };

                        // Create downloadable JSON file
                        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `hakli_corrections_contribution_${new Date().toISOString().slice(0, 10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        // Show instructions
                        const issueUrl = 'https://github.com/hytra3/hakli_glyph_recognizer/issues/new?title=Community%20Corrections%20Contribution&body=Please%20find%20my%20correction%20memory%20attached.%20Thank%20you!';

                        const message = `‚úÖ Corrections file downloaded!\n\n` +
                            `üì§ To share with the community:\n\n` +
                            `1. The file has been downloaded to your computer\n` +
                            `2. Click OK to open a new GitHub Issue\n` +
                            `3. Attach the downloaded JSON file to the issue\n` +
                            `4. Submit the issue\n\n` +
                            `Your corrections will be reviewed and added to the master collection!\n\n` +
                            `Stats: ${exportData.stats.totalCorrections} corrections for ${exportData.stats.totalGlyphs} glyphs`;

                        if (confirm(message)) {
                            window.open(issueUrl, '_blank');
                        }

                        recordAction('export_for_contribution', { stats: exportData.stats });

                        return { success: true };
                    } catch (error) {
                        console.error('Export failed:', error);
                        alert('‚ùå Failed to export corrections. Check console for details.');
                        return null;
                    }
                };

            const downloadCorrectionsFromCloud = async (url = null) => {
                    try {
                        // Default to master collection
                        const masterUrl = url || 'https://raw.githubusercontent.com/hytra3/hakli_glyph_recognizer/main/community-corrections/master.json';

                        // Fetch the corrections data
                        const response = await fetch(masterUrl);
                        if (!response.ok) {
                            if (response.status === 404) {
                                alert('‚ÑπÔ∏è No master corrections available yet.\n\nBe the first to contribute!');
                                return null;
                            }
                            throw new Error('Failed to download corrections');
                        }

                        const cloudData = await response.json();

                        // Check if there are any corrections
                        if (!cloudData.corrections || Object.keys(cloudData.corrections).length === 0) {
                            alert('‚ÑπÔ∏è The master collection is empty.\n\nContribute your corrections to help the community!');
                            return null;
                        }

                        // Merge with existing corrections
                        const existing = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                        let newCorrections = 0;
                        let updatedCorrections = 0;

                        Object.keys(cloudData.corrections).forEach(key => {
                            if (!existing[key]) {
                                existing[key] = cloudData.corrections[key];
                                newCorrections++;
                            } else {
                                // Merge correction counts
                                cloudData.corrections[key].corrections.forEach(cloudCorr => {
                                    const existingCorr = existing[key].corrections.find(c => c.to.id === cloudCorr.to.id);
                                    if (existingCorr) {
                                        existingCorr.count += cloudCorr.count;
                                        updatedCorrections++;
                                    } else {
                                        existing[key].corrections.push(cloudCorr);
                                        newCorrections++;
                                    }
                                });
                            }
                        });

                        localStorage.setItem('hakliCorrections', JSON.stringify(existing));

                        const contributorInfo = cloudData.stats?.contributors?.length > 0
                            ? `\n\nThanks to ${cloudData.stats.contributors.length} contributor(s)!`
                            : '';

                        alert(`‚úÖ Community corrections downloaded!\n\n` +
                            `${newCorrections} new corrections added\n` +
                            `${updatedCorrections} existing corrections updated\n\n` +
                            `Total glyphs in your memory: ${Object.keys(existing).length}` +
                            contributorInfo);

                        recordAction('download_from_cloud', {
                            source: masterUrl,
                            newCorrections,
                            updatedCorrections
                        });

                        return { newCorrections, updatedCorrections };
                    } catch (error) {
                        console.error('Download from cloud failed:', error);
                        alert('‚ùå Failed to download corrections from cloud.\n\nThe master collection may not exist yet, or there may be a network issue.');
                        return null;
                    }
                };
          
            // ============================================
            // CORRECTION MEMORY
            // ============================================

            const saveCorrectionToMemory = (originalGlyph, correctedGlyph, confidence) => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    const key = originalGlyph.id;

                    if (!corrections[key]) {
                        corrections[key] = {
                            originalGlyph: originalGlyph,
                            corrections: []
                        };
                    }

                    // Find if this correction already exists
                    const existingIndex = corrections[key].corrections.findIndex(c => c.to.id === correctedGlyph.id);

                    if (existingIndex >= 0) {
                        corrections[key].corrections[existingIndex].count++;
                        corrections[key].corrections[existingIndex].lastUsed = new Date().toISOString();
                    } else {
                        corrections[key].corrections.push({
                            to: correctedGlyph,
                            count: 1,
                            firstUsed: new Date().toISOString(),
                            lastUsed: new Date().toISOString(),
                            avgConfidence: confidence
                        });
                    }

                    localStorage.setItem('hakliCorrections', JSON.stringify(corrections));
                    console.log('Correction saved to memory:', originalGlyph.name, '‚Üí', correctedGlyph.name);
                } catch (error) {
                    console.error('Failed to save correction:', error);
                }
            };

            const getCorrectionSuggestion = (glyphId) => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    if (corrections[glyphId] && corrections[glyphId].corrections.length > 0) {
                        // Return most frequently used correction
                        const sorted = [...corrections[glyphId].corrections].sort((a, b) => b.count - a.count);
                        return sorted[0];
                    }
                    return null;
                } catch (error) {
                    console.error('Failed to get correction suggestion:', error);
                    return null;
                }
            };

            const exportCorrectionMemory = () => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    const exportData = {
                        version: '1.0',
                        exportDate: new Date().toISOString(),
                        corrections: corrections,
                        stats: {
                            totalGlyphs: Object.keys(corrections).length,
                            totalCorrections: Object.values(corrections).reduce((sum, c) => sum + c.corrections.reduce((s, cor) => s + cor.count, 0), 0)
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hakli_corrections_${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    alert(`Exported ${exportData.stats.totalCorrections} corrections for ${exportData.stats.totalGlyphs} glyphs!`);
                } catch (error) {
                    console.error('Export failed:', error);
                    alert('Failed to export corrections');
                }
            };

            const importCorrectionMemory = (jsonData) => {
                try {
                    const imported = JSON.parse(jsonData);
                    const existing = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');

                    // Merge imported with existing
                    Object.keys(imported.corrections).forEach(key => {
                        if (existing[key]) {
                            // Merge correction counts
                            imported.corrections[key].corrections.forEach(importedCorr => {
                                const existingCorr = existing[key].corrections.find(c => c.to.id === importedCorr.to.id);
                                if (existingCorr) {
                                    existingCorr.count += importedCorr.count;
                                } else {
                                    existing[key].corrections.push(importedCorr);
                                }
                            });
                        } else {
                            existing[key] = imported.corrections[key];
                        }
                    });

                    localStorage.setItem('hakliCorrections', JSON.stringify(existing));
                    alert(`Imported corrections successfully! Total glyphs in memory: ${Object.keys(existing).length}`);
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Failed to import corrections - invalid file format');
                }
            };

            // ============================================
            // EXPORT FUNCTIONS
            // ============================================

            const exportTranscription = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';

                orderedResults.forEach((result, index) => {
                    transcription += result.glyph.transliteration || result.glyph.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });

                const blob = new Blob([transcription], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_transcription_${new Date().toISOString().slice(0, 10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                recordAction('export_transcription', { transcription });
            };

            const exportDetectionData = () => {
                const data = {
                    timestamp: new Date().toISOString(),
                    imageFile: image ? 'uploaded_image' : null,
                    viewMode: viewMode,
                    readingDirection: readingDirection,
                    detections: recognitionResults.map((result, index) => ({
                        index: index,
                        glyph: result.glyph.name,
                        transliteration: result.glyph.transliteration,
                        confidence: result.confidence,
                        position: result.position,
                        matchType: result.matchType,
                        isManual: result.isManual || false,
                        isMerged: result.isMerged || false,
                        validated: validations[index] ? validations[index].isCorrect : null
                    })),
                    readingOrder: viewMode === 'reading' ? readingOrder : null,
                    wordBoundaries: Array.from(wordBoundaries),
                    actionHistory: actionHistory
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_detection_data_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                recordAction('export_detection_data', { detectionCount: recognitionResults.length });
            };

            const exportAnnotatedImage = () => {
                if (!imageRef.current) return;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;

                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;

                // Draw original image
                ctx.drawImage(img, 0, 0);

                // Draw detection boxes and labels
                recognitionResults.forEach((detection, index) => {
                    const pos = detection.position;

                    // Determine box color based on validation
                    let boxColor = '#3b82f6'; // blue - unvalidated
                    if (validations[index]) {
                        boxColor = validations[index].isCorrect ? '#10b981' : '#ef4444'; // green or red
                    }

                    // Draw box
                    ctx.strokeStyle = boxColor;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(pos.x, pos.y, pos.width, pos.height);

                    // Draw semi-transparent background for label
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    const labelText = detection.glyph.name;
                    ctx.font = '16px Arial';
                    const textWidth = ctx.measureText(labelText).width;
                    ctx.fillRect(pos.x, pos.y - 25, textWidth + 10, 25);

                    // Draw label text
                    ctx.fillStyle = 'white';
                    ctx.fillText(labelText, pos.x + 5, pos.y - 7);

                    // Draw reading order number if in reading view
                    if (viewMode === 'reading') {
                        const orderNum = getReadingOrderIndex(index);
                        ctx.fillStyle = '#facc15';
                        ctx.beginPath();
                        ctx.arc(pos.x - 15, pos.y - 15, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#ca8a04';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(orderNum.toString(), pos.x - 15, pos.y - 15);
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'alphabetic';
                    }
                });

                // Convert to blob and download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hakli_annotated_${new Date().toISOString().slice(0, 10)}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    recordAction('export_annotated_image', {});
                });
            };

            const exportHtmlReport = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';

                orderedResults.forEach((result, index) => {
                    transcription += result.glyph.transliteration || result.glyph.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });

                // Generate annotated image
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;

                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.drawImage(img, 0, 0);

                // Draw detection boxes
                recognitionResults.forEach((detection, index) => {
                    const pos = detection.position;
                    let boxColor = '#3b82f6';
                    if (validations[index]) {
                        boxColor = validations[index].isCorrect ? '#10b981' : '#ef4444';
                    }

                    ctx.strokeStyle = boxColor;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(pos.x, pos.y, pos.width, pos.height);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    const labelText = detection.glyph.name;
                    ctx.font = '16px Arial';
                    const textWidth = ctx.measureText(labelText).width;
                    ctx.fillRect(pos.x, pos.y - 25, textWidth + 10, 25);
                    ctx.fillStyle = 'white';
                    ctx.fillText(labelText, pos.x + 5, pos.y - 7);

                    if (viewMode === 'reading') {
                        const orderNum = getReadingOrderIndex(index);
                        ctx.fillStyle = '#facc15';
                        ctx.beginPath();
                        ctx.arc(pos.x - 15, pos.y - 15, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#ca8a04';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(orderNum.toString(), pos.x - 15, pos.y - 15);
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'alphabetic';
                    }
                });

                const annotatedImageDataUrl = canvas.toDataURL();
                const originalImageDataUrl = image;

                // Calculate statistics
                const totalDetections = recognitionResults.length;
                const validatedCorrect = Object.values(validations).filter(v => v.isCorrect).length;
                const corrected = recognitionResults.filter(r => r.corrected).length;
                const avgConfidence = recognitionResults.length > 0
                    ? (recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length * 100).toFixed(1)
                    : 0;

                // Create iframe to build HTML document
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                document.body.appendChild(iframe);

                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                iframeDoc.open();
                iframeDoc.write('<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body></body></html>');
                iframeDoc.close();

                // Build document structure
                const container = iframeDoc.createElement('div');
                container.className = 'container';

                // Add styles
                const style = iframeDoc.createElement('style');
                style.textContent = '* { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; padding: 20px; } .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow: hidden; } .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; } .header h1 { font-size: 28px; margin-bottom: 10px; } .header .date { opacity: 0.9; font-size: 14px; } .section { padding: 30px; border-bottom: 1px solid #e5e7eb; } .section:last-child { border-bottom: none; } .section-title { font-size: 20px; font-weight: 600; margin-bottom: 15px; color: #1f2937; } .image-container { text-align: center; margin: 20px 0; } .image-container img { max-width: 100%; height: auto; border: 2px solid #e5e7eb; border-radius: 4px; } .image-toggle { margin: 20px 0; text-align: center; } .toggle-btn { background: #3b82f6; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background 0.2s; } .toggle-btn:hover { background: #2563eb; } .toggle-btn.active { background: #10b981; } .transcription-box { background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 6px; padding: 20px; font-family: "Courier New", monospace; font-size: 18px; line-height: 1.8; word-wrap: break-word; margin: 15px 0; } .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; } .stat-card { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; padding: 15px; text-align: center; } .stat-value { font-size: 32px; font-weight: 700; color: #3b82f6; margin-bottom: 5px; } .stat-label { font-size: 14px; color: #6b7280; } .detection-list { margin: 15px 0; } .detection-item { background: #f9fafb; border-left: 4px solid #3b82f6; padding: 12px 15px; margin: 8px 0; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; } .detection-item.correct { border-left-color: #10b981; } .detection-item.incorrect { border-left-color: #ef4444; } .detection-glyph { font-weight: 600; font-size: 16px; } .detection-confidence { color: #6b7280; font-size: 14px; } .footer { background: #f9fafb; padding: 20px 30px; text-align: center; color: #6b7280; font-size: 14px; } .legend { display: flex; gap: 20px; justify-content: center; margin: 15px 0; flex-wrap: wrap; } .legend-item { display: flex; align-items: center; gap: 8px; font-size: 14px; } .legend-box { width: 20px; height: 20px; border-radius: 3px; }';
                iframeDoc.head.appendChild(style);

                // Header
                const header = iframeDoc.createElement('div');
                header.className = 'header';
                header.innerHTML = '<h1>üìú Hakli Glyph Recognition Report</h1><div class="date">Generated on ' + new Date().toLocaleString() + '</div>';
                container.appendChild(header);

                // Statistics section
                const statsSection = iframeDoc.createElement('div');
                statsSection.className = 'section';
                statsSection.innerHTML = '<div class="section-title">üìä Recognition Statistics</div><div class="stats-grid"><div class="stat-card"><div class="stat-value">' + totalDetections + '</div><div class="stat-label">Total Glyphs</div></div><div class="stat-card"><div class="stat-value">' + avgConfidence + '%</div><div class="stat-label">Avg Confidence</div></div><div class="stat-card"><div class="stat-value">' + validatedCorrect + '</div><div class="stat-label">Validated Correct</div></div><div class="stat-card"><div class="stat-value">' + corrected + '</div><div class="stat-label">Corrected</div></div></div>';
                container.appendChild(statsSection);

                // Transcription section
                const transcriptionSection = iframeDoc.createElement('div');
                transcriptionSection.className = 'section';
                transcriptionSection.innerHTML = '<div class="section-title">üìù Transcription</div><div class="transcription-box">' + transcription + '</div>';
                container.appendChild(transcriptionSection);

                // Image section
                const imageSection = iframeDoc.createElement('div');
                imageSection.className = 'section';
                imageSection.innerHTML = '<div class="section-title">üñºÔ∏è Source Image</div><div class="image-toggle"><button class="toggle-btn" id="toggleBtn" onclick="toggleImage()">Show Annotated Version</button></div><div class="legend"><div class="legend-item"><div class="legend-box" style="background: #3b82f6;"></div><span>Unvalidated</span></div><div class="legend-item"><div class="legend-box" style="background: #10b981;"></div><span>Validated Correct</span></div><div class="legend-item"><div class="legend-box" style="background: #ef4444;"></div><span>Validated Incorrect</span></div></div><div class="image-container"><img id="mainImage" src="' + originalImageDataUrl + '" alt="Hakli inscription"></div>';
                container.appendChild(imageSection);

                // Detection details section
                const detectionSection = iframeDoc.createElement('div');
                detectionSection.className = 'section';
                let detectionHtml = '<div class="section-title">üîç Detection Details</div><div class="detection-list">';
                orderedResults.forEach((result, index) => {
                    const originalIndex = recognitionResults.indexOf(result);
                    const validation = validations[originalIndex];
                    const validationClass = validation ? (validation.isCorrect ? 'correct' : 'incorrect') : '';
                    const correctedBadge = result.corrected ? '<span style="background: #fef3c7; padding: 2px 8px; border-radius: 3px; font-size: 12px;">‚úèÔ∏è Corrected</span>' : '';
                    const orderPrefix = viewMode === 'reading' ? (index + 1) + '. ' : '';
                    detectionHtml += '<div class="detection-item ' + validationClass + '"><div><span class="detection-glyph">' + orderPrefix + result.glyph.name + '</span><span style="color: #6b7280; margin-left: 10px;">' + (result.glyph.transliteration || '') + '</span>' + correctedBadge + '</div><div class="detection-confidence">' + Math.round(result.confidence * 100) + '%</div></div>';
                });
                detectionHtml += '</div>';
                detectionSection.innerHTML = detectionHtml;
                container.appendChild(detectionSection);

                // Footer
                const footer = iframeDoc.createElement('div');
                footer.className = 'footer';
                footer.textContent = 'Generated by Hakli Glyph Recognizer (beta v251024)';
                container.appendChild(footer);

                // Add script
                const script = iframeDoc.createElement('script');
                script.textContent = 'let showingAnnotated = false; const originalImage = "' + originalImageDataUrl + '"; const annotatedImage = "' + annotatedImageDataUrl + '"; function toggleImage() { const img = document.getElementById("mainImage"); const btn = document.getElementById("toggleBtn"); showingAnnotated = !showingAnnotated; if (showingAnnotated) { img.src = annotatedImage; btn.textContent = "Show Original"; btn.classList.add("active"); } else { img.src = originalImage; btn.textContent = "Show Annotated Version"; btn.classList.remove("active"); } }';
                iframeDoc.body.appendChild(script);

                iframeDoc.body.appendChild(container);

                // Get HTML and download
                const htmlContent = '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="UTF-8">\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n<title>Hakli Recognition Report</title>\n' + style.outerHTML + '\n</head>\n<body>\n' + container.outerHTML + '\n' + script.outerHTML + '\n</body>\n</html>';

                document.body.removeChild(iframe);

                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'hakli_report_' + new Date().toISOString().slice(0, 10) + '.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                recordAction('export_html_report', {
                    glyphCount: recognitionResults.length,
                    transcriptionLength: transcription.length
                });

                alert('HTML report exported successfully!');
            };

            const copyTranscriptionToClipboard = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';

                orderedResults.forEach((result, index) => {
                    transcription += result.glyph.transliteration || result.glyph.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });

                navigator.clipboard.writeText(transcription).then(() => {
                    alert('Transcription copied to clipboard!');
                    recordAction('copy_transcription', {});
                }).catch(err => {
                    console.error('Failed to copy:', err);
                });
            };

            // ============================================
            // UI HELPERS
            // ============================================

            const getDetectionBoxStyle = (index) => {
                const detection = recognitionResults[index];
                if (!detection || !imageRef.current) return {};
                const imageRect = imageRef.current.getBoundingClientRect();
                const scaleX = imageRect.width / imageRef.current.naturalWidth;
                const scaleY = imageRect.height / imageRef.current.naturalHeight;
                return {
                    left: detection.position.x * scaleX + 'px',
                    top: detection.position.y * scaleY + 'px',
                    width: detection.position.width * scaleX + 'px',
                    height: detection.position.height * scaleY + 'px'
                };
            };

            const getDetectionBoxClass = (index) => {
                let classes = ['detection-box'];
                if (validations[index]) {
                    classes.push(validations[index].isCorrect ? 'validated-correct' : 'validated-incorrect');
                } else {
                    classes.push('unvalidated');
                }
                if (selectedRegions.has(index)) classes.push('selected');
                return classes.join(' ');
            };

            const getReadingOrderedResults = () => {
                if (viewMode === 'detection') return recognitionResults;

                // If manual reading order exists, use it
                if (readingOrder.length === recognitionResults.length) {
                    return readingOrder.map(idx => recognitionResults[idx]);
                }

                // Otherwise, auto-sort by direction
                const sorted = recognitionResults.map((result, idx) => ({ result, originalIndex: idx }));

                if (readingDirection === 'ltr') {
                    sorted.sort((a, b) =>
                        a.result.position.y - b.result.position.y ||
                        a.result.position.x - b.result.position.x
                    );
                } else if (readingDirection === 'rtl') {
                    sorted.sort((a, b) =>
                        a.result.position.y - b.result.position.y ||
                        b.result.position.x - a.result.position.x
                    );
                } else if (readingDirection === 'ttb') {
                    sorted.sort((a, b) =>
                        a.result.position.x - b.result.position.x ||
                        a.result.position.y - b.result.position.y
                    );
                }

                return sorted.map(item => item.result);
            };

            const getFilteredResults = () => {
                if (!useConfidenceFilter) {
                    return recognitionResults;
                }
                return recognitionResults.filter(result => result.confidence >= confidenceThreshold / 100);
            };   

            const addToIsolatedGlyphs = (bounds, thumbnail) => {
                setIsolatedGlyphs(prev => [...prev, {
                    bounds: bounds,
                    thumbnail: thumbnail,
                    area: bounds.width * bounds.height,
                    aspectRatio: bounds.width / bounds.height
                }]);
            };

            const saveSession = () => {
                try {
                    const session = {
                        version: '1.0',
                        timestamp: new Date().toISOString(),
                        image: image,
                        recognitionResults: recognitionResults,
                        validations: validations,
                        isolatedGlyphs: isolatedGlyphs,
                        wordBoundaries: Array.from(wordBoundaries),
                        readingOrder: readingOrder,
                        readingDirection: readingDirection,
                        viewMode: viewMode
                    };

                    localStorage.setItem('hakli_session', JSON.stringify(session));
                    alert('‚úÖ Session saved!\n\nYour work is saved locally in this browser.\nYou can close the tab and come back later.');
                    recordAction('save_session', { timestamp: session.timestamp });
                } catch (error) {
                    console.error('Save session error:', error);
                    showError(
                        'Save Failed',
                        'Could not save your session.',
                        [
                            'Your browser may have disabled localStorage',
                            'You may be in private/incognito mode',
                            'Try exporting your data instead'
                        ]
                    );
                }
            };

            const loadSession = () => {
                try {
                    const saved = localStorage.getItem('hakli_session');
                    if (!saved) {
                        alert('‚ÑπÔ∏è No saved session found.');
                        return;
                    }

                    const session = JSON.parse(saved);

                    if (confirm(`üìÇ Load saved session?\n\nFrom: ${new Date(session.timestamp).toLocaleString()}\nGlyphs: ${session.recognitionResults.length}\n\nThis will replace your current work!`)) {
                        setImage(session.image);
                        setRecognitionResults(session.recognitionResults || []);
                        setValidations(session.validations || {});
                        setIsolatedGlyphs(session.isolatedGlyphs || []);
                        setWordBoundaries(new Set(session.wordBoundaries || []));
                        setReadingOrder(session.readingOrder || []);
                        setReadingDirection(session.readingDirection || 'detection');
                        setViewMode(session.viewMode || 'detection');

                        alert('‚úÖ Session loaded successfully!');
                        recordAction('load_session', { timestamp: session.timestamp });
                    }
                } catch (error) {
                    console.error('Load session error:', error);
                    showError(
                        'Load Failed',
                        'Could not load your saved session.',
                        [
                            'The saved data may be corrupted',
                            'Try clearing your browser cache',
                            'Check the browser console for details'
                        ]
                    );
                }
            };

            const clearSession = () => {
                if (confirm('üóëÔ∏è Delete saved session?\n\nThis will permanently delete your saved work.\nThis cannot be undone!')) {
                    localStorage.removeItem('hakli_session');
                    alert('‚úÖ Saved session deleted.');
                    recordAction('clear_session', {});
                }
            };

            const recordAction = (actionType, actionData) => {
                const action = {
                    type: actionType,
                    data: actionData,
                    timestamp: new Date().toISOString(),
                    id: Date.now()
                };
                setActionHistory(prev => [...prev, action].slice(-50));
                // Only log important actions
                if (['exclude_regions', 'merge_detections', 'upload_to_cloud'].includes(actionType)) {
                    console.log(`‚úì ${actionType}:`, actionData);
                }
                // Take snapshot after modifying actions
                const modifyingActions = ['validation', 'delete_detection', 'merge_detections', 
                                        'add_manual_detection', 'correct_glyph', 'reorder_reading', 
                                        'toggle_word_boundary'];
                if (modifyingActions.includes(actionType)) {
                    setTimeout(takeSnapshot, 0);
                }
            };

            const takeSnapshot = () => {
                const snapshot = {
                    recognitionResults: [...recognitionResults],
                    validations: { ...validations },
                    selectedRegions: new Set(selectedRegions),
                    wordBoundaries: new Set(wordBoundaries),
                    readingOrder: [...readingOrder],
                    isolatedGlyphs: [...isolatedGlyphs]
                };
                
                // Remove any "future" history if we're not at the end
                const newHistory = stateHistory.slice(0, historyIndex + 1);
                newHistory.push(snapshot);
                
                // Keep only last 50 states
                const trimmedHistory = newHistory.slice(-50);
                
                setStateHistory(trimmedHistory);
                setHistoryIndex(trimmedHistory.length - 1);
            };

            const handleImageMouseDown = (event) => {
                // Manual detection mode
                if (manualDetectionMode) {
                    const coords = getImageCoordinates(event);
                    if (!coords) return;
                    setIsDrawing(true);
                    setDrawStart(coords);
                    setDrawCurrent(coords);
                    return;
                }

                // Trim mode
                if (trimMode !== null) {
                    const coords = getImageCoordinates(event);
                    if (!coords) return;
                    setIsDrawing(true);
                    setDrawStart(coords);
                    setDrawCurrent(coords);
                    return;
                }

                // Exclude mode
                if (excludeMode !== null) {
                    const coords = getImageCoordinates(event);
                    if (!coords) return;
                    setIsDrawing(true);
                    setDrawStart(coords);
                    setDrawCurrent(coords);
                    return;
                }
            };

            const handleImageMouseMove = (event) => {
                if (!isDrawing) return;

                event.preventDefault();
                const coords = getImageCoordinates(event);
                if (coords) {
                    setDrawCurrent(coords);
                }
            };

            const handleImageMouseUp = (event) => {
                if (!isDrawing || !drawStart) return;

                const coords = getImageCoordinates(event);
                if (!coords) return;

                const bounds = {
                    x: Math.min(drawStart.x, coords.x),
                    y: Math.min(drawStart.y, coords.y),
                    width: Math.abs(coords.x - drawStart.x),
                    height: Math.abs(coords.y - drawStart.y)
                };

                // Manual detection mode
                if (manualDetectionMode && bounds.width > 10 && bounds.height > 10) {
                    const thumbnail = extractRegionThumbnail(imageRef.current, { bounds: bounds });

                    const manualDetection = {
                        glyph: { id: 'unknown', name: 'Unknown', transliteration: '?' },
                        confidence: 0.5,
                        position: bounds,
                        matchType: 'manual',
                        isManual: true,
                        regionIndex: isolatedGlyphs.length,
                        thumbnail: thumbnail
                    };

                    setIsolatedGlyphs(prev => [...prev, {
                        bounds: bounds,
                        thumbnail: thumbnail,
                        area: bounds.width * bounds.height,
                        aspectRatio: bounds.width / bounds.height
                    }]);

                    setRecognitionResults(prev => [...prev, manualDetection]);
                    recordAction('add_manual_detection', { bounds, thumbnail: !!thumbnail });
                }

                // Trim mode
                if (trimMode !== null && bounds.width > 10 && bounds.height > 10) {
                    applyTrim(trimMode, bounds);
                }

                // Exclude mode
                if (excludeMode !== null && bounds.width > 10 && bounds.height > 10) {
                    // Add to exclusion regions
                    setExcludeRegions(prev => [...prev, bounds]);
                }

                setIsDrawing(false);
                setDrawStart(null);
                setDrawCurrent(null);
            };

            const toggleRegionSelection = (regionIndex) => {
                setSelectedRegions(prev => {
                    const newSet = new Set(prev);
                    newSet.has(regionIndex) ? newSet.delete(regionIndex) : newSet.add(regionIndex);
                    return newSet;
                });
            };

            const handleDetectionClick = (event, index) => {
                if (event.ctrlKey || event.metaKey) {
                    event.stopPropagation();
                    toggleRegionSelection(index);
                }
            };
            
            const getReadingOrderIndex = (detectionIndex) => {
                const orderedResults = getReadingOrderedResults();
                    return orderedResults.findIndex(result => 
                    recognitionResults.indexOf(result) === detectionIndex
                ) + 1;
            };

            const applyReadingDirection = (direction) => {
                setReadingDirection(direction);
                
            // Auto-generate reading order based on direction
            const sorted = recognitionResults.map((result, idx) => ({ result, idx }));
                
            if (direction === 'ltr') {
                sorted.sort((a, b) => 
                    a.result.position.y - b.result.position.y || 
                    a.result.position.x - b.result.position.x
                );
            } else if (direction === 'rtl') {
                sorted.sort((a, b) => 
                    a.result.position.y - b.result.position.y || 
                    b.result.position.x - a.result.position.x
                );
            } else if (direction === 'ttb') {
                sorted.sort((a, b) => 
                    a.result.position.x - b.result.position.x || 
                    a.result.position.y - b.result.position.y
                );
            } else {
                // Detection order - just use original indices
                setReadingOrder(recognitionResults.map((_, idx) => idx));
                return;
            }
            
                setReadingOrder(sorted.map(item => item.idx));
            };

            const toggleWordBoundary = (readingOrderIndex) => {
                setWordBoundaries(prev => {
                    const newSet = new Set(prev);
                    newSet.has(readingOrderIndex) ? newSet.delete(readingOrderIndex) : newSet.add(readingOrderIndex);
                    return newSet;
                });
                recordAction('toggle_word_boundary', { readingOrderIndex });
            };

            const handleDragStart = (e, index) => {
                // Prevent dragging in detection order mode
                if (readingDirection === 'detection') {
                    e.preventDefault();
                    alert('‚ö†Ô∏è Cannot reorder in Detection Order mode.\n\nPlease select a reading direction (LTR, RTL, or TTB) to manually reorder glyphs.');
                    return;
                }
                setDraggedItem(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = (e, dropIndex) => {
                e.preventDefault();
                if (draggedItem === null || draggedItem === dropIndex) return;
                
                const newOrder = [...readingOrder];
                const draggedValue = newOrder[draggedItem];
                newOrder.splice(draggedItem, 1);
                newOrder.splice(dropIndex, 0, draggedValue);
                
                setReadingOrder(newOrder);
                setDraggedItem(null);
                
                recordAction('reorder_reading', { from: draggedItem, to: dropIndex });
            };

            const handleRecognitionError = (error, context = 'Recognition') => {
                console.error(`‚ùå ${context} error:`, error);
                alert(`‚ùå ${context} failed. Check console for details.`);
            };

            useEffect(() => {
                if (selectedRegions.size >= 2) {
                    const selectedDetections = Array.from(selectedRegions).map(i => recognitionResults[i]);
                    if (selectedDetections.length > 0) {
                        const minX = Math.min(...selectedDetections.map(d => d.position.x));
                        const minY = Math.min(...selectedDetections.map(d => d.position.y));
                        const maxX = Math.max(...selectedDetections.map(d => d.position.x + d.position.width));
                        const maxY = Math.max(...selectedDetections.map(d => d.position.y + d.position.height));
                        setMergeIndicator({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });
                    }
                } else {
                    setMergeIndicator(null);
                }
            }, [selectedRegions, recognitionResults]);


            const startCorrection = (detectionIndex) => {
                setCorrectionMode(detectionIndex);
            };

            const applyCorrection = (detectionIndex, newGlyph) => {
                const oldGlyph = recognitionResults[detectionIndex].glyph;
                const confidence = recognitionResults[detectionIndex].confidence;

                recordAction('correct_glyph', {
                    detectionIndex: detectionIndex,
                    oldGlyph: oldGlyph,
                    newGlyph: newGlyph
                });

                // Save to correction memory
                saveCorrectionToMemory(oldGlyph, newGlyph, confidence);

                setRecognitionResults(prev => prev.map((result, index) => {
                    if (index === detectionIndex) {
                        return {
                            ...result,
                            glyph: newGlyph,
                            corrected: true,
                            originalGlyph: result.glyph
                        };
                    }
                    return result;
                }));

                setCorrectionMode(null);
            };

            const cancelCorrection = () => {
                setCorrectionMode(null);
            };

                    
            const undo = () => {
                if (historyIndex <= 0) return;
                
                const previousState = stateHistory[historyIndex - 1];
                setRecognitionResults(previousState.recognitionResults);
                setValidations(previousState.validations);
                setSelectedRegions(previousState.selectedRegions);
                setWordBoundaries(previousState.wordBoundaries);
                setReadingOrder(previousState.readingOrder);
                setIsolatedGlyphs(previousState.isolatedGlyphs);
                setHistoryIndex(historyIndex - 1);
                
                console.log('Undo to state', historyIndex - 1);
            };

            const redo = () => {
                if (historyIndex >= stateHistory.length - 1) return;
                
                const nextState = stateHistory[historyIndex + 1];
                setRecognitionResults(nextState.recognitionResults);
                setValidations(nextState.validations);
                setSelectedRegions(nextState.selectedRegions);
                setWordBoundaries(nextState.wordBoundaries);
                setReadingOrder(nextState.readingOrder);
                setIsolatedGlyphs(nextState.isolatedGlyphs);
                setHistoryIndex(historyIndex + 1);
                
                console.log('Redo to state', historyIndex + 1);
            }; 

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file && file.type.indexOf('image/') === 0) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setImage(e.target.result);
                        setRecognitionResults([]);
                        setValidations({});
                        setActionHistory([]);
                        setIsolatedGlyphs([]);
                        setSelectedRegions(new Set());
                        setMergeIndicator(null);
                    };
                    reader.readAsDataURL(file);
                }
            };

            

            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Escape: Close correction modal or cancel trim/exclude modes
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        if (correctionMode !== null) {
                            cancelCorrection();
                        } else if (trimMode !== null) {
                            setTrimMode(null);
                            setIsDrawing(false);
                            setDrawStart(null);
                            setDrawCurrent(null);
                        } else if (excludeMode !== null) {
                            setExcludeMode(null);
                            setExcludeRegions([]);
                            setIsDrawing(false);
                            setDrawStart(null);
                            setDrawCurrent(null);
                        }
                        return;
                    }

                    // Undo: Ctrl+Z
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        undo();
                    }
                    // Redo: Ctrl+Shift+Z or Ctrl+Y
                    if ((e.ctrlKey || e.metaKey) && (e.shiftKey && e.key === 'z' || e.key === 'y')) {
                        e.preventDefault();
                        redo();
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [historyIndex, stateHistory, correctionMode, trimMode, excludeMode]);

            useEffect(() => {
                if (chartLoadStatus === 'not-loaded') {
                    setChartLoadStatus('loading');
                    const githubJsonUrl = 'https://raw.githubusercontent.com/hytra3/hakli_glyph_recognizer/main/Hakli_glyphs.JSON';
                    fetch(githubJsonUrl)
                        .then(response => response.json())
                        .then(chartData => {
                            setEquivalenceChart(chartData);
                            const imageCache = {};
                            const loadPromises = [];

                            // Count total images to load
                            let totalImagesToLoad = 0;

                            for (const glyph of chartData.glyphs) {
                                if (glyph.images && glyph.images.primary) totalImagesToLoad++;
                                if (glyph.images && glyph.images.variants) totalImagesToLoad += glyph.images.variants.length;
                                if (glyph.images && glyph.images.examples) totalImagesToLoad += glyph.images.examples.length;
                            }

                            setImageLoadingProgress({ loaded: 0, total: totalImagesToLoad });
                            console.log(`üì¶ Loading ${totalImagesToLoad} images for ${chartData.glyphs.length} glyphs...`);

                            let loadedCount = 0;

                            for (const glyph of chartData.glyphs) {
                                // Load primary image
                                if (glyph.images && glyph.images.primary) {
                                    const fullUrl = convertToGitHubUrl(glyph.images.primary);
                                    if (fullUrl) {
                                        const promise = new Promise((resolve) => {
                                            const img = new Image();
                                            img.crossOrigin = 'anonymous';
                                            img.onload = () => {
                                                imageCache[glyph.id] = img;
                                                loadedCount++;
                                                setImageLoadingProgress({ loaded: loadedCount, total: totalImagesToLoad });
                                                console.log(`‚úì Loaded ${loadedCount}/${totalImagesToLoad}: ${glyph.id}`);
                                                resolve();
                                            };
                                            img.onerror = () => {
                                                console.log(`‚úó Failed to load: ${glyph.id}`);
                                                loadedCount++;
                                                setImageLoadingProgress({ loaded: loadedCount, total: totalImagesToLoad });
                                                resolve();
                                            };
                                            img.src = fullUrl;
                                        });
                                        loadPromises.push(promise);
                                    }
                                }

                                // Load variant images
                                if (glyph.images && glyph.images.variants) {
                                    for (let i = 0; i < glyph.images.variants.length; i++) {
                                        const fullUrl = convertToGitHubUrl(glyph.images.variants[i]);
                                        if (fullUrl) {
                                            const variantKey = `${glyph.id}_variant_${i}`;
                                            const promise = new Promise((resolve) => {
                                                const img = new Image();
                                                img.crossOrigin = 'anonymous';
                                                img.onload = () => {
                                                    imageCache[variantKey] = img;
                                                    loadedCount++;
                                                    setImageLoadingProgress({ loaded: loadedCount, total: totalImagesToLoad });
                                                    console.log(`‚úì Loaded ${loadedCount}/${totalImagesToLoad}: ${variantKey}`);
                                                    resolve();
                                                };
                                                img.onerror = () => {
                                                    console.log(`‚úó Failed to load: ${variantKey}`);
                                                    loadedCount++;
                                                    setImageLoadingProgress({ loaded: loadedCount, total: totalImagesToLoad });
                                                    resolve();
                                                };
                                                img.src = fullUrl;
                                            });
                                            loadPromises.push(promise);
                                        }
                                    }
                                }

                                // Load example images
                                if (glyph.images && glyph.images.examples) {
                                    for (let i = 0; i < glyph.images.examples.length; i++) {
                                        const fullUrl = convertToGitHubUrl(glyph.images.examples[i]);
                                        if (fullUrl) {
                                            const exampleKey = `${glyph.id}_example_${i}`;
                                            const promise = new Promise((resolve) => {
                                                const img = new Image();
                                                img.crossOrigin = 'anonymous';
                                                img.onload = () => {
                                                    imageCache[exampleKey] = img;
                                                    loadedCount++;
                                                    setImageLoadingProgress({ loaded: loadedCount, total: totalImagesToLoad });
                                                    console.log(`‚úì Loaded ${loadedCount}/${totalImagesToLoad}: ${exampleKey}`);
                                                    resolve();
                                                };
                                                img.onerror = () => {
                                                    console.log(`‚úó Failed to load: ${exampleKey}`);
                                                    loadedCount++;
                                                    setImageLoadingProgress({ loaded: loadedCount, total: totalImagesToLoad });
                                                    resolve();
                                                };
                                                img.src = fullUrl;
                                            });
                                            loadPromises.push(promise);
                                        }
                                    }
                                }
                            }

                            Promise.all(loadPromises).then(() => {
                                console.log(`‚úÖ Loaded ${Object.keys(imageCache).length} total images for ${chartData.glyphs.length} glyphs`);
                                setLoadedGlyphImages(imageCache);
                                setChartLoadStatus('loaded');
                                setImageLoadingProgress({ loaded: 0, total: 0 }); // Reset
                            });
                        })
                        .catch(() => setChartLoadStatus('error'));
                }
            }, [chartLoadStatus]);

            return (
                <div className="max-w-6xl mx-auto p-6 bg-white">
                    <div className="mb-8">
                        <h1 className="text-3xl font-bold text-gray-900 mb-2">Hakli Glyph Recognizer</h1>
                        <p className="text-gray-600">beta v251029 ¬©marty heaton</p>
                    </div>

                    <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                        <div className="flex items-center justify-between">
                            <div>
                                <h3 className="font-semibold text-gray-900">Equivalence Chart Status</h3>
                                <div className="flex items-center gap-2 mt-1">
                                    {chartLoadStatus === 'loading' && (
                                        <span className="text-blue-600">
                                            Loading {equivalenceChart?.glyphs?.length || '...'} glyphs...
                                            {imageLoadingProgress.total > 0 && (
                                                <span className="ml-2">({imageLoadingProgress.loaded}/{imageLoadingProgress.total} images)</span>
                                            )}
                                        </span>
                                    )}
                                    {chartLoadStatus === 'loaded' && (
                                        <span className="text-green-600">
                                            ‚úÖ Loaded {equivalenceChart?.glyphs?.length || 0} glyphs, {Object.keys(loadedGlyphImages).length} images
                                        </span>
                                    )}
                                    {chartLoadStatus === 'error' && <span className="text-red-600">‚ùå Error loading chart</span>}
                                </div>
                            </div>
                            <button onClick={() => setChartLoadStatus('not-loaded')} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600" disabled={chartLoadStatus === 'loading'}>
                                Reload Chart
                            </button>
                        </div>
                    </div>

                    <div className="mb-6">
                        <input type="file" accept="image/*" onChange={handleFileUpload} className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" />
                    </div>

                    {recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                            <div className="flex items-center justify-between mb-4">
                                <h3 className="font-semibold text-gray-900">View Mode</h3>
                                <div className="flex gap-2">
                                    <button 
                                        onClick={() => setViewMode('detection')}
                                        className={`px-4 py-2 rounded font-medium ${viewMode === 'detection' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        üì∑ Detection View
                                    </button>
                                    <button 
                                        onClick={() => {
                                            setViewMode('reading');
                                            if (readingOrder.length === 0) {
                                                setReadingOrder(recognitionResults.map((_, idx) => idx));
                                            }
                                        }}
                                        className={`px-4 py-2 rounded font-medium ${viewMode === 'reading' ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        üìñ Reading Order View
                                    </button>
                                </div>
                            </div>
                            
                            {viewMode === 'reading' && (
                                <div className="pt-4 border-t border-gray-300">
                                    <div className="flex items-center justify-between">
                                        <span className="text-sm font-medium text-gray-700">Reading Direction:</span>
                                        <div className="flex gap-2">
                                            <button 
                                                onClick={() => applyReadingDirection('detection')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'detection' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Original detection order"
                                            >
                                                üî¢ Detection Order
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('ltr')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'ltr' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Left to Right"
                                            >
                                                ‚Üí LTR
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('rtl')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'rtl' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Right to Left"
                                            >
                                                ‚Üê RTL
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('ttb')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'ttb' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Top to Bottom"
                                            >
                                                ‚Üì TTB
                                            </button>
                                        </div>
                                    </div>
                                    <div className="mt-3 p-3 bg-blue-50 border border-blue-200 rounded text-sm text-blue-800">
                                        üí° Tip: In Reading Order View, you can drag detection cards below to manually reorder them.
                                    </div>
                                </div>
                            )}
                            
                            {viewMode === 'detection' && (
                                <div className="pt-4 border-t border-gray-300">
                                    <div className="p-3 bg-gray-100 border border-gray-300 rounded text-sm text-gray-700">
                                        üì∑ Detection View shows glyphs in the order they were detected (left-to-right on the image). Use this mode for validation and editing.
                                    </div>
                                </div>
                            )}
                        </div>
                    )}


                    {image && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <div className="flex flex-wrap gap-3 items-center mb-4">
                                <button onClick={recognizeGlyphs} disabled={isProcessing || !equivalenceChart} className="px-6 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50">
                                    {isProcessing ? 'Processing...' : 'Recognize Glyphs'}
                                </button>
                                {/* üëá ADD THIS PROGRESS BAR */}
                                {isProcessing && processingProgress.total > 0 && (
                                    <div className="mt-3 p-3 bg-blue-50 rounded border border-blue-200">
                                        <div className="flex items-center justify-between mb-2">
                                            <span className="text-sm font-medium text-gray-700">
                                                Processing region {processingProgress.current} of {processingProgress.total}
                                            </span>
                                            <span className="text-sm text-gray-600">
                                                {Math.round((processingProgress.current / processingProgress.total) * 100)}%
                                            </span>
                                        </div>
                                        <div className="w-full bg-gray-200 rounded-full h-2.5">
                                            <div
                                                className="bg-blue-600 h-2.5 rounded-full transition-all duration-300"
                                                style={{ width: ((processingProgress.current / processingProgress.total) * 100) + '%' }}
                                            />
                                        </div>
                                    </div>
                                )}

                                <button onClick={() => setManualDetectionMode(!manualDetectionMode)} className={`px-4 py-2 rounded ${manualDetectionMode ? 'bg-orange-500 text-white hover:bg-orange-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>
                                    {manualDetectionMode ? 'Exit Manual Mode' : 'Manual Detection'}
                                </button>
                                
                                <button
                                    onClick={() => setTemplateTrainingMode(!templateTrainingMode)}
                                    className={`px-4 py-2 rounded ${templateTrainingMode ? 'bg-purple-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                >
                                    {templateTrainingMode ? 'üéì Exit Template Training' : 'üéì Template Training Mode'}
                                </button>

                                {templateTrainingMode && (
                                    <div className="mt-4 p-4 bg-purple-50 border-2 border-purple-300 rounded-lg">
                                        <h4 className="font-semibold text-purple-900 mb-2">üéì Template Training Mode Active</h4>
                                        <p className="text-sm text-purple-700 mb-3">
                                            Click any detection below to save it as a template image. Good templates improve future recognition accuracy!
                                        </p>
                                        <div className="text-xs text-purple-600 space-y-1">
                                            <div>‚Ä¢ <strong>Primary:</strong> The main reference image (replaces existing)</div>
                                            <div>‚Ä¢ <strong>Variant:</strong> Alternative style of the same glyph (adds to collection)</div>
                                            <div>‚Ä¢ <strong>Example:</strong> Additional training data (adds to collection)</div>
                                            <div>‚Ä¢ replace Hakli_glyphs.JSON </div>
                                        </div>
                                        {equivalenceChart && (
                                            <button
                                                onClick={exportUpdatedChart}
                                                className="mt-3 px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 text-sm"
                                            >
                                                üíæ Export Training Chart
                                            </button>
                                        )}
                                    </div>
                                )}
                                                            
                                <button onClick={() => setShowRegionBoundaries(!showRegionBoundaries)} className={`px-4 py-2 rounded ${showRegionBoundaries ? 'bg-purple-500 text-white hover:bg-purple-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>
                                    Region Boundaries
                                </button>
                                <button
                                    onClick={() => {
                                        if (confirm('üóëÔ∏è Clear all detections and start over?\n\nThis will remove:\n‚Ä¢ All detected glyphs\n‚Ä¢ All validations\n‚Ä¢ Manual selections\n‚Ä¢ Reading order\n\nThis cannot be undone!')) {
                                            setRecognitionResults([]);
                                            setValidations({});
                                            setSelectedRegions(new Set());
                                            setIsolatedGlyphs([]);
                                            setWordBoundaries(new Set());
                                            setReadingOrder([]);
                                            setMergeIndicator(null);
                                            setManualDetectionMode(false);
                                            setTrimMode(null);
                                            setExcludeMode(null);
                                            setExcludeRegions([]);
                                            recordAction('clear_all', { timestamp: new Date().toISOString() });
                                            alert('‚úÖ All detections cleared!');
                                        }
                                    }}
                                    className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                                    disabled={recognitionResults.length === 0}
                                >
                                    üóëÔ∏è Clear All
                                </button>
                                {isolatedGlyphs.length > 0 && (
                                    <button
                                        onClick={() => setShowRegionBoundaries(!showRegionBoundaries)}
                                        className="px-4 py-2 bg-teal-500 text-white rounded hover:bg-teal-600"
                                    >
                                        {showRegionBoundaries ? 'Hide' : 'Show'} Isolated Regions ({isolatedGlyphs.length})
                                    </button>
                                )}
                                <span className="text-sm text-gray-600">{recognitionResults.length} detections</span>
                            </div>

                            {recognitionResults.length > 0 && (
                                <div className="mt-4 p-4 bg-white border-2 border-gray-300 rounded-lg">
                                    <div className="flex items-center justify-between mb-3">
                                        <div className="flex items-center gap-3">
                                            <h4 className="font-semibold text-gray-900">Confidence Filter</h4>
                                            <label className="flex items-center gap-2 cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={useConfidenceFilter}
                                                    onChange={(e) => setUseConfidenceFilter(e.target.checked)}
                                                    className="w-4 h-4"
                                                />
                                                <span className="text-sm text-gray-700">Enable</span>
                                            </label>
                                        </div>
                                        <div className="text-sm">
                                            {useConfidenceFilter ? (
                                                <span className="text-blue-600 font-semibold">
                                                    Showing {getFilteredResults().length} of {recognitionResults.length} detections
                                                    {recognitionResults.length - getFilteredResults().length > 0 && (
                                                        <span className="text-gray-500 ml-2">
                                                            ({recognitionResults.length - getFilteredResults().length} hidden)
                                                        </span>
                                                    )}
                                                </span>
                                            ) : (
                                                <span className="text-gray-600">Showing all {recognitionResults.length} detections</span>
                                            )}
                                        </div>
                                    </div>
                                    
                                    <div className="flex items-center gap-4">
                                        <label className="text-sm font-medium text-gray-700 whitespace-nowrap">
                                            Min Confidence: {confidenceThreshold}%
                                        </label>
                                        <input
                                            type="range"
                                            min="0"
                                            max="100"
                                            value={confidenceThreshold}
                                            onChange={(e) => setConfidenceThreshold(parseInt(e.target.value))}
                                            disabled={!useConfidenceFilter}
                                            className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed"
                                            style={{
                                                background: useConfidenceFilter 
                                                    ? `linear-gradient(to right, #ef4444 0%, #f59e0b ${confidenceThreshold / 2}%, #10b981 ${confidenceThreshold}%, #e5e7eb ${confidenceThreshold}%, #e5e7eb 100%)`
                                                    : '#e5e7eb'
                                            }}
                                        />
                                        <span className="text-xs text-gray-500 whitespace-nowrap">
                                            {confidenceThreshold < 40 && 'üî¥ Low'}
                                            {confidenceThreshold >= 40 && confidenceThreshold < 70 && 'üü° Medium'}
                                            {confidenceThreshold >= 70 && 'üü¢ High'}
                                        </span>
                                    </div>
                                </div>
                            )}
                                <button 
                                    onClick={undo}
                                    disabled={historyIndex <= 0}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed"
                                    title="Undo (Ctrl+Z)"
                                >
                                    ‚Ü∂ Undo
                                </button>
                                <button 
                                    onClick={redo}
                                    disabled={historyIndex >= stateHistory.length - 1}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed"
                                    title="Redo (Ctrl+Y)"
                                >
                                    ‚Ü∑ Redo
                                </button>

                            {selectedRegions.size > 0 && (
                                <div className="flex flex-wrap gap-3 items-center pt-3 border-t border-gray-200">
                                    <span className="text-sm text-gray-600">{selectedRegions.size} selected</span>
                                    {selectedRegions.size >= 2 && (
                                        <button onClick={mergeSelectedDetections} className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600">
                                            Merge Selected
                                        </button>
                                    )}
                                    <button onClick={() => setSelectedRegions(new Set())} className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                                        Clear Selection
                                    </button>
                                </div>
                            )}
                            
                            {manualDetectionMode && (
                                <div className="mt-3 p-3 bg-orange-50 border border-orange-200 rounded text-sm text-orange-800">
                                    Manual Mode: Click and drag to create detections. Ctrl/Cmd+Click to select for merging.
                                </div>
                            )}
                            {recognitionResults.length > 0 && (
                                <div className="mt-3 p-3 bg-blue-50 border border-blue-200 rounded text-sm text-blue-800">
                                    üí° Tip: Ctrl/Cmd+Click any detection box to select it. Delete (‚úï) Merge (‚ö°) and exclude buttons will appear.
                                </div>
                            )}
                        </div>
                    )}

                    {image && (
                        <div className="mb-6">
                            <div className="canvas-container relative" ref={imageContainerRef}
                                onMouseMove={handleImageMouseMove}
                                onMouseUp={handleImageMouseUp}
                                onMouseLeave={handleImageMouseUp}
                            >
                                <img
                                    ref={imageRef}
                                    src={image}
                                    alt="Uploaded inscription"
                                    className="max-w-full h-auto border border-gray-300 rounded"
                                    onMouseDown={handleImageMouseDown}
                                    style={{ 
                                        cursor: manualDetectionMode ? 'crosshair' : 'default',
                                        userSelect: 'none',
                                        pointerEvents: 'auto'
                                    }}
                                    draggable={false}
                                />

                                {/* Trim mode indicator */}
                                {trimMode !== null && recognitionResults[trimMode] && (() => {
                                    const det = recognitionResults[trimMode];
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div
                                            className="absolute border-4 border-dashed border-blue-500 bg-blue-100 bg-opacity-20 pointer-events-none"
                                            style={{
                                                left: det.position.x * scaleX + 'px',
                                                top: det.position.y * scaleY + 'px',
                                                width: det.position.width * scaleX + 'px',
                                                height: det.position.height * scaleY + 'px',
                                                zIndex: 20
                                            }}
                                        >
                                            <div className="absolute top-1 left-1 bg-blue-500 text-white text-xs px-2 py-1 rounded">
                                                ‚úÇÔ∏è Draw smaller box to trim
                                            </div>
                                        </div>
                                    );
                                })()}

                                {/* Exclude mode indicator */}
                                {excludeMode !== null && recognitionResults[excludeMode] && (() => {
                                    const det = recognitionResults[excludeMode];
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <>
                                            <div
                                                className="absolute border-4 border-dashed border-purple-500 bg-purple-100 bg-opacity-20 pointer-events-none"
                                                style={{
                                                    left: det.position.x * scaleX + 'px',
                                                    top: det.position.y * scaleY + 'px',
                                                    width: det.position.width * scaleX + 'px',
                                                    height: det.position.height * scaleY + 'px',
                                                    zIndex: 20
                                                }}
                                            >
                                                <div className="absolute top-1 left-1 bg-purple-500 text-white text-xs px-2 py-1 rounded">
                                                    üö´ Draw box(es) to exclude
                                                </div>
                                            </div>

                                            {/* Show exclusion regions */}
                                            {excludeRegions.map((exRegion, idx) => (
                                                <div
                                                    key={`exclude-${idx}`}
                                                    className="absolute border-2 border-red-500 bg-red-500 bg-opacity-30 pointer-events-none"
                                                    style={{
                                                        left: exRegion.x * scaleX + 'px',
                                                        top: exRegion.y * scaleY + 'px',
                                                        width: exRegion.width * scaleX + 'px',
                                                        height: exRegion.height * scaleY + 'px',
                                                        zIndex: 21
                                                    }}
                                                />
                                            ))}

                                            {/* Apply/Cancel buttons for exclude mode */}
                                            {excludeRegions.length > 0 && (
                                                <div
                                                    className="absolute flex gap-2"
                                                    style={{
                                                        left: det.position.x * scaleX + 'px',
                                                        bottom: 'calc(100% - ' + ((det.position.y + det.position.height) * scaleY) + 'px - 40px)',
                                                        zIndex: 22,
                                                        pointerEvents: 'auto'
                                                    }}
                                                >
                                                    <button
                                                        onClick={() => applyExclude(excludeMode)}
                                                        className="px-3 py-1 bg-green-500 text-white text-sm rounded hover:bg-green-600 font-semibold"
                                                    >
                                                        ‚úì Apply Exclusions
                                                    </button>
                                                    <button
                                                        onClick={() => {
                                                            setExcludeMode(null);
                                                            setExcludeRegions([]);
                                                        }}
                                                        className="px-3 py-1 bg-gray-500 text-white text-sm rounded hover:bg-gray-600"
                                                    >
                                                        ‚úï Cancel
                                                    </button>
                                                </div>
                                            )}
                                        </>
                                    );
                                })()}
                                
                                {showRegionBoundaries && isolatedGlyphs.map((region, index) => {
                                    if (!imageRef.current) return null;
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    const isSelected = selectedIsolatedRegion === index;
                                    return (
                                        <div
                                            key={`region-${index}`}
                                            className={`region-boundary cursor-pointer ${isSelected ? 'ring-2 ring-blue-500' : ''}`}
                                            style={{
                                                left: region.bounds.x * scaleX + 'px',
                                                top: region.bounds.y * scaleY + 'px',
                                                width: region.bounds.width * scaleX + 'px',
                                                height: region.bounds.height * scaleY + 'px',
                                                borderColor: isSelected ? '#3b82f6' : 'rgba(156, 163, 175, 0.5)'
                                            }}
                                            onClick={() => setSelectedIsolatedRegion(isSelected ? null : index)}
                                        />
                                    );
                                })}
                                
                                {recognitionResults.map((detection, index) => {
                                    if (!imageRef.current) return null;
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;

                                    let boxColor = '#3b82f6';
                                    const isSelected = selectedRegions.has(index);
                                    const isValidated = validations[index];

                                    if (isValidated) {
                                        boxColor = isValidated.isCorrect ? '#10b981' : '#ef4444';
                                    }

                                    return (
                                        <div
                                            key={`detection-${index}`}
                                            className={`detection-box ${isSelected ? 'selected' : ''} ${templateTrainingMode ? 'cursor-pointer hover:ring-4 hover:ring-purple-400' : ''}`}
                                            style={{
                                                left: detection.position.x * scaleX + 'px',
                                                top: detection.position.y * scaleY + 'px',
                                                width: detection.position.width * scaleX + 'px',
                                                height: detection.position.height * scaleY + 'px',
                                                borderColor: boxColor
                                            }}
                                            onClick={() => {
                                                if (templateTrainingMode) {
                                                    setSelectedForTemplate(index);
                                                } else {
                                                    toggleRegionSelection(index);
                                                }
                                            }}
                                        >
                                            <div className="detection-label" style={{ backgroundColor: boxColor + 'e6' }}>
                                                {detection.glyph.name}
                                                {detection.corrected && <span className="ml-1">‚úèÔ∏è</span>}
                                            </div>

                                            {viewMode === 'reading' && (
                                                <div className="reading-order-badge">
                                                    {getReadingOrderIndex(index)}
                                                </div>
                                            )}

                                            {templateTrainingMode && selectedForTemplate === index && (
                                                <div
                                                    className="absolute top-full left-0 mt-2 bg-white rounded-lg shadow-xl border-2 border-purple-400 p-3 z-50"
                                                    style={{ minWidth: '200px' }}
                                                    onClick={(e) => e.stopPropagation()}
                                                >
                                                    <div className="font-semibold text-sm mb-2 text-purple-900">
                                                        Save &quot;{detection.glyph.name}&quot; as:
                                                    </div>
                                                    <div className="flex flex-col gap-2">
                                                        <button
                                                            onClick={() => saveAsTemplate(index, 'primary')}
                                                            className="px-3 py-2 bg-blue-500 text-white text-sm rounded hover:bg-blue-600"
                                                        >
                                                            üéØ Primary Template
                                                        </button>
                                                        <button
                                                            onClick={() => saveAsTemplate(index, 'variant')}
                                                            className="px-3 py-2 bg-green-500 text-white text-sm rounded hover:bg-green-600"
                                                        >
                                                            ‚≠ê Variant
                                                        </button>
                                                        <button
                                                            onClick={() => saveAsTemplate(index, 'example')}
                                                            className="px-3 py-2 bg-yellow-500 text-white text-sm rounded hover:bg-yellow-600"
                                                        >
                                                            üìö Example
                                                        </button>
                                                        <button
                                                            onClick={() => setSelectedForTemplate(null)}
                                                            className="px-3 py-2 bg-gray-300 text-gray-700 text-sm rounded hover:bg-gray-400"
                                                        >
                                                            ‚úï Cancel
                                                        </button>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                                
                                {isDrawing && drawStart && drawCurrent && imageRef.current && (() => {
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div className="manual-selection-box" style={{
                                            left: Math.min(drawStart.x, drawCurrent.x) * scaleX + 'px',
                                            top: Math.min(drawStart.y, drawCurrent.y) * scaleY + 'px',
                                            width: Math.abs(drawCurrent.x - drawStart.x) * scaleX + 'px',
                                            height: Math.abs(drawCurrent.y - drawStart.y) * scaleY + 'px'
                                        }} />
                                    );
                                })()}
                                
                                {mergeIndicator && imageRef.current && (() => {
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div className="merge-indicator" style={{
                                            left: mergeIndicator.x * scaleX + 'px',
                                            top: mergeIndicator.y * scaleY + 'px',
                                            width: mergeIndicator.width * scaleX + 'px',
                                            height: mergeIndicator.height * scaleY + 'px'
                                        }} />
                                    );
                                })()}
                            </div>
                        </div>
                    )}
                        {isolatedGlyphs.length > 0 && showRegionBoundaries && (
                        <div className="mt-4 p-4 bg-gray-50 border-2 border-teal-300 rounded-lg">
                            <h4 className="font-semibold text-gray-900 mb-3">Isolated Glyph Regions ({isolatedGlyphs.length})</h4>
                            <div className="mb-2 text-sm text-gray-600">
                                üí° Hover over a region to see the delete button
                            </div>
                            <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-2">
                                {isolatedGlyphs.map((region, index) => {
                                    const letter = String.fromCharCode(65 + index);
                                    return (
                                        <div
                                            key={`thumb-${index}`}
                                            className="relative flex flex-col items-center p-2 bg-white border-2 border-gray-300 rounded hover:border-blue-400 hover:shadow-lg transition-all group"
                                        >
                                            {region.thumbnail && (
                                                <img src={region.thumbnail} alt={`Region ${letter}`} className="w-full h-auto border border-gray-200" />
                                            )}
                                            <div className="text-xs font-bold text-teal-600 mt-1">{letter}</div>
                                            <div className="text-xs text-gray-500">{region.bounds.width}√ó{region.bounds.height}</div>

                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (confirm(`Delete region ${letter}?\n\nThis will remove the isolated region and any detection associated with it.`)) {
                                                        deleteIsolatedRegion(index);
                                                    }
                                                }}
                                                className="absolute -top-2 -right-2 w-6 h-6 bg-red-500 text-white rounded-full hover:bg-red-600 flex items-center justify-center text-sm font-bold shadow-lg opacity-0 group-hover:opacity-100 transition-opacity"
                                                title="Delete this region"
                                            >
                                                √ó
                                            </button>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    {correctionMode !== null && equivalenceChart && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={cancelCorrection}>
                            <div className="bg-white rounded-lg p-6 max-w-5xl w-full max-h-[85vh] overflow-y-auto shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900">Select Correct Glyph</h3>
                                    <button 
                                        onClick={cancelCorrection} 
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none w-8 h-8 flex items-center justify-center"
                                        title="Close (Esc)"
                                    >
                                        &times;
                                    </button>
                                </div>
                                
                                <div className="mb-4 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-blue-200 rounded-lg">
                                    <div className="flex items-center justify-between gap-4">
                                        <div className="flex-1">
                                            <span className="text-sm text-gray-600">Currently detected as:</span>
                                            <div className="text-xl font-bold text-gray-900 mt-1">
                                                {recognitionResults[correctionMode].glyph.name}
                                                <span className="ml-3 text-base font-normal text-gray-600">
                                                    ({recognitionResults[correctionMode].glyph.transliteration || recognitionResults[correctionMode].glyph.name})
                                                </span>
                                            </div>
                                            <div className="text-sm text-gray-500 mt-1">
                                                {Math.round(recognitionResults[correctionMode].confidence * 100)}% confidence
                                            </div>
                                        </div>
                                        {recognitionResults[correctionMode].regionIndex !== undefined &&
                                            isolatedGlyphs[recognitionResults[correctionMode].regionIndex]?.thumbnail && (
                                                <div className="flex-shrink-0">
                                                    <div className="text-xs text-gray-600 mb-1 text-center">Detected Region:</div>
                                                    <img
                                                        src={isolatedGlyphs[recognitionResults[correctionMode].regionIndex].thumbnail}
                                                        alt="Isolated region"
                                                        className="w-32 h-auto border-2 border-blue-300 rounded"
                                                    />
                                                </div>
                                            )}
                                    </div>
                                </div>                          
                                <div className="mb-4">
                                    <input
                                        type="text"
                                        placeholder="Search glyphs by name or transliteration..."
                                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none"
                                        onChange={(e) => {
                                            const searchTerm = e.target.value.toLowerCase();
                                            const glyphGrid = e.target.parentElement.nextElementSibling;
                                            const buttons = glyphGrid.querySelectorAll('button');
                                            buttons.forEach(btn => {
                                                const text = btn.textContent.toLowerCase();
                                                btn.style.display = text.includes(searchTerm) ? '' : 'none';
                                            });
                                        }}
                                    />
                                </div>
                                
                                {(() => {
                                    const suggestion = getCorrectionSuggestion(recognitionResults[correctionMode].glyph.id);
                                    if (suggestion) {
                                        return (
                                            <div className="mb-4 p-3 bg-green-50 border-2 border-green-300 rounded-lg">
                                                <div className="flex items-center justify-between">
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-green-700 font-semibold">üí° Suggestion:</span>
                                                        <span className="text-gray-700">
                                                            You've corrected this to <strong>{suggestion.to.name}</strong> {suggestion.count} time{suggestion.count > 1 ? 's' : ''} before
                                                        </span>
                                                    </div>
                                                    <button
                                                        onClick={() => applyCorrection(correctionMode, suggestion.to)}
                                                        className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 font-semibold"
                                                    >
                                                        Apply Suggestion
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    }
                                    return null;
                                })()}

                                <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2">
                                    {equivalenceChart.glyphs.map((glyph, index) => {
                                        const isCurrentGlyph = glyph.id === recognitionResults[correctionMode].glyph.id;
                                        return (
                                            <button
                                                key={`glyph-${glyph.id}-${index}`}
                                                onClick={() => applyCorrection(correctionMode, glyph)}
                                                className={`p-3 border-2 rounded-lg flex flex-col items-center gap-1 transition-all hover:scale-105 ${
                                                    isCurrentGlyph 
                                                        ? 'border-blue-500 bg-blue-50 ring-2 ring-blue-300' 
                                                        : 'border-gray-200 hover:border-blue-400 hover:bg-blue-50'
                                                }`}
                                                title={`${glyph.name} (${glyph.transliteration || glyph.name})`}
                                            >
                                                <div className="font-bold text-xl">{glyph.name}</div>
                                                <div className="text-xs text-gray-600 text-center leading-tight">
                                                    {glyph.transliteration || glyph.name}
                                                </div>
                                                {isCurrentGlyph && (
                                                    <div className="text-xs text-blue-600 font-semibold mt-1">Current</div>
                                                )}
                                            </button>
                                        );
                                    })}
                                </div>
                                
                                <div className="mt-6 pt-4 border-t border-gray-200 flex items-center justify-between">
                                    <div className="text-sm text-gray-500">
                                        üí° Tip: You can also search glyphs above to find them quickly
                                    </div>
                                    <button 
                                        onClick={cancelCorrection}
                                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <h3 className="font-semibold text-gray-900 mb-3">
                                {viewMode === 'detection' ? 'Detection Results' : 'Reading Order Results'}
                                {viewMode === 'reading' && <span className="ml-2 text-sm text-gray-600">(drag cards to reorder)</span>}
                            </h3>
                            
                            {/* Validation Statistics */}
                            <div className="mb-4 flex flex-wrap gap-4 text-sm">
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-600">Total:</span>
                                    <span className="font-semibold text-gray-900">{recognitionResults.length}</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-green-600">‚úì Validated Correct:</span>
                                    <span className="font-semibold text-green-700">
                                        {Object.values(validations).filter(v => v.isCorrect).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-red-600">‚úó Validated Incorrect:</span>
                                    <span className="font-semibold text-red-700">
                                        {Object.values(validations).filter(v => !v.isCorrect).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-orange-600">‚úèÔ∏è Corrected:</span>
                                    <span className="font-semibold text-orange-700">
                                        {recognitionResults.filter(r => r.corrected).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-600">Unvalidated:</span>
                                    <span className="font-semibold text-gray-700">
                                        {recognitionResults.length - Object.keys(validations).length}
                                    </span>
                                </div>
                            </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                        {(viewMode === 'detection' ? getFilteredResults() : getReadingOrderedResults().filter(r => getFilteredResults().includes(r))).map((result, displayIndex) => {
                            const originalIndex = viewMode === 'detection' ? displayIndex : recognitionResults.indexOf(result);
                            const readingOrderNum = viewMode === 'reading' ? displayIndex + 1 : null;
                            
                            return (
                                <div 
                                    key={`result-${originalIndex}`} 
                                    className={`p-3 bg-white rounded border ${selectedRegions.has(originalIndex) ? 'ring-2 ring-amber-400' : ''} ${validations[originalIndex] ? (validations[originalIndex].isCorrect ? 'border-green-300' : 'border-red-300') : 'border-gray-200'} ${viewMode === 'reading' ? 'cursor-move' : ''}`}
                                    draggable={viewMode === 'reading'}
                                    onDragStart={(e) => viewMode === 'reading' && handleDragStart(e, displayIndex)}
                                    onDragOver={(e) => viewMode === 'reading' && handleDragOver(e, displayIndex)}
                                    onDrop={(e) => viewMode === 'reading' && handleDrop(e, displayIndex)}
                                >
                                    <div className="flex items-start justify-between mb-2">
                                        <div className="flex-1">
                                            <div className="flex items-center gap-2">
                                                {viewMode === 'reading' && (
                                                    <div className="flex-shrink-0 w-6 h-6 rounded-full bg-yellow-400 border-2 border-yellow-600 text-xs font-bold flex items-center justify-center">
                                                        {readingOrderNum}
                                                    </div>
                                                )}
                                                <div className="flex-1">
                                                    <div className="font-medium text-gray-900 flex items-center gap-2">
                                                        {result.glyph.name}
                                                        {result.corrected && (
                                                            <span className="text-xs bg-orange-100 text-orange-700 px-2 py-0.5 rounded border border-orange-300">
                                                                ‚úèÔ∏è Corrected
                                                            </span>
                                                        )}
                                                        {result.isMerged && <span className="text-xs text-gray-500">(merged)</span>}
                                                        {result.isManual && <span className="text-xs text-gray-500">(manual)</span>}
                                                    </div>
                                                    {result.corrected && result.originalGlyph && (
                                                        <div className="text-xs text-gray-500 mt-0.5">
                                                            Originally: <span className="line-through">{result.originalGlyph.name}</span>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="text-sm text-gray-600 mt-1">{result.glyph.transliteration || result.glyph.name}</div>
                                            <div className="text-xs text-gray-500">Confidence: {Math.round(result.confidence * 100)}%</div>
                                            {result.regionIndex !== undefined && isolatedGlyphs[result.regionIndex]?.thumbnail && (
                                                <div className="mt-2 flex items-center gap-2">
                                                    <span className="text-xs text-gray-500">Region:</span>
                                                    <img
                                                        src={isolatedGlyphs[result.regionIndex].thumbnail}
                                                        alt="Isolated region"
                                                        className="w-16 h-auto border border-gray-300 rounded"
                                                    />
                                                </div>
                                            )}
                                        </div>
                                        <div className="flex gap-1">
                                            <button 
                                                onClick={() => startCorrection(originalIndex)} 
                                                className="text-orange-500 hover:text-orange-700 text-sm"
                                                title="Change glyph"
                                            >
                                                ‚úèÔ∏è
                                            </button>
                                            <button 
                                                onClick={() => deleteDetection(originalIndex)} 
                                                className="text-red-500 hover:text-red-700 text-sm"
                                                title="Delete detection"
                                            >
                                                ‚úï
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex gap-2 flex-wrap">
                                        <button 
                                            onClick={() => validateDetection(originalIndex, true)} 
                                            className={`px-3 py-1 text-xs rounded ${validations[originalIndex]?.isCorrect ? 'bg-green-500 text-white' : 'bg-green-100 text-green-700 hover:bg-green-200'}`}
                                        >
                                            ‚úì Correct
                                        </button>
                                        <button 
                                            onClick={() => validateDetection(originalIndex, false)} 
                                            className={`px-3 py-1 text-xs rounded ${validations[originalIndex] && !validations[originalIndex].isCorrect ? 'bg-red-500 text-white' : 'bg-red-100 text-red-700 hover:bg-red-200'}`}
                                        >
                                            ‚úó Incorrect
                                        </button>
                                        {viewMode === 'reading' && (
                                            <button 
                                                onClick={() => toggleWordBoundary(displayIndex)} 
                                                className={`px-3 py-1 text-xs rounded ${wordBoundaries.has(displayIndex) ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Mark word boundary after this glyph"
                                            >
                                                | Word Break
                                            </button>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                    </div>
                    )}


                    {viewMode === 'reading' && recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border-2 border-blue-200">
                            <div className="flex items-center justify-between mb-3">
                                <h3 className="font-semibold text-gray-900">Transcription</h3>
                                <div className="flex gap-2">
                                    <button 
                                        onClick={copyTranscriptionToClipboard}
                                        className="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 flex items-center gap-1"
                                        title="Copy transcription to clipboard"
                                    >
                                        üìã Copy
                                    </button>
                                    <button 
                                        onClick={exportTranscription}
                                        className="px-3 py-1 bg-green-500 text-white text-sm rounded hover:bg-green-600 flex items-center gap-1"
                                        title="Download transcription as text file"
                                    >
                                        üíæ Export TXT
                                    </button>
                                </div>
                            </div>
                            <div className="p-4 bg-white rounded border-2 border-blue-300 shadow-inner">
                                <div className="font-mono text-lg leading-relaxed">
                                    {getReadingOrderedResults().map((result, index) => (
                                        <span key={index}>
                                            <span className="text-gray-900">{result.glyph.transliteration || result.glyph.name}</span>
                                            {wordBoundaries.has(index) && <span className="text-blue-600 font-bold mx-1">|</span>}
                                            {!wordBoundaries.has(index) && index < getReadingOrderedResults().length - 1 && <span className="text-gray-400">¬∑</span>}
                                        </span>
                                    ))}
                                </div>
                            </div>

                            <div className="mt-3 text-xs text-gray-600">
                                <span className="text-blue-600 font-bold">|</span> = word boundary &middot; 
                                <span className="text-gray-400">&middot;</span> = glyph separator
                            </div>
                        </div>
                    )}

                    <div className="mt-8 p-4 bg-gray-50 rounded-lg">
                        <div className="text-sm text-gray-600">
                            <div className="flex items-center gap-2">
                                <span className={`w-2 h-2 rounded-full ${isOpenCvReady ? 'bg-green-500' : 'bg-red-500'}`} />
                                OpenCV Status: {isOpenCvReady ? 'Ready' : 'Loading...'}
                                {actionHistory.length > 0 && <span className="ml-4 text-xs text-gray-500">{actionHistory.length} actions recorded</span>}
                            </div>
                        </div>
                    </div>

                    {recognitionResults.length > 0 && (
                        <div className="mt-6 p-4 bg-yellow-50 rounded-lg border-2 border-yellow-300">
                            <h3 className="font-semibold text-gray-900 mb-3">üß† Correction Memory</h3>
                            <div className="flex flex-wrap gap-3 items-center mb-3">
                                <input
                                    type="file"
                                    accept=".json"
                                    onChange={(e) => {
                                        const file = e.target.files[0];
                                        if (file) {
                                                const reader = new FileReader();
                                                reader.onload = (event) => importCorrectionMemory(event.target.result);
                                                reader.readAsText(file);
                                            }
                                        }}
                                        id="import-corrections"
                                         className="block text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-yellow-100 file:text-yellow-700 hover:file:bg-yellow-200"
                                 />
                                    <button
                                        onClick={exportCorrectionMemory}
                                        className="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600"
                                    >
                                        üì• Export Memory
                                    </button>
                                    <button
                                        onClick={() => setShowCloudSyncModal(true)}
                                        className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                                        >
                                        ‚òÅÔ∏è Cloud Sync
                                    </button>
                                    <button
                                        onClick={() => {
                                            if (confirm('Clear all correction memory? This cannot be undone.')) {
                                                localStorage.removeItem('hakliCorrections');
                                                alert('Correction memory cleared!');
                                            }
                                        }}
                                        className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                                    >
                                        üóëÔ∏è Clear Memory
                                    </button>
                                </div>
                                <div className="text-xs text-gray-600">
                                    üí° Import previously exported corrections to continue learning from your past work. Your corrections are automatically saved and will suggest glyphs you've corrected before.
                                </div>
                            </div>
                    )}
                    {recognitionResults.length > 0 && (       
                        <div className="mt-6 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                            <h3 className="font-semibold text-gray-900 mb-3">Export Options</h3>
                            <div className="flex flex-wrap gap-3">
                                <button
                                    onClick={exportHtmlReport}
                                    className="px-4 py-2 bg-emerald-500 text-white rounded hover:bg-emerald-600 flex items-center gap-2"
                                >
                                    üìÑ Export HTML Report
                                </button>
                                <button 
                                    onClick={exportDetectionData}
                                    className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 flex items-center gap-2"
                                >
                                    üìä Export Detection Data (JSON)
                                </button>
                                <button 
                                    onClick={exportAnnotatedImage}
                                    className="px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 flex items-center gap-2"
                                >
                                    üñºÔ∏è Export Annotated Image
                                </button>
                                {viewMode === 'reading' && (
                                    <button 
                                        onClick={exportTranscription}
                                        className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 flex items-center gap-2"
                                    >
                                        üìù Export Transcription (TXT)
                                    </button>
                                )}
                                <button
                                    onClick={exportCorrectionMemory}
                                    className="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 flex items-center gap-2"
                                >
                                    üß† Export Correction Memory
                                </button>
                            </div>
                            <div className="mt-3 text-xs text-gray-600">
                                Export your work in different formats: JSON for data analysis, annotated images for presentations, or plain text transcriptions.
                            </div>
                        </div>
                    )}
                    
                    {showCloudSyncModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setShowCloudSyncModal(false)}>
                            <div className="bg-white rounded-lg p-6 max-w-2xl w-full shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900">‚òÅÔ∏è Cloud Sync</h3>
                                    <button
                                        onClick={() => setShowCloudSyncModal(false)}
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                    >
                                        &times;
                                    </button>
                                </div>

                                <div className="space-y-4">
                                    {/* Download from Master */}
                                    <div className="p-4 bg-blue-50 border-2 border-blue-200 rounded-lg">
                                        <h4 className="font-semibold text-blue-900 mb-2">üì• Download Community Corrections</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Get the latest corrections from the community master collection
                                        </p>
                                        <button
                                            onClick={async () => {
                                                setShowCloudSyncModal(false);
                                                await downloadCorrectionsFromCloud(MASTER_PASTE_RAW_URL);
                                            }}
                                            className="w-full px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 font-semibold"
                                        >
                                            Download from Master Collection
                                        </button>
                                    </div>

                                    {/* Download from Custom URL */}
                                    <div className="p-4 bg-gray-50 border-2 border-gray-200 rounded-lg">
                                        <h4 className="font-semibold text-gray-900 mb-2">üîó Download from Custom URL</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Import corrections from a specific GitHub raw URL or other source
                                        </p>
                                        <div className="flex gap-2">
                                            <input
                                                type="text"
                                                placeholder="Paste raw JSON URL here..."
                                                value={customGistUrl}
                                                onChange={(e) => setCustomGistUrl(e.target.value)}
                                                className="flex-1 px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none"
                                            />
                                            <button
                                                onClick={async () => {
                                                    if (customGistUrl) {
                                                        setShowCloudSyncModal(false);
                                                        await downloadCorrectionsFromCloud(customGistUrl);
                                                        setCustomGistUrl('');
                                                    }
                                                }}
                                                disabled={!customGistUrl}
                                                className="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                            >
                                                Download
                                            </button>
                                        </div>
                                    </div>

                                    {/* Upload Your Corrections */}
                                    <div className="p-4 bg-green-50 border-2 border-green-200 rounded-lg">
                                        <h4 className="font-semibold text-green-900 mb-2">üì§ Share Your Corrections</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Export your corrections and submit them to the community via GitHub Issue
                                        </p>
                                        <button
                                            onClick={async () => {
                                                setShowCloudSyncModal(false);
                                                await uploadCorrectionsToCloud();
                                            }}
                                            className="w-full px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 font-semibold"
                                        >
                                            üì• Export & Create Issue
                                        </button>
                                        <div className="mt-3 text-xs text-gray-600 bg-white p-2 rounded border border-green-300">
                                            <p className="font-semibold mb-1">How it works:</p>
                                            <ol className="list-decimal list-inside space-y-1">
                                                <li>Downloads your corrections as a JSON file</li>
                                                <li>Opens a GitHub Issue template</li>
                                                <li>You attach the file and submit</li>
                                                <li>Corrections are reviewed and added to master</li>
                                            </ol>
                                        </div>
                                    </div>
                                </div>

                                <div className="mt-4 pt-4 border-t border-gray-200">
                                    <button
                                        onClick={() => setShowCloudSyncModal(false)}
                                        className="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                    >
                                        Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<HakliGlyphRecognizer />);
    </script>
</body>

</html>
