<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Glyph Recognizer - Modular</title>
    <meta name="description" content="Ancient South Arabian script recognition tool for field documentation">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#5d4e6d">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Hakli">
    <link rel="apple-touch-icon" href="favicon.svg">
    
    <!-- React & Babel -->
    <!-- DEVELOPMENT MODE (slower, more debugging info): -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- PRODUCTION MODE (faster, optimized - uncomment these and comment out development above to test): -->
    <!-- <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script> -->
    <!-- <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script> -->
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Custom Tailwind configuration with earthy archaeological palette
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Earthy archaeological palette inspired by ancient materials
                        'ancient-purple': '#5d4e6d',  // Tyrian purple (theme color)
                        'stone': '#8b7d6b',           // Weathered sandstone
                        'clay': '#a67c52',            // Terracotta/pottery
                        'patina': '#6b8e7f',          // Aged bronze/copper patina
                        'ochre': '#b8956a',           // Desert sand/ochre pigment
                        'rust': '#a0674f',            // Oxidized iron/rust
                        'stone-light': '#a69988',     // Lighter stone
                        'stone-dark': '#6d6355',      // Darker stone
                    }
                }
            }
        }
    </script>
    
    <!-- OpenCV -->
    <script>
        var isOpenCvReady = false;
        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('‚úÖ OpenCV.js is ready');
        }
    </script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        .detection-box {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
            border: 3px solid;
            border-radius: 4px;
            cursor: pointer;
        }
        .detection-box.validated-correct { border-color: #6b8e7f; background: rgba(107, 142, 127, 0.25); }
        .detection-box.validated-incorrect { border-color: #a0674f; background: rgba(239, 68, 68, 0.25); }
        .detection-box.unvalidated { border-color: #8b7d6b; background: rgba(59, 130, 246, 0.25); }
        .detection-box.selected { border-color: #b8956a; background: rgba(245, 158, 11, 0.3); border-width: 4px; }
        .detection-box.uncertain { border-style: dashed; border-color: #f97316; background: rgba(249, 115, 22, 0.15); }
        .detection-box.uncertain.validated-correct { border-style: dashed; border-color: #6b8e7f; }
        .detection-box.uncertain.validated-incorrect { border-style: dashed; border-color: #a0674f; }

        .detection-label {
            position: absolute;
            top: -25px;
            left: 0;
            padding: 2px 8px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            border-radius: 3px;
            white-space: nowrap;
            opacity: 0.9;
        }
        
        .reading-order-badge {
            position: absolute;
            top: -20px;
            left: -20px;
            width: 28px;
            height: 28px;
            background-color: #b8956a;
            border: 2px solid #8d7350;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
            z-index: 20;
        }
        
        .canvas-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }
        
        .manual-selection-box {
            position: absolute;
            border: 2px dashed #b8956a;
            background: rgba(245, 158, 11, 0.1);
            pointer-events: none;
            z-index: 5;
        }
        
        .region-boundary {
            position: absolute;
            border: 1px solid rgba(156, 163, 175, 0.5);
            background: rgba(156, 163, 175, 0.05);
            pointer-events: none;
            z-index: 3;
        }
        
        .merge-indicator {
            position: absolute;
            border: 3px solid #8b5cf6;
            background: rgba(139, 92, 246, 0.15);
            border-radius: 8px;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- ========================================== -->
    <!-- MODULAR BACKEND - Loads before app        -->
    <!-- ========================================== -->
    
    <!-- Core -->
    <script src="src/core/config.js"></script>
    <script src="src/utils/helpers.js"></script>
    
    <!-- Storage -->
    <script src="src/storage/hki.js"></script>
    <script src="src/storage/cache.js"></script>
    <script src="src/storage/corrections.js"></script>
    <script src="src/storage/export.js"></script>
    
    <!-- Recognition -->
    <script src="src/recognition/preprocessing.js"></script>
    <script src="src/recognition/isolation.js"></script>
    <script src="src/recognition/matching.js"></script>
    <script src="src/recognition/nms.js"></script>
    <script src="src/recognition/validation.js"></script>
    <script src="src/recognition/template-learning.js"></script>
    
    <!-- Reading & Transcription -->
    <script src="src/reading/reading.js"></script>
    <script src="src/reading/transcription.js"></script>
    
    <!-- Cloud Sync -->
    <script src="src/storage/drive-sync.js"></script>
    
    <script>
        // Verify backend
        console.log('üöÄ Hakli Glyph Recognizer - Modular v251215');
        
        // List available TTS voices after they load
        if ('speechSynthesis' in window) {
            // Voices load asynchronously, so we need to wait
            const listVoices = () => {
                const voices = window.speechSynthesis.getVoices();
                const arabicVoices = voices.filter(v => v.lang.startsWith('ar'));
                const englishVoices = voices.filter(v => v.lang.startsWith('en'));
                
                console.log('üîä Text-to-Speech Voices Available:');
                console.log('üìó English voices:', englishVoices.length);
                englishVoices.forEach(v => console.log('  -', v.name, '(' + v.lang + ')'));
                console.log('üìï Arabic voices:', arabicVoices.length);
                if (arabicVoices.length > 0) {
                    arabicVoices.forEach(v => console.log('  -', v.name, '(' + v.lang + ')'));
                } else {
                    console.log('  ‚ö†Ô∏è No Arabic voices found. Install Arabic language pack for better pronunciation.');
                }
            };
            
            // Try immediately (sometimes works)
            if (window.speechSynthesis.getVoices().length > 0) {
                listVoices();
            }
            // Also listen for voices to load (more reliable)
            window.speechSynthesis.onvoiceschanged = listVoices;
        } else {
            console.warn('‚ö†Ô∏è Text-to-speech not supported in this browser');
        }
        const modulesLoaded = {
            config: typeof CONFIG !== 'undefined',
            utils: typeof Utils !== 'undefined',
            hki: typeof HKIStorage !== 'undefined',
            cache: typeof CacheStorage !== 'undefined',
            corrections: typeof CorrectionMemory !== 'undefined',
            export: typeof ExportUtils !== 'undefined',
            isolation: typeof Isolation !== 'undefined',
            matching: typeof Matching !== 'undefined',
            preprocessing: typeof Preprocessing !== 'undefined',
            nms: typeof NMS !== 'undefined',
            validation: typeof Validation !== 'undefined',
            polygonRegion: typeof PolygonRegion !== 'undefined',
            templateLearning: typeof TemplateLearning !== 'undefined',
            readingOrder: typeof ReadingOrder !== 'undefined',
            transcription: typeof Transcription !== 'undefined',
            driveSync: typeof DriveSync !== 'undefined'
        };
        console.log('üì¶ Modular backend:', modulesLoaded);
        const allLoaded = Object.values(modulesLoaded).every(v => v);
        if (allLoaded) {
            console.log('‚úÖ All backend modules loaded - App starting with full modular backend');
        } else {
            const missing = Object.entries(modulesLoaded).filter(([k, v]) => !v).map(([k]) => k);
            console.warn('‚ö†Ô∏è Missing modules:', missing.join(', '));
        }
    </script>

    <!-- ========================================== -->
    <!-- ORIGINAL APPLICATION CODE                  -->
    <!-- ========================================== -->

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function HakliGlyphRecognizer() {
            const [image, setImage] = useState(null);
            const [displayImage, setDisplayImage] = useState(null); // The image to display (may be rotated)
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [chartLoadStatus, setChartLoadStatus] = useState('not-loaded');
            const [loadedGlyphImages, setLoadedGlyphImages] = useState({});
            const [manualDetectionMode, setManualDetectionMode] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawStart, setDrawStart] = useState(null);
            const [drawCurrent, setDrawCurrent] = useState(null);
            const [selectedRegions, setSelectedRegions] = useState(new Set());
            const [validations, setValidations] = useState({});
            const [actionHistory, setActionHistory] = useState([]);
            const [isolatedGlyphs, setIsolatedGlyphs] = useState([]);
            const [showRegionBoundaries, setShowRegionBoundaries] = useState(false);
            const [mergeIndicator, setMergeIndicator] = useState(null);
            const [showChartViewer, setShowChartViewer] = useState(false);
            const [showCorrectionAnalysis, setShowCorrectionAnalysis] = useState(false);
            const [showArabicLabels, setShowArabicLabels] = useState(false);
            const [isChartStatusCollapsed, setIsChartStatusCollapsed] = useState(false);
            const [isRotationCollapsed, setIsRotationCollapsed] = useState(true); // Start collapsed
            const [isBlurCollapsed, setIsBlurCollapsed] = useState(true); // Start collapsed
            const [isThresholdCollapsed, setIsThresholdCollapsed] = useState(false); // Expanded - most used
            const [isMorphCollapsed, setIsMorphCollapsed] = useState(true); // Start collapsed
            const [isControlsCollapsed, setIsControlsCollapsed] = useState(true); // Start collapsed - Recognize button shown in header
            const [isViewModeCollapsed, setIsViewModeCollapsed] = useState(false);
            const [isCorrectionMemoryCollapsed, setIsCorrectionMemoryCollapsed] = useState(true); // Start collapsed
            const [isExportOptionsCollapsed, setIsExportOptionsCollapsed] = useState(true); // Start collapsed
            const [processingProgress, setProcessingProgress] = useState({ current: 0, total: 0 });
            const [imageLoadingProgress, setImageLoadingProgress] = useState({ loaded: 0, total: 0 });

            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);

            const [viewMode, setViewMode] = useState('detection'); // 'detection' or 'reading'
            const [readingDirection, setReadingDirection] = useState('detection'); // 'detection', 'ltr', 'rtl', 'ttb'
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [columnBreaks, setColumnBreaks] = useState(new Set()); // Mark end of column after this glyph
            const [lineBreaks, setLineBreaks] = useState(new Set()); // Mark end of line after this glyph
            const [readingOrder, setReadingOrder] = useState([]); // Array of indices for manual ordering
            const [draggedItem, setDraggedItem] = useState(null);
            const [correctionMode, setCorrectionMode] = useState(null); // Index of detection being corrected, or null
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [stateHistory, setStateHistory] = useState([]);
            const [confidenceThreshold, setConfidenceThreshold] = useState(0);
            const [useConfidenceFilter, setUseConfidenceFilter] = useState(false);
            const [showConfidenceFilter, setShowConfidenceFilter] = useState(false);
            const [imageRotation, setImageRotation] = useState(0);
            const [rotatedImageDimensions, setRotatedImageDimensions] = useState(null); // { width, height } of rotated image used in recognition
            const [showCloudSyncModal, setShowCloudSyncModal] = useState(false);
            const [showCommunityModal, setShowCommunityModal] = useState(false);
            const [customGistUrl, setCustomGistUrl] = useState('');
            const [showFilePickerModal, setShowFilePickerModal] = useState(null); // { files: [], isLoading: boolean }
            const [showTopMatches, setShowTopMatches] = useState(false); // Toggle for showing alternative matches in cards
            const [driveAuthStatus, setDriveAuthStatus] = useState(0); // Counter to force re-render when auth changes
            const [trimMode, setTrimMode] = useState(null); // Index of detection being trimmed, or null
            const [excludeMode, setExcludeMode] = useState(null); // Index of detection being excluded, or null
            const [excludeRegions, setExcludeRegions] = useState([]); // Array of exclusion boxes
            const [selectedIsolatedRegion, setSelectedIsolatedRegion] = useState(null); // to enable delete when show isolated
            const [templateTrainingMode, setTemplateTrainingMode] = useState(false); // add glyph to template 
            const [selectedForTemplate, setSelectedForTemplate] = useState(null);
            const [adjustMode, setAdjustMode] = useState(null); // Index of detection being adjusted, or null
            const [draggingCorner, setDraggingCorner] = useState(null); // Which corner is being dragged: 'tl', 'tr', 'bl', 'br'
            const [dragStartPos, setDragStartPos] = useState(null); // Starting position of drag
            const [transcriptionPosition, setTranscriptionPosition] = useState({ x: 0, y: 0 }); // Position of draggable transcription box
            const [isDraggingTranscription, setIsDraggingTranscription] = useState(false);
            const [transcriptionDragStart, setTranscriptionDragStart] = useState({ x: 0, y: 0 });
            const [showTranscription, setShowTranscription] = useState(true); // Show/hide transcription box
            
            // Preprocessing state
            const [isPreprocessingCollapsed, setIsPreprocessingCollapsed] = useState(false);
            const [showPreprocessPreview, setShowPreprocessPreview] = useState(true);
            const [preprocessing, setPreprocessing] = useState({
                rotation: 0,
                useAdaptiveThreshold: false,
                blockSize: 11,
                constantOffset: 2,
                gaussianBlur: 0,
                morphologyOperation: 'none',
                invertColors: false
            });
            const [originalMat, setOriginalMat] = useState(null);
            const [preprocessedMat, setPreprocessedMat] = useState(null);
            
            // Dismissable tips state
            const [dismissedTips, setDismissedTips] = useState(() => {
                try {
                    const saved = localStorage.getItem('hakli_dismissed_tips');
                    return saved ? JSON.parse(saved) : {};
                } catch { return {}; }
            });
            
            // Dismiss a tip permanently
            const dismissTip = (tipId) => {
                const updated = { ...dismissedTips, [tipId]: true };
                setDismissedTips(updated);
                localStorage.setItem('hakli_dismissed_tips', JSON.stringify(updated));
            };
            
            // Reset all tips (for settings)
            const resetAllTips = () => {
                setDismissedTips({});
                localStorage.removeItem('hakli_dismissed_tips');
            };
            
            // Dismissable tip component
            const DismissableTip = ({ id, children, className = '' }) => {
                if (dismissedTips[id]) return null;
                return (
                    <div className={`relative p-3 bg-[#f7f3ed] border-2 border-[#d4c4a8] rounded-lg ${className}`}>
                        <button
                            onClick={() => dismissTip(id)}
                            className="absolute top-1 right-1 w-6 h-6 flex items-center justify-center text-yellow-600 hover:text-[#6d5d42] hover:bg-yellow-100 rounded-full transition-colors"
                            title="Dismiss this tip"
                        >
                            ‚úï
                        </button>
                        <div className="pr-6 text-sm text-[#6d5d42]">{children}</div>
                    </div>
                );
            };
            
            // Auto-detect reading direction using ReadingOrder module
            const autoDetectReadingOrder = () => {
                if (typeof ReadingOrder !== 'undefined' && recognitionResults.length > 0) {
                    // Use ALL results for reading order (confidence filtering only affects display)
                    const detected = ReadingOrder.detectDirection(recognitionResults);
                    setReadingDirection(detected);
                    const order = ReadingOrder.generateOrder(recognitionResults, detected);
                    setReadingOrder(order);
                    console.log(`üìñ Auto-detected: ${detected}, ordered ${order.length} glyphs`);
                    return detected;
                }
                return null;
            };
            const [adjustmentsApplied, setAdjustmentsApplied] = useState(false);
            const [isImageLoading, setIsImageLoading] = useState(false);
            const [eraserMode, setEraserMode] = useState(false);
            const [brushSize, setBrushSize] = useState(15);
            const [isErasing, setIsErasing] = useState(false);
            const [eraserHistory, setEraserHistory] = useState([]); // Track canvas states for undo
            const [eraserCursorStyle, setEraserCursorStyle] = useState('crosshair');
            const eraserCanvasRef = useRef(null);
            const preprocessCanvasRef = useRef(null);
            const originalCanvasRef = useRef(null);
            
            // Filter function for recognition results
            const getFilteredResults = () => {
                if (!useConfidenceFilter) {
                    return recognitionResults;
                }
                return recognitionResults.filter(r => r.confidence >= (confidenceThreshold / 100));
            };
            
            // Get results in reading order, applying confidence filter
            const getReadingOrderedResults = () => {
                const ordered = readingOrder.length === 0 
                    ? recognitionResults 
                    : readingOrder.map(index => recognitionResults[index]).filter(r => r !== undefined);
                
                // Apply confidence filter
                if (!useConfidenceFilter) {
                    return ordered;
                }
                return ordered.filter(r => r.confidence >= (confidenceThreshold / 100));
            };
            
            // Copy transcription to clipboard
            const copyTranscriptionToClipboard = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';
                
                orderedResults.forEach((result, index) => {
                    transcription += result.glyph.transliteration || result.glyph.name;
                    
                    if (viewMode === 'reading') {
                        if (lineBreaks.has(index)) {
                            transcription += '\n';
                        } else if (columnBreaks.has(index)) {
                            transcription += ' || ';
                        } else if (wordBoundaries.has(index)) {
                            transcription += ' | ';
                        } else if (index < orderedResults.length - 1) {
                            transcription += ' ';
                        }
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });
                
                navigator.clipboard.writeText(transcription).then(() => {
                    alert('‚úÖ Transcription copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    alert('‚ùå Failed to copy to clipboard');
                });
            };
            
            // Text-to-speech for transcription
            const speakTranscription = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let text = '';
                
                orderedResults.forEach((result, index) => {
                    // Use transliteration for English TTS, Arabic for Arabic TTS
                    const content = showArabicLabels 
                        ? (result.glyph.arabic || result.glyph.name)
                        : (result.glyph.transliteration || result.glyph.name);
                    
                    text += content;
                    
                    // Add pauses for breaks (longer pauses help with comprehension)
                    if (viewMode === 'reading') {
                        if (lineBreaks.has(index)) {
                            text += '. ';  // Full stop creates longer pause
                        } else if (columnBreaks.has(index)) {
                            text += ', ';  // Comma creates medium pause
                        } else if (wordBoundaries.has(index)) {
                            text += ' ';   // Space creates short pause
                        } else if (index < orderedResults.length - 1) {
                            text += ' ';
                        }
                    } else if (index < orderedResults.length - 1) {
                        text += ' ';
                    }
                });
                
                // Cancel any ongoing speech
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                    return; // If already speaking, just cancel (toggle behavior)
                }
                
                // Create speech utterance
                const utterance = new SpeechSynthesisUtterance(text);
                
                // Configure voice settings based on language
                if (showArabicLabels) {
                    // Arabic settings
                    utterance.lang = 'ar-SA';  // Arabic (Saudi Arabia) - closest to Omani Arabic
                    utterance.rate = 0.6;      // Slower for Semitic pronunciation
                    utterance.pitch = 1.0;
                } else {
                    // English transliteration settings
                    utterance.lang = 'en-US';
                    utterance.rate = 0.7;
                    utterance.pitch = 1.0;
                }
                
                utterance.volume = 1.0; // Full volume (0-1)
                
                // Try to select the best available voice
                const voices = window.speechSynthesis.getVoices();
                
                if (showArabicLabels) {
                    // Prioritize Arabic voices in this order:
                    // 1. ar-SA (Saudi) - closest to Omani/Jibbali
                    // 2. ar-EG (Egyptian) - widely understood
                    // 3. ar-* (any other Arabic)
                    const preferredVoice = voices.find(voice => voice.lang === 'ar-SA') ||
                                          voices.find(voice => voice.lang === 'ar-EG') ||
                                          voices.find(voice => voice.lang.startsWith('ar-')) ||
                                          voices.find(voice => voice.lang.startsWith('ar'));
                    
                    if (preferredVoice) {
                        utterance.voice = preferredVoice;
                        console.log('üîä Using Arabic voice:', preferredVoice.name, '(' + preferredVoice.lang + ')');
                    } else {
                        console.warn('‚ö†Ô∏è No Arabic voice found. Using system default.');
                        console.log('üí° Tip: Install Arabic language pack on your device for better pronunciation.');
                    }
                } else {
                    // English voice selection
                    const preferredVoice = voices.find(voice => voice.lang === 'en-US') ||
                                          voices.find(voice => voice.lang.startsWith('en'));
                    if (preferredVoice) {
                        utterance.voice = preferredVoice;
                    }
                }
                
                // Error handling
                utterance.onerror = (event) => {
                    console.error('Speech synthesis error:', event);
                    if (event.error === 'not-allowed') {
                        alert('‚ùå Text-to-speech blocked. Please allow audio playback in your browser.');
                    } else if (event.error === 'language-unavailable') {
                        alert('‚ùå Arabic language not available.\n\nüí° Install Arabic language pack on your device:\n\n‚Ä¢ Windows: Settings > Time & Language > Language\n‚Ä¢ macOS: System Preferences > Accessibility > Speech\n‚Ä¢ iOS: Settings > General > Keyboard > Keyboards > Add Arabic\n‚Ä¢ Android: Settings > System > Languages & input > Text-to-speech');
                    } else {
                        alert('‚ùå Text-to-speech failed: ' + event.error);
                    }
                };
                
                // Success callback
                utterance.onend = () => {
                    console.log('‚úÖ Speech synthesis completed');
                };
                
                // Speak the text
                window.speechSynthesis.speak(utterance);
            };
            
            // Action history tracking
            const recordAction = (actionType, actionData) => {
                const action = {
                    type: actionType,
                    data: actionData,
                    timestamp: new Date().toISOString(),
                    id: Date.now()
                };
                setActionHistory(prev => [...prev, action].slice(-50));
                // Only log important actions
                if (['exclude_regions', 'merge_detections', 'upload_to_cloud'].includes(actionType)) {
                    console.log(`‚úì ${actionType}:`, actionData);
                }
                // For modifying actions, snapshot is taken BEFORE the change (in the calling code)
                // This just logs the action for history
            };
            
            // Take snapshot of current state BEFORE making changes
            const takeSnapshotBeforeChange = () => {
                const snapshot = {
                    recognitionResults: [...recognitionResults],
                    validations: { ...validations },
                    selectedRegions: new Set(selectedRegions),
                    wordBoundaries: new Set(wordBoundaries),
                    readingOrder: [...readingOrder],
                    isolatedGlyphs: [...isolatedGlyphs]
                };
                
                // Remove any "future" history if we're not at the end
                const newHistory = stateHistory.slice(0, historyIndex + 1);
                newHistory.push(snapshot);
                
                // Keep only last 50 states
                const trimmedHistory = newHistory.slice(-50);
                
                setStateHistory(trimmedHistory);
                setHistoryIndex(trimmedHistory.length - 1);
                console.log('üì∏ Snapshot taken, history length:', trimmedHistory.length);
            };
            
            // Session save/load functions
            const saveSession = () => {
                const sessionData = {
                    image,
                    recognitionResults,
                    readingOrder,
                    wordBoundaries: Array.from(wordBoundaries),
                    columnBreaks: Array.from(columnBreaks),
                    lineBreaks: Array.from(lineBreaks),
                    translationEnglish,
                    translationArabic,
                    readingDirection,
                    viewMode,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(sessionData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_session_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('‚úÖ Session saved!');
                recordAction('save_session');
            };
            
            const loadSession = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const sessionData = JSON.parse(e.target.result);
                        
                        // Load image and process it through OpenCV
                        if (sessionData.image) {
                            setIsImageLoading(true);
                            const img = new Image();
                            img.onload = () => {
                                // Set the image
                                setImage(sessionData.image);
                                
                                // Create OpenCV Mat from image
                                if (isOpenCvReady) {
                                    const canvas = document.createElement('canvas');
                                    canvas.width = img.width;
                                    canvas.height = img.height;
                                    const ctx = canvas.getContext('2d');
                                    ctx.drawImage(img, 0, 0);
                                    
                                    const mat = cv.imread(canvas);
                                    setOriginalMat(mat);
                                    
                                    // Show original on canvas
                                    if (originalCanvasRef.current) {
                                        cv.imshow(originalCanvasRef.current, mat);
                                    }
                                    
                                    // Process with default or saved preprocessing settings
                                    processImageWithSettings(mat, preprocessing);
                                }
                                
                                setIsImageLoading(false);
                            };
                            img.onerror = () => {
                                setIsImageLoading(false);
                                alert('‚ùå Failed to load image from HKI file.');
                            };
                            img.src = sessionData.image;
                        }
                        
                        // Restore all other data
                        setRecognitionResults(sessionData.recognitionResults || []);
                        setReadingOrder(sessionData.readingOrder || []);
                        setWordBoundaries(new Set(sessionData.wordBoundaries || []));
                        setColumnBreaks(new Set(sessionData.columnBreaks || []));
                        setLineBreaks(new Set(sessionData.lineBreaks || []));
                        setTranslationEnglish(sessionData.translationEnglish || '');
                        setTranslationArabic(sessionData.translationArabic || '');
                        setInscriptionTitle(sessionData.inscriptionTitle || '');
                        setInscriptionNotes(sessionData.inscriptionNotes || '');
                        setReadingDirection(sessionData.readingDirection || 'detection');
                        setViewMode(sessionData.viewMode || 'detection');
                        
                        alert('‚úÖ Session loaded successfully!');
                        recordAction('load_session');
                    } catch (error) {
                        alert('‚ùå Failed to load session: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            // Undo/Redo functions
            const undo = () => {
                if (historyIndex <= 0) return;
                
                const previousState = stateHistory[historyIndex - 1];
                setRecognitionResults(previousState.recognitionResults);
                setValidations(previousState.validations);
                setSelectedRegions(previousState.selectedRegions);
                setWordBoundaries(previousState.wordBoundaries);
                setReadingOrder(previousState.readingOrder);
                setIsolatedGlyphs(previousState.isolatedGlyphs);
                setHistoryIndex(historyIndex - 1);
                
                console.log('Undo to state', historyIndex - 1);
            };

            const redo = () => {
                if (historyIndex >= stateHistory.length - 1) return;
                
                const nextState = stateHistory[historyIndex + 1];
                setRecognitionResults(nextState.recognitionResults);
                setValidations(nextState.validations);
                setSelectedRegions(nextState.selectedRegions);
                setWordBoundaries(nextState.wordBoundaries);
                setReadingOrder(nextState.readingOrder);
                setIsolatedGlyphs(nextState.isolatedGlyphs);
                setHistoryIndex(historyIndex + 1);
                
                console.log('Redo to state', historyIndex + 1);
            };
            
            // Aliases for consistency
            const handleUndo = undo;
            const handleRedo = redo;
            
            // Open JSON viewer in new window
            const openJsonViewer = () => {
                if (!recognitionResults || recognitionResults.length === 0) {
                    alert('‚ùå No data to view. Please detect glyphs first.');
                    return;
                }
                
                // Build current data and save to cache so viewer can access it
                const currentData = {
                    timestamp: new Date().toISOString(),
                    imageData: image || null,
                    viewMode: viewMode,
                    readingDirection: readingDirection,
                    detections: recognitionResults.map((result, index) => ({
                        index: index,
                        glyph: result.glyph.name,
                        transliteration: result.glyph.transliteration,
                        arabic: result.glyph.arabic || result.glyph.transliteration || result.glyph.name,
                        confidence: result.confidence,
                        position: result.position,
                        matchType: result.matchType,
                        isManual: result.isManual || false,
                        isMerged: result.isMerged || false,
                        validated: validations[index] ? validations[index].isCorrect : null
                    })),
                    readingOrder: viewMode === 'reading' ? readingOrder : null,
                    wordBoundaries: Array.from(wordBoundaries),
                    columnBreaks: Array.from(columnBreaks || []),
                    lineBreaks: Array.from(lineBreaks || []),
                    translations: {
                        english: translationEnglish || '',
                        arabic: translationArabic || ''
                    },
                    statistics: {
                        totalGlyphs: recognitionResults.length,
                        uniqueGlyphs: new Set(recognitionResults.map(r => r.glyph.name)).size,
                        averageConfidence: recognitionResults.length > 0 
                            ? (recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length * 100).toFixed(1)
                            : 0
                    }
                };
                
                // Save to cache so viewer can access it
                const filename = `Current_Inscription_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                saveToLocalCache(currentData, filename);
                
                // Open viewer window with autoload parameter
                const viewerUrl = window.location.href.replace('index.html', 'hakli_viewer.html').replace(/\/$/, '') + '/hakli_viewer.html?autoload=' + encodeURIComponent(filename);
                window.open(viewerUrl, 'HakliViewer', 'width=1200,height=800,menubar=no,toolbar=no,location=no,status=no');
            };
            
            // LocalStorage cache for recent exports
            const saveToLocalCache = (jsonData, filename) => {
                try {
                    const cache = JSON.parse(localStorage.getItem('hakliRecentExports') || '[]');
                    const newEntry = {
                        filename: filename,
                        data: jsonData,
                        timestamp: new Date().toISOString(),
                        id: Date.now()
                    };
                    
                    // Add to beginning, keep last 10
                    cache.unshift(newEntry);
                    const trimmedCache = cache.slice(0, 10);
                    
                    localStorage.setItem('hakliRecentExports', JSON.stringify(trimmedCache));
                    console.log('‚úì Saved to local cache');
                } catch (error) {
                    console.warn('Failed to cache locally:', error);
                }
            };
            
            const getLocalCache = () => {
                try {
                    return JSON.parse(localStorage.getItem('hakliRecentExports') || '[]');
                } catch (error) {
                    console.warn('Failed to read local cache:', error);
                    return [];
                }
            };
            
            // Save to Google Drive
            const saveToGoogleDrive = async () => {
                if (!recognitionResults || recognitionResults.length === 0) {
                    alert('‚ùå No data to save. Please detect glyphs first.');
                    return;
                }
                
                // Check if signed in to Google Drive
                if (typeof DriveSync === 'undefined' || !DriveSync.isSignedIn()) {
                    alert('‚ö†Ô∏è Please sign in to Google Drive first.\n\nClick "üîÑ Change Account" below to sign in with your Google account.');
                    setShowCloudSyncModal(true); // Open the modal to sign in
                    return;
                }
                
                // Prepare HKI data format
                // Ensure all results have thumbnails - copy from isolatedGlyphs if missing
                const resultsWithThumbnails = recognitionResults.map((result, index) => {
                    if (result.thumbnail) {
                        return result; // Already has thumbnail
                    }
                    
                    // Try to get thumbnail from isolatedGlyphs using regionIndex
                    if (result.regionIndex !== undefined && isolatedGlyphs[result.regionIndex]?.thumbnail) {
                        console.log(`üì∏ Copying missing thumbnail for result ${index} from isolatedGlyphs[${result.regionIndex}]`);
                        return {
                            ...result,
                            thumbnail: isolatedGlyphs[result.regionIndex].thumbnail
                        };
                    }
                    
                    console.warn(`‚ö†Ô∏è No thumbnail found for result ${index} (regionIndex: ${result.regionIndex})`);
                    return result;
                });
                
                const hkiData = {
                    version: "1.0",
                    timestamp: new Date().toISOString(),
                    inscriptionTitle: inscriptionTitle || `Inscription ${new Date().toLocaleDateString()}`,
                    location: '', // User can add this in metadata
                    image: image, // Base64 image
                    recognitionResults: resultsWithThumbnails,
                    readingOrder: readingOrder,
                    readingDirection: readingDirection,
                    wordBoundaries: Array.from(wordBoundaries),
                    columnBreaks: Array.from(columnBreaks || []),
                    lineBreaks: Array.from(lineBreaks || []),
                    validations: validations,
                    translationEnglish: translationEnglish || '',
                    translationArabic: translationArabic || '',
                    inscriptionNotes: inscriptionNotes || '',
                    actionHistory: actionHistory,
                    statistics: {
                        totalGlyphs: recognitionResults.length,
                        uniqueGlyphs: new Set(recognitionResults.map(r => r.glyph.name)).size,
                        averageConfidence: recognitionResults.length > 0 
                            ? (recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length)
                            : 0
                    }
                };
                
                try {
                    // Generate filename from inscription title
                    const title = inscriptionTitle || 'Inscription';
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    const filename = `${title.replace(/[^a-z0-9]/gi, '_')}_${timestamp}.hki`;
                    
                    const result = await DriveSync.saveToCloud(hkiData, filename);
                    if (result.success) {
                        alert('‚úÖ Saved to Google Drive!\n\nüìÅ File: ' + result.filename);
                        recordAction('save_to_drive', { filename: result.filename });
                    } else {
                        alert('‚ùå Save failed: ' + (result.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Save error:', error);
                    alert('‚ùå Save failed: ' + error.message);
                }
            };
            
            // Enhanced Transcription Display States
            const [showEnhancedTranscription, setShowEnhancedTranscription] = useState(false);
            const [transcriptionFormat, setTranscriptionFormat] = useState('english-ltr'); // english-ltr, arabic-rtl, vertical-rl, vertical-lr
            const [transcriptionScript, setTranscriptionScript] = useState('english'); // english or arabic
            
            // Dismissible tips
            const [showReadingOrderTip, setShowReadingOrderTip] = useState(true);
            const [showDetectionCanvasTip, setShowDetectionCanvasTip] = useState(true);
            const [showCorrectionModalTip, setShowCorrectionModalTip] = useState(true);
            
            // Translation States
            const [translationEnglish, setTranslationEnglish] = useState('');
            const [translationArabic, setTranslationArabic] = useState('');
            const [showTranslationSection, setShowTranslationSection] = useState(false);
            
            // Inscription Metadata
            const [inscriptionNotes, setInscriptionNotes] = useState('');
            const [inscriptionTitle, setInscriptionTitle] = useState('');

            const MASTER_PASTE_URL = ''; // Will update after first upload
            const MASTER_PASTE_RAW_URL = ''; // Will update after first upload

            // ============================================
            // UTILITY FUNCTIONS
            // ============================================
            
            const convertToGitHubUrl = (githubUrl) => {
                if (!githubUrl) return null;
                if (githubUrl.indexOf('http') === 0) {
                    if (githubUrl.indexOf('github.com') !== -1 && githubUrl.indexOf('/blob/') !== -1) {
                        return githubUrl.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                    }
                    return githubUrl;
                }
                if (typeof githubUrl === 'string' && githubUrl.length > 0) {
                    const baseUrl = 'https://raw.githubusercontent.com/hytra3/hakli_glyph_recognizer/main/';
                    const cleanPath = githubUrl.indexOf('/') === 0 ? githubUrl.substring(1) : githubUrl;
                    return baseUrl + cleanPath;
                }
                return null;
            };

            const getImageCoordinates = (event) => {
                if (!imageRef.current) return null;
                const rect = imageRef.current.getBoundingClientRect();
                const scaleX = imageRef.current.naturalWidth / rect.width;
                const scaleY = imageRef.current.naturalHeight / rect.height;
                return {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            };

            const extractRegionThumbnail = (inputImage, region) => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = region.bounds.width;
                    canvas.height = region.bounds.height;

                    ctx.drawImage(
                        inputImage,
                        region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height,
                        0, 0, region.bounds.width, region.bounds.height
                    );

                    return canvas.toDataURL();
                } catch (error) {
                    console.error('Thumbnail extraction error:', error);
                    return null;
                }
            };

            const extractRegionThumbnailWithExclusions = (inputImage, region, exclusions, originalBounds) => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = region.bounds.width;
                    canvas.height = region.bounds.height;

                    // Draw the region
                    ctx.drawImage(
                        inputImage,
                        region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height,
                        0, 0, region.bounds.width, region.bounds.height
                    );

                    // Mask out the excluded regions with white rectangles
                    ctx.fillStyle = 'white';
                    exclusions.forEach(exRegion => {
                        // Convert exclusion region coordinates to thumbnail-relative coordinates
                        const thumbX = exRegion.x - region.bounds.x;
                        const thumbY = exRegion.y - region.bounds.y;
                        const thumbWidth = exRegion.width;
                        const thumbHeight = exRegion.height;

                        // Only draw if the exclusion intersects with the thumbnail region
                        if (thumbX < region.bounds.width && thumbY < region.bounds.height &&
                            thumbX + thumbWidth > 0 && thumbY + thumbHeight > 0) {
                            
                            const drawX = Math.max(0, thumbX);
                            const drawY = Math.max(0, thumbY);
                            const drawWidth = Math.min(region.bounds.width - drawX, thumbX + thumbWidth - drawX);
                            const drawHeight = Math.min(region.bounds.height - drawY, thumbY + thumbHeight - drawY);

                            ctx.fillRect(drawX, drawY, drawWidth, drawHeight);
                        }
                    });

                    return canvas.toDataURL();
                } catch (error) {
                    console.error('Thumbnail extraction with exclusions error:', error);
                    return null;
                }
            };

            const calculateIoU = (box1, box2) => {
                const x1 = Math.max(box1.x, box2.x);
                const y1 = Math.max(box1.y, box2.y);
                const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
                const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

                const intersectionArea = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
                const box1Area = box1.width * box1.height;
                const box2Area = box2.width * box2.height;
                const unionArea = box1Area + box2Area - intersectionArea;

                return unionArea > 0 ? intersectionArea / unionArea : 0;
            };

            // Add this utility function at the top
            const preprocessImageForMatching = (img) => {
                let gray = new cv.Mat();
                const binary = new cv.Mat();
                const processed = new cv.Mat();

                if (img.channels() > 1) {
                    cv.cvtColor(img, gray, cv.COLOR_RGBA2GRAY);
                } else {
                    img.copyTo(gray);
                }

                cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 3);

                // Lighter preprocessing for ancient inscriptions
                const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                cv.morphologyEx(binary, processed, cv.MORPH_CLOSE, kernel);

                // Skip MORPH_OPEN and erosion - they fragment ancient inscriptions
                // cv.morphologyEx(processed, processed, cv.MORPH_OPEN, kernel);
                // const thinKernel = cv.getStructuringElement(cv.MORPH_CROSS, new cv.Size(2, 2));
                // cv.erode(processed, processed, thinKernel, new cv.Point(-1, -1), 1);

                kernel.delete();
                // thinKernel.delete();  // Commented out since we're not creating it
                gray.delete();
                binary.delete();

                return processed;
            };

            // ============================================
            // GLYPH ISOLATION & RECOGNITION
            // ============================================

            const isolateGlyphs = (inputImage) => {
                if (!isOpenCvReady) return [];
                try {
                    const src = cv.imread(inputImage);
                    const gray = new cv.Mat();
                    const binary = new cv.Mat();
                    const denoised = new cv.Mat();
                    const processed = new cv.Mat();

                    // Convert to grayscale
                    if (src.channels() > 1) {
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    } else {
                        src.copyTo(gray);
                    }
                    // Adaptive thresholding
                    cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

                    // Remove noise with opening (erosion then dilation)
                    const smallKernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(2, 2));
                    cv.morphologyEx(binary, denoised, cv.MORPH_OPEN, smallKernel);

                    // Connect broken strokes with closing (dilation then erosion)
                    const largeKernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                    cv.morphologyEx(denoised, processed, cv.MORPH_CLOSE, largeKernel);

                    // Find contours
                    const contours = new cv.MatVector();
                    const hierarchy = new cv.Mat();
                    cv.findContours(processed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    const isolatedRegions = [];

                    // Calculate dynamic thresholds based on image size
                    const imageArea = src.rows * src.cols;
                    // For small images (<50k pixels), use smaller minimum area
                    const isSmallImage = imageArea < 50000;
                    const minArea = isSmallImage ? Math.max(10, imageArea * 0.0005) : imageArea * 0.002;
                    const maxArea = imageArea * 0.15;   // 15% of image (increased for small images)
                    
                    console.log(`üîç Isolation: image ${src.cols}x${src.rows} (${imageArea}px), minArea=${minArea.toFixed(0)}, maxArea=${maxArea.toFixed(0)}, contours=${contours.size()}`);

                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const boundingRect = cv.boundingRect(contour);
                        const area = boundingRect.width * boundingRect.height;
                        const aspectRatio = boundingRect.width / boundingRect.height;

                        // Calculate solidity (ratio of contour area to bounding box area)
                        const contourArea = cv.contourArea(contour);
                        const solidity = contourArea / area;

                        // Filter criteria - more lenient for small images
                        const sizeOk = area >= minArea && area <= maxArea;
                        const aspectOk = aspectRatio >= 0.1 && aspectRatio <= 10.0;  // More lenient
                        const solidityOk = solidity >= 0.15; // More lenient for small regions

                        if (sizeOk && aspectOk && solidityOk) {
                            const padding = 5;
                            isolatedRegions.push({
                                bounds: {
                                    x: Math.max(0, boundingRect.x - padding),
                                    y: Math.max(0, boundingRect.y - padding),
                                    width: Math.min(src.cols - boundingRect.x + padding, boundingRect.width + 2 * padding),
                                    height: Math.min(src.rows - boundingRect.y + padding, boundingRect.height + 2 * padding)
                                },
                                area,
                                aspectRatio,
                                solidity
                            });
                        }
                    }

                    // Sort by position (left to right, top to bottom)
                    isolatedRegions.sort((a, b) => {
                        const rowDiff = a.bounds.y - b.bounds.y;
                        if (Math.abs(rowDiff) > 20) return rowDiff; // Different rows
                        return a.bounds.x - b.bounds.x; // Same row, sort by x
                    });

                    console.log(`‚úì Isolated ${isolatedRegions.length} regions`);

                    // Cleanup
                    src.delete();
                    gray.delete();
                    binary.delete();
                    denoised.delete();
                    processed.delete();
                    smallKernel.delete();
                    largeKernel.delete();
                    contours.delete();
                    hierarchy.delete();

                    return isolatedRegions;
                } catch (error) {
                    console.error('Glyph isolation error:', error);
                    return [];
                }
            };

            const performTemplateMatchingOnRegion = (inputImage, templateImage, region, glyphId) => {
                if (!isOpenCvReady) return [];
                try {
                    const src = cv.imread(inputImage);
                    const regionMat = src.roi(new cv.Rect(region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height));
                    const templ = cv.imread(templateImage);
                    const matches = [];

                    // Enhanced preprocessing - normalize both images
                    const preprocessForShape = (img) => {
                        let gray = new cv.Mat();
                        const binary = new cv.Mat();
                        const processed = new cv.Mat();  // ADD THIS LINE

                        // Convert to grayscale
                        if (img.channels() > 1) {
                            cv.cvtColor(img, gray, cv.COLOR_RGBA2GRAY);
                        } else {
                            img.copyTo(gray);
                        }

                        // Adaptive threshold
                        cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 3);

                        // Lighter preprocessing for ancient inscriptions
                        const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                        cv.morphologyEx(binary, processed, cv.MORPH_CLOSE, kernel);

                        // Skip aggressive erosion that fragments Glyphs
                        // const thinKernel = cv.getStructuringElement(cv.MORPH_CROSS, new cv.Size(3, 3));
                        // cv.erode(processed, processed, thinKernel, new cv.Point(-1, -1), 2);

                        kernel.delete();
                        // thinKernel.delete();  // Commented out
                        gray.delete();
                        binary.delete();

                        return processed;  // CHANGE FROM 'normalized' TO 'processed'
                    };

                    const processedRegion = preprocessForShape(regionMat);
                    const processedTemplate = preprocessForShape(templ);

                    // Method 1: Contour Shape Matching (PRIMARY)
                    let shapeScore = 0;
                    let shapeMethod = 'none';
                    try {
                        const contoursRegion = new cv.MatVector();
                        const contoursTemplate = new cv.MatVector();
                        const hierarchy = new cv.Mat();

                        cv.findContours(processedRegion, contoursRegion, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                        cv.findContours(processedTemplate, contoursTemplate, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                        if (contoursRegion.size() > 0 && contoursTemplate.size() > 0) {
                            // Find largest contour in each
                            let maxAreaRegion = 0;
                            let maxContourRegionIdx = 0;
                            for (let i = 0; i < contoursRegion.size(); i++) {
                                const area = cv.contourArea(contoursRegion.get(i));
                                if (area > maxAreaRegion) {
                                    maxAreaRegion = area;
                                    maxContourRegionIdx = i;
                                }
                            }

                            let maxAreaTemplate = 0;
                            let maxContourTemplateIdx = 0;
                            for (let i = 0; i < contoursTemplate.size(); i++) {
                                const area = cv.contourArea(contoursTemplate.get(i));
                                if (area > maxAreaTemplate) {
                                    maxAreaTemplate = area;
                                    maxContourTemplateIdx = i;
                                }
                            }

                            // Try all 3 shape matching methods
                            const methods = [
                                { method: cv.CONTOURS_MATCH_I1, name: 'I1' },
                                { method: cv.CONTOURS_MATCH_I2, name: 'I2' },
                                { method: cv.CONTOURS_MATCH_I3, name: 'I3' }
                            ];

                            let bestShapeScore = 0;
                            for (const m of methods) {
                                try {
                                    const shapeDiff = cv.matchShapes(
                                        contoursRegion.get(maxContourRegionIdx),
                                        contoursTemplate.get(maxContourTemplateIdx),
                                        m.method,
                                        0
                                    );

                                    // Convert distance to similarity (lower distance = higher score)
                                    // Different methods have different scales
                                    let score = 0;
                                    if (m.method === cv.CONTOURS_MATCH_I1) {
                                        score = Math.max(0, 1 - (shapeDiff / 3)); // I1 tends to give values 0-3
                                    } else if (m.method === cv.CONTOURS_MATCH_I2) {
                                        score = Math.max(0, 1 - (shapeDiff / 5)); // I2 tends to give values 0-5
                                    } else {
                                        score = Math.max(0, 1 - (shapeDiff / 10)); // I3 can give larger values
                                    }

                                    if (score > bestShapeScore) {
                                        bestShapeScore = score;
                                        shapeMethod = m.name;
                                    }
                                } catch (e) {
                                    // Method failed, skip
                                }
                            }

                            shapeScore = bestShapeScore;
                        }

                        contoursRegion.delete();
                        contoursTemplate.delete();
                        hierarchy.delete();
                    } catch (shapeError) {
                        console.log(`Shape matching failed for ${glyphId}:`, shapeError);
                        shapeScore = 0;
                    }

                    // Method 2: Aspect Ratio Similarity
                    let aspectScore = 0;
                    const regionAspect = processedRegion.cols / processedRegion.rows;
                    const templateAspect = processedTemplate.cols / processedTemplate.rows;
                    const aspectDiff = Math.abs(regionAspect - templateAspect);
                    aspectScore = Math.max(0, 1 - aspectDiff);

                    // Method 3: Template Matching (SECONDARY - only best scale)
                    let templateScore = 0;
                    let bestScale = 1.0;
                    let bestRotation = 0;
                    try {
                        // Try fewer scales, focus on likely matches :: added more scales because not matching
                        const scales = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 1.1, 1.2];
                        // Try rotations for in-situ inscriptions (¬±10 degrees in 5-degree increments)
                        const rotations = [-10, -5, 0, 5, 10];

                        for (const rotation of rotations) {
                            // Rotate template if needed
                            let rotatedTemplate = processedTemplate;
                            if (rotation !== 0) {
                                rotatedTemplate = new cv.Mat();
                                const center = new cv.Point(processedTemplate.cols / 2, processedTemplate.rows / 2);
                                const rotMatrix = cv.getRotationMatrix2D(center, rotation, 1.0);
                                cv.warpAffine(processedTemplate, rotatedTemplate, rotMatrix, processedTemplate.size());
                                rotMatrix.delete();
                            }

                            for (const scale of scales) {
                                const scaledTempl = new cv.Mat();
                                const newSize = new cv.Size(
                                    Math.floor(rotatedTemplate.cols * scale),
                                    Math.floor(rotatedTemplate.rows * scale)
                                );

                                if (newSize.width < 10 || newSize.height < 10 ||
                                    newSize.width > processedRegion.cols || newSize.height > processedRegion.rows) {
                                    continue;
                                }

                                cv.resize(rotatedTemplate, scaledTempl, newSize, 0, 0, cv.INTER_AREA);

                                const dst = new cv.Mat();
                                cv.matchTemplate(processedRegion, scaledTempl, dst, cv.TM_CCOEFF_NORMED);
                                const result = cv.minMaxLoc(dst);

                                if (result.maxVal > templateScore) {
                                    templateScore = result.maxVal;
                                    bestScale = scale;
                                    bestRotation = rotation;
                                }

                                dst.delete();
                                scaledTempl.delete();
                            }

                            // Clean up rotated template if we created one
                            if (rotation !== 0) {
                                rotatedTemplate.delete();
                            }
                        }
                    } catch (e) {
                        templateScore = 0;
                    }

                    // Weighted combination - SHAPE is primary
                    const weights = {
                        shape: 0.70,      // Shape matching is most important
                        aspect: 0.15,     // Aspect ratio helps
                        template: 0.15    // Template is just a tiebreaker
                    };

                    const combinedScore = (shapeScore * weights.shape) +
                        (aspectScore * weights.aspect) +
                        (templateScore * weights.template);

                    // Only log low confidence matches (might be wrong) and high confidence (definitely right)
                    if (combinedScore < 0.5 || combinedScore > 0.8) {
                        console.log(`Glyph ${glyphId}: Combined=${(combinedScore * 100).toFixed(1)}% [Shape=${(shapeScore * 100).toFixed(1)}% Aspect=${(aspectScore * 100).toFixed(1)}% Template=${(templateScore * 100).toFixed(1)}%] Scale=${bestScale.toFixed(2)} Rotation=${bestRotation}¬∞`);
                    }

                    // Lower threshold since we're focusing on shape (raised to .4 from .3 : .3 was lower shape)
                    if (combinedScore >= 0.40) {  // Stricter threshold
                        matches.push({
                            confidence: combinedScore,
                            position: region.bounds,
                            scale: bestScale,
                            rotation: bestRotation,
                            debug: {
                                shapeScore: shapeScore,
                                aspectScore: aspectScore,
                                templateScore: templateScore,
                                shapeMethod: shapeMethod,
                                rotation: bestRotation
                            }
                        });
                    }

                    processedRegion.delete();
                    processedTemplate.delete();
                    src.delete();
                    regionMat.delete();
                    templ.delete();

                    return matches;
                } catch (error) {
                    console.error('Shape matching error:', error);
                    return [];
                }
            };

            const applyNonMaximumSuppression = (detections, iouThreshold = 0.3) => {
                if (detections.length === 0) return detections;

                // Sort by confidence (highest first)
                const sorted = [...detections].sort((a, b) => b.confidence - a.confidence);
                const keep = [];

                while (sorted.length > 0) {
                    const current = sorted.shift();
                    keep.push(current);

                    // Remove detections that overlap too much with current
                    for (let i = sorted.length - 1; i >= 0; i--) {
                        const iou = calculateIoU(current.position, sorted[i].position);
                        if (iou > iouThreshold) {
                            sorted.splice(i, 1);
                        }
                    }
                }

                return keep;
            };

            const recognizeGlyphs = () => {
                if (!image || !equivalenceChart || !isOpenCvReady) return;
                setIsProcessing(true);
                setRecognitionResults([]);
                console.log('Starting recognition with', equivalenceChart.glyphs.length, 'Glyphs and', Object.keys(loadedGlyphImages).length, 'loaded images');
                
                // Use preprocessed image if available, otherwise use original
                const sourceForRecognition = preprocessedMat || originalMat;
                
                if (sourceForRecognition) {
                    // Use the OpenCV Mat directly - convert to canvas then to Image
                    console.log('‚úì Using preprocessed image for recognition');
                    const canvas = document.createElement('canvas');
                    cv.imshow(canvas, sourceForRecognition);
                    
                    const tempImg = new Image();
                    tempImg.onload = async () => {
                        try {
                        // The preprocessing already includes rotation, so skip that step
                        let processImg = tempImg;
                        console.log(`‚úì Using preprocessed image: ${processImg.width}x${processImg.height}`);
                        setRotatedImageDimensions({ width: processImg.width, height: processImg.height });
                        
                        // Convert canvas back to data URL for display
                        setDisplayImage(canvas.toDataURL());
                        
                        const isolated = isolateGlyphs(processImg);
                        const isolatedWithThumbnails = isolated.map(region => ({
                            ...region,
                            thumbnail: extractRegionThumbnail(processImg, region)
                        }));
                        setIsolatedGlyphs(isolatedWithThumbnails);
                        console.log('‚úì Isolated', isolated.length, 'regions');
                        if (isolated.length === 0) {
                            console.log('No regions found - check image contrast and size');
                            setIsProcessing(false);
                            return;
                        }

                        const results = [];
                        let totalMatches = 0;
                        const totalRegions = isolated.length;

                        // Loop through each region with progress tracking
                        for (let regionIndex = 0; regionIndex < isolated.length; regionIndex++) {
                            const region = isolated[regionIndex];

                            // Update progress
                            setProcessingProgress({ current: regionIndex + 1, total: totalRegions });
                            console.log('üìä Progress:', regionIndex + 1, 'of', totalRegions);    

                            let topMatches = []; // Track top 3 matches

                            for (const glyph of equivalenceChart.glyphs) {
                                // Check primary image
                                if (loadedGlyphImages[glyph.id]) {
                                    const matches = performTemplateMatchingOnRegion(processImg, loadedGlyphImages[glyph.id], region, glyph.id);
                                    totalMatches += matches.length;
                                    for (const match of matches) {
                                        topMatches.push({
                                            glyph,
                                            confidence: match.confidence,
                                            position: region.bounds,
                                            matchType: 'primary'
                                        });
                                    }
                                }

                                // Check variant images
                                if (glyph.images && glyph.images.variants) {
                                    for (let i = 0; i < glyph.images.variants.length; i++) {
                                        const variantKey = `${glyph.id}_variant_${i}`;
                                        if (loadedGlyphImages[variantKey]) {
                                            const matches = performTemplateMatchingOnRegion(processImg, loadedGlyphImages[variantKey], region, `${glyph.id}_v${i}`);
                                            for (const match of matches) {
                                                const weightedConfidence = match.confidence * 0.95;
                                                topMatches.push({
                                                    glyph,
                                                    confidence: weightedConfidence,
                                                    position: region.bounds,
                                                    matchType: 'variant',
                                                    variantIndex: i
                                                });
                                            }
                                        }
                                    }
                                }

                                // Check example images
                                if (glyph.images && glyph.images.examples) {
                                    for (let i = 0; i < glyph.images.examples.length; i++) {
                                        const exampleKey = `${glyph.id}_example_${i}`;
                                        if (loadedGlyphImages[exampleKey]) {
                                            const matches = performTemplateMatchingOnRegion(processImg, loadedGlyphImages[exampleKey], region, `${glyph.id}_ex${i}`);
                                            for (const match of matches) {
                                                const weightedConfidence = match.confidence * 0.90;
                                                topMatches.push({
                                                    glyph,
                                                    confidence: weightedConfidence,
                                                    position: region.bounds,
                                                    matchType: 'example',
                                                    exampleIndex: i
                                                });
                                            }
                                        }
                                    }
                                }
                            }

                            // Sort by confidence and keep top 3
                            topMatches.sort((a, b) => b.confidence - a.confidence);
                            const top3 = topMatches.slice(0, 3);
                            
                            // Use best match as primary
                            const bestMatch = top3[0];
                            
                            if (bestMatch && bestMatch.confidence > 0.30) {
                                // Check if there's a close second match (within 15%)
                                const hasCloseMatch = top3.length > 1 && 
                                    (bestMatch.confidence - top3[1].confidence) < 0.15;
                                
                                results.push({
                                    ...bestMatch,
                                    regionIndex: regionIndex,
                                    alternatives: top3.slice(1), // Include 2nd and 3rd place
                                    hasCloseMatch: hasCloseMatch,
                                    selectedAlternative: null // Track if user manually selects different option
                                });
                                
                                const altText = hasCloseMatch ? ` (alt: ${top3[1].glyph.name})` : '';
                                console.log(`‚úÖ Region ${regionIndex + 1}: ${bestMatch.glyph.name} (${Math.round(bestMatch.confidence * 100)}%)${altText}`);
                            }
                        }
                        // Reset progress when done
                        setProcessingProgress({ current: 0, total: 0 });

                        // Apply non-maximum suppression to remove overlapping detections
                        const filteredResults = applyNonMaximumSuppression(results, 0.3);
                        console.log(`‚úì Recognition complete: ${filteredResults.length} glyphs detected (${results.length - filteredResults.length} overlapping removed)`);

                        // Apply confidence threshold filter based on slider value
                        const confidenceFilteredResults = filteredResults.filter(r =>
                            r.confidence >= (confidenceThreshold / 100)
                        );

                        console.log(`‚úì After confidence filter (${confidenceThreshold}%): ${confidenceFilteredResults.length} glyphs (${filteredResults.length - confidenceFilteredResults.length} filtered out)`);

                        setRecognitionResults(confidenceFilteredResults);
                        setIsProcessing(false);
                        
                        // Take initial snapshot for undo system
                        setTimeout(() => {
                            takeSnapshotBeforeChange();
                            console.log('üì∏ Initial snapshot taken after recognition');
                        }, 100);
                    } catch (error) {
                        console.error('Recognition error:', error);
                        setIsProcessing(false);
                    }
                };
                tempImg.src = canvas.toDataURL();
            } else {
                // Fallback to original image if no preprocessing
                console.log('‚ö† No preprocessed image available, using original');
                const tempImg = new Image();
                tempImg.onload = async () => {
                    try {
                        let processImg = tempImg;
                        setRotatedImageDimensions({ width: processImg.width, height: processImg.height });
                        setDisplayImage(image);
                        
                        const isolated = isolateGlyphs(processImg);
                        const isolatedWithThumbnails = isolated.map(region => ({
                            ...region,
                            thumbnail: extractRegionThumbnail(processImg, region)
                        }));
                        setIsolatedGlyphs(isolatedWithThumbnails);
                        console.log('‚úì Isolated', isolated.length, 'regions');
                        if (isolated.length === 0) {
                            console.log('No regions found - check image contrast and size');
                            setIsProcessing(false);
                            return;
                        }

                        const results = [];
                        let totalMatches = 0;
                        const totalRegions = isolated.length;

                        for (let regionIndex = 0; regionIndex < isolated.length; regionIndex++) {
                            const region = isolated[regionIndex];
                            setProcessingProgress({ current: regionIndex + 1, total: totalRegions });
                            console.log('üìä Progress:', regionIndex + 1, 'of', totalRegions);    

                            let bestMatch = null;
                            let bestRawConfidence = 0;

                            for (const glyph of equivalenceChart.glyphs) {
                                if (loadedGlyphImages[glyph.id]) {
                                    const matches = performTemplateMatchingOnRegion(processImg, loadedGlyphImages[glyph.id], region, glyph.id);
                                    totalMatches += matches.length;
                                    for (const match of matches) {
                                        if (match.confidence > bestRawConfidence) {
                                            bestRawConfidence = match.confidence;
                                            bestMatch = {
                                                glyph,
                                                confidence: match.confidence,
                                                position: region.bounds,
                                                matchType: 'primary'
                                            };
                                        }
                                    }
                                }
                            }

                            if (bestMatch) {
                                results.push(bestMatch);
                            }
                        }

                        console.log(`‚úì Found ${results.length} glyphs out of ${totalRegions} regions (checked ${totalMatches} template combinations)`);
                        const confidenceFilteredResults = useConfidenceFilter 
                            ? results.filter(r => r.confidence >= (confidenceThreshold / 100))
                            : results;

                        setRecognitionResults(confidenceFilteredResults);
                        setIsProcessing(false);
                    } catch (error) {
                        console.error('Recognition error:', error);
                        setIsProcessing(false);
                    }
                };
                tempImg.src = image;
            }
            };  // end recognizeGlyphs

            // ============================================
            // DETECTION MANIPULATION
            // ============================================

            const validateDetection = (detectionIndex, isCorrect) => {
                recordAction('validation', {
                    detectionIndex,
                    isCorrect,
                    detectionData: recognitionResults[detectionIndex]
                });
                setValidations(prev => ({
                    ...prev,
                    [detectionIndex]: {
                        isCorrect,
                        timestamp: new Date().toISOString(),
                        detectionData: recognitionResults[detectionIndex]
                    }
                }));
            };

            const deleteIsolatedRegion = (regionIndex) => {
                recordAction('delete_isolated_region', {
                    index: regionIndex,
                    region: isolatedGlyphs[regionIndex]
                });

                // Remove the isolated region
                setIsolatedGlyphs(prev => prev.filter((_, i) => i !== regionIndex));

                // Remove any detections that reference this region
                setRecognitionResults(prev => prev.filter(r => r.regionIndex !== regionIndex).map(r => ({
                    ...r,
                    regionIndex: r.regionIndex > regionIndex ? r.regionIndex - 1 : r.regionIndex
                })));

                // Clear selection
                setSelectedIsolatedRegion(null);

                console.log(`‚úì Deleted isolated region ${regionIndex}`);
            };

            const deleteDetection = (detectionIndex) => {
                // Take snapshot BEFORE making changes for undo
                takeSnapshotBeforeChange();
                
                recordAction('delete_detection', {
                    index: detectionIndex,
                    detection: recognitionResults[detectionIndex]
                });
                // Update recognition results
                setRecognitionResults(prev => prev.filter((_, i) => i !== detectionIndex));
                // Update validations with shifted indices
                setValidations(prev => {
                    const newValidations = { ...prev };
                    delete newValidations[detectionIndex];
                    const shifted = {};
                    Object.keys(newValidations).forEach(key => {
                        const numKey = parseInt(key);
                        shifted[numKey > detectionIndex ? numKey - 1 : numKey] = newValidations[key];
                    });
                    return shifted;
                });
                // Update selected regions - remove deleted index and shift others
                setSelectedRegions(prev => {
                    const newSet = new Set();
                    prev.forEach(idx => {
                        if (idx !== detectionIndex) {
                            // Shift down indices that come after the deleted one
                            newSet.add(idx > detectionIndex ? idx - 1 : idx);
                        }
                    });
                    return newSet;
                });
                // Clear merge indicator if it existed
                setMergeIndicator(null);
            };

            const mergeSelectedDetections = () => {
                const selectedIndices = Array.from(selectedRegions).sort((a, b) => a - b);
                if (selectedIndices.length < 2) {
                    alert('Please select at least 2 detections to merge');
                    return;
                }
                
                // Take snapshot BEFORE making changes for undo
                takeSnapshotBeforeChange();

                const detectionsToMerge = selectedIndices.map(i => recognitionResults[i]);
                const minX = Math.min(...detectionsToMerge.map(d => d.position.x));
                const minY = Math.min(...detectionsToMerge.map(d => d.position.y));
                const maxX = Math.max(...detectionsToMerge.map(d => d.position.x + d.position.width));
                const maxY = Math.max(...detectionsToMerge.map(d => d.position.y + d.position.height));

                const baseDetection = detectionsToMerge.reduce((best, current) =>
                    current.confidence > best.confidence ? current : best
                );

                const mergedBounds = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };

                // Extract new thumbnail for merged region
                const mergedThumbnail = extractRegionThumbnail(imageRef.current, { bounds: mergedBounds });

                const mergedDetection = {
                    ...baseDetection,
                    position: mergedBounds,
                    confidence: detectionsToMerge.reduce((sum, d) => sum + d.confidence, 0) / detectionsToMerge.length,
                    mergedFrom: detectionsToMerge.length,
                    isMerged: true,
                    thumbnail: mergedThumbnail,  // Add the new thumbnail
                    regionIndex: isolatedGlyphs.length  // Will be the next index
                };

                recordAction('merge_detections', {
                    indices: selectedIndices,
                    detections: detectionsToMerge,
                    mergedResult: mergedDetection
                });

                // Remove the merged detections
                let newResults = recognitionResults.slice();
                for (let i = selectedIndices.length - 1; i >= 0; i--) {
                    newResults.splice(selectedIndices[i], 1);
                }
                newResults.push(mergedDetection);

                // Add merged region to isolated glyphs
                setIsolatedGlyphs(prev => [...prev, {
                    bounds: mergedBounds,
                    thumbnail: mergedThumbnail,
                    area: mergedBounds.width * mergedBounds.height,
                    aspectRatio: mergedBounds.width / mergedBounds.height
                }]);

                setRecognitionResults(newResults);
                setSelectedRegions(new Set());
                setMergeIndicator(null);
            };

            const applyTrim = (detectionIndex, newBounds) => {
                const detection = recognitionResults[detectionIndex];
                const oldBounds = detection.position;

                // Ensure new bounds are within old bounds
                const trimmedBounds = {
                    x: Math.max(oldBounds.x, newBounds.x),
                    y: Math.max(oldBounds.y, newBounds.y),
                    width: Math.min(newBounds.x + newBounds.width, oldBounds.x + oldBounds.width) - Math.max(oldBounds.x, newBounds.x),
                    height: Math.min(newBounds.y + newBounds.height, oldBounds.y + oldBounds.height) - Math.max(oldBounds.y, newBounds.y)
                };

                if (trimmedBounds.width < 10 || trimmedBounds.height < 10) {
                    alert('‚ùå Trimmed region too small. Try again.');
                    setTrimMode(null);
                    return;
                }

                // Extract new thumbnail
                const thumbnail = extractRegionThumbnail(imageRef.current, { bounds: trimmedBounds });

                // Update the detection
                const updatedDetection = {
                    ...detection,
                    position: trimmedBounds,
                    thumbnail: thumbnail,
                    trimmed: true,
                    originalBounds: oldBounds
                };

                // Update isolated glyph if it exists
                if (detection.regionIndex !== undefined) {
                    setIsolatedGlyphs(prev => {
                        const updated = [...prev];
                        updated[detection.regionIndex] = {
                            bounds: trimmedBounds,
                            thumbnail: thumbnail,
                            area: trimmedBounds.width * trimmedBounds.height,
                            aspectRatio: trimmedBounds.width / trimmedBounds.height
                        };
                        return updated;
                    });
                }

                // Update recognition results
                setRecognitionResults(prev =>
                    prev.map((r, i) => i === detectionIndex ? updatedDetection : r)
                );

                recordAction('trim_detection', {
                    index: detectionIndex,
                    oldBounds,
                    newBounds: trimmedBounds
                });

                setTrimMode(null);
                alert('‚úÖ Detection trimmed! You may want to correct the glyph if recognition changed.');
            };

            const applyExclude = (detectionIndex) => {
                if (excludeRegions.length === 0) {
                    alert('‚ùå No exclusion regions drawn. Draw at least one region to exclude.');
                    return;
                }

                const detection = recognitionResults[detectionIndex];
                const originalBounds = detection.position;
                const oldGlyph = detection.glyph.name;

                try {
                    const tempImg = new Image();
                    tempImg.src = image;

                    tempImg.onload = () => {
                        const src = cv.imread(tempImg);
                        const regionMat = src.roi(new cv.Rect(
                            originalBounds.x,
                            originalBounds.y,
                            originalBounds.width,
                            originalBounds.height
                        ));

                        // Create mask (white = keep, black = exclude)
                        const mask = new cv.Mat(regionMat.rows, regionMat.cols, cv.CV_8UC1, new cv.Scalar(255));

                        // Draw exclusion regions on mask
                        excludeRegions.forEach(exRegion => {
                            const relX = exRegion.x - originalBounds.x;
                            const relY = exRegion.y - originalBounds.y;
                            const relWidth = exRegion.width;
                            const relHeight = exRegion.height;

                            if (relX < regionMat.cols && relY < regionMat.rows &&
                                relX + relWidth > 0 && relY + relHeight > 0) {
                                const point1 = new cv.Point(
                                    Math.max(0, relX),
                                    Math.max(0, relY)
                                );
                                const point2 = new cv.Point(
                                    Math.min(regionMat.cols, relX + relWidth),
                                    Math.min(regionMat.rows, relY + relHeight)
                                );
                                cv.rectangle(mask, point1, point2, new cv.Scalar(0), -1);
                            }
                        });

                        // Apply mask to get only the glyph pixels that should remain
                        const gray = new cv.Mat();
                        const binary = new cv.Mat();
                        
                        // Convert to grayscale
                        if (regionMat.channels() > 1) {
                            cv.cvtColor(regionMat, gray, cv.COLOR_RGBA2GRAY);
                        } else {
                            regionMat.copyTo(gray);
                        }
                        
                        // Use Otsu's method for adaptive thresholding
                        // This automatically finds the best threshold value
                        cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
                        
                        // Apply the exclusion mask
                        const masked = new cv.Mat();
                        cv.bitwise_and(binary, mask, masked);
                        
                        // Add some morphological operations to clean up noise
                        const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                        const cleaned = new cv.Mat();
                        cv.morphologyEx(masked, cleaned, cv.MORPH_CLOSE, kernel);
                        cv.morphologyEx(cleaned, cleaned, cv.MORPH_OPEN, kernel);
                        
                        // Find bounding box of remaining glyph pixels
                        let minX = cleaned.cols, minY = cleaned.rows, maxX = 0, maxY = 0;
                        let hasPixels = false;
                        let pixelCount = 0;

                        for (let y = 0; y < cleaned.rows; y++) {
                            for (let x = 0; x < cleaned.cols; x++) {
                                if (cleaned.ucharAt(y, x) > 0) {
                                    hasPixels = true;
                                    pixelCount++;
                                    minX = Math.min(minX, x);
                                    minY = Math.min(minY, y);
                                    maxX = Math.max(maxX, x);
                                    maxY = Math.max(maxY, y);
                                }
                            }
                        }

                        src.delete();
                        regionMat.delete();
                        mask.delete();
                        gray.delete();
                        binary.delete();
                        masked.delete();
                        cleaned.delete();
                        kernel.delete();
                        
                        console.log(`Exclude: Found ${pixelCount} glyph pixels, bounds: (${minX},${minY}) to (${maxX},${maxY})`);

                        if (!hasPixels) {
                            alert('‚ùå Exclusion removed all content. Canceling.');
                            setExcludeMode(null);
                            setExcludeRegions([]);
                            return;
                        }

                        // Create new bounds
                        const newBounds = {
                            x: originalBounds.x + minX,
                            y: originalBounds.y + minY,
                            width: maxX - minX + 1,
                            height: maxY - minY + 1
                        };

                        if (newBounds.width < 10 || newBounds.height < 10) {
                            alert('‚ùå Remaining region too small after exclusion.');
                            setExcludeMode(null);
                            setExcludeRegions([]);
                            return;
                        }

                        const thumbnail = extractRegionThumbnailWithExclusions(tempImg, { bounds: newBounds }, excludeRegions, originalBounds);

                        const newDetection = {
                            glyph: { id: 'unknown', name: 'Unknown', transliteration: '?' },
                            confidence: 0.5,
                            position: newBounds,
                            matchType: 'excluded',
                            isExcluded: true,
                            thumbnail: thumbnail,
                            regionIndex: isolatedGlyphs.length
                        };

                        setRecognitionResults(prev => {
                            const updated = [...prev];
                            updated.splice(detectionIndex, 1);
                            updated.push(newDetection);
                            return updated;
                        });
                        
                        // Update reading order to account for removed and added detection
                        setReadingOrder(prev => {
                            if (prev.length === 0) return prev;
                            // Remove the deleted index and adjust all indices after it
                            const newOrder = prev
                                .filter(idx => idx !== detectionIndex)
                                .map(idx => idx > detectionIndex ? idx - 1 : idx);
                            // Add the new detection at the end
                            newOrder.push(recognitionResults.length - 1);
                            return newOrder;
                        });

                        setIsolatedGlyphs(prev => [...prev, {
                            bounds: newBounds,
                            thumbnail: thumbnail,
                            area: newBounds.width * newBounds.height,
                            aspectRatio: newBounds.width / newBounds.height
                        }]);

                        recordAction('exclude_regions', {
                            originalIndex: detectionIndex,
                            originalGlyph: oldGlyph,
                            exclusions: excludeRegions,
                            newBounds: newBounds
                        });

                        setExcludeMode(null);
                        setExcludeRegions([]);

                        alert(`‚úÖ Excluded regions from "${oldGlyph}"!\n\nNew detection created with adjusted boundaries.\nOriginal detection removed.\n\nüí° Tip: Correct the new "Unknown" detection using ‚úèÔ∏è`);

                        setTimeout(() => {
                            const cards = document.querySelectorAll('.p-3.bg-white.rounded.border');
                            if (cards.length > 0) cards[cards.length - 1].scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }, 200);
                    };

                    tempImg.onerror = () => {
                        alert('‚ùå Failed to load image for exclusion');
                        setExcludeMode(null);
                        setExcludeRegions([]);
                    };
                } catch (error) {
                    console.error('Exclude error:', error);
                    alert('‚ùå Failed to apply exclusions.');
                    setExcludeMode(null);
                    setExcludeRegions([]);
                }
            };


            const applyAdjustment = (detectionIndex) => {
                const detection = recognitionResults[detectionIndex];
                if (!detection || !imageRef.current) return;

                try {
                    const corners = detection.corners || {
                        tl: { x: detection.position.x, y: detection.position.y },
                        tr: { x: detection.position.x + detection.position.width, y: detection.position.y },
                        bl: { x: detection.position.x, y: detection.position.y + detection.position.height },
                        br: { x: detection.position.x + detection.position.width, y: detection.position.y + detection.position.height }
                    };

                    // Calculate bounding rectangle from corners
                    const minX = Math.min(corners.tl.x, corners.tr.x, corners.bl.x, corners.br.x);
                    const maxX = Math.max(corners.tl.x, corners.tr.x, corners.bl.x, corners.br.x);
                    const minY = Math.min(corners.tl.y, corners.tr.y, corners.bl.y, corners.br.y);
                    const maxY = Math.max(corners.tl.y, corners.tr.y, corners.bl.y, corners.br.y);

                    const newBounds = {
                        x: Math.round(minX),
                        y: Math.round(minY),
                        width: Math.round(maxX - minX),
                        height: Math.round(maxY - minY)
                    };

                    if (newBounds.width < 5 || newBounds.height < 5) {
                        alert('‚ùå Adjusted region too small.');
                        setAdjustMode(null);
                        return;
                    }

                    // Extract thumbnail using polygon mask (Option 5)
                    // This extracts ONLY pixels inside the quadrilateral, excluding unwanted areas
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas size to bounding box
                    canvas.width = newBounds.width;
                    canvas.height = newBounds.height;
                    
                    // Fill with white background
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Create clipping path from the quadrilateral corners
                    ctx.save();
                    ctx.beginPath();
                    // Convert corners to canvas coordinates (relative to bounding box)
                    ctx.moveTo(corners.tl.x - newBounds.x, corners.tl.y - newBounds.y);
                    ctx.lineTo(corners.tr.x - newBounds.x, corners.tr.y - newBounds.y);
                    ctx.lineTo(corners.br.x - newBounds.x, corners.br.y - newBounds.y);
                    ctx.lineTo(corners.bl.x - newBounds.x, corners.bl.y - newBounds.y);
                    ctx.closePath();
                    ctx.clip();
                    
                    // Draw the image with the clipping mask applied
                    ctx.drawImage(
                        imageRef.current,
                        newBounds.x, newBounds.y, newBounds.width, newBounds.height,
                        0, 0, newBounds.width, newBounds.height
                    );
                    ctx.restore();
                    
                    // Convert to data URL
                    const thumbnail = canvas.toDataURL('image/png');

                    // Update the detection with new position and corners
                    setRecognitionResults(prev => {
                        const updated = [...prev];
                        updated[detectionIndex] = {
                            ...updated[detectionIndex],
                            position: newBounds,
                            corners: corners,
                            thumbnail: thumbnail,
                            isAdjusted: true
                        };
                        return updated;
                    });

                    // Update isolated glyph if it exists
                    if (detection.regionIndex !== undefined && isolatedGlyphs[detection.regionIndex]) {
                        setIsolatedGlyphs(prev => {
                            const updated = [...prev];
                            updated[detection.regionIndex] = {
                                ...updated[detection.regionIndex],
                                bounds: newBounds,
                                thumbnail: thumbnail,
                                area: newBounds.width * newBounds.height,
                                aspectRatio: newBounds.width / newBounds.height
                            };
                            return updated;
                        });
                    }

                    recordAction('adjust_bounds', {
                        detectionIndex: detectionIndex,
                        oldBounds: detection.position,
                        newBounds: newBounds,
                        corners: corners
                    });

                    setAdjustMode(null);
                    alert('‚úÖ Box adjusted successfully!');

                } catch (error) {
                    console.error('Adjustment error:', error);
                    alert('‚ùå Failed to apply adjustment.');
                    setAdjustMode(null);
                }
            };


            const saveAsTemplate = (detectionIndex, templateType) => {
                const detection = recognitionResults[detectionIndex];
                if (!detection || !imageRef.current) return;

                let imageDataUrl;

                // If the detection has been adjusted (polygon-masked), use the existing thumbnail
                // Otherwise, extract from the original image with padding
                if (detection.isAdjusted && detection.thumbnail) {
                    // Use the already-masked thumbnail
                    imageDataUrl = detection.thumbnail;
                } else {
                    // Create canvas to crop the region with padding
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const pos = detection.position;

                    // Add padding around the glyph (10%)
                    const padding = Math.max(pos.width, pos.height) * 0.1;
                    const cropX = Math.max(0, pos.x - padding);
                    const cropY = Math.max(0, pos.y - padding);
                    const cropWidth = Math.min(imageRef.current.naturalWidth - cropX, pos.width + padding * 2);
                    const cropHeight = Math.min(imageRef.current.naturalHeight - cropY, pos.height + padding * 2);

                    canvas.width = cropWidth;
                    canvas.height = cropHeight;

                    // Draw the cropped region
                    ctx.drawImage(
                        imageRef.current,
                        cropX, cropY, cropWidth, cropHeight,
                        0, 0, cropWidth, cropHeight
                    );

                    // Convert to data URL
                    imageDataUrl = canvas.toDataURL('image/png');
                }

                // Update equivalence chart
                const updatedChart = { ...equivalenceChart };
                const glyphIndex = updatedChart.glyphs.findIndex(s => s.id === detection.glyph.id);

                if (glyphIndex === -1) {
                    alert('Glyph not found in chart!');
                    return;
                }

                const glyph = updatedChart.glyphs[glyphIndex];

                // Initialize images object if it doesn't exist
                if (!glyph.images) {
                    glyph.images = { primary: null, variants: [], examples: [] };
                }

                // Add based on template type
                if (templateType === 'primary') {
                    glyph.images.primary = imageDataUrl;
                    alert(`‚úÖ Saved as PRIMARY template for "${glyph.name}"\n\nNote: This replaces the existing primary image.`);
                } else if (templateType === 'variant') {
                    if (!glyph.images.variants) glyph.images.variants = [];
                    glyph.images.variants.push(imageDataUrl);
                    alert(`‚úÖ Saved as VARIANT template for "${glyph.name}"\n\nVariants: ${glyph.images.variants.length}`);
                } else if (templateType === 'example') {
                    if (!glyph.images.examples) glyph.images.examples = [];
                    glyph.images.examples.push(imageDataUrl);
                    alert(`‚úÖ Saved as EXAMPLE template for "${glyph.name}"\n\nExamples: ${glyph.images.examples.length}`);
                }

                setEquivalenceChart(updatedChart);

                // Reload the image in the cache
                const img = new Image();
                img.onload = () => {
                    const newCache = { ...loadedGlyphImages };
                    if (templateType === 'primary') {
                        newCache[glyph.id] = img;
                    } else if (templateType === 'variant') {
                        newCache[`${glyph.id}_variant_${glyph.images.variants.length - 1}`] = img;
                    } else if (templateType === 'example') {
                        newCache[`${glyph.id}_example_${glyph.images.examples.length - 1}`] = img;
                    }
                    setLoadedGlyphImages(newCache);
                };
                img.src = imageDataUrl;

                recordAction('save_template', {
                    glyphId: detection.glyph.id,
                    glyphName: detection.glyph.name,
                    templateType: templateType,
                    confidence: detection.confidence
                });

                setSelectedForTemplate(null);
            };

            const exportUpdatedChart = () => {
                const chartJson = JSON.stringify(equivalenceChart, null, 2);
                const blob = new Blob([chartJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Hakli_gylphs_training_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('‚úÖ Updated equivalence chart exported!\n\nYou can now:\n1. Review the new templates\n2. Upload to GitHub to use in future sessions\n3. Share with other users');
            };


            // ============================================
            // CLOUD SYNC
            // ============================================

            const uploadCorrectionsToCloud = async () => {
                    try {
                        const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                        const exportData = {
                            version: '1.0',
                            uploadDate: new Date().toISOString(),
                            corrections: corrections,
                            stats: {
                                totalGlyphs: Object.keys(corrections).length,
                                totalCorrections: Object.values(corrections).reduce((sum, c) =>
                                    sum + c.corrections.reduce((s, cor) => s + cor.count, 0), 0)
                            },
                            source: 'hakli-recognizer-community-contribution'
                        };

                        // Create downloadable JSON file
                        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `hakli_corrections_contribution_${new Date().toISOString().slice(0, 10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        // Show instructions
                        const issueUrl = 'https://github.com/hytra3/hakli_glyph_recognizer/issues/new?title=Community%20Corrections%20Contribution&body=Please%20find%20my%20correction%20memory%20attached.%20Thank%20you!';

                        const message = `‚úÖ Corrections file downloaded!\n\n` +
                            `üì§ To share with the community:\n\n` +
                            `1. The file has been downloaded to your computer\n` +
                            `2. Click OK to open a new GitHub Issue\n` +
                            `3. Attach the downloaded JSON file to the issue\n` +
                            `4. Submit the issue\n\n` +
                            `Your corrections will be reviewed and added to the master collection!\n\n` +
                            `Stats: ${exportData.stats.totalCorrections} corrections for ${exportData.stats.totalGlyphs} glyphs`;

                        if (confirm(message)) {
                            window.open(issueUrl, '_blank');
                        }

                        recordAction('export_for_contribution', { stats: exportData.stats });

                        return { success: true };
                    } catch (error) {
                        console.error('Export failed:', error);
                        alert('‚ùå Failed to export corrections. Check console for details.');
                        return null;
                    }
                };

            const downloadCorrectionsFromCloud = async (url = null) => {
                    try {
                        // Default to master collection
                        const masterUrl = url || 'https://raw.githubusercontent.com/hytra3/hakli_glyph_recognizer/main/community-corrections/master.json';

                        // Fetch the corrections data
                        const response = await fetch(masterUrl);
                        if (!response.ok) {
                            if (response.status === 404) {
                                alert('‚ÑπÔ∏è No master corrections available yet.\n\nBe the first to contribute!');
                                return null;
                            }
                            throw new Error('Failed to download corrections');
                        }

                        const cloudData = await response.json();

                        // Check if there are any corrections
                        if (!cloudData.corrections || Object.keys(cloudData.corrections).length === 0) {
                            alert('‚ÑπÔ∏è The master collection is empty.\n\nContribute your corrections to help the community!');
                            return null;
                        }

                        // Merge with existing corrections
                        const existing = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                        let newCorrections = 0;
                        let updatedCorrections = 0;

                        Object.keys(cloudData.corrections).forEach(key => {
                            if (!existing[key]) {
                                existing[key] = cloudData.corrections[key];
                                newCorrections++;
                            } else {
                                // Merge correction counts
                                cloudData.corrections[key].corrections.forEach(cloudCorr => {
                                    const existingCorr = existing[key].corrections.find(c => c.to.id === cloudCorr.to.id);
                                    if (existingCorr) {
                                        existingCorr.count += cloudCorr.count;
                                        updatedCorrections++;
                                    } else {
                                        existing[key].corrections.push(cloudCorr);
                                        newCorrections++;
                                    }
                                });
                            }
                        });

                        localStorage.setItem('hakliCorrections', JSON.stringify(existing));

                        const contributorInfo = cloudData.stats?.contributors?.length > 0
                            ? `\n\nThanks to ${cloudData.stats.contributors.length} contributor(s)!`
                            : '';

                        alert(`‚úÖ Community corrections downloaded!\n\n` +
                            `${newCorrections} new corrections added\n` +
                            `${updatedCorrections} existing corrections updated\n\n` +
                            `Total glyphs in your memory: ${Object.keys(existing).length}` +
                            contributorInfo);

                        recordAction('download_from_cloud', {
                            source: masterUrl,
                            newCorrections,
                            updatedCorrections
                        });

                        return { newCorrections, updatedCorrections };
                    } catch (error) {
                        console.error('Download from cloud failed:', error);
                        alert('‚ùå Failed to download corrections from cloud.\n\nThe master collection may not exist yet, or there may be a network issue.');
                        return null;
                    }
                };
          
            // ============================================
            // CORRECTION MEMORY
            // ============================================

            const saveCorrectionToMemory = (originalGlyph, correctedGlyph, confidence) => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    const key = originalGlyph.id;

                    if (!corrections[key]) {
                        corrections[key] = {
                            originalGlyph: originalGlyph,
                            corrections: []
                        };
                    }

                    // Find if this correction already exists
                    const existingIndex = corrections[key].corrections.findIndex(c => c.to.id === correctedGlyph.id);

                    if (existingIndex >= 0) {
                        corrections[key].corrections[existingIndex].count++;
                        corrections[key].corrections[existingIndex].lastUsed = new Date().toISOString();
                    } else {
                        corrections[key].corrections.push({
                            to: correctedGlyph,
                            count: 1,
                            firstUsed: new Date().toISOString(),
                            lastUsed: new Date().toISOString(),
                            avgConfidence: confidence
                        });
                    }

                    localStorage.setItem('hakliCorrections', JSON.stringify(corrections));
                    console.log('Correction saved to memory:', originalGlyph.name, '‚Üí', correctedGlyph.name);
                } catch (error) {
                    console.error('Failed to save correction:', error);
                }
            };
            
            // Helper function for tracking corrections by ID
            const trackCorrection = (originalGlyphId, correctedGlyphId) => {
                const originalGlyph = equivalenceChart.glyphs.find(g => g.id === originalGlyphId);
                const correctedGlyph = equivalenceChart.glyphs.find(g => g.id === correctedGlyphId);
                
                if (originalGlyph && correctedGlyph) {
                    saveCorrectionToMemory(originalGlyph, correctedGlyph, 0.85); // Default confidence for swaps
                }
            };

            const getCorrectionSuggestion = (glyphId) => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    if (corrections[glyphId] && corrections[glyphId].corrections.length > 0) {
                        // Return most frequently used correction
                        const sorted = [...corrections[glyphId].corrections].sort((a, b) => b.count - a.count);
                        return sorted[0];
                    }
                    return null;
                } catch (error) {
                    console.error('Failed to get correction suggestion:', error);
                    return null;
                }
            };

            const exportCorrectionMemory = () => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    const exportData = {
                        version: '1.0',
                        exportDate: new Date().toISOString(),
                        corrections: corrections,
                        stats: {
                            totalGlyphs: Object.keys(corrections).length,
                            totalCorrections: Object.values(corrections).reduce((sum, c) => sum + c.corrections.reduce((s, cor) => s + cor.count, 0), 0)
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hakli_corrections_${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    alert(`Exported ${exportData.stats.totalCorrections} corrections for ${exportData.stats.totalGlyphs} glyphs!`);
                } catch (error) {
                    console.error('Export failed:', error);
                    alert('Failed to export corrections');
                }
            };

            const importCorrectionMemory = (jsonData) => {
                try {
                    const imported = JSON.parse(jsonData);
                    const existing = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');

                    // Merge imported with existing
                    Object.keys(imported.corrections).forEach(key => {
                        if (existing[key]) {
                            // Merge correction counts
                            imported.corrections[key].corrections.forEach(importedCorr => {
                                const existingCorr = existing[key].corrections.find(c => c.to.id === importedCorr.to.id);
                                if (existingCorr) {
                                    existingCorr.count += importedCorr.count;
                                } else {
                                    existing[key].corrections.push(importedCorr);
                                }
                            });
                        } else {
                            existing[key] = imported.corrections[key];
                        }
                    });

                    localStorage.setItem('hakliCorrections', JSON.stringify(existing));
                    alert(`Imported corrections successfully! Total glyphs in memory: ${Object.keys(existing).length}`);
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Failed to import corrections - invalid file format');
                }
            };

            // ============================================
            // EXPORT FUNCTIONS
            // ============================================

            // Generate transcription text based on format and script
            const getEnhancedTranscription = () => {
                const layoutStructure = getLayoutStructure(); // Returns array of lines, each containing array of columns
                const orderedResults = getReadingOrderedResults();
                
                // Build text with proper breaks marked
                return layoutStructure.map(line => {
                    return line.map(column => {
                        // For RTL, we need to reverse the column
                        const processedColumn = transcriptionFormat === 'arabic-rtl' 
                            ? [...column].reverse() 
                            : column;
                        
                        let columnText = '';
                        processedColumn.forEach((result, colIndex) => {
                            const text = transcriptionScript === 'arabic' 
                                ? (result.glyph.arabic || result.glyph.name)
                                : (result.glyph.transliteration || result.glyph.name);
                            
                            columnText += text;
                            
                            // Find the index of this result in the ordered results
                            const globalIndex = orderedResults.indexOf(result);
                            
                            // Add space or word boundary marker between glyphs
                            if (colIndex < processedColumn.length - 1) {
                                if (wordBoundaries.has(globalIndex)) {
                                    columnText += ' | '; // Word boundary marker
                                } else {
                                    columnText += ' '; // Normal space
                                }
                            }
                        });
                        return columnText;
                    });
                });
            };

            const exportTranscription = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';

                orderedResults.forEach((result, index) => {
                    transcription += result.glyph.transliteration || result.glyph.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });

                const blob = new Blob([transcription], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_transcription_${new Date().toISOString().slice(0, 10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                recordAction('export_transcription', { transcription });
            };

            const exportDetectionData = () => {
                const data = {
                    timestamp: new Date().toISOString(),
                    imageFile: image ? 'uploaded_image' : null,
                    imageData: image || null,
                    viewMode: viewMode,
                    readingDirection: readingDirection,
                    detections: recognitionResults.map((result, index) => ({
                        index: index,
                        glyph: result.glyph.name,
                        transliteration: result.glyph.transliteration,
                        arabic: result.glyph.arabic || result.glyph.transliteration || result.glyph.name,
                        confidence: result.confidence,
                        position: result.position,
                        matchType: result.matchType,
                        isManual: result.isManual || false,
                        isMerged: result.isMerged || false,
                        validated: validations[index] ? validations[index].isCorrect : null
                    })),
                    readingOrder: viewMode === 'reading' ? readingOrder : null,
                    wordBoundaries: Array.from(wordBoundaries),
                    columnBreaks: Array.from(columnBreaks || []),
                    lineBreaks: Array.from(lineBreaks || []),
                    translations: {
                        english: translationEnglish || '',
                        arabic: translationArabic || ''
                    },
                    statistics: {
                        totalGlyphs: recognitionResults.length,
                        uniqueGlyphs: new Set(recognitionResults.map(r => r.glyph.name)).size,
                        words: Array.from(wordBoundaries).length + 1,
                        lines: Array.from(lineBreaks || []).length + 1,
                        averageConfidence: recognitionResults.length > 0 
                            ? (recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length * 100).toFixed(1)
                            : 0
                    },
                    actionHistory: actionHistory
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_detection_data_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                recordAction('export_detection_data', { detectionCount: recognitionResults.length });
                alert('‚úÖ Detection data exported with translations!');
            };

            const exportAnnotatedImage = () => {
                if (!imageRef.current) return;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;

                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;

                // Draw original image
                ctx.drawImage(img, 0, 0);

                // Draw detection boxes and labels
                recognitionResults.forEach((detection, index) => {
                    const pos = detection.position;

                    // Determine box color based on validation
                    let boxColor = '#8b7d6b'; // blue - unvalidated
                    if (validations[index]) {
                        boxColor = validations[index].isCorrect ? '#6b8e7f' : '#a0674f'; // green or red
                    }

                    // Draw box
                    ctx.strokeStyle = boxColor;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(pos.x, pos.y, pos.width, pos.height);

                    // Draw semi-transparent background for label
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    const labelText = detection.glyph.name;
                    ctx.font = '16px Arial';
                    const textWidth = ctx.measureText(labelText).width;
                    ctx.fillRect(pos.x, pos.y - 25, textWidth + 10, 25);

                    // Draw label text
                    ctx.fillStyle = 'white';
                    ctx.fillText(labelText, pos.x + 5, pos.y - 7);

                    // Draw reading order number if in reading view
                    if (viewMode === 'reading') {
                        const orderNum = getReadingOrderIndex(index);
                        ctx.fillStyle = '#facc15';
                        ctx.beginPath();
                        ctx.arc(pos.x - 15, pos.y - 15, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#ca8a04';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(orderNum.toString(), pos.x - 15, pos.y - 15);
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'alphabetic';
                    }
                });

                // Convert to blob and download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hakli_annotated_${new Date().toISOString().slice(0, 10)}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    recordAction('export_annotated_image', {});
                });
            };

            const exportHtmlReport = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';

                orderedResults.forEach((result, index) => {
                    transcription += result.glyph.transliteration || result.glyph.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });

                // Generate annotated image
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;

                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.drawImage(img, 0, 0);

                // Draw detection boxes
                recognitionResults.forEach((detection, index) => {
                    const pos = detection.position;
                    let boxColor = '#8b7d6b';
                    if (validations[index]) {
                        boxColor = validations[index].isCorrect ? '#6b8e7f' : '#a0674f';
                    }

                    ctx.strokeStyle = boxColor;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(pos.x, pos.y, pos.width, pos.height);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    const labelText = detection.glyph.name;
                    ctx.font = '16px Arial';
                    const textWidth = ctx.measureText(labelText).width;
                    ctx.fillRect(pos.x, pos.y - 25, textWidth + 10, 25);
                    ctx.fillStyle = 'white';
                    ctx.fillText(labelText, pos.x + 5, pos.y - 7);

                    if (viewMode === 'reading') {
                        const orderNum = getReadingOrderIndex(index);
                        ctx.fillStyle = '#facc15';
                        ctx.beginPath();
                        ctx.arc(pos.x - 15, pos.y - 15, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#ca8a04';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(orderNum.toString(), pos.x - 15, pos.y - 15);
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'alphabetic';
                    }
                });

                const annotatedImageDataUrl = canvas.toDataURL();
                const originalImageDataUrl = image;
                
                // Capture preprocessed image if available
                let preprocessedImageDataUrl = null;
                if (preprocessCanvasRef.current && preprocessedMat && !preprocessedMat.isDeleted()) {
                    try {
                        preprocessedImageDataUrl = preprocessCanvasRef.current.toDataURL('image/png');
                    } catch (err) {
                        console.warn('Could not capture preprocessed image:', err);
                    }
                }

                // Calculate statistics
                const totalDetections = recognitionResults.length;
                const validatedCorrect = Object.values(validations).filter(v => v.isCorrect).length;
                const corrected = recognitionResults.filter(r => r.corrected).length;
                const avgConfidence = recognitionResults.length > 0
                    ? (recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length * 100).toFixed(1)
                    : 0;

                // Create iframe to build HTML document
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                document.body.appendChild(iframe);

                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                iframeDoc.open();
                iframeDoc.write('<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body></body></html>');
                iframeDoc.close();

                // Build document structure
                const container = iframeDoc.createElement('div');
                container.className = 'container';

                // Add styles
                const style = iframeDoc.createElement('style');
                style.textContent = '* { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; padding: 20px; } .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow: hidden; } .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; } .header h1 { font-size: 28px; margin-bottom: 10px; } .header .date { opacity: 0.9; font-size: 14px; } .section { border-bottom: 1px solid #e5e7eb; } .section:last-child { border-bottom: none; } .section-header { padding: 20px 30px; cursor: pointer; background: #f9fafb; transition: background 0.2s; display: flex; justify-content: space-between; align-items: center; } .section-header:hover { background: #f3f4f6; } .section-title { font-size: 20px; font-weight: 600; color: #1f2937; } .section-content { padding: 10px 30px 30px 30px; } .section-content.collapsed { display: none; } .toggle-icon { font-size: 18px; color: #6b7280; transition: transform 0.2s; } .toggle-icon.collapsed { transform: rotate(-90deg); } .image-container { text-align: center; margin: 20px 0; } .image-container img { max-width: 100%; height: auto; border: 2px solid #e5e7eb; border-radius: 4px; } .source-images-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0; } .source-image-card { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; padding: 10px; } .source-image-card img { max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px; } .source-image-label { font-size: 12px; font-weight: 600; color: #6b7280; text-align: center; margin-top: 8px; } .image-toggle { margin: 20px 0; text-align: center; } .toggle-btn { background: #8b7d6b; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background 0.2s; } .toggle-btn:hover { background: #6d6355; } .toggle-btn.active { background: #6b8e7f; } .transcription-box { background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 6px; padding: 20px; font-family: "Courier New", monospace; font-size: 18px; line-height: 1.8; word-wrap: break-word; margin: 15px 0; } .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; } .stat-card { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; padding: 15px; text-align: center; } .stat-value { font-size: 32px; font-weight: 700; color: #8b7d6b; margin-bottom: 5px; } .stat-label { font-size: 14px; color: #6b7280; } .detection-list { margin: 15px 0; } .detection-item { background: #f9fafb; border-left: 4px solid #8b7d6b; padding: 12px 15px; margin: 8px 0; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; } .detection-item.correct { border-left-color: #6b8e7f; } .detection-item.incorrect { border-left-color: #a0674f; } .detection-glyph { font-weight: 600; font-size: 16px; } .detection-confidence { color: #6b7280; font-size: 14px; } .footer { background: #f9fafb; padding: 20px 30px; text-align: center; color: #6b7280; font-size: 14px; } .legend { display: flex; gap: 20px; justify-content: center; margin: 15px 0; flex-wrap: wrap; } .legend-item { display: flex; align-items: center; gap: 8px; font-size: 14px; } .legend-box { width: 20px; height: 20px; border-radius: 3px; }';
                iframeDoc.head.appendChild(style);

                // Header
                const header = iframeDoc.createElement('div');
                header.className = 'header';
                header.innerHTML = '<h1>üìú Hakli Glyph Recognition Report</h1><div class="date">Generated on ' + new Date().toLocaleString() + '</div>';
                container.appendChild(header);

                // Image section (FIRST)
                const imageSection = iframeDoc.createElement('div');
                imageSection.className = 'section';
                
                // Build source images grid HTML
                let sourceImagesHtml = '<div class="source-images-grid"><div class="source-image-card"><img src="' + originalImageDataUrl + '" alt="Original image"><div class="source-image-label">üì∑ Original Image</div></div>';
                if (preprocessedImageDataUrl) {
                    sourceImagesHtml += '<div class="source-image-card"><img src="' + preprocessedImageDataUrl + '" alt="Preprocessed image"><div class="source-image-label">‚öôÔ∏è Preprocessed Image</div></div>';
                }
                sourceImagesHtml += '</div>';
                
                imageSection.innerHTML = '<div class="section-header" onclick="toggleSection(this)"><div class="section-title">üñºÔ∏è Source Image</div><div class="toggle-icon">‚ñº</div></div><div class="section-content">' + sourceImagesHtml + '<div class="image-toggle"><button class="toggle-btn" id="toggleBtn" onclick="toggleImage()">Show Annotated Version</button></div><div class="legend"><div class="legend-item"><div class="legend-box" style="background: #8b7d6b;"></div><span>Unvalidated</span></div><div class="legend-item"><div class="legend-box" style="background: #6b8e7f;"></div><span>Validated Correct</span></div><div class="legend-item"><div class="legend-box" style="background: #a0674f;"></div><span>Validated Incorrect</span></div></div><div class="image-container"><img id="mainImage" src="' + originalImageDataUrl + '" alt="Hakli inscription"></div></div>';
                container.appendChild(imageSection);

                // Transcription section (SECOND)
                const transcriptionSection = iframeDoc.createElement('div');
                transcriptionSection.className = 'section';
                transcriptionSection.innerHTML = '<div class="section-header" onclick="toggleSection(this)"><div class="section-title">üìù Transcription</div><div class="toggle-icon">‚ñº</div></div><div class="section-content"><div class="transcription-box">' + transcription + '</div></div>';
                container.appendChild(transcriptionSection);

                // Translation section (THIRD - NEW!)
                if (translationEnglish || translationArabic || inscriptionNotes) {
                    const translationSection = iframeDoc.createElement('div');
                    translationSection.className = 'section';
                    let translationHtml = '<div class="section-header" onclick="toggleSection(this)"><div class="section-title">üåç Translation & Notes</div><div class="toggle-icon">‚ñº</div></div><div class="section-content">';
                    
                    if (translationEnglish) {
                        translationHtml += '<div style="margin-bottom: 20px;"><div style="font-weight: 600; color: #667eea; margin-bottom: 8px;">English:</div><div class="transcription-box" style="font-family: inherit; font-size: 16px;">' + translationEnglish + '</div></div>';
                    }
                    
                    if (translationArabic) {
                        translationHtml += '<div style="margin-bottom: 20px;"><div style="font-weight: 600; color: #667eea; margin-bottom: 8px;">Arabic (ÿßŸÑÿπÿ±ÿ®Ÿäÿ©):</div><div class="transcription-box" style="font-family: \'Traditional Arabic\', \'Arabic Typesetting\', \'Scheherazade\', serif; font-size: 18px; direction: rtl;">' + translationArabic + '</div></div>';
                    }
                    
                    if (inscriptionNotes) {
                        translationHtml += '<div><div style="font-weight: 600; color: #667eea; margin-bottom: 8px;">üìù Notes:</div><div class="transcription-box" style="font-family: inherit; font-size: 14px; white-space: pre-wrap;">' + inscriptionNotes + '</div></div>';
                    }
                    
                    translationHtml += '</div>';
                    translationSection.innerHTML = translationHtml;
                    container.appendChild(translationSection);
                }

                // Detection details section (FOURTH)
                const detectionSection = iframeDoc.createElement('div');
                detectionSection.className = 'section';
                let detectionHtml = '<div class="section-header" onclick="toggleSection(this)"><div class="section-title">üîç Detection Details</div><div class="toggle-icon">‚ñº</div></div><div class="section-content"><div class="detection-list">';
                orderedResults.forEach((result, index) => {
                    const originalIndex = recognitionResults.indexOf(result);
                    const validation = validations[originalIndex];
                    const validationClass = validation ? (validation.isCorrect ? 'correct' : 'incorrect') : '';
                    const correctedBadge = result.corrected ? '<span style="background: #fef3c7; padding: 2px 8px; border-radius: 3px; font-size: 12px;">‚úèÔ∏è Corrected</span>' : '';
                    const orderPrefix = viewMode === 'reading' ? (index + 1) + '. ' : '';
                    detectionHtml += '<div class="detection-item ' + validationClass + '"><div><span class="detection-glyph">' + orderPrefix + result.glyph.name + '</span><span style="color: #6b7280; margin-left: 10px;">' + (result.glyph.transliteration || '') + '</span>' + correctedBadge + '</div><div class="detection-confidence">' + Math.round(result.confidence * 100) + '%</div></div>';
                });
                detectionHtml += '</div></div>';
                detectionSection.innerHTML = detectionHtml;
                container.appendChild(detectionSection);

                // Statistics section (LAST - MOVED TO BOTTOM)
                const statsSection = iframeDoc.createElement('div');
                statsSection.className = 'section';
                statsSection.innerHTML = '<div class="section-header" onclick="toggleSection(this)"><div class="section-title">üìä Recognition Statistics</div><div class="toggle-icon">‚ñº</div></div><div class="section-content"><div class="stats-grid"><div class="stat-card"><div class="stat-value">' + totalDetections + '</div><div class="stat-label">Total Glyphs</div></div><div class="stat-card"><div class="stat-value">' + avgConfidence + '%</div><div class="stat-label">Avg Confidence</div></div><div class="stat-card"><div class="stat-value">' + validatedCorrect + '</div><div class="stat-label">Validated Correct</div></div><div class="stat-card"><div class="stat-value">' + corrected + '</div><div class="stat-label">Corrected</div></div></div></div>';
                container.appendChild(statsSection);

                // Footer
                const footer = iframeDoc.createElement('div');
                footer.className = 'footer';
                footer.textContent = 'Generated by Hakli Glyph Recognizer (beta v251215) ¬© hoopoe holdings';
                container.appendChild(footer);

                // Add script
                const script = iframeDoc.createElement('script');
                script.textContent = 'let showingAnnotated = false; const originalImage = "' + originalImageDataUrl + '"; const annotatedImage = "' + annotatedImageDataUrl + '"; function toggleImage() { const img = document.getElementById("mainImage"); const btn = document.getElementById("toggleBtn"); showingAnnotated = !showingAnnotated; if (showingAnnotated) { img.src = annotatedImage; btn.textContent = "Show Original"; btn.classList.add("active"); } else { img.src = originalImage; btn.textContent = "Show Annotated Version"; btn.classList.remove("active"); } } function toggleSection(header) { const content = header.nextElementSibling; const icon = header.querySelector(".toggle-icon"); if (content.classList.contains("collapsed")) { content.classList.remove("collapsed"); icon.classList.remove("collapsed"); icon.textContent = "‚ñº"; } else { content.classList.add("collapsed"); icon.classList.add("collapsed"); icon.textContent = "‚ñ∂"; } }';
                iframeDoc.body.appendChild(script);

                iframeDoc.body.appendChild(container);

                // Get HTML and download
                const htmlContent = '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="UTF-8">\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n<title>Hakli Recognition Report</title>\n' + style.outerHTML + '\n</head>\n<body>\n' + container.outerHTML + '\n' + script.outerHTML + '\n</body>\n</html>';

                document.body.removeChild(iframe);

                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'hakli_report_' + new Date().toISOString().slice(0, 10) + '.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                recordAction('export_html_report', {
                    glyphCount: recognitionResults.length,
                    transcriptionLength: transcription.length
                });

                alert('HTML report exported successfully!');
            };

            const handleImageMouseDown = (event) => {
                // Manual detection mode
                if (manualDetectionMode) {
                    const coords = getImageCoordinates(event);
                    if (!coords) return;
                    setIsDrawing(true);
                    setDrawStart(coords);
                    setDrawCurrent(coords);
                    return;
                }

                // Trim mode
                if (trimMode !== null) {
                    const coords = getImageCoordinates(event);
                    if (!coords) return;
                    setIsDrawing(true);
                    setDrawStart(coords);
                    setDrawCurrent(coords);
                    return;
                }

                // Exclude mode
                if (excludeMode !== null) {
                    const coords = getImageCoordinates(event);
                    if (!coords) return;
                    setIsDrawing(true);
                    setDrawStart(coords);
                    setDrawCurrent(coords);
                    return;
                }
            };

            const handleImageMouseMove = (event) => {
                if (!isDrawing) return;

                event.preventDefault();
                const coords = getImageCoordinates(event);
                if (coords) {
                    setDrawCurrent(coords);
                }
            };

            const handleImageMouseUp = (event) => {
                if (!isDrawing || !drawStart) return;

                const coords = getImageCoordinates(event);
                if (!coords) return;

                const bounds = {
                    x: Math.min(drawStart.x, coords.x),
                    y: Math.min(drawStart.y, coords.y),
                    width: Math.abs(coords.x - drawStart.x),
                    height: Math.abs(coords.y - drawStart.y)
                };

                // Manual detection mode
                if (manualDetectionMode && bounds.width > 10 && bounds.height > 10) {
                    const thumbnail = extractRegionThumbnail(imageRef.current, { bounds: bounds });

                    const manualDetection = {
                        glyph: { id: 'unknown', name: 'Unknown', transliteration: '?' },
                        confidence: 0.5,
                        position: bounds,
                        matchType: 'manual',
                        isManual: true,
                        regionIndex: isolatedGlyphs.length,
                        thumbnail: thumbnail
                    };

                    setIsolatedGlyphs(prev => [...prev, {
                        bounds: bounds,
                        thumbnail: thumbnail,
                        area: bounds.width * bounds.height,
                        aspectRatio: bounds.width / bounds.height
                    }]);

                    setRecognitionResults(prev => {
                        const newResults = [...prev, manualDetection];
                        const newIndex = newResults.length - 1;
                        
                        // Add to reading order if we're using it
                        if (readingOrder.length > 0) {
                            setReadingOrder(ro => [...ro, newIndex]);
                        }
                        
                        return newResults;
                    });
                    recordAction('add_manual_detection', { bounds, thumbnail: !!thumbnail });
                }

                // Trim mode
                if (trimMode !== null && bounds.width > 10 && bounds.height > 10) {
                    applyTrim(trimMode, bounds);
                }

                // Exclude mode
                if (excludeMode !== null && bounds.width > 10 && bounds.height > 10) {
                    // Add to exclusion regions
                    setExcludeRegions(prev => [...prev, bounds]);
                }

                setIsDrawing(false);
                setDrawStart(null);
                setDrawCurrent(null);
            };

            const toggleRegionSelection = (regionIndex) => {
                setSelectedRegions(prev => {
                    const newSet = new Set(prev);
                    newSet.has(regionIndex) ? newSet.delete(regionIndex) : newSet.add(regionIndex);
                    // Auto-expand Controls & Options when 2+ regions selected for merge
                    if (newSet.size >= 2) {
                        setIsControlsCollapsed(false);
                    }
                    return newSet;
                });
            };

            const handleDetectionClick = (event, index) => {
                if (event.ctrlKey || event.metaKey) {
                    event.stopPropagation();
                    toggleRegionSelection(index);
                }
            };
            
            const getReadingOrderIndex = (detectionIndex) => {
                const orderedResults = getReadingOrderedResults();
                    return orderedResults.findIndex(result => 
                    recognitionResults.indexOf(result) === detectionIndex
                ) + 1;
            };

            // Transcription box drag handlers
            const transcriptionRef = React.useRef(null);
            
            const handleTranscriptionMouseDown = (e) => {
                // Only drag from the header area
                if (e.target.closest('.transcription-drag-handle')) {
                    setIsDraggingTranscription(true);
                    
                    // Get actual position of the box
                    const rect = transcriptionRef.current?.getBoundingClientRect();
                    if (rect) {
                        setTranscriptionDragStart({
                            x: e.clientX - rect.left,
                            y: e.clientY - rect.top
                        });
                    }
                    e.preventDefault();
                }
            };

            const handleTranscriptionMouseMove = (e) => {
                if (isDraggingTranscription) {
                    const newX = e.clientX - transcriptionDragStart.x;
                    const newY = e.clientY - transcriptionDragStart.y;
                    
                    // Allow dragging anywhere - no clamping during drag
                    setTranscriptionPosition({
                        x: newX,
                        y: newY
                    });
                }
            };

            const handleTranscriptionMouseUp = () => {
                setIsDraggingTranscription(false);
                
                // Check if final position is out of bounds and bounce back if needed
                const maxX = window.innerWidth - 300; // Keep at least 300px visible
                const maxY = window.innerHeight - 100; // Keep at least 100px visible
                
                if (transcriptionPosition.x < 0 || transcriptionPosition.x > maxX ||
                    transcriptionPosition.y < 0 || transcriptionPosition.y > maxY) {
                    // Out of bounds - bounce back to safe position
                    setTranscriptionPosition({
                        x: Math.max(0, Math.min(transcriptionPosition.x, maxX)),
                        y: Math.max(0, Math.min(transcriptionPosition.y, maxY))
                    });
                }
            };

            // Add global listeners for transcription dragging
            React.useEffect(() => {
                if (isDraggingTranscription) {
                    window.addEventListener('mousemove', handleTranscriptionMouseMove);
                    window.addEventListener('mouseup', handleTranscriptionMouseUp);
                    return () => {
                        window.removeEventListener('mousemove', handleTranscriptionMouseMove);
                        window.removeEventListener('mouseup', handleTranscriptionMouseUp);
                    };
                }
            }, [isDraggingTranscription, transcriptionDragStart]);

            const applyReadingDirection = (direction) => {
                setReadingDirection(direction);
                
                // Auto-generate reading order based on direction
                const sorted = recognitionResults.map((result, idx) => ({ result, idx }));
                
                if (direction === 'ltr') {
                    sorted.sort((a, b) => 
                        a.result.position.y - b.result.position.y || 
                        a.result.position.x - b.result.position.x
                    );
                } else if (direction === 'rtl') {
                    sorted.sort((a, b) => 
                        a.result.position.y - b.result.position.y || 
                        b.result.position.x - a.result.position.x
                    );
                } else if (direction === 'ttb') {
                    sorted.sort((a, b) => 
                        b.result.position.x - a.result.position.x ||  // Right to left (rightmost column first)
                        a.result.position.y - b.result.position.y     // Top to bottom within column
                    );
                } else {
                    // Detection order - just use original indices
                    setReadingOrder(recognitionResults.map((_, idx) => idx));
                    return;
                }
                
                setReadingOrder(sorted.map(item => item.idx));
            };

            const toggleWordBoundary = (readingOrderIndex) => {
                setWordBoundaries(prev => {
                    const newSet = new Set(prev);
                    newSet.has(readingOrderIndex) ? newSet.delete(readingOrderIndex) : newSet.add(readingOrderIndex);
                    return newSet;
                });
                recordAction('toggle_word_boundary', { readingOrderIndex });
            };

            const toggleColumnBreak = (readingOrderIndex) => {
                setColumnBreaks(prev => {
                    const newSet = new Set(prev);
                    newSet.has(readingOrderIndex) ? newSet.delete(readingOrderIndex) : newSet.add(readingOrderIndex);
                    return newSet;
                });
                recordAction('toggle_column_break', { readingOrderIndex });
            };

            const toggleLineBreak = (readingOrderIndex) => {
                setLineBreaks(prev => {
                    const newSet = new Set(prev);
                    newSet.has(readingOrderIndex) ? newSet.delete(readingOrderIndex) : newSet.add(readingOrderIndex);
                    return newSet;
                });
                recordAction('toggle_line_break', { readingOrderIndex });
            };

            // Build 2D layout structure based on column and line breaks
            const getLayoutStructure = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                const lines = [];
                let currentLine = [];
                let currentColumn = [];

                orderedResults.forEach((result, index) => {
                    currentColumn.push(result);

                    if (columnBreaks.has(index)) {
                        // End of column
                        currentLine.push(currentColumn);
                        currentColumn = [];
                    }

                    if (lineBreaks.has(index)) {
                        // End of line
                        if (currentColumn.length > 0) {
                            currentLine.push(currentColumn);
                            currentColumn = [];
                        }
                        if (currentLine.length > 0) {
                            lines.push(currentLine);
                            currentLine = [];
                        }
                    }
                });

                // Add any remaining glyphs
                if (currentColumn.length > 0) {
                    currentLine.push(currentColumn);
                }
                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }

                // If no breaks were marked, treat as single column in single line
                if (lines.length === 0) {
                    lines.push([orderedResults]);
                }

                return lines;
            };

            const handleDragStart = (e, index) => {
                // Prevent dragging in detection order mode
                if (readingDirection === 'detection') {
                    e.preventDefault();
                    alert('‚ö†Ô∏è Cannot reorder while in Detection Order mode.\n\nüìñ Please select a reading direction:\n‚Ä¢ ‚Üí LTR (Left to Right)\n‚Ä¢ ‚Üê RTL (Right to Left)\n‚Ä¢ ‚Üì TTB (Top to Bottom)\n\nYou\'ll find these buttons in the "Reading Direction" section above.');
                    return;
                }
                setDraggedItem(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = (e, dropIndex) => {
                e.preventDefault();
                if (draggedItem === null || draggedItem === dropIndex) return;
                
                const newOrder = [...readingOrder];
                const draggedValue = newOrder[draggedItem];
                newOrder.splice(draggedItem, 1);
                newOrder.splice(dropIndex, 0, draggedValue);
                
                setReadingOrder(newOrder);
                setDraggedItem(null);
                
                recordAction('reorder_reading', { from: draggedItem, to: dropIndex });
            };

            const handleRecognitionError = (error, context = 'Recognition') => {
                console.error(`‚ùå ${context} error:`, error);
                alert(`‚ùå ${context} failed. Check console for details.`);
            };

            useEffect(() => {
                if (selectedRegions.size >= 2) {
                    const selectedDetections = Array.from(selectedRegions).map(i => recognitionResults[i]);
                    if (selectedDetections.length > 0) {
                        const minX = Math.min(...selectedDetections.map(d => d.position.x));
                        const minY = Math.min(...selectedDetections.map(d => d.position.y));
                        const maxX = Math.max(...selectedDetections.map(d => d.position.x + d.position.width));
                        const maxY = Math.max(...selectedDetections.map(d => d.position.y + d.position.height));
                        setMergeIndicator({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });
                    }
                } else {
                    setMergeIndicator(null);
                }
            }, [selectedRegions, recognitionResults]);


            const startCorrection = (detectionIndex) => {
                setCorrectionMode(detectionIndex);
            };

            const applyCorrection = (detectionIndex, newGlyph) => {
                const oldGlyph = recognitionResults[detectionIndex].glyph;
                const confidence = recognitionResults[detectionIndex].confidence;

                recordAction('correct_glyph', {
                    detectionIndex: detectionIndex,
                    oldGlyph: oldGlyph,
                    newGlyph: newGlyph
                });

                // Save to correction memory
                saveCorrectionToMemory(oldGlyph, newGlyph, confidence);

                setRecognitionResults(prev => prev.map((result, index) => {
                    if (index === detectionIndex) {
                        return {
                            ...result,
                            glyph: newGlyph,
                            corrected: true,
                            originalGlyph: result.glyph
                        };
                    }
                    return result;
                }));

                setCorrectionMode(null);
            };

            const cancelCorrection = () => {
                setCorrectionMode(null);
            };

            const startAdjustMode = (detectionIndex) => {
                setAdjustMode(detectionIndex);
                // Initialize corners if they don't exist
                const detection = recognitionResults[detectionIndex];
                if (!detection.corners) {
                    const pos = detection.position;
                    setRecognitionResults(prev => {
                        const updated = [...prev];
                        updated[detectionIndex] = {
                            ...updated[detectionIndex],
                            corners: {
                                tl: { x: pos.x, y: pos.y },
                                tr: { x: pos.x + pos.width, y: pos.y },
                                bl: { x: pos.x, y: pos.y + pos.height },
                                br: { x: pos.x + pos.width, y: pos.y + pos.height }
                            }
                        };
                        return updated;
                    });
                }
            };

                    
            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file && file.type.indexOf('image/') === 0) {
                    setIsImageLoading(true);
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setImage(e.target.result);
                        setDisplayImage(null); // Clear any rotated display
                        setImageRotation(0); // Reset rotation
                        setRotatedImageDimensions(null); // Clear rotated dimensions
                        setRecognitionResults([]);
                        setValidations({});
                        setActionHistory([]);
                        setIsolatedGlyphs([]);
                        setSelectedRegions(new Set());
                        setMergeIndicator(null);
                        setAdjustmentsApplied(false); // Reset adjustment state
                        
                        // Clear translation/metadata fields for fresh image
                        setTranslationEnglish('');
                        setTranslationArabic('');
                        setInscriptionTitle('');
                        setInscriptionNotes('');
                        setReadingOrder([]);
                        setWordBoundaries(new Set());
                        setColumnBreaks(new Set());
                        setLineBreaks(new Set());
                        
                        // Load image into OpenCV Mat for preprocessing
                        if (isOpenCvReady) {
                            const img = new Image();
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                
                                const mat = cv.imread(canvas);
                                setOriginalMat(mat);
                                
                                // Show original on canvas
                                if (originalCanvasRef.current) {
                                    cv.imshow(originalCanvasRef.current, mat);
                                }
                                
                                // Process immediately
                                processImageWithSettings(mat, preprocessing);
                                setIsImageLoading(false);
                            };
                            img.onerror = () => {
                                setIsImageLoading(false);
                                alert('‚ùå Failed to load image. Please try again.');
                            };
                            img.src = e.target.result;
                        } else {
                            setIsImageLoading(false);
                            alert('‚ö†Ô∏è OpenCV is still loading. Please wait a moment and try again.');
                        }
                    };
                    reader.onerror = () => {
                        setIsImageLoading(false);
                        alert('‚ùå Failed to read file. Please try again.');
                    };
                    reader.readAsDataURL(file);
                }
            };
            
            // Process image with current preprocessing settings
            const processImageWithSettings = (sourceMat, settings) => {
                if (!sourceMat || !isOpenCvReady) return;
                
                // Check if Mat is still valid
                if (sourceMat.isDeleted()) {
                    console.warn('Source Mat already deleted, skipping preprocessing');
                    return;
                }
                
                try {
                    // Clean up previous preprocessed mat
                    if (preprocessedMat && !preprocessedMat.isDeleted()) {
                        preprocessedMat.delete();
                    }
                    
                    let processed = sourceMat.clone();
                    
                    // 1. Rotation
                    if (settings.rotation !== 0) {
                        const center = new cv.Point(processed.cols / 2, processed.rows / 2);
                        const rotMatrix = cv.getRotationMatrix2D(center, settings.rotation, 1.0);
                        
                        const radians = (settings.rotation * Math.PI) / 180;
                        const sin = Math.abs(Math.sin(radians));
                        const cos = Math.abs(Math.cos(radians));
                        const newWidth = Math.round(processed.cols * cos + processed.rows * sin);
                        const newHeight = Math.round(processed.cols * sin + processed.rows * cos);
                        
                        rotMatrix.data64F[2] += (newWidth / 2) - center.x;
                        rotMatrix.data64F[5] += (newHeight / 2) - center.y;
                        
                        const rotated = new cv.Mat();
                        const dsize = new cv.Size(newWidth, newHeight);
                        cv.warpAffine(processed, rotated, rotMatrix, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255, 255, 255, 255));
                        processed.delete();
                        processed = rotated;
                        rotMatrix.delete();
                    }
                    
                    // 2. Convert to grayscale if needed
                    if (processed.channels() > 1) {
                        const gray = new cv.Mat();
                        cv.cvtColor(processed, gray, cv.COLOR_RGBA2GRAY);
                        processed.delete();
                        processed = gray;
                    }
                    
                    // 3. Gaussian blur
                    if (settings.gaussianBlur > 0) {
                        const ksize = new cv.Size(settings.gaussianBlur, settings.gaussianBlur);
                        cv.GaussianBlur(processed, processed, ksize, 0);
                    }
                    
                    // 4. Adaptive threshold
                    if (settings.useAdaptiveThreshold) {
                        const thresholded = new cv.Mat();
                        cv.adaptiveThreshold(
                            processed,
                            thresholded,
                            255,
                            cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                            cv.THRESH_BINARY,
                            settings.blockSize,
                            settings.constantOffset
                        );
                        processed.delete();
                        processed = thresholded;
                    }
                    
                    // 5. Invert colors
                    if (settings.invertColors) {
                        cv.bitwise_not(processed, processed);
                    }
                    
                    // 6. Morphology
                    if (settings.morphologyOperation !== 'none') {
                        const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                        
                        if (settings.morphologyOperation === 'close' || settings.morphologyOperation === 'both') {
                            cv.morphologyEx(processed, processed, cv.MORPH_CLOSE, kernel);
                        }
                        if (settings.morphologyOperation === 'open' || settings.morphologyOperation === 'both') {
                            cv.morphologyEx(processed, processed, cv.MORPH_OPEN, kernel);
                        }
                        
                        kernel.delete();
                    }
                    
                    setPreprocessedMat(processed);
                    
                    // Show on preview canvas
                    if (showPreprocessPreview && preprocessCanvasRef.current) {
                        cv.imshow(preprocessCanvasRef.current, processed);
                    }
                    
                    console.log('‚úì Preprocessing complete:', settings);
                } catch (error) {
                    console.error('Preprocessing error:', error);
                }
            };
            
            // Update preprocessing setting
            const updatePreprocessingSetting = (key, value) => {
                const newSettings = { ...preprocessing, [key]: value };
                setPreprocessing(newSettings);
                setAdjustmentsApplied(false); // Mark as needing reapplication
                if (originalMat) {
                    processImageWithSettings(originalMat, newSettings);
                }
            };
            
            // Reset preprocessing to defaults
            const resetPreprocessing = () => {
                const defaults = {
                    rotation: 0,
                    useAdaptiveThreshold: false,
                    blockSize: 11,
                    constantOffset: 2,
                    gaussianBlur: 0,
                    morphologyOperation: 'none',
                    invertColors: false
                };
                setPreprocessing(defaults);
                setAdjustmentsApplied(false); // Mark as needing reapplication
                if (originalMat) {
                    processImageWithSettings(originalMat, defaults);
                }
            };
            
            // Apply adjustments to main recognition image
            const applyAdjustments = () => {
                if (!preprocessedMat || preprocessedMat.isDeleted()) {
                    alert('‚ö†Ô∏è No preprocessed image available. Please adjust settings first.');
                    return;
                }
                
                try {
                    // Convert preprocessed Mat to canvas then to data URL
                    const canvas = document.createElement('canvas');
                    cv.imshow(canvas, preprocessedMat);
                    const dataURL = canvas.toDataURL();
                    
                    // Force update by adding timestamp to ensure React sees it as new
                    const timestamp = Date.now();
                    
                    // Update the display image
                    setDisplayImage(dataURL);
                    setImage(dataURL); // Also update the base image state
                    setAdjustmentsApplied(true);
                    
                    console.log('‚úì Adjustments applied to recognition image (timestamp:', timestamp, ')');
                } catch (error) {
                    console.error('Error applying adjustments:', error);
                    alert('‚ùå Failed to apply adjustments. Please try again.');
                }
            };
            
            // Eraser mode functions
            const toggleEraserMode = () => {
                const newMode = !eraserMode;
                setEraserMode(newMode);
                
                if (newMode) {
                    // Entering eraser mode - use setTimeout to ensure canvas is rendered
                    setTimeout(() => {
                        if (preprocessedMat && !preprocessedMat.isDeleted() && eraserCanvasRef.current) {
                            cv.imshow(eraserCanvasRef.current, preprocessedMat);
                            
                            // Save initial state for undo
                            const canvas = eraserCanvasRef.current;
                            const imageData = canvas.toDataURL();
                            setEraserHistory([imageData]);
                            
                            console.log('‚úì Eraser canvas loaded with image');
                        }
                    }, 100); // Small delay to ensure canvas is in DOM
                } else {
                    // Exiting eraser mode - apply erased version back to preprocessedMat
                    if (eraserCanvasRef.current) {
                        try {
                            const erasedMat = cv.imread(eraserCanvasRef.current);
                            if (preprocessedMat && !preprocessedMat.isDeleted()) {
                                preprocessedMat.delete();
                            }
                            setPreprocessedMat(erasedMat);
                            
                            // Update the preview canvas
                            if (preprocessCanvasRef.current) {
                                cv.imshow(preprocessCanvasRef.current, erasedMat);
                            }
                            
                            // Mark adjustments as needing reapplication
                            setAdjustmentsApplied(false);
                            
                            // Clear history
                            setEraserHistory([]);
                            
                            console.log('‚úì Eraser changes applied');
                        } catch (error) {
                            console.error('Error applying eraser:', error);
                        }
                    }
                }
            };
            
            // Update eraser cursor style when brush size or canvas changes
            useEffect(() => {
                const updateCursorStyle = () => {
                    const canvas = eraserCanvasRef.current;
                    if (!canvas || !eraserMode) {
                        setEraserCursorStyle('crosshair');
                        return;
                    }
                    
                    const rect = canvas.getBoundingClientRect();
                    if (rect.width === 0 || canvas.width === 0) {
                        setEraserCursorStyle('crosshair');
                        return;
                    }
                    
                    const scaleX = rect.width / canvas.width;
                    const displayBrushSize = Math.round(brushSize * scaleX);
                    const diameter = displayBrushSize * 2;
                    const cursorSvg = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${diameter}" height="${diameter}" viewBox="0 0 ${diameter} ${diameter}"><circle cx="${displayBrushSize}" cy="${displayBrushSize}" r="${displayBrushSize - 1}" fill="none" stroke="white" stroke-width="2"/><circle cx="${displayBrushSize}" cy="${displayBrushSize}" r="${displayBrushSize - 1}" fill="none" stroke="black" stroke-width="1"/></svg>') ${displayBrushSize} ${displayBrushSize}, crosshair`;
                    setEraserCursorStyle(cursorSvg);
                };
                
                if (eraserMode) {
                    // Update immediately
                    updateCursorStyle();
                    
                    // Also update on window resize
                    window.addEventListener('resize', updateCursorStyle);
                    return () => window.removeEventListener('resize', updateCursorStyle);
                }
            }, [brushSize, eraserMode]);
            
            const handleEraserMouseDown = (e) => {
                if (!eraserMode || !eraserCanvasRef.current) return;
                setIsErasing(true);
                drawEraser(e);
            };
            
            const handleEraserMouseMove = (e) => {
                if (!eraserMode || !isErasing || !eraserCanvasRef.current) return;
                drawEraser(e);
            };
            
            const handleEraserMouseUp = () => {
                if (isErasing && eraserCanvasRef.current) {
                    // Save current canvas state to history
                    const imageData = eraserCanvasRef.current.toDataURL();
                    setEraserHistory(prev => [...prev, imageData]);
                }
                setIsErasing(false);
            };
            
            // Touch event handlers for mobile
            const handleEraserTouchStart = (e) => {
                if (!eraserMode || !eraserCanvasRef.current) return;
                e.preventDefault(); // Prevent scrolling while erasing
                setIsErasing(true);
                const touch = e.touches[0];
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                drawEraser(mouseEvent);
            };
            
            const handleEraserTouchMove = (e) => {
                if (!eraserMode || !isErasing || !eraserCanvasRef.current) return;
                e.preventDefault(); // Prevent scrolling while erasing
                const touch = e.touches[0];
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                drawEraser(mouseEvent);
            };
            
            const handleEraserTouchEnd = () => {
                if (isErasing && eraserCanvasRef.current) {
                    // Save current canvas state to history
                    const imageData = eraserCanvasRef.current.toDataURL();
                    setEraserHistory(prev => [...prev, imageData]);
                }
                setIsErasing(false);
            };
            
            const drawEraser = (e) => {
                const canvas = eraserCanvasRef.current;
                if (!canvas) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x, y, brushSize, 0, Math.PI * 2);
                ctx.fill();
            };
            
            const undoLastStroke = () => {
                if (!eraserCanvasRef.current || eraserHistory.length <= 1) return;
                
                // Remove last state
                const newHistory = eraserHistory.slice(0, -1);
                setEraserHistory(newHistory);
                
                // Restore previous state
                const previousState = newHistory[newHistory.length - 1];
                const img = new Image();
                img.onload = () => {
                    const canvas = eraserCanvasRef.current;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = previousState;
            };
            
            const clearAllEraser = () => {
                if (!eraserCanvasRef.current) return;
                
                if (window.confirm('Clear all eraser marks and start over?')) {
                    // Restore original preprocessed image
                    if (preprocessedMat && !preprocessedMat.isDeleted()) {
                        cv.imshow(eraserCanvasRef.current, preprocessedMat);
                        
                        // Reset history to just the initial state
                        const imageData = eraserCanvasRef.current.toDataURL();
                        setEraserHistory([imageData]);
                    }
                }
            };
            
            // Export preprocessing settings
            const exportPreprocessingSettings = () => {
                const json = JSON.stringify(preprocessing, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'preprocessing-settings.json';
                a.click();
                URL.revokeObjectURL(url);
            };
            
            // Cleanup effect for OpenCV Mats
            useEffect(() => {
                return () => {
                    if (originalMat && !originalMat.isDeleted()) originalMat.delete();
                    if (preprocessedMat && !preprocessedMat.isDeleted()) preprocessedMat.delete();
                };
            }, []);
            
            // Update original canvas when originalMat changes
            useEffect(() => {
                if (originalMat && originalCanvasRef.current && showPreprocessPreview) {
                    try {
                        console.log('Displaying original mat to canvas');
                        // Use requestAnimationFrame to ensure canvas is fully rendered
                        requestAnimationFrame(() => {
                            if (originalCanvasRef.current && originalMat && !originalMat.isDeleted()) {
                                cv.imshow(originalCanvasRef.current, originalMat);
                            }
                        });
                    } catch (error) {
                        console.error('Error showing original:', error);
                    }
                }
            }, [originalMat, showPreprocessPreview]);
            
            // Redraw preprocessed canvas when preview is shown
            useEffect(() => {
                if (preprocessedMat && preprocessCanvasRef.current && showPreprocessPreview) {
                    try {
                        // Use requestAnimationFrame to ensure canvas is fully rendered
                        requestAnimationFrame(() => {
                            if (preprocessCanvasRef.current && preprocessedMat && !preprocessedMat.isDeleted()) {
                                cv.imshow(preprocessCanvasRef.current, preprocessedMat);
                            }
                        });
                    } catch (error) {
                        console.error('Error showing preprocessed:', error);
                    }
                }
            }, [preprocessedMat, showPreprocessPreview]);
            
            // Re-process when settings change
            useEffect(() => {
                if (originalMat && !originalMat.isDeleted()) {
                    processImageWithSettings(originalMat, preprocessing);
                }
            }, [preprocessing]);

            

            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Escape: Close correction modal or cancel trim/exclude modes
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        if (correctionMode !== null) {
                            cancelCorrection();
                        } else if (trimMode !== null) {
                            setTrimMode(null);
                            setIsDrawing(false);
                            setDrawStart(null);
                            setDrawCurrent(null);
                        } else if (excludeMode !== null) {
                            setExcludeMode(null);
                            setExcludeRegions([]);
                            setIsDrawing(false);
                            setDrawStart(null);
                            setDrawCurrent(null);
                        } else if (adjustMode !== null) {
                            setAdjustMode(null);
                            setDraggingCorner(null);
                            setDragStartPos(null);
                        }
                        return;
                    }

                    // Undo: Ctrl+Z
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        undo();
                    }
                    // Redo: Ctrl+Shift+Z or Ctrl+Y
                    if ((e.ctrlKey || e.metaKey) && (e.shiftKey && e.key === 'z' || e.key === 'y')) {
                        e.preventDefault();
                        redo();
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [historyIndex, stateHistory, correctionMode, trimMode, excludeMode, adjustMode]);

            // Global mouse event handler for corner dragging
            useEffect(() => {
                if (!draggingCorner || adjustMode === null) return;

                const handleMouseMove = (e) => {
                    if (!imageRef.current) return;
                    e.preventDefault();
                    
                    const imageRect = imageRef.current.getBoundingClientRect();
                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                    
                    const newX = (e.clientX - imageRect.left) / scaleX;
                    const newY = (e.clientY - imageRect.top) / scaleY;

                    // Update the corner position
                    setRecognitionResults(prev => {
                        const updated = [...prev];
                        const detection = updated[adjustMode];
                        if (!detection) return prev;
                        
                        const newCorners = { ...detection.corners };
                        newCorners[draggingCorner] = { x: newX, y: newY };
                        
                        // Calculate new bounding box from corners
                        const minX = Math.min(newCorners.tl.x, newCorners.tr.x, newCorners.bl.x, newCorners.br.x);
                        const maxX = Math.max(newCorners.tl.x, newCorners.tr.x, newCorners.bl.x, newCorners.br.x);
                        const minY = Math.min(newCorners.tl.y, newCorners.tr.y, newCorners.bl.y, newCorners.br.y);
                        const maxY = Math.max(newCorners.tl.y, newCorners.tr.y, newCorners.bl.y, newCorners.br.y);
                        
                        updated[adjustMode] = {
                            ...detection,
                            corners: newCorners,
                            position: {
                                x: Math.round(minX),
                                y: Math.round(minY),
                                width: Math.round(maxX - minX),
                                height: Math.round(maxY - minY)
                            }
                        };
                        return updated;
                    });
                };

                const handleMouseUp = () => {
                    setDraggingCorner(null);
                    setDragStartPos(null);
                };

                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
                
                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
            }, [draggingCorner, adjustMode]);

            useEffect(() => {
                if (chartLoadStatus === 'not-loaded') {
                    setChartLoadStatus('loading');
                    const githubJsonUrl = 'https://raw.githubusercontent.com/hytra3/hakli_glyph_recognizer/main/Hakli_glyphs.JSON';
                    fetch(githubJsonUrl)
                        .then(response => response.json())
                        .then(chartData => {
                            setEquivalenceChart(chartData);
                            const imageCache = {};
                            const loadPromises = [];

                            // Count total images to load
                            let totalImagesToLoad = 0;

                            for (const glyph of chartData.glyphs) {
                                if (glyph.images && glyph.images.primary) totalImagesToLoad++;
                                if (glyph.images && glyph.images.variants) totalImagesToLoad += glyph.images.variants.length;
                                // Skip examples for initial load - they're only for chart viewing
                            }

                            setImageLoadingProgress({ loaded: 0, total: totalImagesToLoad });
                            console.log(`üì¶ Loading ${totalImagesToLoad} template images for ${chartData.glyphs.length} glyphs (examples will load in background)...`);
                            console.log(`üìä Progress tracking: will update every ${Math.max(1, Math.floor(totalImagesToLoad / 20))} images`);

                            let loadedCount = 0;
                            const updateInterval = Math.max(1, Math.floor(totalImagesToLoad / 20)); // Update progress bar ~20 times

                            const createImageLoader = (url, key) => {
                                return new Promise((resolve) => {
                                    const img = new Image();
                                    img.crossOrigin = 'anonymous';
                                    img.onload = () => {
                                        imageCache[key] = img;
                                        loadedCount++;
                                        // Only update progress every N images to reduce re-renders
                                        if (loadedCount % updateInterval === 0 || loadedCount === totalImagesToLoad || loadedCount === 1) {
                                            console.log(`üìä Progress: ${loadedCount}/${totalImagesToLoad}`);
                                            // Use requestAnimationFrame to force browser to paint the update
                                            requestAnimationFrame(() => {
                                                setImageLoadingProgress({ loaded: loadedCount, total: totalImagesToLoad });
                                            });
                                        }
                                        resolve();
                                    };
                                    img.onerror = () => {
                                        loadedCount++;
                                        if (loadedCount % updateInterval === 0 || loadedCount === totalImagesToLoad || loadedCount === 1) {
                                            console.log(`üìä Progress: ${loadedCount}/${totalImagesToLoad} (error)`);
                                            // Use requestAnimationFrame to force browser to paint the update
                                            requestAnimationFrame(() => {
                                                setImageLoadingProgress({ loaded: loadedCount, total: totalImagesToLoad });
                                            });
                                        }
                                        resolve();
                                    };
                                    img.src = url;
                                });
                            };

                            for (const glyph of chartData.glyphs) {
                                // Load primary image
                                if (glyph.images && glyph.images.primary) {
                                    loadPromises.push(createImageLoader(glyph.images.primary, glyph.id));
                                }

                                // Load variant images
                                if (glyph.images && glyph.images.variants) {
                                    for (let i = 0; i < glyph.images.variants.length; i++) {
                                        const variantKey = `${glyph.id}_variant_${i}`;
                                        loadPromises.push(createImageLoader(glyph.images.variants[i], variantKey));
                                    }
                                }

                                // Skip examples initially - load in background
                            }

                            Promise.all(loadPromises).then(() => {
                                console.log(`‚úÖ Loaded ${Object.keys(imageCache).length} images for ${chartData.glyphs.length} glyphs`);
                                setLoadedGlyphImages(imageCache);
                                setChartLoadStatus('loaded');
                                setImageLoadingProgress({ loaded: 0, total: 0 }); // Reset
                                
                                // Lazy load ALL examples in background
                                const lazyLoadPromises = [];
                                for (const glyph of chartData.glyphs) {
                                    if (glyph.images && glyph.images.examples) {
                                        for (let i = 0; i < glyph.images.examples.length; i++) {
                                            const exampleKey = `${glyph.id}_example_${i}`;
                                            const lazyPromise = createImageLoader(glyph.images.examples[i], exampleKey);
                                            lazyLoadPromises.push(lazyPromise);
                                        }
                                    }
                                }
                                
                                // Load examples in background
                                if (lazyLoadPromises.length > 0) {
                                    console.log(`üîÑ Loading ${lazyLoadPromises.length} example images in background...`);
                                    Promise.all(lazyLoadPromises).then(() => {
                                        setLoadedGlyphImages(prev => ({...prev, ...imageCache}));
                                        console.log(`‚úÖ All example images loaded`);
                                    });
                                }
                            });
                        })
                        .catch(() => setChartLoadStatus('error'));
                }
            }, [chartLoadStatus]);

            return (
                <div className="max-w-6xl mx-auto p-6 bg-white">
                    <div className="mb-8">
                        <div className="flex items-center gap-3 mb-2">
                            <img src="hh-logo.png" alt="Hoopoe Holdings Logo" className="w-12 h-12 rounded-full object-cover" />
                            <h1 className="text-3xl font-bold text-gray-900">Hakli Glyph Recognizer</h1>
                        </div>
                        <p className="text-sm text-gray-500">Based on Ahmad Al-Jallad (2025), <em>The Decipherment of the Dhofari Script</em></p>
                        <p className="text-sm text-gray-500">beta v251215 ¬©hoopoe holdings</p>
                    </div>

                    <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                        <div className="flex items-center justify-between mb-2">
                            <button
                                onClick={() => setIsChartStatusCollapsed(!isChartStatusCollapsed)}
                                className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700"
                            >
                                <span>{isChartStatusCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                <h3>Equivalence Chart Status</h3>
                            </button>
                            {chartLoadStatus === 'loaded' && (
                                <span className="text-sm text-patina">
                                    ‚úÖ {equivalenceChart?.glyphs?.length || 0} glyphs
                                </span>
                            )}
                        </div>
                        
                        {!isChartStatusCollapsed && (
                            <div>
                                <div className="flex items-center gap-2 mt-1">
                                    {chartLoadStatus === 'loading' && (
                                        <div className="flex-1">
                                            <div className="flex items-center gap-2 mb-2">
                                                <span className="text-stone-dark">
                                                    Loading {equivalenceChart?.glyphs?.length || '...'} glyphs...
                                                    {imageLoadingProgress.total > 0 && (
                                                        <span className="ml-2">({imageLoadingProgress.loaded}/{imageLoadingProgress.total} images)</span>
                                                    )}
                                                </span>
                                            </div>
                                            {imageLoadingProgress.total > 0 && (
                                                <div className="w-full bg-gray-200 rounded-full h-2.5">
                                                    <div 
                                                        className="bg-stone-dark h-2.5 rounded-full transition-all duration-300" 
                                                        style={{width: `${(imageLoadingProgress.loaded / imageLoadingProgress.total * 100).toFixed(1)}%`}}
                                                    ></div>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                    {chartLoadStatus === 'loaded' && (
                                        <span className="text-patina">
                                            ‚úÖ Loaded {equivalenceChart?.glyphs?.length || 0} glyphs, {Object.keys(loadedGlyphImages).length} images
                                        </span>
                                    )}
                                    {chartLoadStatus === 'error' && <span className="text-rust">‚ùå Error loading chart</span>}
                                </div>
                                <div className="flex gap-2 mt-3">
                                    <button 
                                        onClick={() => setShowChartViewer(true)} 
                                        className="px-4 py-2 bg-ancient-purple text-white rounded hover:bg-[#4a3e54]" 
                                        disabled={chartLoadStatus !== 'loaded'}
                                    >
                                        üìä View Chart
                                    </button>
                                    <button 
                                        onClick={() => setChartLoadStatus('not-loaded')} 
                                        className="px-4 py-2 bg-stone text-white rounded hover:bg-stone-dark" 
                                        disabled={chartLoadStatus === 'loading'}
                                    >
                                        üîÑ Reload Chart
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Upload Section - Collapsible */}
                    {!image ? (
                        <div className="mb-6">
                            {/* Chart Loading Notice */}
                            {chartLoadStatus !== 'loaded' && (
                                <div className="mb-4 p-4 bg-amber-50 border-2 border-amber-300 rounded-lg">
                                    <div className="flex items-start gap-3">
                                        <div className="text-2xl">‚è≥</div>
                                        <div className="flex-1">
                                            <div className="font-semibold text-amber-900 mb-1">Loading Glyph Recognition Chart...</div>
                                            <div className="text-sm text-amber-800 mb-3">
                                                Please wait a moment while the Hakli glyph database loads. 
                                                You'll be able to upload images once it's ready.
                                            </div>
                                            
                                            {/* Progress Bar */}
                                            <div>
                                                <div className="flex justify-between text-xs text-amber-700 mb-1">
                                                    <span>Loading glyph images...</span>
                                                    <span className="font-mono font-semibold">
                                                        {imageLoadingProgress.total > 0 
                                                            ? `${imageLoadingProgress.loaded}/${imageLoadingProgress.total}`
                                                            : 'Preparing...'
                                                        }
                                                    </span>
                                                </div>
                                                <div className="w-full bg-amber-200 rounded-full h-3 overflow-hidden">
                                                    <div 
                                                        className="bg-amber-600 h-3 transition-all duration-300 ease-out"
                                                        style={{width: imageLoadingProgress.total > 0 
                                                            ? `${(imageLoadingProgress.loaded / imageLoadingProgress.total) * 100}%`
                                                            : '0%'
                                                        }}
                                                    />
                                                </div>
                                                {imageLoadingProgress.total > 0 && (
                                                    <div className="text-xs text-amber-600 mt-1 text-center font-medium">
                                                        {Math.round((imageLoadingProgress.loaded / imageLoadingProgress.total) * 100)}%
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                            
                            <div 
                                className={`p-6 rounded-lg border-2 border-dashed ${!equivalenceChart ? 'border-gray-300 bg-gray-100 opacity-50 cursor-not-allowed' : 'border-gray-400 bg-gray-50'} transition-colors`}
                                onDragOver={(e) => {
                                    if (!equivalenceChart) return;
                                    e.preventDefault();
                                    e.currentTarget.style.backgroundColor = '#e5e7eb';
                                    e.currentTarget.style.borderColor = '#8b7d6b';
                                }}
                                onDragLeave={(e) => {
                                    if (!equivalenceChart) return;
                                    e.currentTarget.style.backgroundColor = '#f9fafb';
                                    e.currentTarget.style.borderColor = '#9ca3af';
                                }}
                                onDrop={(e) => {
                                    if (!equivalenceChart) return;
                                    e.preventDefault();
                                    e.currentTarget.style.backgroundColor = '#f9fafb';
                                    e.currentTarget.style.borderColor = '#9ca3af';
                                    
                                    const file = e.dataTransfer.files[0];
                                    if (file && file.type.indexOf('image/') === 0) {
                                        // Manually trigger the file upload handler
                                        const fakeEvent = { target: { files: [file] } };
                                        handleFileUpload(fakeEvent);
                                    }
                                }}
                            >
                                <div className="text-center">
                                    <div className="text-5xl mb-3">üì∏</div>
                                    <label className="block text-base font-semibold text-gray-800 mb-2">
                                        Upload Inscription Image
                                    </label>
                                    
                                    {/* Hidden file input */}
                                    <input 
                                        id="fileUploadInput"
                                        type="file" 
                                        accept="image/*" 
                                        onChange={handleFileUpload} 
                                        disabled={isImageLoading}
                                        style={{display: 'none'}}
                                    />
                                    
                                    <div className="space-y-2">
                                        <p className="text-sm text-gray-600 font-medium">
                                            Drag & drop your image here
                                        </p>
                                        <p className="text-xs text-gray-500">or</p>
                                        <button
                                            onClick={() => document.getElementById('fileUploadInput').click()}
                                            disabled={isImageLoading || !equivalenceChart}
                                            className="px-4 py-2 bg-stone text-white rounded-lg hover:bg-stone-dark disabled:bg-gray-400 disabled:cursor-not-allowed font-medium text-sm transition-colors"
                                            title={!equivalenceChart ? "‚è≥ Please wait for the glyph chart to load..." : "Select an inscription image"}
                                        >
                                            {isImageLoading ? 'Loading...' : 'Browse Files'}
                                        </button>
                                        
                                        <div className="pt-3 mt-3 border-t border-gray-300">
                                            <p className="text-xs text-gray-500 mb-2">or load a saved session:</p>
                                            <button
                                                onClick={async () => {
                                                    if (typeof DriveSync === 'undefined' || !DriveSync.isSignedIn()) {
                                                        alert('‚ö†Ô∏è Please sign in to Google Drive first.\n\n1. Click OK to close this message\n2. Click the "üîê Sign in with Google" button that appears\n3. After signing in, click "Load from Google Drive" again');
                                                        setShowCloudSyncModal(true);
                                                        return;
                                                    }
                                                    
                                                    try {
                                                        const files = await DriveSync.listFiles();
                                                        console.log('Drive files:', files);
                                                        
                                                        if (files.length === 0) {
                                                            alert('üìÇ No HKI files found in your Hakli_Inscriptions folder.\n\nSave an inscription first to create HKI files.');
                                                            return;
                                                        }
                                                        
                                                        // Load all file thumbnails
                                                        setShowFilePickerModal({ files, isLoading: true });
                                                        
                                                        const filesWithThumbnails = await Promise.all(
                                                            files.map(async (file) => {
                                                                try {
                                                                    const hkiData = await DriveSync.loadFromCloud(file.id);
                                                                    return {
                                                                        ...file,
                                                                        thumbnail: hkiData.image || null,
                                                                        title: hkiData.inscriptionTitle || file.name,
                                                                        location: hkiData.location || null
                                                                    };
                                                                } catch (err) {
                                                                    console.error(`Failed to load thumbnail for ${file.name}:`, err);
                                                                    return { ...file, thumbnail: null, title: file.name, location: null };
                                                                }
                                                            })
                                                        );
                                                        
                                                        setShowFilePickerModal({ files: filesWithThumbnails, isLoading: false });
                                                    } catch (err) {
                                                        console.error('Load error:', err);
                                                        alert('‚ùå Load failed: ' + err.message);
                                                    }
                                                }}
                                                disabled={!equivalenceChart}
                                                className="px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5a7968] disabled:bg-gray-400 disabled:cursor-not-allowed font-medium text-sm transition-colors"
                                                title={!equivalenceChart ? "‚è≥ Please wait for the glyph chart to load..." : "Load a saved inscription from Google Drive"}
                                            >
                                                ‚òÅÔ∏è Load from Google Drive
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            {isImageLoading && (
                                <div className="mt-2 flex items-center gap-2 text-stone-dark">
                                    <div className="w-4 h-4 border-2 border-stone-dark border-t-transparent rounded-full animate-spin"></div>
                                    <span className="text-sm font-medium">Loading image...</span>
                                </div>
                            )}
                        </div>
                    ) : (
                        <div className="mb-6 p-3 bg-[#f0f5f3] border border-[#b5d4c8] rounded-lg flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <span className="text-patina">‚úì</span>
                                <span className="text-sm font-medium text-gray-700">Image loaded</span>
                            </div>
                            <button
                                onClick={() => {
                                    setImage(null);
                                    setOriginalMat(null);
                                    setPreprocessedMat(null);
                                    setRecognitionResults([]);
                                    setDisplayImage(null);
                                }}
                                className="px-3 py-1 text-xs bg-stone text-white rounded hover:bg-stone-dark"
                            >
                                üì§ Upload Different Image
                            </button>
                        </div>
                    )}

                    {/* Preprocessing Panel */}
                    {image && originalMat && (
                        <div className="mb-6 border-2 border-gray-300 rounded-lg bg-gray-50">
                            <div 
                                className="p-4 bg-gray-200 cursor-pointer flex justify-between items-center rounded-t-lg hover:bg-gray-300"
                                onClick={() => setIsPreprocessingCollapsed(!isPreprocessingCollapsed)}
                            >
                                <h3 className="font-semibold text-gray-900 text-lg">
                                    {isPreprocessingCollapsed ? '‚ñ∂' : '‚ñº'} Image Preprocessing
                                    {isPreprocessingCollapsed && preprocessing.useAdaptiveThreshold && (
                                        <span className="text-sm text-stone-dark ml-2">(Active)</span>
                                    )}
                                </h3>
                                <div className="flex gap-2" onClick={(e) => e.stopPropagation()}>
                                    <button 
                                        onClick={resetPreprocessing}
                                        className="px-3 py-1 text-sm bg-white border border-gray-300 rounded hover:bg-gray-100"
                                    >
                                        Reset
                                    </button>
                                    <button 
                                        onClick={exportPreprocessingSettings}
                                        className="px-3 py-1 text-sm bg-white border border-gray-300 rounded hover:bg-gray-100"
                                    >
                                        Export
                                    </button>
                                </div>
                            </div>
                            
                            {/* Compact status bar when collapsed */}
                            {isPreprocessingCollapsed && (preprocessing.useAdaptiveThreshold || preprocessing.gaussianBlur > 0 || preprocessing.rotation !== 0 || preprocessing.morphologyOperation !== 'none' || preprocessing.invertColors) && (
                                <div className="px-4 py-2 bg-[#f5f3f0] border-t border-stone-light flex items-center justify-between">
                                    <div className="text-sm text-stone-dark">
                                        <span className="font-medium">Active: </span>
                                        {preprocessing.gaussianBlur > 0 && <span className="mr-2">Blur:{preprocessing.gaussianBlur}</span>}
                                        {preprocessing.useAdaptiveThreshold && <span className="mr-2">Threshold</span>}
                                        {preprocessing.rotation !== 0 && <span className="mr-2">Rot:{preprocessing.rotation}¬∞</span>}
                                        {preprocessing.morphologyOperation !== 'none' && <span className="mr-2">{preprocessing.morphologyOperation}</span>}
                                        {preprocessing.invertColors && <span className="mr-2">Inverted</span>}
                                    </div>
                                    <button
                                        onClick={applyAdjustments}
                                        disabled={!preprocessedMat}
                                        className={`px-4 py-1 text-sm rounded font-medium ${adjustmentsApplied ? 'bg-patina text-white' : 'bg-ochre text-white animate-pulse'}`}
                                    >
                                        {adjustmentsApplied ? '‚úì Applied' : '‚ö° Apply'}
                                    </button>
                                </div>
                            )}
                            
                            {!isPreprocessingCollapsed && (
                                <div className="p-5">
                                    {/* Preview Canvases */}
                                    {showPreprocessPreview && (
                                        <div className="mb-5 border border-gray-300 rounded-lg p-4 bg-white">
                                            <div className="flex justify-between items-center mb-3">
                                                <span className="font-semibold text-sm">Image Comparison</span>
                                                <button 
                                                    onClick={() => setShowPreprocessPreview(false)}
                                                    className="px-2 py-1 text-xs bg-gray-100 border border-gray-300 rounded hover:bg-gray-200"
                                                >
                                                    Hide Preview
                                                </button>
                                            </div>
                                            <div className="flex gap-5 justify-center flex-wrap">
                                                <div className="flex-1 min-w-[300px] max-w-[500px]">
                                                    <div className="font-semibold text-sm text-gray-600 mb-2">Original</div>
                                                    <canvas ref={originalCanvasRef} className="max-w-full border-2 border-gray-300 rounded bg-gray-100" style={{minHeight: '200px'}} />
                                                </div>
                                                <div className="flex-1 min-w-[300px] max-w-[500px]">
                                                    <div className="font-semibold text-sm text-gray-600 mb-2">Preprocessed</div>
                                                    <canvas ref={preprocessCanvasRef} className="max-w-full border-2 border-gray-300 rounded bg-gray-100" style={{minHeight: '200px'}} />
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    {!showPreprocessPreview && (
                                        <button 
                                            onClick={() => setShowPreprocessPreview(true)}
                                            className="mb-5 px-4 py-2 text-sm bg-patina text-white rounded hover:bg-[#5d7a6d]"
                                        >
                                            Show Preview
                                        </button>
                                    )}
                                    
                                    {!showPreprocessPreview && recognitionResults.length === 0 && (
                                        <div className="mb-4 p-3 bg-gray-50 border border-gray-300 rounded text-xs text-gray-600 text-center">
                                            üí° Tip: Scroll down to <strong>Controls & Options</strong> section to see the preprocessed image and run recognition
                                        </div>
                                    )}
                                    
                                    {/* Rotation Control */}
                                    <div className="mb-3 bg-white rounded-lg border border-gray-200 overflow-hidden">
                                        <div 
                                            className="p-3 flex items-center justify-between cursor-pointer hover:bg-gray-50"
                                            onClick={() => setIsRotationCollapsed(!isRotationCollapsed)}
                                        >
                                            <span className="font-semibold">
                                                {isRotationCollapsed ? '‚ñ∂' : '‚ñº'} Rotation: {preprocessing.rotation}¬∞
                                            </span>
                                            <div className="flex gap-2">
                                                {preprocessing.rotation !== 0 && recognitionResults.length > 0 && (
                                                    <span className="text-xs bg-[#f5e8e4] text-rust px-2 py-1 rounded">‚ö†Ô∏è Boxes won't move</span>
                                                )}
                                                {preprocessing.rotation !== 0 && (
                                                    <span className="text-xs bg-stone-light text-stone-dark px-2 py-1 rounded">Active</span>
                                                )}
                                            </div>
                                        </div>
                                        {!isRotationCollapsed && (
                                            <div className="p-4 pt-0">
                                                <input
                                                    type="range"
                                                    min="-180"
                                                    max="180"
                                                    value={preprocessing.rotation}
                                                    onChange={(e) => {
                                                        const newRotation = parseFloat(e.target.value);
                                                        if (recognitionResults.length > 0 && newRotation !== preprocessing.rotation) {
                                                            if (!confirm('‚ö†Ô∏è Warning: Rotating after recognition will not move detection boxes.\n\nThe boxes will stay in their original positions. You\'ll need to:\n1. Clear all detections\n2. Apply rotation\n3. Run recognition again\n\nContinue with rotation?')) {
                                                                return;
                                                            }
                                                        }
                                                        updatePreprocessingSetting('rotation', newRotation);
                                                    }}
                                                    className="w-full mb-2"
                                                />
                                                <div className="flex gap-2">
                                                    <button 
                                                        onClick={() => {
                                                            if (recognitionResults.length > 0) {
                                                                if (!confirm('‚ö†Ô∏è Warning: Rotating after recognition will not move detection boxes.\n\nThe boxes will stay in their original positions. You\'ll need to:\n1. Clear all detections\n2. Apply rotation\n3. Run recognition again\n\nContinue with rotation?')) {
                                                                    return;
                                                                }
                                                            }
                                                            updatePreprocessingSetting('rotation', preprocessing.rotation - 90);
                                                        }} 
                                                        className="flex-1 px-3 py-2 text-sm bg-white border border-gray-300 rounded hover:bg-gray-100"
                                                    >
                                                        -90¬∞
                                                    </button>
                                                    <button 
                                                        onClick={() => updatePreprocessingSetting('rotation', 0)} 
                                                        className="flex-1 px-3 py-2 text-sm bg-white border border-gray-300 rounded hover:bg-gray-100"
                                                    >
                                                        0¬∞
                                                    </button>
                                                    <button 
                                                        onClick={() => {
                                                            if (recognitionResults.length > 0) {
                                                                if (!confirm('‚ö†Ô∏è Warning: Rotating after recognition will not move detection boxes.\n\nThe boxes will stay in their original positions. You\'ll need to:\n1. Clear all detections\n2. Apply rotation\n3. Run recognition again\n\nContinue with rotation?')) {
                                                                    return;
                                                                }
                                                            }
                                                            updatePreprocessingSetting('rotation', preprocessing.rotation + 90);
                                                        }} 
                                                        className="flex-1 px-3 py-2 text-sm bg-white border border-gray-300 rounded hover:bg-gray-100"
                                                    >
                                                        +90¬∞
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Gaussian Blur */}
                                    <div className="mb-3 bg-white rounded-lg border border-gray-200 overflow-hidden">
                                        <div className="p-3 flex items-center justify-between">
                                            <label className="font-semibold flex items-center cursor-pointer hover:bg-gray-50">
                                                <span 
                                                    className="mr-2 cursor-pointer px-1"
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        setIsBlurCollapsed(!isBlurCollapsed);
                                                    }}
                                                >
                                                    {isBlurCollapsed ? '‚ñ∂' : '‚ñº'}
                                                </span>
                                                <input
                                                    type="checkbox"
                                                    checked={preprocessing.gaussianBlur > 0}
                                                    onChange={(e) => updatePreprocessingSetting('gaussianBlur', e.target.checked ? 5 : 0)}
                                                    className="mr-2"
                                                />
                                                Gaussian Blur {preprocessing.gaussianBlur > 0 ? `(${preprocessing.gaussianBlur}√ó${preprocessing.gaussianBlur})` : ''}
                                            </label>
                                            {preprocessing.gaussianBlur > 0 && (
                                                <span className="text-xs bg-stone-light text-stone-dark px-2 py-1 rounded">Active</span>
                                            )}
                                        </div>
                                        {!isBlurCollapsed && preprocessing.gaussianBlur > 0 && (
                                            <div className="p-4 pt-0">
                                                <select
                                                    value={preprocessing.gaussianBlur}
                                                    onChange={(e) => updatePreprocessingSetting('gaussianBlur', parseInt(e.target.value))}
                                                    className="w-full p-2 text-sm border border-gray-300 rounded"
                                                >
                                                    <option value="3">Light (3√ó3)</option>
                                                    <option value="5">Medium (5√ó5)</option>
                                                    <option value="7">Strong (7√ó7)</option>
                                                    <option value="9">Very Strong (9√ó9)</option>
                                                </select>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Adaptive Threshold */}
                                    <div className="mb-3 bg-white rounded-lg border border-gray-200 overflow-hidden">
                                        <div className="p-3 flex items-center justify-between">
                                            <label className="font-semibold flex items-center cursor-pointer hover:bg-gray-50">
                                                <span 
                                                    className="mr-2 cursor-pointer px-1"
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        setIsThresholdCollapsed(!isThresholdCollapsed);
                                                    }}
                                                >
                                                    {isThresholdCollapsed ? '‚ñ∂' : '‚ñº'}
                                                </span>
                                                <input
                                                    type="checkbox"
                                                    checked={preprocessing.useAdaptiveThreshold}
                                                    onChange={(e) => updatePreprocessingSetting('useAdaptiveThreshold', e.target.checked)}
                                                    className="mr-2"
                                                />
                                                Adaptive Threshold {preprocessing.useAdaptiveThreshold ? `(${preprocessing.blockSize}/${preprocessing.constantOffset})` : ''}
                                            </label>
                                            {preprocessing.useAdaptiveThreshold && (
                                                <span className="text-xs bg-stone-light text-stone-dark px-2 py-1 rounded">Active</span>
                                            )}
                                        </div>
                                        {!isThresholdCollapsed && preprocessing.useAdaptiveThreshold && (
                                            <div className="p-4 pt-0">
                                                <label className="block font-semibold text-sm text-gray-700 mb-1">
                                                    Block Size: {preprocessing.blockSize}
                                                    <span className="font-normal text-xs text-gray-500 ml-2">(larger = smoother)</span>
                                                </label>
                                                <input
                                                    type="range"
                                                    min="3"
                                                    max="99"
                                                    step="2"
                                                    value={preprocessing.blockSize}
                                                    onChange={(e) => updatePreprocessingSetting('blockSize', parseInt(e.target.value))}
                                                    className="w-full mb-3"
                                                />

                                                <label className="block font-semibold text-sm text-gray-700 mb-1">
                                                    Constant Offset: {preprocessing.constantOffset}
                                                    <span className="font-normal text-xs text-gray-500 ml-2">(higher = more white)</span>
                                                </label>
                                                <input
                                                    type="range"
                                                    min="-20"
                                                    max="20"
                                                    value={preprocessing.constantOffset}
                                                    onChange={(e) => updatePreprocessingSetting('constantOffset', parseInt(e.target.value))}
                                                    className="w-full"
                                                />
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Invert Colors */}
                                    <div className="mb-3 bg-white rounded-lg border border-gray-200 overflow-hidden">
                                        <div className="p-3 flex items-center justify-between">
                                            <label className="font-semibold flex items-center cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={preprocessing.invertColors}
                                                    onChange={(e) => updatePreprocessingSetting('invertColors', e.target.checked)}
                                                    className="mr-2"
                                                />
                                                Invert Colors
                                                <span className="font-normal text-xs text-gray-500 ml-2">(light on dark)</span>
                                            </label>
                                            {preprocessing.invertColors && (
                                                <span className="text-xs bg-stone-light text-stone-dark px-2 py-1 rounded">Active</span>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {/* Morphology */}
                                    <div className="mb-3 bg-white rounded-lg border border-gray-200 overflow-hidden">
                                        <div 
                                            className="p-3 flex items-center justify-between cursor-pointer hover:bg-gray-50"
                                            onClick={() => setIsMorphCollapsed(!isMorphCollapsed)}
                                        >
                                            <span className="font-semibold">
                                                {isMorphCollapsed ? '‚ñ∂' : '‚ñº'} Morphology {preprocessing.morphologyOperation !== 'none' ? `(${preprocessing.morphologyOperation})` : ''}
                                            </span>
                                            {preprocessing.morphologyOperation !== 'none' && (
                                                <span className="text-xs bg-stone-light text-stone-dark px-2 py-1 rounded">Active</span>
                                            )}
                                        </div>
                                        {!isMorphCollapsed && (
                                            <div className="p-4 pt-0">
                                                <select
                                                    value={preprocessing.morphologyOperation}
                                                    onChange={(e) => updatePreprocessingSetting('morphologyOperation', e.target.value)}
                                                    className="w-full p-2 text-sm border border-gray-300 rounded"
                                                >
                                                    <option value="none">None</option>
                                                    <option value="close">Close (fill small gaps)</option>
                                                    <option value="open">Open (remove small noise)</option>
                                                    <option value="both">Both (clean thoroughly)</option>
                                                </select>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Manual Eraser */}
                                    <div className="mb-5 p-4 bg-white rounded-lg border border-gray-200">
                                        <label className="block font-semibold mb-3">
                                            üñåÔ∏è Manual Eraser
                                            <span className="font-normal text-xs text-gray-500 ml-2">(remove noise manually)</span>
                                        </label>
                                        
                                        {!eraserMode ? (
                                            <button
                                                onClick={toggleEraserMode}
                                                disabled={!preprocessedMat}
                                                className="w-full px-4 py-3 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3e54] disabled:opacity-50 disabled:cursor-not-allowed font-semibold transition-colors"
                                            >
                                                üñåÔ∏è Enable Eraser Mode
                                            </button>
                                        ) : (
                                            <div>
                                                {/* Eraser Canvas */}
                                                <div className="mb-3 border-2 border-ancient-purple rounded-lg overflow-hidden bg-gray-100">
                                                    <canvas
                                                        ref={eraserCanvasRef}
                                                        onMouseDown={handleEraserMouseDown}
                                                        onMouseMove={handleEraserMouseMove}
                                                        onMouseUp={handleEraserMouseUp}
                                                        onMouseLeave={handleEraserMouseUp}
                                                        onTouchStart={handleEraserTouchStart}
                                                        onTouchMove={handleEraserTouchMove}
                                                        onTouchEnd={handleEraserTouchEnd}
                                                        onTouchCancel={handleEraserTouchEnd}
                                                        className="max-w-full"
                                                        style={{
                                                            cursor: eraserCursorStyle,
                                                            touchAction: 'none' // Prevent default touch behaviors
                                                        }}
                                                    />
                                                </div>
                                                
                                                {/* Brush Size Control */}
                                                <div className="mb-3">
                                                    <label className="block text-sm font-semibold mb-2">
                                                        Brush Size: {brushSize}px
                                                    </label>
                                                    <input
                                                        type="range"
                                                        min="5"
                                                        max="50"
                                                        value={brushSize}
                                                        onChange={(e) => setBrushSize(parseInt(e.target.value))}
                                                        className="w-full"
                                                    />
                                                    <div className="flex justify-between text-xs text-gray-500 mt-1">
                                                        <span>Fine (5px)</span>
                                                        <span>Large (50px)</span>
                                                    </div>
                                                </div>
                                                
                                                {/* Eraser Controls */}
                                                <div className="flex gap-2 mb-2">
                                                    <button
                                                        onClick={undoLastStroke}
                                                        disabled={eraserHistory.length <= 1}
                                                        className="flex-1 px-3 py-2 bg-stone text-white rounded hover:bg-stone-dark disabled:opacity-50 disabled:cursor-not-allowed text-sm font-semibold"
                                                        title="Undo last stroke"
                                                    >
                                                        ‚Ü∂ Undo
                                                    </button>
                                                    <button
                                                        onClick={clearAllEraser}
                                                        className="flex-1 px-3 py-2 bg-ochre text-white rounded hover:bg-[#a18259] text-sm font-semibold"
                                                        title="Clear all strokes"
                                                    >
                                                        üîÑ Reset
                                                    </button>
                                                </div>
                                                <div className="flex gap-2">
                                                    <button
                                                        onClick={toggleEraserMode}
                                                        className="w-full px-3 py-2 bg-patina text-white rounded hover:bg-[#5d7a6d] text-sm font-semibold"
                                                    >
                                                        ‚úì Done Erasing
                                                    </button>
                                                </div>
                                                
                                                <p className="mt-2 text-xs text-gray-600">
                                                    Click and drag to erase noise. Use Undo to remove last stroke. Click "Done" when finished.
                                                </p>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Summary */}
                                    <div className="p-4 bg-[#f5f3f0] border border-stone-light rounded-lg">
                                        <strong className="block mb-2">Active Settings:</strong>
                                        <ul className="list-disc ml-5 text-sm">
                                            {preprocessing.rotation !== 0 && <li>Rotation: {preprocessing.rotation}¬∞</li>}
                                            {preprocessing.gaussianBlur > 0 && <li>Gaussian Blur: {preprocessing.gaussianBlur}√ó{preprocessing.gaussianBlur}</li>}
                                            {preprocessing.useAdaptiveThreshold && <li>Adaptive Threshold (Block: {preprocessing.blockSize}, Offset: {preprocessing.constantOffset})</li>}
                                            {preprocessing.invertColors && <li>Colors Inverted</li>}
                                            {preprocessing.morphologyOperation !== 'none' && <li>Morphology: {preprocessing.morphologyOperation}</li>}
                                            {preprocessing.rotation === 0 && !preprocessing.useAdaptiveThreshold && preprocessing.gaussianBlur === 0 && preprocessing.morphologyOperation === 'none' && !preprocessing.invertColors && (
                                                <li className="italic text-gray-600">No preprocessing active</li>
                                            )}
                                        </ul>
                                    </div>
                                    
                                    {/* Apply Adjustments Button */}
                                    <div className="mt-4 p-4 bg-white border-2 rounded-lg" style={{borderColor: adjustmentsApplied ? '#6b8e7f' : '#b8956a'}}>
                                        <div className="flex items-center justify-between">
                                            <div className="flex items-center gap-3">
                                                {adjustmentsApplied ? (
                                                    <>
                                                        <div className="w-3 h-3 bg-patina rounded-full"></div>
                                                        <span className="font-semibold text-patina">‚úì Adjustments Applied</span>
                                                    </>
                                                ) : (
                                                    <>
                                                        <div className="w-3 h-3 bg-ochre rounded-full animate-pulse"></div>
                                                        <span className="font-semibold text-amber-700">Adjustments Ready</span>
                                                    </>
                                                )}
                                            </div>
                                            <button
                                                onClick={applyAdjustments}
                                                disabled={!preprocessedMat}
                                                className="px-6 py-2 bg-stone text-white rounded-lg hover:bg-stone-dark disabled:opacity-50 disabled:cursor-not-allowed font-semibold transition-colors"
                                            >
                                                {adjustmentsApplied ? 'üîÑ Reapply Adjustments' : '‚ú® Apply Adjustments'}
                                            </button>
                                        </div>
                                        <p className="mt-2 text-xs text-gray-600">
                                            {adjustmentsApplied 
                                                ? 'The preprocessed image is ready for recognition. Click "Recognize Glyphs" below.'
                                                : 'Click "Apply Adjustments" to update the main image with your preprocessing settings before recognition.'}
                                        </p>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                            <button
                                onClick={() => setIsViewModeCollapsed(!isViewModeCollapsed)}
                                className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700 mb-3 w-full text-left"
                            >
                                <span>{isViewModeCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                <h3>View Mode</h3>
                            </button>
                            
                            {!isViewModeCollapsed && (
                            <>
                            <div className="flex items-center justify-between mb-4">
                                <div className="flex gap-2">
                                    <button 
                                        onClick={() => setViewMode('detection')}
                                        className={`px-4 py-2 rounded font-medium ${viewMode === 'detection' ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        üì∑ Detection View
                                    </button>
                                    <button 
                                        onClick={() => {
                                            setViewMode('reading');
                                            if (readingOrder.length === 0) {
                                                setReadingOrder(recognitionResults.map((_, idx) => idx));
                                            }
                                            // Auto-detect reading direction if still in detection mode
                                            if (readingDirection === 'detection') {
                                                autoDetectReadingOrder();
                                            }
                                        }}
                                        className={`px-4 py-2 rounded font-medium ${viewMode === 'reading' ? 'bg-patina text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        üìñ Reading Order View
                                    </button>
                                    <button 
                                        onClick={() => setShowArabicLabels(!showArabicLabels)}
                                        className={`px-4 py-2 rounded font-medium ${showArabicLabels ? 'bg-ancient-purple text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                        title={showArabicLabels ? 'Showing Arabic labels' : 'Showing English labels'}
                                    >
                                        {showArabicLabels ? 'üî§ Arabic' : 'ABC English'}
                                    </button>
                                </div>
                            </div>
                            
                            {viewMode === 'reading' && !showTranscription && (
                                        <button 
                                            onClick={() => setShowTranscription(true)}
                                            className="px-4 py-2 rounded font-medium bg-stone text-white hover:bg-stone-dark"
                                            title="Show transcription box"
                                        >
                                            üìù Show Transcription
                                        </button>
                                    )}
                            
                            {viewMode === 'reading' && (
                                <div className="pt-4 border-t border-gray-300">
                                    <div className="flex items-center justify-between">
                                        <span className="text-sm font-medium text-gray-700">Reading Direction:</span>
                                        <div className="flex gap-2">
                                            <button 
                                                onClick={() => {
                                                    const detected = autoDetectReadingOrder();
                                                    if (detected) {
                                                        alert(`üîÆ Auto-detected: ${detected.toUpperCase()}\n\nReading order has been generated based on glyph positions.`);
                                                    }
                                                }}
                                                className="px-3 py-1 text-sm rounded bg-ancient-purple text-white hover:bg-[#4a3e54]"
                                                title="Auto-detect reading direction based on glyph positions"
                                            >
                                                üîÆ Auto
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('detection')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'detection' ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Original detection order"
                                            >
                                                üî¢ Detection Order
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('ltr')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'ltr' ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Left to Right"
                                            >
                                                ‚Üí LTR
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('rtl')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'rtl' ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Right to Left"
                                            >
                                                ‚Üê RTL
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('ttb')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'ttb' ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Top to Bottom"
                                            >
                                                ‚Üì TTB
                                            </button>
                                        </div>
                                    </div>
                                    {!dismissedTips['reading-order'] && (
                                        <DismissableTip id="reading-order" className="mt-3">
                                            <strong>üí° Tip:</strong> In Reading Order View, drag cards to reorder. Use üîÆ Auto to detect direction from glyph positions.
                                        </DismissableTip>
                                    )}
                                </div>
                            )}
                            
                            {viewMode === 'detection' && (
                                <div className="pt-4 border-t border-gray-300">
                                    <div className="p-3 bg-gray-100 border border-gray-300 rounded text-sm text-gray-700">
                                        üì∑ Detection View shows glyphs in the order they were detected (left-to-right on the image). Use this mode for validation and editing.
                                    </div>
                                </div>
                            )}
                            </>
                            )}
                        </div>
                    )}


                    {image && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <div className="flex items-center justify-between mb-3">
                                <button
                                    onClick={() => setIsControlsCollapsed(!isControlsCollapsed)}
                                    className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700"
                                >
                                    <span>{isControlsCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                    <h3>Controls & Options</h3>
                                </button>
                                
                                {isControlsCollapsed && (
                                    <button 
                                        onClick={recognizeGlyphs} 
                                        disabled={isProcessing || !equivalenceChart} 
                                        className="px-6 py-2 bg-patina text-white rounded hover:bg-[#5d7a6d] disabled:opacity-50 font-semibold"
                                    >
                                        {isProcessing ? 'Processing...' : 'üîç Recognize Glyphs'}
                                    </button>
                                )}
                            </div>
                            
                            {!isControlsCollapsed && (
                                <>
                                <div className="flex flex-wrap gap-3 items-center mb-4">
                                <button onClick={recognizeGlyphs} disabled={isProcessing || !equivalenceChart} className="px-6 py-2 bg-patina text-white rounded hover:bg-[#5d7a6d] disabled:opacity-50">
                                    {isProcessing ? 'Processing...' : 'Recognize Glyphs'}
                                </button>
                                {/* üëá ADD THIS PROGRESS BAR */}
                                {isProcessing && processingProgress.total > 0 && (
                                    <div className="mt-3 p-3 bg-[#f5f3f0] rounded border border-stone-light">
                                        <div className="flex items-center justify-between mb-2">
                                            <span className="text-sm font-medium text-gray-700">
                                                Processing region {processingProgress.current} of {processingProgress.total}
                                            </span>
                                            <span className="text-sm text-gray-600">
                                                {Math.round((processingProgress.current / processingProgress.total) * 100)}%
                                            </span>
                                        </div>
                                        <div className="w-full bg-gray-200 rounded-full h-2.5">
                                            <div
                                                className="bg-stone-dark h-2.5 rounded-full transition-all duration-300"
                                                style={{ width: ((processingProgress.current / processingProgress.total) * 100) + '%' }}
                                            />
                                        </div>
                                    </div>
                                )}

                                <button onClick={() => setManualDetectionMode(!manualDetectionMode)} className={`px-4 py-2 rounded ${manualDetectionMode ? 'bg-orange-500 text-white hover:bg-orange-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>
                                    {manualDetectionMode ? 'Exit Manual Mode' : 'Manual Detection'}
                                </button>
                                
                                <button
                                    onClick={() => setTemplateTrainingMode(!templateTrainingMode)}
                                    className={`px-4 py-2 rounded ${templateTrainingMode ? 'bg-[#4a3e54] text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                >
                                    {templateTrainingMode ? 'üéì Exit Template Training' : 'üéì Template Training Mode'}
                                </button>

                                {templateTrainingMode && (
                                    <div className="mt-4 p-4 bg-[#f3f1f4] border-2 border-ancient-purple rounded-lg">
                                        <h4 className="font-semibold text-ancient-purple mb-2">üéì Template Training Mode Active</h4>
                                        <p className="text-sm text-ancient-purple mb-3">
                                            Click any detection below to save it as a template image. Good templates improve future recognition accuracy!
                                        </p>
                                        <div className="text-xs text-ancient-purple space-y-1">
                                            <div>‚Ä¢ <strong>Primary:</strong> The main reference image (replaces existing)</div>
                                            <div>‚Ä¢ <strong>Variant:</strong> Alternative style of the same glyph (adds to collection)</div>
                                            <div>‚Ä¢ <strong>Example:</strong> Additional training data (adds to collection)</div>
                                            <div> then replace Hakli_glyphs.JSON </div>
                                        </div>
                                        {equivalenceChart && (
                                            <div className="mt-3 flex gap-2">
                                                <button
                                                    onClick={exportUpdatedChart}
                                                    className="px-4 py-2 bg-[#4a3e54] text-white rounded hover:bg-purple-700 text-sm"
                                                >
                                                    üíæ Export Training Chart
                                                </button>
                                                <button
                                                    onClick={() => window.open('merge_hakli_training_glyphs.html', '_blank')}
                                                    className="px-4 py-2 bg-stone-dark text-white rounded hover:bg-stone-dark text-sm"
                                                    title="Open the tool to merge training file with base Hakli_glyphs.JSON"
                                                >
                                                    üîÄ Merge Training File
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                )}
                                                            
                                <button onClick={() => setShowRegionBoundaries(!showRegionBoundaries)} className={`px-4 py-2 rounded ${showRegionBoundaries ? 'bg-ancient-purple text-white hover:bg-[#4a3e54]' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>
                                    Region Boundaries
                                </button>
                                <button
                                    onClick={() => {
                                        if (confirm('üóëÔ∏è Clear all detections and start over?\n\nThis will remove:\n‚Ä¢ All detected glyphs\n‚Ä¢ All validations\n‚Ä¢ Manual selections\n‚Ä¢ Reading order\n\nThis cannot be undone!')) {
                                            setRecognitionResults([]);
                                            setValidations({});
                                            setSelectedRegions(new Set());
                                            setIsolatedGlyphs([]);
                                            setWordBoundaries(new Set());
                                            setReadingOrder([]);
                                            setMergeIndicator(null);
                                            setManualDetectionMode(false);
                                            setTrimMode(null);
                                            setExcludeMode(null);
                                            setExcludeRegions([]);
                                            recordAction('clear_all', { timestamp: new Date().toISOString() });
                                            alert('‚úÖ All detections cleared!');
                                        }
                                    }}
                                    className="px-4 py-2 bg-rust text-white rounded hover:bg-[#8d5d47]"
                                    disabled={recognitionResults.length === 0}
                                >
                                    üóëÔ∏è Clear All
                                </button>
                                {isolatedGlyphs.length > 0 && (
                                    <button
                                        onClick={() => setShowRegionBoundaries(!showRegionBoundaries)}
                                        className="px-4 py-2 bg-patina text-white rounded hover:bg-teal-600"
                                    >
                                        {showRegionBoundaries ? 'Hide' : 'Show'} Isolated Regions ({isolatedGlyphs.length})
                                    </button>
                                )}
                                <span className="text-sm text-gray-600">{recognitionResults.length} detections</span>
                                <button 
                                    onClick={undo}
                                    disabled={historyIndex <= 0}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed"
                                    title="Undo (Ctrl+Z)"
                                >
                                    ‚Ü∂ Undo
                                </button>
                                <button 
                                    onClick={redo}
                                    disabled={historyIndex >= stateHistory.length - 1}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed"
                                    title="Redo (Ctrl+Y)"
                                >
                                    ‚Ü∑ Redo
                                </button>
                            </div>

                            {recognitionResults.length > 0 && (
                                <div className="mt-4 p-4 bg-white border-2 border-gray-300 rounded-lg">
                                    <div className="flex items-center justify-between mb-3">
                                        <div className="flex items-center gap-3">
                                            <button
                                                onClick={() => setShowConfidenceFilter(!showConfidenceFilter)}
                                                className="flex items-center gap-2 text-gray-700 hover:text-gray-900 font-semibold"
                                            >
                                                <span>{showConfidenceFilter ? '‚ñº' : '‚ñ∂'}</span>
                                                <h4 className="text-gray-900">Confidence Filter</h4>
                                            </button>
                                            {!showConfidenceFilter && (
                                                <label className="flex items-center gap-2 cursor-pointer">
                                                    <input
                                                        type="checkbox"
                                                        checked={useConfidenceFilter}
                                                        onChange={(e) => setUseConfidenceFilter(e.target.checked)}
                                                        className="w-4 h-4"
                                                    />
                                                    <span className="text-sm text-gray-700">Enable</span>
                                                </label>
                                            )}
                                        </div>
                                        <div className="text-sm">
                                            {useConfidenceFilter ? (
                                                <span className="text-stone-dark font-semibold">
                                                    Showing {getFilteredResults().length} of {recognitionResults.length} detections
                                                    {recognitionResults.length - getFilteredResults().length > 0 && (
                                                        <span className="text-gray-500 ml-2">
                                                            ({recognitionResults.length - getFilteredResults().length} hidden)
                                                        </span>
                                                    )}
                                                </span>
                                            ) : (
                                                <span className="text-gray-600">Showing all {recognitionResults.length} detections</span>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {showConfidenceFilter && (
                                        <>
                                            <div className="mb-3 pb-3 border-b border-gray-200">
                                                <label className="flex items-center gap-2 cursor-pointer">
                                                    <input
                                                        type="checkbox"
                                                        checked={useConfidenceFilter}
                                                        onChange={(e) => {
                                                            setUseConfidenceFilter(e.target.checked);
                                                            if (e.target.checked) {
                                                                setShowConfidenceFilter(true); // Auto-expand when enabling
                                                            }
                                                        }}
                                                        className="w-4 h-4"
                                                    />
                                                    <span className="text-sm font-medium text-gray-700">Enable Filter</span>
                                                </label>
                                            </div>
                                            <div className="flex items-center gap-4">
                                                <label className="text-sm font-medium text-gray-700 whitespace-nowrap">
                                                    Min Confidence: {confidenceThreshold}%
                                                </label>
                                                <input
                                                    type="range"
                                                    min="0"
                                                    max="100"
                                                    value={confidenceThreshold}
                                                    onChange={(e) => setConfidenceThreshold(parseInt(e.target.value))}
                                                    disabled={!useConfidenceFilter}
                                                    className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed"
                                                    style={{
                                                        background: useConfidenceFilter 
                                                            ? `linear-gradient(to right, #a0674f 0%, #b8956a ${confidenceThreshold / 2}%, #6b8e7f ${confidenceThreshold}%, #e5e7eb ${confidenceThreshold}%, #e5e7eb 100%)`
                                                            : '#e5e7eb'
                                                    }}
                                                />
                                                <span className="text-xs text-gray-500 whitespace-nowrap">
                                                    {confidenceThreshold < 40 && 'üî¥ Low'}
                                                    {confidenceThreshold >= 40 && confidenceThreshold < 70 && 'üü° Medium'}
                                                    {confidenceThreshold >= 70 && 'üü¢ High'}
                                                </span>
                                            </div>
                                        </>
                                    )}
                                </div>
                            )}

                            {selectedRegions.size > 0 && (
                                <div className="flex flex-wrap gap-3 items-center pt-3 border-t border-gray-200">
                                    <span className="text-sm text-gray-600">{selectedRegions.size} selected</span>
                                    {selectedRegions.size >= 2 && (
                                        <>
                                            <button onClick={mergeSelectedDetections} className="px-4 py-2 bg-ancient-purple text-white rounded hover:bg-[#4a3e54] font-semibold">
                                                ‚ö° Merge Selected
                                            </button>
                                            <span className="text-xs text-gray-500">Combines {selectedRegions.size} detections into one</span>
                                        </>
                                    )}
                                    {selectedRegions.size === 1 && (
                                        <span className="text-xs text-stone-dark">Select 1+ more (click ‚ö°) to merge</span>
                                    )}
                                    <button onClick={() => setSelectedRegions(new Set())} className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                                        Clear Selection
                                    </button>
                                </div>
                            )}
                            
                            {manualDetectionMode && (
                                <div className="mt-3 p-3 bg-orange-50 border border-orange-200 rounded text-sm text-orange-800">
                                    Manual Mode: Click and drag to create detections. Ctrl/Cmd+Click to select for merging.
                                </div>
                            )}
                            {recognitionResults.length > 0 && showDetectionCanvasTip && (
                                <div className="mt-3 p-3 bg-[#f7f3ed] border border-[#d4c4a8] rounded text-sm text-[#6d5d42] flex items-center justify-between">
                                    <span>üí° Tip: Ctrl/Cmd+Click any detection box to select it. Delete (‚úï) Merge (‚ö°) and Exclude (üî•) buttons will appear. Click wrench (üîß) to adjust box corners by dragging.</span>
                                    <button 
                                        onClick={() => setShowDetectionCanvasTip(false)}
                                        className="ml-3 text-yellow-600 hover:text-[#6d5d42] font-bold text-lg leading-none flex-shrink-0"
                                        title="Dismiss tip"
                                    >
                                        √ó
                                    </button>
                                </div>
                            )}
                            </>
                            )}
                        </div>
                    )}

                    {image && (
                        <div className="mb-6">
                            <div className="canvas-container relative" ref={imageContainerRef}
                                onMouseMove={handleImageMouseMove}
                                onMouseUp={handleImageMouseUp}
                                onMouseLeave={handleImageMouseUp}
                            >
                                <img
                                    ref={imageRef}
                                    src={displayImage || image}
                                    alt="Uploaded inscription"
                                    className="max-w-full h-auto border border-gray-300 rounded"
                                    onMouseDown={handleImageMouseDown}
                                    style={{ 
                                        cursor: manualDetectionMode ? 'crosshair' : 'default',
                                        userSelect: 'none',
                                        pointerEvents: 'auto',
                                        transform: displayImage ? 'none' : `rotate(${imageRotation}deg)`, // Only rotate preview
                                        transformOrigin: 'center center',
                                        transition: 'transform 0.3s ease'
                                    }}
                                    draggable={false}
                                />

                                {/* Trim mode indicator */}
                                {trimMode !== null && recognitionResults[trimMode] && (() => {
                                    const det = recognitionResults[trimMode];
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const refWidth = rotatedImageDimensions ? rotatedImageDimensions.width : imageRef.current.naturalWidth;
                                    const refHeight = rotatedImageDimensions ? rotatedImageDimensions.height : imageRef.current.naturalHeight;
                                    const scaleX = imageRect.width / refWidth;
                                    const scaleY = imageRect.height / refHeight;
                                    return (
                                        <div
                                            className="absolute border-4 border-dashed border-stone bg-stone-light bg-opacity-20 pointer-events-none"
                                            style={{
                                                left: det.position.x * scaleX + 'px',
                                                top: det.position.y * scaleY + 'px',
                                                width: det.position.width * scaleX + 'px',
                                                height: det.position.height * scaleY + 'px',
                                                zIndex: 20
                                            }}
                                        >
                                            <div className="absolute top-1 left-1 bg-stone text-white text-xs px-2 py-1 rounded">
                                                ‚úÇÔ∏è Draw smaller box to trim
                                            </div>
                                        </div>
                                    );
                                })()}

                                {/* Exclude mode indicator */}
                                {excludeMode !== null && recognitionResults[excludeMode] && (() => {
                                    const det = recognitionResults[excludeMode];
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const refWidth = rotatedImageDimensions ? rotatedImageDimensions.width : imageRef.current.naturalWidth;
                                    const refHeight = rotatedImageDimensions ? rotatedImageDimensions.height : imageRef.current.naturalHeight;
                                    const scaleX = imageRect.width / refWidth;
                                    const scaleY = imageRect.height / refHeight;
                                    return (
                                        <>
                                            {/* Highlight the detection being edited - more visible purple border */}
                                            <div
                                                className="absolute border-4 border-dashed border-ancient-purple pointer-events-none"
                                                style={{
                                                    left: det.position.x * scaleX + 'px',
                                                    top: det.position.y * scaleY + 'px',
                                                    width: det.position.width * scaleX + 'px',
                                                    height: det.position.height * scaleY + 'px',
                                                    zIndex: 20,
                                                    backgroundColor: 'rgba(147, 51, 234, 0.1)'
                                                }}
                                            />

                                            {/* Show exclusion regions drawn by user - more visible */}
                                            {excludeRegions.map((exRegion, idx) => (
                                                <div
                                                    key={`exclude-${idx}`}
                                                    className="absolute border-4 border-red-600 bg-rust pointer-events-none"
                                                    style={{
                                                        left: exRegion.x * scaleX + 'px',
                                                        top: exRegion.y * scaleY + 'px',
                                                        width: exRegion.width * scaleX + 'px',
                                                        height: exRegion.height * scaleY + 'px',
                                                        zIndex: 21,
                                                        opacity: 0.5
                                                    }}
                                                />
                                            ))}
                                        </>
                                    );
                                })()}
                                
                                {showRegionBoundaries && isolatedGlyphs.map((region, index) => {
                                    if (!imageRef.current) return null;
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const refWidth = rotatedImageDimensions ? rotatedImageDimensions.width : imageRef.current.naturalWidth;
                                    const refHeight = rotatedImageDimensions ? rotatedImageDimensions.height : imageRef.current.naturalHeight;
                                    const scaleX = imageRect.width / refWidth;
                                    const scaleY = imageRect.height / refHeight;
                                    const isSelected = selectedIsolatedRegion === index;
                                    return (
                                        <div
                                            key={`region-${index}`}
                                            className={`region-boundary cursor-pointer ${isSelected ? 'ring-2 ring-blue-500' : ''}`}
                                            style={{
                                                left: region.bounds.x * scaleX + 'px',
                                                top: region.bounds.y * scaleY + 'px',
                                                width: region.bounds.width * scaleX + 'px',
                                                height: region.bounds.height * scaleY + 'px',
                                                borderColor: isSelected ? '#8b7d6b' : 'rgba(156, 163, 175, 0.5)'
                                            }}
                                            onClick={() => setSelectedIsolatedRegion(isSelected ? null : index)}
                                        />
                                    );
                                })}
                                
                                {getFilteredResults().map((detection, filteredIndex) => {
                                    if (!imageRef.current) return null;
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    // Use rotated dimensions if available, otherwise fall back to natural dimensions
                                    const refWidth = rotatedImageDimensions ? rotatedImageDimensions.width : imageRef.current.naturalWidth;
                                    const refHeight = rotatedImageDimensions ? rotatedImageDimensions.height : imageRef.current.naturalHeight;
                                    const scaleX = imageRect.width / refWidth;
                                    const scaleY = imageRect.height / refHeight;

                                    // Get the original index from recognitionResults
                                    const index = recognitionResults.indexOf(detection);
                                    let boxColor = '#8b7d6b';
                                    const isSelected = selectedRegions.has(index);
                                    const isValidated = validations[index];
                                    const isAdjusting = adjustMode === index;

                                    if (isValidated) {
                                        boxColor = isValidated.isCorrect ? '#6b8e7f' : '#a0674f';
                                    }

                                    // Get corners (either stored or calculated from position)
                                    const corners = detection.corners || {
                                        tl: { x: detection.position.x, y: detection.position.y },
                                        tr: { x: detection.position.x + detection.position.width, y: detection.position.y },
                                        bl: { x: detection.position.x, y: detection.position.y + detection.position.height },
                                        br: { x: detection.position.x + detection.position.width, y: detection.position.y + detection.position.height }
                                    };

                                    // Check if we're in adjust mode (declare once at the top)
                                    const isInAdjustMode = adjustMode !== null;
                                    const isNotAdjusting = isInAdjustMode && !isAdjusting;

                                    const handleCornerMouseDown = (e, corner) => {
                                        e.stopPropagation();
                                        if (adjustMode !== index) return;
                                        setDraggingCorner(corner);
                                        const rect = imageRef.current.getBoundingClientRect();
                                        const scaleX = rect.width / imageRef.current.naturalWidth;
                                        const scaleY = rect.height / imageRef.current.naturalHeight;
                                        setDragStartPos({
                                            x: (e.clientX - rect.left) / scaleX,
                                            y: (e.clientY - rect.top) / scaleY
                                        });
                                    };

                                    // Render as SVG polygon if:
                                    // 1. Box has been adjusted (isAdjusted flag), OR
                                    // 2. Box is currently being adjusted (isAdjusting)
                                    const hasAdjustedCorners = detection.corners && (detection.isAdjusted || isAdjusting);
                                    
                                    if (hasAdjustedCorners) {
                                        // Use SVG to render the quadrilateral
                                        const points = `${corners.tl.x * scaleX},${corners.tl.y * scaleY} ${corners.tr.x * scaleX},${corners.tr.y * scaleY} ${corners.br.x * scaleX},${corners.br.y * scaleY} ${corners.bl.x * scaleX},${corners.bl.y * scaleY}`;
                                        
                                        return (
                                            <React.Fragment key={`detection-${index}`}>
                                                <svg
                                                    style={{
                                                        position: 'absolute',
                                                        left: 0,
                                                        top: 0,
                                                        width: '100%',
                                                        height: '100%',
                                                        pointerEvents: (templateTrainingMode && selectedForTemplate !== null && selectedForTemplate !== index) ? 'none' : (templateTrainingMode ? 'auto' : 'none'),  // Disable when popup is open on another box
                                                        zIndex: isAdjusting ? 100 : 10,  // Higher when actively adjusting
                                                        opacity: (isNotAdjusting || (templateTrainingMode && selectedForTemplate !== null && selectedForTemplate !== index)) ? 0.2 : 1  // Fade when popup is open or when adjusting
                                                    }}
                                                >
                                                    <polygon
                                                        points={points}
                                                        fill={isAdjusting ? "rgba(251, 146, 60, 0.15)" : `${boxColor}40`}
                                                        stroke={templateTrainingMode && selectedForTemplate === index ? "#a855f7" : (isAdjusting ? "#fb923c" : boxColor)}
                                                        strokeWidth={templateTrainingMode && selectedForTemplate === index ? "4" : (isAdjusting ? "3" : "2")}
                                                        strokeDasharray={detection.hasCloseMatch && !isAdjusting ? "8, 4" : "none"}
                                                        className={templateTrainingMode ? 'cursor-pointer' : ''}
                                                        style={{
                                                            transition: 'stroke 0.2s, stroke-width 0.2s'
                                                        }}
                                                        onMouseEnter={(e) => {
                                                            if (templateTrainingMode && selectedForTemplate !== index) {
                                                                e.target.style.stroke = '#a855f7';
                                                                e.target.style.strokeWidth = '3';
                                                            }
                                                        }}
                                                        onMouseLeave={(e) => {
                                                            if (templateTrainingMode && selectedForTemplate !== index) {
                                                                e.target.style.stroke = boxColor;
                                                                e.target.style.strokeWidth = '2';
                                                            }
                                                        }}
                                                        onClick={(e) => {
                                                            if (templateTrainingMode) {
                                                                e.stopPropagation();
                                                                setSelectedForTemplate(selectedForTemplate === index ? null : index);  // Toggle like rectangles
                                                            }
                                                        }}
                                                    />
                                                </svg>
                                                
                                                {/* Invisible clickable overlay for template training mode - removed, using polygon click instead */}
                                                
                                                {/* Label */}
                                                <div
                                                    className="absolute px-2 py-1 text-xs font-bold text-white rounded"
                                                    style={{
                                                        left: corners.tl.x * scaleX + 'px',
                                                        top: (corners.tl.y * scaleY - 24) + 'px',
                                                        backgroundColor: (isAdjusting ? '#fb923c' : boxColor) + 'e6',
                                                        zIndex: isAdjusting ? 101 : 11,
                                                        pointerEvents: templateTrainingMode ? 'none' : ((isNotAdjusting && !templateTrainingMode) ? 'none' : 'auto')  // Pass through clicks in template mode
                                                    }}
                                                >
                                                    {showArabicLabels ? (detection.glyph.arabic || detection.glyph.name) : detection.glyph.name}
                                                    {detection.corrected && <span className="ml-1">‚úèÔ∏è</span>}
                                                </div>

                                                {viewMode === 'reading' && (
                                                    <div 
                                                        className="absolute w-6 h-6 rounded-full bg-ochre border-2 border-[#8d7350] text-xs font-bold flex items-center justify-center"
                                                        style={{
                                                            left: corners.tl.x * scaleX + 'px',
                                                            top: corners.tl.y * scaleY + 'px',
                                                            zIndex: isAdjusting ? 101 : 11
                                                        }}
                                                    >
                                                        {getReadingOrderIndex(index)}
                                                    </div>
                                                )}

                                                {/* Corner handles - only show when actively adjusting THIS box */}
                                                {isAdjusting && (
                                                    <>
                                                        <div
                                                            onMouseDown={(e) => handleCornerMouseDown(e, 'tl')}
                                                            className="absolute w-4 h-4 bg-orange-500 border-2 border-white rounded-full cursor-nwse-resize hover:scale-125 transition-transform"
                                                            style={{
                                                                left: corners.tl.x * scaleX - 8 + 'px',
                                                                top: corners.tl.y * scaleY - 8 + 'px',
                                                                zIndex: 102
                                                            }}
                                                        />
                                                        <div
                                                            onMouseDown={(e) => handleCornerMouseDown(e, 'tr')}
                                                            className="absolute w-4 h-4 bg-orange-500 border-2 border-white rounded-full cursor-nesw-resize hover:scale-125 transition-transform"
                                                            style={{
                                                                left: corners.tr.x * scaleX - 8 + 'px',
                                                                top: corners.tr.y * scaleY - 8 + 'px',
                                                                zIndex: 102
                                                            }}
                                                        />
                                                        <div
                                                            onMouseDown={(e) => handleCornerMouseDown(e, 'bl')}
                                                            className="absolute w-4 h-4 bg-orange-500 border-2 border-white rounded-full cursor-nesw-resize hover:scale-125 transition-transform"
                                                            style={{
                                                                left: corners.bl.x * scaleX - 8 + 'px',
                                                                top: corners.bl.y * scaleY - 8 + 'px',
                                                                zIndex: 102
                                                            }}
                                                        />
                                                        <div
                                                            onMouseDown={(e) => handleCornerMouseDown(e, 'br')}
                                                            className="absolute w-4 h-4 bg-orange-500 border-2 border-white rounded-full cursor-nwse-resize hover:scale-125 transition-transform"
                                                            style={{
                                                                left: corners.br.x * scaleX - 8 + 'px',
                                                                top: corners.br.y * scaleY - 8 + 'px',
                                                                zIndex: 102
                                                            }}
                                                        />
                                                    </>
                                                )}

                                                {/* Template save menu */}
                                                {templateTrainingMode && selectedForTemplate === index && (
                                                    <div
                                                        className="absolute bg-white rounded-lg shadow-xl border-2 border-ancient-purple p-3"
                                                        style={{ 
                                                            minWidth: '200px',
                                                            left: corners.tl.x * scaleX + 'px',
                                                            top: (corners.br.y * scaleY + 8) + 'px',  // Position below the polygon
                                                            zIndex: 1000  // Very high to ensure it's on top of everything
                                                        }}
                                                        onClick={(e) => e.stopPropagation()}
                                                    >
                                                        <div className="font-semibold text-sm mb-2 text-ancient-purple">
                                                            Save &quot;{detection.glyph.name}&quot; as:
                                                        </div>
                                                        <div className="flex flex-col gap-2">
                                                            <button
                                                                onClick={() => saveAsTemplate(index, 'primary')}
                                                                className="px-3 py-2 bg-stone text-white text-sm rounded hover:bg-stone-dark"
                                                            >
                                                                üéØ Primary Template
                                                            </button>
                                                            <button
                                                                onClick={() => saveAsTemplate(index, 'variant')}
                                                                className="px-3 py-2 bg-patina text-white text-sm rounded hover:bg-[#5d7a6d]"
                                                            >
                                                                ‚≠ê Variant
                                                            </button>
                                                            <button
                                                                onClick={() => saveAsTemplate(index, 'example')}
                                                                className="px-3 py-2 bg-ochre text-white text-sm rounded hover:bg-[#a18259]"
                                                            >
                                                                üìö Example
                                                            </button>
                                                            <button
                                                                onClick={() => setSelectedForTemplate(null)}
                                                                className="px-3 py-2 bg-gray-300 text-gray-700 text-sm rounded hover:bg-gray-400"
                                                            >
                                                                ‚úï Cancel
                                                            </button>
                                                        </div>
                                                    </div>
                                                )}
                                            </React.Fragment>
                                        );
                                    }

                                    return (
                                        <div
                                            key={`detection-${index}`}
                                            className={`detection-box ${detection.hasCloseMatch ? 'uncertain' : ''} ${isSelected ? 'selected' : ''} ${isAdjusting ? 'ring-4 ring-orange-400' : ''} ${templateTrainingMode ? 'cursor-pointer hover:ring-4 hover:ring-purple-400' : ''}`}
                                            style={{
                                                left: detection.position.x * scaleX + 'px',
                                                top: detection.position.y * scaleY + 'px',
                                                width: detection.position.width * scaleX + 'px',
                                                height: detection.position.height * scaleY + 'px',
                                                borderColor: isAdjusting ? '#fb923c' : boxColor,
                                                opacity: (isNotAdjusting || (templateTrainingMode && selectedForTemplate !== null && selectedForTemplate !== index)) ? 0.2 : 1,  // Fade when popup is open or when adjusting
                                                pointerEvents: (isNotAdjusting && !templateTrainingMode) || (templateTrainingMode && selectedForTemplate !== null && selectedForTemplate !== index) ? 'none' : 'auto',  // Disable when popup is open on another box
                                                zIndex: isAdjusting ? 100 : 10  // Higher z-index for adjusting box
                                            }}
                                            onClick={() => {
                                                if (templateTrainingMode) {
                                                    // Toggle selection - if clicking same box, deselect. If different box, select it.
                                                    setSelectedForTemplate(selectedForTemplate === index ? null : index);
                                                } else if (!isAdjusting) {
                                                    toggleRegionSelection(index);
                                                }
                                            }}
                                        >
                                            <div className="detection-label" style={{ backgroundColor: (isAdjusting ? '#fb923c' : boxColor) + 'e6' }}>
                                                {showArabicLabels ? (detection.glyph.arabic || detection.glyph.name) : detection.glyph.name}
                                                {detection.corrected && <span className="ml-1">‚úèÔ∏è</span>}
                                            </div>

                                            {viewMode === 'reading' && (
                                                <div className="reading-order-badge">
                                                    {getReadingOrderIndex(index)}
                                                </div>
                                            )}

                                            {templateTrainingMode && selectedForTemplate === index && (
                                                <div
                                                    className="absolute top-full left-0 mt-2 bg-white rounded-lg shadow-xl border-2 border-ancient-purple p-3"
                                                    style={{ minWidth: '200px', zIndex: 1000 }}
                                                    onClick={(e) => e.stopPropagation()}
                                                >
                                                    <div className="font-semibold text-sm mb-2 text-ancient-purple">
                                                        Save &quot;{detection.glyph.name}&quot; as:
                                                    </div>
                                                    <div className="flex flex-col gap-2">
                                                        <button
                                                            onClick={() => saveAsTemplate(index, 'primary')}
                                                            className="px-3 py-2 bg-stone text-white text-sm rounded hover:bg-stone-dark"
                                                        >
                                                            üéØ Primary Template
                                                        </button>
                                                        <button
                                                            onClick={() => saveAsTemplate(index, 'variant')}
                                                            className="px-3 py-2 bg-patina text-white text-sm rounded hover:bg-[#5d7a6d]"
                                                        >
                                                            ‚≠ê Variant
                                                        </button>
                                                        <button
                                                            onClick={() => saveAsTemplate(index, 'example')}
                                                            className="px-3 py-2 bg-ochre text-white text-sm rounded hover:bg-[#a18259]"
                                                        >
                                                            üìö Example
                                                        </button>
                                                        <button
                                                            onClick={() => setSelectedForTemplate(null)}
                                                            className="px-3 py-2 bg-gray-300 text-gray-700 text-sm rounded hover:bg-gray-400"
                                                        >
                                                            ‚úï Cancel
                                                        </button>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                                
                                {isDrawing && drawStart && drawCurrent && imageRef.current && (() => {
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    
                                    // Use red for exclude mode, orange for manual mode
                                    const boxStyle = excludeMode !== null ? {
                                        border: '3px dashed #dc2626',
                                        background: 'rgba(220, 38, 38, 0.2)'
                                    } : {
                                        border: '3px dashed #b8956a',
                                        background: 'rgba(245, 158, 11, 0.2)'
                                    };
                                    
                                    return (
                                        <div style={{
                                            position: 'absolute',
                                            left: Math.min(drawStart.x, drawCurrent.x) * scaleX + 'px',
                                            top: Math.min(drawStart.y, drawCurrent.y) * scaleY + 'px',
                                            width: Math.abs(drawCurrent.x - drawStart.x) * scaleX + 'px',
                                            height: Math.abs(drawCurrent.y - drawStart.y) * scaleY + 'px',
                                            ...boxStyle,
                                            pointerEvents: 'none',
                                            zIndex: 25
                                        }} />
                                    );
                                })()}
                                
                                {mergeIndicator && imageRef.current && (() => {
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div className="merge-indicator" style={{
                                            left: mergeIndicator.x * scaleX + 'px',
                                            top: mergeIndicator.y * scaleY + 'px',
                                            width: mergeIndicator.width * scaleX + 'px',
                                            height: mergeIndicator.height * scaleY + 'px'
                                        }} />
                                    );
                                })()}
                            </div>
                        </div>
                    )}
                        {isolatedGlyphs.length > 0 && showRegionBoundaries && (
                        <div className="mt-4 p-4 bg-gray-50 border-2 border-teal-300 rounded-lg">
                            <h4 className="font-semibold text-gray-900 mb-3">Isolated Glyph Regions ({isolatedGlyphs.length})</h4>
                            <div className="mb-2 text-sm text-gray-600">
                                üí° Hover over a region to see the delete button
                            </div>
                            <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-2">
                                {isolatedGlyphs.map((region, index) => {
                                    const letter = String.fromCharCode(65 + index);
                                    return (
                                        <div
                                            key={`thumb-${index}`}
                                            className="relative flex flex-col items-center p-2 bg-white border-2 border-gray-300 rounded hover:border-stone-light hover:shadow-lg transition-all group"
                                        >
                                            {region.thumbnail && (
                                                <img src={region.thumbnail} alt={`Region ${letter}`} className="w-full h-auto border border-gray-200" />
                                            )}
                                            <div className="text-xs font-bold text-teal-600 mt-1">{letter}</div>
                                            <div className="text-xs text-gray-500">{region.bounds.width}√ó{region.bounds.height}</div>

                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (confirm(`Delete region ${letter}?\n\nThis will remove the isolated region and any detection associated with it.`)) {
                                                        deleteIsolatedRegion(index);
                                                    }
                                                }}
                                                className="absolute -top-2 -right-2 w-6 h-6 bg-rust text-white rounded-full hover:bg-[#8d5d47] flex items-center justify-center text-sm font-bold shadow-lg opacity-0 group-hover:opacity-100 transition-opacity"
                                                title="Delete this region"
                                            >
                                                √ó
                                            </button>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    {correctionMode !== null && equivalenceChart && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={cancelCorrection}>
                            <div className="bg-white rounded-lg p-6 max-w-5xl w-full max-h-[85vh] overflow-y-auto shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900">Select Correct Glyph</h3>
                                    <button 
                                        onClick={cancelCorrection} 
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none w-8 h-8 flex items-center justify-center"
                                        title="Close (Esc)"
                                    >
                                        &times;
                                    </button>
                                </div>
                                
                                <div className="mb-4 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-stone-light rounded-lg">
                                    <div className="flex items-center justify-between gap-4">
                                        <div className="flex-1">
                                            <span className="text-sm text-gray-600">Currently detected as:</span>
                                            <div className="text-xl font-bold text-gray-900 mt-1">
                                                {recognitionResults[correctionMode].glyph.name}
                                                <span className="ml-3 text-base font-normal text-gray-600">
                                                    ({recognitionResults[correctionMode].glyph.transliteration || recognitionResults[correctionMode].glyph.name})
                                                </span>
                                            </div>
                                            <div className="text-sm text-gray-500 mt-1">
                                                {Math.round(recognitionResults[correctionMode].confidence * 100)}% confidence
                                            </div>
                                        </div>
                                        {recognitionResults[correctionMode].regionIndex !== undefined &&
                                            isolatedGlyphs[recognitionResults[correctionMode].regionIndex]?.thumbnail && (
                                                <div className="flex-shrink-0">
                                                    <div className="text-xs text-gray-600 mb-1 text-center">Detected Region:</div>
                                                    <img
                                                        src={isolatedGlyphs[recognitionResults[correctionMode].regionIndex].thumbnail}
                                                        alt="Isolated region"
                                                        className="w-32 h-auto border-2 border-stone rounded"
                                                    />
                                                </div>
                                            )}
                                    </div>
                                </div>                          
                                <div className="mb-4">
                                    <input
                                        type="text"
                                        placeholder="Search glyphs by name or transliteration..."
                                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-stone focus:outline-none"
                                        onChange={(e) => {
                                            const searchTerm = e.target.value.toLowerCase();
                                            const glyphGrid = e.target.parentElement.nextElementSibling;
                                            const buttons = glyphGrid.querySelectorAll('button');
                                            buttons.forEach(btn => {
                                                const text = btn.textContent.toLowerCase();
                                                btn.style.display = text.includes(searchTerm) ? '' : 'none';
                                            });
                                        }}
                                    />
                                </div>
                                
                                {(() => {
                                    const suggestion = getCorrectionSuggestion(recognitionResults[correctionMode].glyph.id);
                                    if (suggestion) {
                                        return (
                                            <div className="mb-4 p-3 bg-[#f0f5f3] border-2 border-patina rounded-lg">
                                                <div className="flex items-center justify-between">
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-patina font-semibold">üí° Suggestion:</span>
                                                        <span className="text-gray-700">
                                                            You've corrected this to <strong>{suggestion.to.name}</strong> {suggestion.count} time{suggestion.count > 1 ? 's' : ''} before
                                                        </span>
                                                    </div>
                                                    <button
                                                        onClick={() => applyCorrection(correctionMode, suggestion.to)}
                                                        className="px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5d7a6d] font-semibold"
                                                    >
                                                        Apply Suggestion
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    }
                                    return null;
                                })()}

                                <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2">
                                    {equivalenceChart.glyphs.map((glyph, index) => {
                                        const isCurrentGlyph = glyph.id === recognitionResults[correctionMode].glyph.id;
                                        return (
                                            <button
                                                key={`glyph-${glyph.id}-${index}`}
                                                onClick={() => applyCorrection(correctionMode, glyph)}
                                                className={`p-3 border-2 rounded-lg flex flex-col items-center gap-1 transition-all hover:scale-105 ${
                                                    isCurrentGlyph 
                                                        ? 'border-stone bg-[#f5f3f0] ring-2 ring-blue-300' 
                                                        : 'border-gray-200 hover:border-stone-light hover:bg-[#f5f3f0]'
                                                }`}
                                                title={`${glyph.name} (${glyph.transliteration || glyph.name})`}
                                            >
                                                <div className="font-bold text-xl">{glyph.name}</div>
                                                <div className="text-xs text-gray-600 text-center leading-tight">
                                                    {glyph.transliteration || glyph.name}
                                                </div>
                                                {isCurrentGlyph && (
                                                    <div className="text-xs text-stone-dark font-semibold mt-1">Current</div>
                                                )}
                                            </button>
                                        );
                                    })}
                                </div>
                                
                                {showCorrectionModalTip && (
                                    <div className="mt-6 pt-4 border-t border-gray-200 flex items-center justify-between">
                                        <div className="text-sm text-gray-500 flex items-center">
                                            üí° Tip: You can also search glyphs above to find them quickly
                                        </div>
                                        <div className="flex gap-2">
                                            <button 
                                                onClick={() => setShowCorrectionModalTip(false)}
                                                className="text-gray-400 hover:text-gray-600 font-bold text-xl leading-none"
                                                title="Dismiss tip"
                                            >
                                                √ó
                                            </button>
                                            <button 
                                                onClick={cancelCorrection}
                                                className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    </div>
                                )}
                                {!showCorrectionModalTip && (
                                    <div className="mt-6 pt-4 border-t border-gray-200 flex justify-end">
                                        <button 
                                            onClick={cancelCorrection}
                                            className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                        >
                                            Cancel
                                        </button>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Exclude Mode Modal */}
                    {excludeMode !== null && recognitionResults[excludeMode] && (
                        <div className="fixed right-4 top-20 z-50 w-96 max-h-[calc(100vh-6rem)] overflow-y-auto">
                            <div className="bg-white rounded-lg p-6 shadow-2xl border-4 border-ancient-purple" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900 flex items-center gap-2">
                                        <span>üî•</span> Exclude Regions
                                    </h3>
                                    <button 
                                        onClick={() => {
                                            setExcludeMode(null);
                                            setExcludeRegions([]);
                                        }} 
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none w-8 h-8 flex items-center justify-center"
                                        title="Close (Esc)"
                                    >
                                        &times;
                                    </button>
                                </div>
                                
                                <div className="mb-4 p-4 bg-gradient-to-r from-[#f3f1f4] to-[#fef1f4] border-2 border-[#c9bfd4] rounded-lg">
                                    <div className="flex items-center gap-4">
                                        <div className="flex-1">
                                            <span className="text-sm text-gray-600">Cleaning detection:</span>
                                            <div className="text-xl font-bold text-gray-900 mt-1">
                                                {recognitionResults[excludeMode].glyph.name}
                                            </div>
                                            <div className="text-sm text-gray-500 mt-1">
                                                Remove unwanted portions from this detection
                                            </div>
                                        </div>
                                        {recognitionResults[excludeMode].regionIndex !== undefined &&
                                            isolatedGlyphs[recognitionResults[excludeMode].regionIndex]?.thumbnail && (
                                                <div className="flex-shrink-0">
                                                    <div className="text-xs text-gray-600 mb-1 text-center">Current Region:</div>
                                                    <img
                                                        src={isolatedGlyphs[recognitionResults[excludeMode].regionIndex].thumbnail}
                                                        alt="Current region"
                                                        className="w-24 h-auto border-2 border-ancient-purple rounded"
                                                    />
                                                </div>
                                            )}
                                    </div>
                                </div>

                                <div className="mb-4 p-4 bg-[#f5f3f0] border border-stone-light rounded-lg">
                                    <h4 className="font-semibold text-stone-dark mb-2">üìù How to Exclude Regions:</h4>
                                    <ol className="text-sm text-gray-700 space-y-2 list-decimal list-inside">
                                        <li><strong className="text-stone-dark">DRAW BOXES on the inscription image</strong> - Click and drag to create red boxes around unwanted portions</li>
                                        <li>The <strong>purple dashed border</strong> shows which detection you're editing</li>
                                        <li><strong>Draw multiple boxes</strong> if you need to exclude several areas</li>
                                        <li>When done drawing, click <strong className="text-patina">"‚úì Apply Exclusions"</strong> below</li>
                                    </ol>
                                </div>

                                <div className="mb-4 p-3 bg-[#f7f3ed] border border-[#d4c4a8] rounded">
                                    <div className="text-sm text-[#6d5d42]">
                                        <strong>Status:</strong> {excludeRegions.length === 0 ? 
                                            '‚ö†Ô∏è No boxes drawn yet - Draw red boxes on the image above!' : 
                                            `‚úì ${excludeRegions.length} exclusion region${excludeRegions.length > 1 ? 's' : ''} drawn - Ready to apply!`}
                                    </div>
                                </div>

                                <div className="flex gap-3">
                                    {excludeRegions.length > 0 && (
                                        <button
                                            onClick={() => applyExclude(excludeMode)}
                                            className="flex-1 px-4 py-3 bg-patina text-white rounded-lg hover:bg-[#5d7a6d] font-semibold text-lg"
                                        >
                                            ‚úì Apply Exclusions
                                        </button>
                                    )}
                                    <button
                                        onClick={() => {
                                            setExcludeMode(null);
                                            setExcludeRegions([]);
                                        }}
                                        className={`${excludeRegions.length > 0 ? 'flex-1' : 'w-full'} px-4 py-3 bg-gray-500 text-white rounded-lg hover:bg-gray-600 font-semibold text-lg`}
                                    >
                                        ‚úï Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Adjust Mode Modal */}
                    {adjustMode !== null && recognitionResults[adjustMode] && (
                        <div className="fixed right-4 top-20 z-50 w-96 max-h-[calc(100vh-6rem)] overflow-y-auto">
                            <div className="bg-white rounded-lg p-6 shadow-2xl border-4 border-teal-400" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900 flex items-center gap-2">
                                        <span>üîß</span> Adjust Box Corners
                                    </h3>
                                    <button 
                                        onClick={() => {
                                            setAdjustMode(null);
                                            setDraggingCorner(null);
                                            setDragStartPos(null);
                                        }} 
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none w-8 h-8 flex items-center justify-center"
                                        title="Close (Esc)"
                                    >
                                        &times;
                                    </button>
                                </div>
                                
                                <div className="mb-4 p-4 bg-gradient-to-r from-teal-50 to-cyan-50 border-2 border-teal-200 rounded-lg">
                                    <div className="flex items-center gap-4">
                                        <div className="flex-1">
                                            <span className="text-sm text-gray-600">Adjusting detection:</span>
                                            <div className="text-xl font-bold text-gray-900 mt-1">
                                                {recognitionResults[adjustMode].glyph.name}
                                            </div>
                                            <div className="text-sm text-gray-500 mt-1">
                                                Drag corners to fit the glyph perfectly
                                            </div>
                                        </div>
                                        {recognitionResults[adjustMode].regionIndex !== undefined &&
                                            isolatedGlyphs[recognitionResults[adjustMode].regionIndex]?.thumbnail && (
                                                <div className="flex-shrink-0">
                                                    <div className="text-xs text-gray-600 mb-1 text-center">Current Region:</div>
                                                    <img
                                                        src={isolatedGlyphs[recognitionResults[adjustMode].regionIndex].thumbnail}
                                                        alt="Current region"
                                                        className="w-24 h-auto border-2 border-teal-300 rounded"
                                                    />
                                                </div>
                                            )}
                                    </div>
                                </div>

                                <div className="mb-4 p-4 bg-[#f5f3f0] border border-stone-light rounded-lg">
                                    <h4 className="font-semibold text-stone-dark mb-2">üìù How to Adjust Corners:</h4>
                                    <ol className="text-sm text-gray-700 space-y-2 list-decimal list-inside">
                                        <li><strong className="text-stone-dark">DRAG the corner circles</strong> on the detection box to adjust each corner independently</li>
                                        <li>The <strong>teal border</strong> shows which detection you're adjusting</li>
                                        <li>Create <strong>trapezoids or parallelograms</strong> to handle perspective or angled glyphs</li>
                                        <li>When done adjusting, click <strong className="text-patina">"‚úì Apply Adjustment"</strong> below</li>
                                    </ol>
                                </div>

                                <div className="mb-4 p-3 bg-[#f7f3ed] border border-ochre rounded-lg text-sm">
                                    <strong className="text-[#6d5d42]">Status:</strong>
                                    <span className="text-gray-700 ml-2">Adjustment mode active - drag the corner handles on the image</span>
                                </div>

                                <div className="flex gap-3">
                                    <button
                                        onClick={() => applyAdjustment(adjustMode)}
                                        className="flex-1 px-4 py-3 bg-patina text-white rounded-lg hover:bg-[#5d7a6d] font-semibold text-lg"
                                    >
                                        ‚úì Apply Adjustment
                                    </button>
                                    <button
                                        onClick={() => {
                                            setAdjustMode(null);
                                            setDraggingCorner(null);
                                            setDragStartPos(null);
                                        }}
                                        className="flex-1 px-4 py-3 bg-gray-500 text-white rounded-lg hover:bg-gray-600 font-semibold text-lg"
                                    >
                                        ‚úï Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <h3 className="font-semibold text-gray-900 mb-3">
                                {viewMode === 'detection' ? 'Detection Results' : 'Reading Order Results'}
                                {viewMode === 'reading' && <span className="ml-2 text-sm text-gray-600">(drag cards to reorder)</span>}
                            </h3>
                            
                            {/* Validation Statistics */}
                            <div className="mb-4 flex flex-wrap gap-4 text-sm items-center">
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-600">Total:</span>
                                    <span className="font-semibold text-gray-900">{recognitionResults.length}</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-patina">‚úì Validated Correct:</span>
                                    <span className="font-semibold text-patina">
                                        {Object.values(validations).filter(v => v.isCorrect).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-rust">‚úó Validated Incorrect:</span>
                                    <span className="font-semibold text-rust">
                                        {Object.values(validations).filter(v => !v.isCorrect).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-orange-600">‚úèÔ∏è Corrected:</span>
                                    <span className="font-semibold text-orange-700">
                                        {recognitionResults.filter(r => r.corrected).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-600">Unvalidated:</span>
                                    <span className="font-semibold text-gray-700">
                                        {recognitionResults.length - Object.keys(validations).length}
                                    </span>
                                </div>
                                
                                {/* Top Matches Toggle */}
                                <button
                                    onClick={() => setShowTopMatches(!showTopMatches)}
                                    className={`ml-auto px-3 py-1 rounded text-xs font-semibold transition-colors ${
                                        showTopMatches 
                                            ? 'bg-orange-500 text-white hover:bg-orange-600' 
                                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                    }`}
                                    title={showTopMatches ? "Hide alternative matches" : "Show alternative matches in cards"}
                                >
                                    {showTopMatches ? 'üîΩ Hide Alternatives' : 'üîº Show Alternatives'}
                                </button>
                            </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                        {(viewMode === 'detection' ? getFilteredResults() : getReadingOrderedResults()).map((result, displayIndex) => {
                            const originalIndex = viewMode === 'detection' ? displayIndex : recognitionResults.indexOf(result);
                            const readingOrderNum = viewMode === 'reading' ? displayIndex + 1 : null;
                            
                            return (
                                <div 
                                    key={`result-${originalIndex}`} 
                                    className={`p-3 bg-white rounded border ${selectedRegions.has(originalIndex) ? 'ring-2 ring-ochre' : ''} ${validations[originalIndex] ? (validations[originalIndex].isCorrect ? 'border-patina' : 'border-rust') : 'border-gray-200'} ${viewMode === 'reading' ? 'cursor-move' : ''}`}
                                    draggable={viewMode === 'reading'}
                                    onDragStart={(e) => viewMode === 'reading' && handleDragStart(e, displayIndex)}
                                    onDragOver={(e) => viewMode === 'reading' && handleDragOver(e, displayIndex)}
                                    onDrop={(e) => viewMode === 'reading' && handleDrop(e, displayIndex)}
                                >
                                    <div className="flex items-start justify-between mb-2">
                                        <div className="flex-1">
                                            <div className="flex items-center gap-2">
                                                {viewMode === 'reading' && (
                                                    <div className="flex-shrink-0 w-6 h-6 rounded-full bg-ochre border-2 border-[#8d7350] text-xs font-bold flex items-center justify-center">
                                                        {readingOrderNum}
                                                    </div>
                                                )}
                                                <div className="flex-1">
                                                    <div className="font-medium text-gray-900 flex items-center gap-2">
                                                        {/* Show prominent language based on showArabicLabels toggle */}
                                                        {showArabicLabels ? (
                                                            <span className="text-2xl" style={{ fontFamily: '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' }}>
                                                                {result.glyph.arabic || result.glyph.name}
                                                            </span>
                                                        ) : (
                                                            <span>{result.glyph.name}</span>
                                                        )}
                                                        {result.corrected && (
                                                            <span className="text-xs bg-orange-100 text-orange-700 px-2 py-0.5 rounded border border-orange-300">
                                                                ‚úèÔ∏è Corrected
                                                            </span>
                                                        )}
                                                        {result.isMerged && <span className="text-xs text-gray-500">(merged)</span>}
                                                        {result.isManual && <span className="text-xs text-gray-500">(manual)</span>}
                                                    </div>
                                                    {/* Show alternate language below */}
                                                    <div className="text-sm text-gray-600 mt-1">
                                                        {showArabicLabels ? (
                                                            // If showing Arabic prominently, show English below
                                                            <span>{result.glyph.name} ({result.glyph.transliteration || result.glyph.name})</span>
                                                        ) : (
                                                            // If showing English prominently, show Arabic below
                                                            result.glyph.arabic && (
                                                                <span style={{ fontFamily: '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' }}>
                                                                    {result.glyph.arabic}
                                                                </span>
                                                            )
                                                        )}
                                                    </div>
                                                    {result.corrected && result.originalGlyph && (
                                                        <div className="text-xs text-gray-500 mt-0.5">
                                                            Originally: <span className="line-through">{result.originalGlyph.name}</span>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="text-xs text-gray-500">Confidence: {Math.round(result.confidence * 100)}%</div>
                                            
                                            {/* Top Matches - show alternatives if they exist AND toggle is on */}
                                            {showTopMatches && result.alternatives && result.alternatives.length > 0 && (
                                                <div className="mt-2 p-2 bg-orange-50 border border-orange-200 rounded">
                                                    <div className="text-xs font-semibold text-orange-700 mb-1">Top matches:</div>
                                                    <div className="space-y-1">
                                                        {/* Show current selection */}
                                                        <button
                                                            className="flex items-center gap-2 text-xs w-full hover:bg-orange-100 p-1 rounded"
                                                            disabled
                                                        >
                                                            <span className="text-green-600">‚úì</span>
                                                            <span className="font-semibold">{result.glyph.name}</span>
                                                            <span className="text-gray-500">({Math.round(result.confidence * 100)}%)</span>
                                                            <span className="text-xs text-gray-400 ml-auto">‚Üê selected</span>
                                                        </button>
                                                        
                                                        {/* Show alternatives as clickable options */}
                                                        {result.alternatives.slice(0, 2).map((alt, altIndex) => (
                                                            <button
                                                                key={altIndex}
                                                                onClick={() => {
                                                                    // Swap alternative with primary
                                                                    const updatedResults = [...recognitionResults];
                                                                    const resultIndex = updatedResults.findIndex(r => r.regionIndex === result.regionIndex);
                                                                    
                                                                    if (resultIndex !== -1) {
                                                                        // Store original for tracking
                                                                        const original = { ...updatedResults[resultIndex] };
                                                                        
                                                                        // Swap: alternative becomes primary
                                                                        updatedResults[resultIndex] = {
                                                                            ...alt,
                                                                            regionIndex: result.regionIndex,
                                                                            alternatives: [
                                                                                { glyph: original.glyph, confidence: original.confidence, matchType: original.matchType },
                                                                                ...result.alternatives.filter((_, i) => i !== altIndex)
                                                                            ],
                                                                            hasCloseMatch: true,
                                                                            selectedAlternative: alt.glyph.name,
                                                                            corrected: true,
                                                                            originalGlyph: result.originalGlyph || result.glyph
                                                                        };
                                                                        
                                                                        // Track as correction
                                                                        trackCorrection(result.glyph.id, alt.glyph.id);
                                                                        
                                                                        setRecognitionResults(updatedResults);
                                                                        console.log(`üîÑ Swapped ${result.glyph.name} ‚Üí ${alt.glyph.name}`);
                                                                    }
                                                                }}
                                                                className="flex items-center gap-2 text-xs w-full hover:bg-orange-100 p-1 rounded cursor-pointer"
                                                            >
                                                                <span className="text-gray-400">‚óã</span>
                                                                <span>{alt.glyph.name}</span>
                                                                <span className="text-gray-500">({Math.round(alt.confidence * 100)}%)</span>
                                                                <span className="text-xs text-blue-500 ml-auto">tap to select</span>
                                                            </button>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                            
                                            {(result.thumbnail || (result.regionIndex !== undefined && isolatedGlyphs[result.regionIndex]?.thumbnail)) && (
                                                <div className="mt-2 flex items-center gap-2">
                                                    <span className="text-xs text-gray-500">Region:</span>
                                                    <img
                                                        src={result.thumbnail || (isolatedGlyphs[result.regionIndex]?.thumbnail)}
                                                        alt="Isolated region"
                                                        className="w-16 h-auto border border-gray-300 rounded"
                                                        onError={(e) => {
                                                            console.warn(`Thumbnail failed to load for index ${originalIndex}`, {
                                                                hasResultThumbnail: !!result.thumbnail,
                                                                regionIndex: result.regionIndex,
                                                                hasIsolatedGlyph: !!isolatedGlyphs[result.regionIndex],
                                                                hasIsolatedThumbnail: !!isolatedGlyphs[result.regionIndex]?.thumbnail
                                                            });
                                                            e.target.style.display = 'none';
                                                        }}
                                                    />
                                                </div>
                                            )}
                                        </div>
                                        <div className="flex gap-1">
                                            <button 
                                                onClick={() => startCorrection(originalIndex)} 
                                                className="text-orange-500 hover:text-orange-700 text-sm"
                                                title="Change glyph"
                                            >
                                                ‚úèÔ∏è
                                            </button>
                                            <button 
                                                onClick={() => {
                                                    setExcludeMode(originalIndex);
                                                    setExcludeRegions([]);
                                                }} 
                                                className="text-ancient-purple hover:text-ancient-purple text-sm"
                                                title="Exclude regions from this detection"
                                            >
                                                üî•
                                            </button>
                                            <button 
                                                onClick={() => startAdjustMode(originalIndex)} 
                                                className="text-teal-500 hover:text-teal-700 text-sm"
                                                title="Adjust box corners independently"
                                            >
                                                üîß
                                            </button>
                                            <button 
                                                onClick={() => toggleRegionSelection(originalIndex)} 
                                                className={`text-sm ${selectedRegions.has(originalIndex) ? 'text-stone-dark' : 'text-blue-400 hover:text-stone-dark'}`}
                                                title="Select for merging (select 2+ then click Merge)"
                                            >
                                                ‚ö°
                                            </button>
                                            <button 
                                                onClick={() => deleteDetection(originalIndex)} 
                                                className="text-red-500 hover:text-rust text-sm"
                                                title="Delete detection"
                                            >
                                                ‚úï
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex gap-2 flex-wrap">
                                        <button 
                                            onClick={() => validateDetection(originalIndex, true)} 
                                            className={`px-3 py-1 text-xs rounded ${validations[originalIndex]?.isCorrect ? 'bg-patina text-white' : 'bg-green-100 text-patina hover:bg-green-200'}`}
                                        >
                                            ‚úì Correct
                                        </button>
                                        <button 
                                            onClick={() => validateDetection(originalIndex, false)} 
                                            className={`px-3 py-1 text-xs rounded ${validations[originalIndex] && !validations[originalIndex].isCorrect ? 'bg-rust text-white' : 'bg-[#f5e8e4] text-rust hover:bg-red-200'}`}
                                        >
                                            ‚úó Incorrect
                                        </button>
                                        {viewMode === 'reading' && (
                                            <>
                                                <button 
                                                    onClick={() => toggleWordBoundary(displayIndex)} 
                                                    className={`px-3 py-1 text-xs rounded ${wordBoundaries.has(displayIndex) ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                    title="Mark word boundary after this glyph"
                                                >
                                                    | Word Break
                                                </button>
                                                <button 
                                                    onClick={() => toggleColumnBreak(displayIndex)} 
                                                    className={`px-3 py-1 text-xs rounded ${columnBreaks.has(displayIndex) ? 'bg-stone text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                    title="Mark column break after this glyph"
                                                >
                                                    || Column Break
                                                </button>
                                                <button 
                                                    onClick={() => toggleLineBreak(displayIndex)} 
                                                    className={`px-3 py-1 text-xs rounded ${lineBreaks.has(displayIndex) ? 'bg-ancient-purple text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                    title="Mark line break after this glyph"
                                                >
                                                    --- Line Break
                                                </button>
                                            </>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                    </div>
                    )}


                    {viewMode === 'reading' && recognitionResults.length > 0 && showTranscription && (
                        <div
                            ref={transcriptionRef} 
                            className="mb-6 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border-2 border-stone-light"
                            style={{
                                position: transcriptionPosition.x !== 0 || transcriptionPosition.y !== 0 ? 'fixed' : 'relative',
                                left: transcriptionPosition.x !== 0 ? `${transcriptionPosition.x}px` : 'auto',
                                top: transcriptionPosition.y !== 0 ? `${transcriptionPosition.y}px` : 'auto',
                                zIndex: isDraggingTranscription ? 1000 : transcriptionPosition.x !== 0 || transcriptionPosition.y !== 0 ? 100 : 'auto',
                                cursor: isDraggingTranscription ? 'grabbing' : 'auto',
                                maxWidth: transcriptionPosition.x !== 0 || transcriptionPosition.y !== 0 ? '600px' : 'none',
                                boxShadow: transcriptionPosition.x !== 0 || transcriptionPosition.y !== 0 ? '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)' : 'none'
                            }}
                        >
                            <div 
                                className="flex items-center justify-between mb-3 transcription-drag-handle"
                                onMouseDown={handleTranscriptionMouseDown}
                                style={{ cursor: 'grab' }}
                                title="Drag to reposition transcription box"
                            >
                                <h3 className="font-semibold text-gray-900 flex items-center gap-2">
                                    <span style={{ cursor: 'grab' }}>‚ãÆ‚ãÆ</span> Transcription
                                </h3>
                                <div className="flex gap-2">
                                    {(transcriptionPosition.x !== 0 || transcriptionPosition.y !== 0) && (
                                        <button 
                                            onClick={() => setTranscriptionPosition({ x: 0, y: 0 })}
                                            className="px-3 py-1 bg-gray-500 text-white text-sm rounded hover:bg-gray-600"
                                            title="Reset position"
                                        >
                                            ‚Ü∫ Reset
                                        </button>
                                    )}
                                    {/* TTS DISABLED - Vowels not identified in Semitic languages
                                    <button 
                                        onClick={() => speakTranscription()}
                                        className="px-3 py-1 bg-ancient-purple text-white text-sm rounded hover:bg-[#4a3d56] flex items-center gap-1"
                                        title="Listen to pronunciation"
                                    >
                                        üîä Listen
                                    </button>
                                    */}
                                    <button 
                                        onClick={copyTranscriptionToClipboard}
                                        className="px-3 py-1 bg-stone text-white text-sm rounded hover:bg-stone-dark flex items-center gap-1"
                                        title="Copy transcription to clipboard"
                                    >
                                        üìã Copy
                                    </button>
                                    <button 
                                        onClick={exportTranscription}
                                        className="px-3 py-1 bg-patina text-white text-sm rounded hover:bg-[#5d7a6d] flex items-center gap-1"
                                        title="Download transcription as text file"
                                    >
                                        üíæ Export TXT
                                    </button>
                                    <button 
                                        onClick={() => setShowTranscription(false)}
                                        className="px-3 py-1 bg-rust text-white text-sm rounded hover:bg-[#8d5d47] font-bold"
                                        title="Close transcription box"
                                    >
                                        ‚úï
                                    </button>
                                </div>
                            </div>
                            <div className="p-4 bg-white rounded border-2 border-stone shadow-inner">
                                <div 
                                    className="font-mono text-lg leading-relaxed"
                                    style={{
                                        fontFamily: showArabicLabels 
                                            ? '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' 
                                            : '"Courier New", monospace'
                                    }}
                                >
                                    {getReadingOrderedResults().map((result, index) => (
                                        <span key={index}>
                                            <span className="text-gray-900">
                                                {showArabicLabels 
                                                    ? (result.glyph.arabic || result.glyph.name)
                                                    : (result.glyph.transliteration || result.glyph.name)
                                                }
                                            </span>
                                            {lineBreaks.has(index) && <span className="text-ancient-purple font-bold mx-2">---</span>}
                                            {!lineBreaks.has(index) && columnBreaks.has(index) && <span className="text-stone-dark font-bold mx-1">||</span>}
                                            {!lineBreaks.has(index) && !columnBreaks.has(index) && wordBoundaries.has(index) && <span className="text-stone-dark font-bold mx-1">|</span>}
                                            {!lineBreaks.has(index) && !columnBreaks.has(index) && !wordBoundaries.has(index) && index < getReadingOrderedResults().length - 1 && <span className="text-gray-400">¬∑</span>}
                                        </span>
                                    ))}
                                </div>
                            </div>

                            <div className="mt-3 text-xs text-gray-600">
                                <span className="text-ancient-purple font-bold">---</span> = line break &middot; 
                                <span className="text-stone-dark font-bold">||</span> = column break &middot; 
                                <span className="text-stone-dark font-bold">|</span> = word boundary &middot; 
                                <span className="text-gray-400">&middot;</span> = glyph separator
                            </div>
                        </div>
                    )}

                    {/* Enhanced Transcription Display */}
                    {viewMode === 'reading' && recognitionResults.length > 0 && (
                        <div className="mt-6 p-4 bg-[#f3f1f4] rounded-lg border-2 border-ancient-purple">
                            <button
                                onClick={() => setShowEnhancedTranscription(!showEnhancedTranscription)}
                                className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700 mb-3"
                            >
                                <span>{showEnhancedTranscription ? '‚ñº' : '‚ñ∂'}</span>
                                <h3>üìú Enhanced Transcription Display</h3>
                            </button>
                            
                            {showEnhancedTranscription && (
                                <>
                                    <DismissableTip id="breaks-howto" className="mb-4">
                                        <div className="font-semibold mb-1">üí° How to use breaks:</div>
                                        <div className="text-xs">
                                            Use the break buttons on each glyph card (in reading mode) to mark the layout:
                                            <span className="ml-2 text-stone-dark font-bold">|</span> Word boundary
                                            <span className="ml-2 text-stone-dark font-bold">||</span> End of column
                                            <span className="ml-2 text-ancient-purple font-bold">---</span> End of line
                                            <br/>
                                            The <span className="inline-block w-4 h-4 rounded-full bg-ochre border border-[#8d7350] text-xs text-center text-white">N</span> numbers show reading order.
                                        </div>
                                    </DismissableTip>
                                    <div className="mb-4 p-4 bg-white rounded-lg border border-[#c9bfd4]">
                                        <div className="grid grid-cols-2 gap-4">
                                            {/* Script Selection */}
                                            <div>
                                                <label className="block text-sm font-semibold text-gray-700 mb-2">Script:</label>
                                                <div className="flex gap-2">
                                                    <button
                                                        onClick={() => setTranscriptionScript('english')}
                                                        className={`px-4 py-2 rounded text-sm font-medium ${
                                                            transcriptionScript === 'english' 
                                                                ? 'bg-ancient-purple text-white' 
                                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                        }`}
                                                    >
                                                        English (abc)
                                                    </button>
                                                    <button
                                                        onClick={() => setTranscriptionScript('arabic')}
                                                        className={`px-4 py-2 rounded text-sm font-medium ${
                                                            transcriptionScript === 'arabic' 
                                                                ? 'bg-ancient-purple text-white' 
                                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                        }`}
                                                    >
                                                        Arabic (ÿπ ÿ® ÿ™)
                                                    </button>
                                                </div>
                                            </div>

                                            {/* Format Selection */}
                                            <div>
                                                <label className="block text-sm font-semibold text-gray-700 mb-2">Direction:</label>
                                                <select
                                                    value={transcriptionFormat}
                                                    onChange={(e) => setTranscriptionFormat(e.target.value)}
                                                    className="w-full px-3 py-2 border border-gray-300 rounded text-sm"
                                                >
                                                    <option value="english-ltr">‚Üí Left to Right</option>
                                                    <option value="arabic-rtl">‚Üê Right to Left</option>
                                                    <option value="vertical-rl">‚Üì Top to Bottom (columns ‚Üí)</option>
                                                    <option value="vertical-lr">‚Üì Top to Bottom (columns ‚Üê)</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Transcription Display */}
                                    <div className="p-6 bg-white rounded-lg border-2 border-ancient-purple shadow-inner">
                                        {transcriptionFormat.startsWith('vertical') ? (
                                            // Vertical display - each line becomes a row of columns
                                            <div className="flex flex-col gap-8">
                                                {getEnhancedTranscription().map((line, lineIndex) => (
                                                    <div 
                                                        key={lineIndex} 
                                                        className={`flex gap-8 justify-center ${transcriptionFormat === 'vertical-rl' ? 'flex-row-reverse' : ''}`}
                                                    >
                                                        {line.map((columnText, colIndex) => (
                                                            <div 
                                                                key={colIndex}
                                                                className="font-mono leading-relaxed"
                                                                style={{
                                                                    writingMode: transcriptionFormat === 'vertical-rl' ? 'vertical-rl' : 'vertical-lr',
                                                                    textOrientation: 'upright',
                                                                    minHeight: '200px',
                                                                    fontSize: transcriptionScript === 'arabic' ? '2rem' : '1.5rem',
                                                                    fontFamily: transcriptionScript === 'arabic' 
                                                                        ? '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' 
                                                                        : '"Courier New", monospace'
                                                                }}
                                                            >
                                                                {columnText}
                                                            </div>
                                                        ))}
                                                    </div>
                                                ))}
                                            </div>
                                        ) : (
                                            // Horizontal display (LTR or RTL) - show lines stacked vertically
                                            <div className="flex flex-col gap-4">
                                                {getEnhancedTranscription().map((line, lineIndex) => (
                                                    <div 
                                                        key={lineIndex}
                                                        className="flex gap-6"
                                                        style={{
                                                            direction: transcriptionFormat === 'arabic-rtl' ? 'rtl' : 'ltr',
                                                            justifyContent: transcriptionFormat === 'arabic-rtl' ? 'flex-end' : 'flex-start'
                                                        }}
                                                    >
                                                        {line.map((columnText, colIndex) => (
                                                            <div 
                                                                key={colIndex}
                                                                className="font-mono leading-relaxed"
                                                                style={{
                                                                    fontSize: transcriptionScript === 'arabic' ? '2rem' : '1.5rem',
                                                                    fontFamily: transcriptionScript === 'arabic' 
                                                                        ? '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif' 
                                                                        : '"Courier New", monospace'
                                                                }}
                                                            >
                                                                {columnText}
                                                            </div>
                                                        ))}
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </div>

                                    <div className="mt-3 flex gap-2 justify-end">
                                        <button
                                            onClick={() => {
                                                const layoutStructure = getEnhancedTranscription();
                                                let text = '';
                                                
                                                if (transcriptionFormat === 'english-ltr') {
                                                    // LTR: Simple left-to-right with spaces
                                                    text = layoutStructure.map(line => 
                                                        line.join(' ')  // Columns as continuous text
                                                    ).join(' ');  // Lines as continuous text
                                                } else if (transcriptionFormat === 'arabic-rtl') {
                                                    // RTL: Right-to-left with spaces (text editors will handle RTL)
                                                    text = layoutStructure.map(line => 
                                                        line.join(' ')
                                                    ).join(' ');
                                                } else if (transcriptionFormat === 'vertical-rl') {
                                                    // Vertical RL: Show columns right-to-left, separated by ||
                                                    text = layoutStructure.map(line => 
                                                        line.reverse().join(' || ')  // Reverse for right-to-left reading
                                                    ).join('\n---\n');
                                                } else if (transcriptionFormat === 'vertical-lr') {
                                                    // Vertical LR: Show columns left-to-right, separated by ||
                                                    text = layoutStructure.map(line => 
                                                        line.join(' || ')
                                                    ).join('\n---\n');
                                                }
                                                
                                                navigator.clipboard.writeText(text);
                                                alert('Transcription copied to clipboard!');
                                            }}
                                            className="px-4 py-2 bg-stone text-white text-sm rounded hover:bg-stone-dark"
                                        >
                                            üìã Copy Text
                                        </button>
                                        <button
                                            onClick={() => {
                                                const layoutStructure = getEnhancedTranscription();
                                                let text = '';
                                                
                                                if (transcriptionFormat === 'english-ltr') {
                                                    // LTR: Simple left-to-right with spaces
                                                    text = layoutStructure.map(line => 
                                                        line.join(' ')
                                                    ).join(' ');
                                                } else if (transcriptionFormat === 'arabic-rtl') {
                                                    // RTL: Right-to-left with spaces
                                                    text = layoutStructure.map(line => 
                                                        line.join(' ')
                                                    ).join(' ');
                                                } else if (transcriptionFormat === 'vertical-rl') {
                                                    // Vertical RL: Show columns right-to-left, separated by ||
                                                    text = layoutStructure.map(line => 
                                                        line.reverse().join(' || ')
                                                    ).join('\n---\n');
                                                } else if (transcriptionFormat === 'vertical-lr') {
                                                    // Vertical LR: Show columns left-to-right, separated by ||
                                                    text = layoutStructure.map(line => 
                                                        line.join(' || ')
                                                    ).join('\n---\n');
                                                }
                                                
                                                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                                                const url = URL.createObjectURL(blob);
                                                const a = document.createElement('a');
                                                a.href = url;
                                                a.download = `hakli_transcription_${transcriptionScript}_${transcriptionFormat}_${new Date().toISOString().slice(0, 10)}.txt`;
                                                document.body.appendChild(a);
                                                a.click();
                                                document.body.removeChild(a);
                                                URL.revokeObjectURL(url);
                                            }}
                                            className="px-4 py-2 bg-patina text-white text-sm rounded hover:bg-[#5d7a6d]"
                                        >
                                            üíæ Export TXT
                                        </button>
                                    </div>
                                </>
                            )}
                        </div>
                    )}

                    {/* Translation Section */}
                    {viewMode === 'reading' && recognitionResults.length > 0 && (
                        <div className="mt-6 p-4 bg-[#f0f5f3] rounded-lg border-2 border-patina">
                            <button
                                onClick={() => setShowTranslationSection(!showTranslationSection)}
                                className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700 mb-3"
                            >
                                <span>{showTranslationSection ? '‚ñº' : '‚ñ∂'}</span>
                                <h3>üåç Translation</h3>
                            </button>
                            
                            {showTranslationSection && (
                                <>
                                    {!dismissedTips['translation-section'] && (
                                        <DismissableTip id="translation-section" className="mb-4">
                                            <strong>üí° Add your translation:</strong> Enter translations in English and/or Arabic. Toggle between languages below. Both will appear in the exported HTML report.
                                        </DismissableTip>
                                    )}

                                    <div className="space-y-4">
                                        {/* Inscription Title Field */}
                                        <div className="mb-4 pb-4 border-b border-[#b5d4c8]">
                                            <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                üè∑Ô∏è Inscription Title (optional):
                                            </label>
                                            <input
                                                type="text"
                                                value={inscriptionTitle}
                                                onChange={(e) => setInscriptionTitle(e.target.value)}
                                                className="w-full px-3 py-2 border border-gray-300 rounded text-sm"
                                                placeholder="e.g., Salalah Temple Inscription, Site A Fragment 3..."
                                            />
                                            <p className="text-xs text-gray-500 mt-1">This title will be used in the filename and Drive listing</p>
                                        </div>

                                        {/* Language Toggle */}
                                        <div className="flex gap-2">
                                            <button
                                                onClick={() => setTranscriptionScript('english')}
                                                className={`px-4 py-2 rounded text-sm font-medium ${
                                                    transcriptionScript === 'english' 
                                                        ? 'bg-patina text-white' 
                                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                }`}
                                            >
                                                English Translation
                                            </button>
                                            <button
                                                onClick={() => setTranscriptionScript('arabic')}
                                                className={`px-4 py-2 rounded text-sm font-medium ${
                                                    transcriptionScript === 'arabic' 
                                                        ? 'bg-patina text-white' 
                                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                }`}
                                            >
                                                Arabic Translation (ÿ™ÿ±ÿ¨ŸÖÿ©)
                                            </button>
                                        </div>

                                        {/* Translation Input */}
                                        {transcriptionScript === 'english' ? (
                                            <div>
                                                <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                    English Translation:
                                                </label>
                                                <textarea
                                                    value={translationEnglish}
                                                    onChange={(e) => setTranslationEnglish(e.target.value)}
                                                    className="w-full px-3 py-2 border border-gray-300 rounded text-sm"
                                                    rows="4"
                                                    placeholder="Enter English translation here..."
                                                />
                                            </div>
                                        ) : (
                                            <div>
                                                <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                    Arabic Translation (ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ©):
                                                </label>
                                                <textarea
                                                    value={translationArabic}
                                                    onChange={(e) => setTranslationArabic(e.target.value)}
                                                    className="w-full px-3 py-2 border border-gray-300 rounded text-lg"
                                                    style={{
                                                        direction: 'rtl',
                                                        fontFamily: '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif'
                                                    }}
                                                    rows="4"
                                                    placeholder="ÿ£ÿØÿÆŸÑ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ŸáŸÜÿß..."
                                                />
                                            </div>
                                        )}

                                        {/* Notes Field */}
                                        <div className="mt-4 pt-4 border-t border-[#b5d4c8]">
                                            <label className="block text-sm font-semibold text-gray-700 mb-2">
                                                üìù Inscription Notes:
                                            </label>
                                            <textarea
                                                value={inscriptionNotes}
                                                onChange={(e) => setInscriptionNotes(e.target.value)}
                                                className="w-full px-3 py-2 border border-gray-300 rounded text-sm"
                                                rows="3"
                                                placeholder="Add any notes, observations, or context about this inscription..."
                                            />
                                        </div>

                                        {/* Preview */}
                                        {(translationEnglish || translationArabic) && (
                                            <div className="p-4 bg-white rounded border-2 border-patina">
                                                <div className="text-sm font-semibold text-gray-700 mb-2">Preview:</div>
                                                {translationEnglish && (
                                                    <div className="mb-2">
                                                        <span className="text-xs text-gray-500">English:</span>
                                                        <div className="text-base">{translationEnglish}</div>
                                                    </div>
                                                )}
                                                {translationArabic && (
                                                    <div>
                                                        <span className="text-xs text-gray-500">Arabic:</span>
                                                        <div 
                                                            className="text-lg" 
                                                            style={{
                                                                direction: 'rtl',
                                                                fontFamily: '"Traditional Arabic", "Arabic Typesetting", "Scheherazade", serif'
                                                            }}
                                                        >
                                                            {translationArabic}
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                </>
                            )}
                        </div>
                    )}

                    <div className="mt-8 p-4 bg-gray-50 rounded-lg">
                        <div className="text-sm text-gray-600">
                            <div className="flex items-center gap-2">
                                <span className={`w-2 h-2 rounded-full ${isOpenCvReady ? 'bg-patina' : 'bg-rust'}`} />
                                OpenCV Status: {isOpenCvReady ? 'Ready' : 'Loading...'}
                                {actionHistory.length > 0 && <span className="ml-4 text-xs text-gray-500">{actionHistory.length} actions recorded</span>}
                            </div>
                        </div>
                    </div>

                    {/* Cloud Storage & Sharing - Always visible */}
                    <div className="mt-6 p-4 bg-[#f7f3ed] rounded-lg border-2 border-ochre">
                        <button
                            onClick={() => setIsCorrectionMemoryCollapsed(!isCorrectionMemoryCollapsed)}
                            className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700 mb-3"
                        >
                                <span>{isCorrectionMemoryCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                <h3>‚òÅÔ∏è Cloud Storage & Sharing</h3>
                            </button>
                            
                            {!isCorrectionMemoryCollapsed && (
                            <>
                            {/* YOUR INSCRIPTIONS (Private Work) - Section 1 */}
                            <div className="mb-4">
                                <h4 className="text-xs font-semibold text-gray-600 uppercase mb-2">Your Inscriptions (Private Work)</h4>
                                <div className="flex flex-wrap gap-3">
                                    <button 
                                        onClick={saveToGoogleDrive}
                                        className="px-4 py-2 bg-stone-dark text-white rounded hover:bg-stone flex items-center gap-2 font-semibold"
                                        title="Save your work-in-progress (auto-backup, only you can access)"
                                    >
                                        üíæ Save to Drive
                                    </button>
                                    <button
                                        onClick={async () => {
                                            if (typeof DriveSync === 'undefined' || !DriveSync.isSignedIn()) {
                                                alert('‚ö†Ô∏è Please sign in to Google Drive first.\n\nClick "üîÑ Change Account" to sign in with your Google account.');
                                                return;
                                            }
                                            
                                            try {
                                                const files = await DriveSync.listFiles();
                                                console.log('Drive files:', files);
                                                
                                                if (files.length === 0) {
                                                    alert('üìÇ No HKI files found in your Hakli_Inscriptions folder.\n\nSave an inscription first using "üíæ Save to Drive" above.');
                                                    return;
                                                }
                                                
                                                // Load all file thumbnails
                                                setShowFilePickerModal({ files, isLoading: true });
                                                
                                                const filesWithThumbnails = await Promise.all(
                                                    files.map(async (file) => {
                                                        try {
                                                            const hkiData = await DriveSync.loadFromCloud(file.id);
                                                            console.log('üì∏ Thumbnail debug for', file.name, ':', {
                                                                hasImage: !!hkiData.image,
                                                                imageLength: hkiData.image ? hkiData.image.length : 0,
                                                                imageStart: hkiData.image ? hkiData.image.substring(0, 50) : null,
                                                                hasLocation: !!hkiData.location
                                                            });
                                                            return {
                                                                ...file,
                                                                thumbnail: hkiData.image || null,
                                                                title: hkiData.inscriptionTitle || file.name,
                                                                location: hkiData.location || null
                                                            };
                                                        } catch (err) {
                                                            console.error(`Failed to load thumbnail for ${file.name}:`, err);
                                                            return { ...file, thumbnail: null, title: file.name, location: null };
                                                        }
                                                    })
                                                );
                                                
                                                setShowFilePickerModal({ files: filesWithThumbnails, isLoading: false });
                                            } catch (err) {
                                                console.error('Load error:', err);
                                                alert('‚ùå Load failed: ' + err.message);
                                            }
                                        }}
                                        className="px-4 py-2 bg-stone text-white rounded hover:bg-stone-dark flex items-center gap-2"
                                        title="Load saved inscriptions to resume editing"
                                    >
                                        üìÇ Load from Drive
                                    </button>
                                    <button
                                        onClick={() => {
                                            // Export full HKI file for sharing with collaborators
                                            const hkiData = {
                                                version: '1.0',
                                                created: new Date().toISOString(),
                                                source: 'Hakli Glyph Recognizer v251215',
                                                inscriptionTitle: inscriptionTitle || 'Untitled Inscription',
                                                inscriptionNotes: inscriptionNotes || '',
                                                image: image,
                                                preprocessing: preprocessing,
                                                recognitionResults: recognitionResults,
                                                readingOrder: readingOrder,
                                                readingDirection: readingDirection,
                                                wordBoundaries: Array.from(wordBoundaries),
                                                columnBreaks: Array.from(columnBreaks),
                                                lineBreaks: Array.from(lineBreaks),
                                                validations: validations,
                                                translationEnglish: translationEnglish,
                                                translationArabic: translationArabic
                                            };
                                            
                                            const blob = new Blob([JSON.stringify(hkiData, null, 2)], { type: 'application/json' });
                                            const url = URL.createObjectURL(blob);
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.download = `hakli_export_${new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5)}.hki.json`;
                                            document.body.appendChild(a);
                                            a.click();
                                            document.body.removeChild(a);
                                            URL.revokeObjectURL(url);
                                            
                                            alert('üì• Full HKI file downloaded!\n\n‚ö†Ô∏è This file contains the complete inscription including the photo.\nShare only with trusted collaborators.');
                                        }}
                                        className="px-4 py-2 bg-ancient-purple text-white rounded hover:bg-[#4a3d56] flex items-center gap-2"
                                        title="Download complete file to share with trusted collaborators"
                                    >
                                        üì• Export Full HKI
                                    </button>
                                    <button
                                        onClick={async () => {
                                            if (typeof DriveSync === 'undefined') {
                                                alert('‚ùå DriveSync module not loaded');
                                                return;
                                            }
                                            
                                            // If signed in, sign out
                                            if (DriveSync.isSignedIn()) {
                                                try {
                                                    await DriveSync.signOut();
                                                    setDriveAuthStatus(prev => prev + 1); // Force re-render
                                                    alert('‚úÖ Signed out from Google Drive.\n\nClick "üîÑ Change Account" again to sign in with a different Google account.');
                                                } catch (err) {
                                                    console.error('Sign-out error:', err);
                                                    alert('‚ùå Sign-out failed: ' + err.message);
                                                }
                                            } else {
                                                // If signed out, open the Cloud Sync modal to sign in
                                                setShowCloudSyncModal(true);
                                            }
                                        }}
                                        className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 flex items-center gap-2"
                                        title={DriveSync && DriveSync.isSignedIn() ? "Sign out and switch to a different Google account" : "Sign in to Google Drive"}
                                    >
                                        üîÑ Change Account
                                    </button>
                                </div>
                            </div>

                            {/* GLYPH CORRECTIONS (Public-Safe Templates) - Section 2 */}
                            <div className="mb-4">
                                <h4 className="text-xs font-semibold text-gray-600 uppercase mb-2">Glyph Corrections (Public-Safe Templates)</h4>
                                <div className="flex flex-wrap gap-3 items-center">
                                    <input
                                        type="file"
                                        accept=".json"
                                        onChange={(e) => {
                                            const file = e.target.files[0];
                                            if (file) {
                                                    const reader = new FileReader();
                                                    reader.onload = (event) => importCorrectionMemory(event.target.result);
                                                    reader.readAsText(file);
                                                }
                                            }}
                                            id="import-corrections"
                                             className="block text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-yellow-100 file:text-yellow-700 hover:file:bg-yellow-200"
                                     />
                                        <button
                                            onClick={() => setShowCommunityModal(true)}
                                            className="px-4 py-2 bg-patina text-white rounded hover:bg-[#5d7a6d] flex items-center gap-2"
                                            title="Download community template improvements"
                                            >
                                            ‚¨áÔ∏è Import from Community
                                        </button>
                                        <button
                                            onClick={() => {
                                                if (confirm('Clear ALL glyph corrections permanently? This cannot be undone. Consider exporting first.')) {
                                                    localStorage.removeItem('hakliCorrections');
                                                    alert('‚úÖ All glyph corrections cleared!');
                                                }
                                            }}
                                            className="px-4 py-2 bg-rust text-white rounded hover:bg-[#8d5d47]"
                                            title="Clear all correction data"
                                        >
                                            üóëÔ∏è Clear All
                                        </button>
                                        <button
                                            onClick={exportCorrectionMemory}
                                            className="px-4 py-2 bg-ochre text-white rounded hover:bg-[#a18259] flex items-center gap-2"
                                            title="Share your template improvements (no photos/locations)"
                                        >
                                            ‚¨ÜÔ∏è Share Corrections Only
                                        </button>
                                        <button
                                            onClick={() => setShowCorrectionAnalysis(true)}
                                            className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 flex items-center gap-2"
                                            title="View statistics on your correction patterns"
                                        >
                                            üìä View Stats
                                        </button>
                                </div>
                            </div>

                            <DismissableTip id="cloud-storage-tip">
                                <strong>üí° Three ways to share:</strong>
                                <ul className="mt-2 space-y-1 text-sm">
                                    <li><strong>üíæ Save to Drive</strong> - Your personal backup (only you can access)</li>
                                    <li><strong>üì• Export Full HKI</strong> - Share complete inscription with trusted collaborators (includes photos - use carefully!)</li>
                                    <li><strong>‚¨ÜÔ∏è Share Corrections Only</strong> - Contribute template improvements to community (public-safe: no photos, no locations)</li>
                                </ul>
                            </DismissableTip>
                            </>
                            )}
                    </div>
                    
                    {/* Export Options - Always visible */}
                    <div className="mt-6 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                        <button
                            onClick={() => setIsExportOptionsCollapsed(!isExportOptionsCollapsed)}
                            className="flex items-center gap-2 font-semibold text-gray-900 hover:text-gray-700 mb-3"
                        >
                                <span>{isExportOptionsCollapsed ? '‚ñ∂' : '‚ñº'}</span>
                                <h3>Export Options</h3>
                            </button>
                            
                            {!isExportOptionsCollapsed && (
                            <>
                            {/* ESSENTIAL EXPORTS - Row 1 */}
                            <div className="mb-4">
                                <h4 className="text-xs font-semibold text-gray-600 uppercase mb-2">Reports & Documents</h4>
                                <div className="flex flex-wrap gap-3">
                                    <button
                                        onClick={exportHtmlReport}
                                        className="px-4 py-2 bg-emerald-500 text-white rounded hover:bg-emerald-600 flex items-center gap-2"
                                        title="Generate beautiful bilingual report"
                                    >
                                        üìÑ Export HTML Report
                                    </button>
                                </div>
                            </div>

                            {/* TEXT & IMAGES - Row 2 */}
                            <div className="mb-4">
                                <h4 className="text-xs font-semibold text-gray-600 uppercase mb-2">Text & Images</h4>
                                <div className="flex flex-wrap gap-3">
                                    {viewMode === 'reading' && (
                                        <button 
                                            onClick={exportTranscription}
                                            className="px-4 py-2 bg-patina text-white rounded hover:bg-[#5d7a6d] flex items-center gap-2"
                                            title="Export transcription as plain text file"
                                        >
                                            üìã Export Transcription (TXT)
                                        </button>
                                    )}
                                    <button 
                                        onClick={exportAnnotatedImage}
                                        className="px-4 py-2 bg-stone text-white rounded hover:bg-stone-dark flex items-center gap-2"
                                        title="Export image with glyph boxes and labels"
                                    >
                                        üñºÔ∏è Export Annotated Image
                                    </button>
                                </div>
                            </div>

                            {/* COMMUNITY SHARING - Row 3 */}
                            <div className="mb-4">
                                <h4 className="text-xs font-semibold text-gray-600 uppercase mb-2">Advanced</h4>
                                <div className="flex flex-wrap gap-3">
                                    <button
                                        onClick={openJsonViewer}
                                        className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 flex items-center gap-2"
                                        title="View current inscription data (HKI format)"
                                    >
                                        üîç View HKI Data
                                    </button>
                                </div>
                            </div>

                            <DismissableTip id="export-options-tip" className="mt-3">
                                <strong>üí° Tip:</strong> For saving your work and sharing inscriptions, see <strong>‚òÅÔ∏è Cloud Storage & Sharing</strong> section above.
                            </DismissableTip>
                            </>
                            )}
                    </div>
                    
                    {showChartViewer && equivalenceChart && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setShowChartViewer(false)}>
                            <div className="bg-white rounded-lg max-w-7xl w-full max-h-[90vh] flex flex-col shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                {/* Sticky Header - Outside scrollable area */}
                                <div className="flex items-center justify-between p-6 pb-4 border-b border-gray-200 flex-shrink-0">
                                    <h3 className="text-2xl font-bold text-gray-900">üìä Glyph Equivalence Chart</h3>
                                    <button
                                        onClick={() => setShowChartViewer(false)}
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                    >
                                        &times;
                                    </button>
                                </div>

                                {/* Scrollable Content */}
                                <div className="overflow-y-auto p-6 pt-4 flex-1">

                                <div className="mb-4 p-3 bg-[#f5f3f0] rounded-lg">
                                    <div className="text-sm text-gray-700">
                                        <strong>{equivalenceChart.glyphs.length}</strong> glyphs loaded with <strong>{Object.keys(loadedGlyphImages).length}</strong> total images
                                    </div>
                                </div>

                                <div className="space-y-6">
                                    {equivalenceChart.glyphs.map((glyph) => {
                                        const primaryLoaded = loadedGlyphImages[glyph.id]; // Primary uses just the glyph.id
                                        const variantCount = glyph.images.variants?.length || 0;
                                        const exampleCount = glyph.images.examples?.length || 0;
                                        const variantsLoaded = glyph.images.variants?.filter((_, idx) => 
                                            loadedGlyphImages[`${glyph.id}_variant_${idx}`]
                                        ).length || 0;
                                        const examplesLoaded = glyph.images.examples?.filter((_, idx) => 
                                            loadedGlyphImages[`${glyph.id}_example_${idx}`]
                                        ).length || 0;
                                        
                                        return (
                                            <div key={glyph.id} className="border-2 border-gray-200 rounded-lg p-4 hover:border-ancient-purple transition-colors">
                                                <div className="flex items-start gap-4">
                                                    {/* Glyph Info */}
                                                    <div className="flex-shrink-0 text-center">
                                                        <div className="text-4xl font-bold text-ancient-purple mb-1">
                                                            {glyph.arabic || '?'}
                                                        </div>
                                                        <div className="text-sm font-mono text-gray-600">
                                                            {glyph.name}
                                                        </div>
                                                        <div className="text-xs text-gray-500 mt-1">
                                                            ID: {glyph.id}
                                                        </div>
                                                    </div>

                                                    {/* Images Grid */}
                                                    <div className="flex-1">
                                                        {/* Primary Image */}
                                                        <div className="mb-3">
                                                            <div className="flex items-center gap-2 mb-2">
                                                                <h4 className="text-sm font-semibold text-gray-700">Primary</h4>
                                                                {primaryLoaded ? (
                                                                    <span className="text-xs text-patina">‚úÖ Loaded</span>
                                                                ) : (
                                                                    <span className="text-xs text-rust">‚ùå Not loaded</span>
                                                                )}
                                                            </div>
                                                            <div className="flex flex-wrap gap-2">
                                                                {primaryLoaded ? (
                                                                    <div className="relative group">
                                                                        <img 
                                                                            src={primaryLoaded.src} 
                                                                            alt={`Primary: ${glyph.name}`}
                                                                            className="h-16 border-2 border-gray-300 rounded hover:border-ancient-purple transition-colors bg-white p-1"
                                                                        />
                                                                        <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-10 transition-opacity rounded"></div>
                                                                    </div>
                                                                ) : (
                                                                    <div className="h-16 w-16 border-2 border-dashed border-gray-300 rounded flex items-center justify-center text-gray-400 text-xs">
                                                                        No image
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>

                                                        {/* Variants */}
                                                        {variantCount > 0 && (
                                                            <div className="mb-3">
                                                                <div className="flex items-center gap-2 mb-2">
                                                                    <h4 className="text-sm font-semibold text-gray-700">
                                                                        Variants ({variantsLoaded}/{variantCount})
                                                                    </h4>
                                                                    {variantsLoaded === variantCount ? (
                                                                        <span className="text-xs text-patina">‚úÖ All loaded</span>
                                                                    ) : (
                                                                        <span className="text-xs text-orange-600">‚ö†Ô∏è {variantCount - variantsLoaded} missing</span>
                                                                    )}
                                                                </div>
                                                                <div className="flex flex-wrap gap-2">
                                                                    {glyph.images.variants.map((_, idx) => {
                                                                        const variantImg = loadedGlyphImages[`${glyph.id}_variant_${idx}`];
                                                                        return variantImg ? (
                                                                            <div key={idx} className="relative group">
                                                                                <img 
                                                                                    src={variantImg.src} 
                                                                                    alt={`Variant ${idx + 1}: ${glyph.name}`}
                                                                                    className="h-16 border-2 border-gray-300 rounded hover:border-ancient-purple transition-colors bg-white p-1"
                                                                                />
                                                                                <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-10 transition-opacity rounded"></div>
                                                                            </div>
                                                                        ) : (
                                                                            <div key={idx} className="h-16 w-16 border-2 border-dashed border-gray-300 rounded flex items-center justify-center text-gray-400 text-xs">
                                                                                V{idx + 1}
                                                                            </div>
                                                                        );
                                                                    })}
                                                                </div>
                                                            </div>
                                                        )}

                                                        {/* Examples */}
                                                        {exampleCount > 0 && (
                                                            <div>
                                                                <div className="flex items-center gap-2 mb-2">
                                                                    <h4 className="text-sm font-semibold text-gray-700">
                                                                        Examples ({examplesLoaded}/{exampleCount})
                                                                    </h4>
                                                                    {examplesLoaded === exampleCount ? (
                                                                        <span className="text-xs text-patina">‚úÖ All loaded</span>
                                                                    ) : (
                                                                        <span className="text-xs text-orange-600">‚ö†Ô∏è {exampleCount - examplesLoaded} missing</span>
                                                                    )}
                                                                </div>
                                                                <div className="flex flex-wrap gap-2">
                                                                    {glyph.images.examples.map((_, idx) => {
                                                                        const exampleImg = loadedGlyphImages[`${glyph.id}_example_${idx}`];
                                                                        return exampleImg ? (
                                                                            <div key={idx} className="relative group">
                                                                                <img 
                                                                                    src={exampleImg.src} 
                                                                                    alt={`Example ${idx + 1}: ${glyph.name}`}
                                                                                    className="h-16 border-2 border-gray-300 rounded hover:border-ancient-purple transition-colors bg-white p-1"
                                                                                />
                                                                                <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-10 transition-opacity rounded"></div>
                                                                            </div>
                                                                        ) : (
                                                                            <div key={idx} className="h-16 w-16 border-2 border-dashed border-gray-300 rounded flex items-center justify-center text-gray-400 text-xs">
                                                                                E{idx + 1}
                                                                            </div>
                                                                        );
                                                                    })}
                                                                </div>
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                                </div>
                                {/* End of Scrollable Content */}

                                {/* Sticky Footer - Outside scrollable area */}
                                <div className="p-6 pt-4 border-t border-gray-200 flex-shrink-0">
                                    <button
                                        onClick={() => setShowChartViewer(false)}
                                        className="w-full px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3e54] font-semibold"
                                    >
                                        Close Chart Viewer
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {showCorrectionAnalysis && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setShowCorrectionAnalysis(false)}>
                            <div className="bg-white rounded-lg max-w-5xl w-full max-h-[90vh] flex flex-col shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                {/* Header */}
                                <div className="flex items-center justify-between p-6 pb-4 border-b border-gray-200 flex-shrink-0">
                                    <h3 className="text-2xl font-bold text-gray-900">üìä Correction Analysis</h3>
                                    <button
                                        onClick={() => setShowCorrectionAnalysis(false)}
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                    >
                                        &times;
                                    </button>
                                </div>

                                {/* Scrollable Content */}
                                <div className="overflow-y-auto p-6 pt-4 flex-1">
                                    {(() => {
                                        const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                                        const correctionKeys = Object.keys(corrections);
                                        
                                        if (correctionKeys.length === 0) {
                                            return (
                                                <div className="text-center py-12">
                                                    <div className="text-6xl mb-4">üì≠</div>
                                                    <h4 className="text-xl font-semibold text-gray-700 mb-2">No Corrections Yet</h4>
                                                    <p className="text-gray-600">
                                                        Start correcting misidentified glyphs to build up your correction memory.
                                                        This analysis will help you identify which glyphs need better template images.
                                                    </p>
                                                </div>
                                            );
                                        }

                                        // Calculate statistics
                                        const stats = correctionKeys.map(key => {
                                            const data = corrections[key];
                                            
                                            // Safety check: ensure data structure is valid
                                            if (!data || !data.corrections || !Array.isArray(data.corrections) || data.corrections.length === 0) {
                                                return null;
                                            }
                                            
                                            // Safety check: ensure originalGlyph exists
                                            if (!data.originalGlyph || !data.originalGlyph.id) {
                                                return null;
                                            }
                                            
                                            const totalCorrections = data.corrections.reduce((sum, c) => sum + (c.count || 0), 0);
                                            const uniqueCorrections = data.corrections.length;
                                            const mostCommon = [...data.corrections].sort((a, b) => (b.count || 0) - (a.count || 0))[0];
                                            
                                            return {
                                                originalGlyph: data.originalGlyph,
                                                totalCorrections,
                                                uniqueCorrections,
                                                mostCommon,
                                                allCorrections: data.corrections
                                            };
                                        }).filter(s => s !== null).sort((a, b) => b.totalCorrections - a.totalCorrections);

                                        const totalAllCorrections = stats.reduce((sum, s) => sum + s.totalCorrections, 0);

                                        return (
                                            <>
                                                {/* Summary Stats */}
                                                <div className="grid grid-cols-3 gap-4 mb-6">
                                                    <div className="bg-[#f5f3f0] border-2 border-stone-light rounded-lg p-4">
                                                        <div className="text-3xl font-bold text-stone-dark">{correctionKeys.length}</div>
                                                        <div className="text-sm text-gray-600">Glyphs Corrected</div>
                                                    </div>
                                                    <div className="bg-[#f0f5f3] border-2 border-[#b5d4c8] rounded-lg p-4">
                                                        <div className="text-3xl font-bold text-patina">{totalAllCorrections}</div>
                                                        <div className="text-sm text-gray-600">Total Corrections</div>
                                                    </div>
                                                    <div className="bg-[#f3f1f4] border-2 border-[#c9bfd4] rounded-lg p-4">
                                                        <div className="text-3xl font-bold text-ancient-purple">
                                                            {stats.length > 0 ? Math.round(totalAllCorrections / stats.length) : 0}
                                                        </div>
                                                        <div className="text-sm text-gray-600">Avg per Glyph</div>
                                                    </div>
                                                </div>

                                                {/* Priority List */}
                                                <div className="mb-4">
                                                    <h4 className="text-lg font-semibold text-gray-900 mb-2">
                                                        üéØ Priority: Glyphs Needing Better Templates
                                                    </h4>
                                                    <p className="text-sm text-gray-600 mb-4">
                                                        Sorted by frequency of corrections. High correction counts indicate template images may need improvement.
                                                    </p>
                                                </div>

                                                {/* Detailed List */}
                                                <div className="space-y-4">
                                                    {stats.map((stat, idx) => {
                                                        const priority = stat.totalCorrections >= 10 ? 'high' : 
                                                                       stat.totalCorrections >= 5 ? 'medium' : 'low';
                                                        const priorityColors = {
                                                            high: 'border-rust bg-red-50',
                                                            medium: 'border-orange-300 bg-orange-50',
                                                            low: 'border-gray-300 bg-gray-50'
                                                        };
                                                        const priorityBadges = {
                                                            high: 'bg-rust',
                                                            medium: 'bg-orange-500',
                                                            low: 'bg-gray-500'
                                                        };

                                                        return (
                                                            <div key={stat.originalGlyph.id} className={`border-2 rounded-lg p-4 ${priorityColors[priority]}`}>
                                                                <div className="flex items-start gap-4">
                                                                    {/* Rank & Priority */}
                                                                    <div className="flex-shrink-0 text-center">
                                                                        <div className="text-2xl font-bold text-gray-600">#{idx + 1}</div>
                                                                        <div className={`mt-1 px-2 py-1 ${priorityBadges[priority]} text-white text-xs rounded uppercase font-semibold`}>
                                                                            {priority}
                                                                        </div>
                                                                    </div>

                                                                    {/* Glyph Info */}
                                                                    <div className="flex-shrink-0">
                                                                        <div className="text-4xl font-bold text-ancient-purple mb-1">
                                                                            {stat.originalGlyph.arabic || '?'}
                                                                        </div>
                                                                        <div className="text-sm font-mono text-gray-600">
                                                                            {stat.originalGlyph.name}
                                                                        </div>
                                                                        <div className="text-xs text-gray-500">
                                                                            ID: {stat.originalGlyph.id}
                                                                        </div>
                                                                    </div>

                                                                    {/* Statistics */}
                                                                    <div className="flex-1">
                                                                        <div className="mb-3">
                                                                            <div className="text-sm font-semibold text-gray-700 mb-1">
                                                                                Correction Statistics:
                                                                            </div>
                                                                            <div className="flex gap-4 text-sm">
                                                                                <div>
                                                                                    <span className="font-semibold text-gray-900">{stat.totalCorrections}</span>
                                                                                    <span className="text-gray-600"> total corrections</span>
                                                                                </div>
                                                                                <div>
                                                                                    <span className="font-semibold text-gray-900">{stat.uniqueCorrections}</span>
                                                                                    <span className="text-gray-600"> unique targets</span>
                                                                                </div>
                                                                            </div>
                                                                        </div>

                                                                        <div className="mb-2">
                                                                            <div className="text-sm font-semibold text-gray-700 mb-2">
                                                                                Most Often Corrected To:
                                                                            </div>
                                                                            {stat.mostCommon && stat.mostCommon.to ? (
                                                                            <div className="flex items-center gap-3 p-2 bg-white rounded border border-gray-200">
                                                                                <div className="text-2xl font-bold text-patina">
                                                                                    {stat.mostCommon.to.arabic || stat.mostCommon.to.name || '?'}
                                                                                </div>
                                                                                <div className="flex-1">
                                                                                    <div className="text-sm font-mono text-gray-700">
                                                                                        {stat.mostCommon.to.name || 'Unknown'}
                                                                                    </div>
                                                                                    <div className="text-xs text-gray-500">
                                                                                        {stat.mostCommon.count || 0} times 
                                                                                        ({Math.round((stat.mostCommon.count || 0) / stat.totalCorrections * 100)}% of corrections)
                                                                                    </div>
                                                                                </div>
                                                                            </div>
                                                                            ) : (
                                                                                <div className="p-2 bg-gray-100 rounded text-sm text-gray-600">
                                                                                    No correction data available
                                                                                </div>
                                                                            )}
                                                                        </div>

                                                                        {stat.allCorrections.length > 1 && (
                                                                            <div className="mt-2">
                                                                                <div className="text-xs text-gray-600 mb-1">Other corrections:</div>
                                                                                <div className="flex flex-wrap gap-2">
                                                                                    {stat.allCorrections.slice(1).map((c, i) => (
                                                                                        <div key={i} className="px-2 py-1 bg-white border border-gray-200 rounded text-xs">
                                                                                            <span className="font-bold">{c.to.arabic || c.to.name}</span>
                                                                                            <span className="text-gray-500 ml-1">√ó{c.count}</span>
                                                                                        </div>
                                                                                    ))}
                                                                                </div>
                                                                            </div>
                                                                        )}

                                                                        <div className="mt-3 p-2 bg-[#f7f3ed] border border-[#d4c4a8] rounded">
                                                                            <div className="text-xs font-semibold text-[#6d5d42] mb-1">üí° Recommendation:</div>
                                                                            <div className="text-xs text-gray-700">
                                                                                {priority === 'high' && 
                                                                                    `High priority! This glyph is frequently misidentified. Add clearer template images or more variants to Hakli_glyphs.JSON.`
                                                                                }
                                                                                {priority === 'medium' && 
                                                                                    `Consider reviewing this glyph's template images. Add variants if different inscription styles exist.`
                                                                                }
                                                                                {priority === 'low' && 
                                                                                    `Low correction frequency suggests templates are working reasonably well.`
                                                                                }
                                                                            </div>
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>

                                                {/* Action Tips */}
                                                <div className="mt-6 p-4 bg-[#f5f3f0] border-2 border-stone-light rounded-lg">
                                                    <h4 className="font-semibold text-stone-dark mb-2">üìù Next Steps:</h4>
                                                    <ul className="text-sm text-gray-700 space-y-1 list-disc list-inside">
                                                        <li>Focus on high-priority glyphs (10+ corrections) first</li>
                                                        <li>Add clearer <strong>primary</strong> images to Hakli_glyphs.JSON</li>
                                                        <li>Add <strong>variants</strong> for different carving styles</li>
                                                        <li>Add <strong>examples</strong> from actual inscriptions where confusion occurs</li>
                                                        <li>Re-test with problematic inscriptions after updating templates</li>
                                                    </ul>
                                                </div>
                                            </>
                                        );
                                    })()}
                                </div>

                                {/* Footer */}
                                <div className="p-6 pt-4 border-t border-gray-200 flex-shrink-0">
                                    <button
                                        onClick={() => setShowCorrectionAnalysis(false)}
                                        className="w-full px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3e54] font-semibold"
                                    >
                                        Close Analysis
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {showCloudSyncModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setShowCloudSyncModal(false)}>
                            <div className="bg-white rounded-lg p-6 max-w-2xl w-full shadow-2xl max-h-[90vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900">‚òÅÔ∏è Cloud Sync</h3>
                                    <button
                                        onClick={() => setShowCloudSyncModal(false)}
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                    >
                                        &times;
                                    </button>
                                </div>

                                <div className="space-y-4">
                                    {/* Google Drive Section - Just Auth Status */}
                                    <div className="p-4 bg-[#f3f1f4] border-2 border-[#c9bfd4] rounded-lg">
                                        <h4 className="font-semibold text-ancient-purple mb-2">üíæ Google Drive Authentication</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Connect to Google Drive to save and load your HKI inscription files
                                        </p>
                                        
                                        {/* Sign In/Out */}
                                        <div className="flex gap-2 flex-wrap items-center">
                                            {(() => {
                                                try {
                                                    const isSignedIn = typeof DriveSync !== 'undefined' && DriveSync.isSignedIn && DriveSync.isSignedIn();
                                                    
                                                    if (isSignedIn) {
                                                        // Show Sign Out button when signed in
                                                        return (
                                                            <>
                                                                <button
                                                                    onClick={async () => {
                                                                        if (typeof DriveSync !== 'undefined') {
                                                                            try {
                                                                                await DriveSync.signOut();
                                                                                setDriveAuthStatus(prev => prev + 1); // Force re-render
                                                                                alert('‚úÖ Signed out from Google Drive.\n\nClose this window and click "üîÑ Change Account" to sign in again.');
                                                                            } catch (err) {
                                                                                console.error('Sign-out error:', err);
                                                                                alert('‚ùå Sign-out failed: ' + err.message);
                                                                            }
                                                                        }
                                                                    }}
                                                                    className="px-4 py-2 bg-rust text-white rounded-lg hover:bg-[#8d5d47] font-semibold"
                                                                >
                                                                    üö™ Sign Out
                                                                </button>
                                                                <span className="text-sm text-green-600 font-medium">
                                                                    ‚úì Connected to Google Drive
                                                                </span>
                                                            </>
                                                        );
                                                    } else {
                                                        // Show Sign In button when not signed in
                                                        return (
                                                            <button
                                                                onClick={async () => {
                                                                    if (typeof DriveSync !== 'undefined') {
                                                                        try {
                                                                            const success = await DriveSync.initialize();
                                                                            if (success) {
                                                                                const signedIn = await DriveSync.signIn();
                                                                                if (signedIn) {
                                                                                    alert('‚úÖ Connected to Google Drive!');
                                                                                    setShowCloudSyncModal(false); // Close modal after sign-in
                                                                                }
                                                                            } else {
                                                                                alert('‚ö†Ô∏è Drive sync initialization failed. Check console.');
                                                                            }
                                                                        } catch (err) {
                                                                            console.error('Drive sign-in error:', err);
                                                                            alert('‚ùå Sign-in failed: ' + err.message);
                                                                        }
                                                                    } else {
                                                                        alert('‚ùå DriveSync module not loaded');
                                                                    }
                                                                }}
                                                                className="px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3e54] font-semibold"
                                                            >
                                                                üîê Sign in with Google
                                                            </button>
                                                        );
                                                    }
                                                } catch {
                                                    return (
                                                        <button
                                                            onClick={async () => {
                                                                if (typeof DriveSync !== 'undefined') {
                                                                    try {
                                                                        const success = await DriveSync.initialize();
                                                                        if (success) {
                                                                            const signedIn = await DriveSync.signIn();
                                                                            if (signedIn) {
                                                                                setDriveAuthStatus(prev => prev + 1); // Force re-render
                                                                                alert('‚úÖ Connected to Google Drive!');
                                                                                setShowCloudSyncModal(false); // Close modal after sign-in
                                                                            }
                                                                        } else {
                                                                            alert('‚ö†Ô∏è Drive sync initialization failed. Check console.');
                                                                        }
                                                                    } catch (err) {
                                                                        console.error('Drive sign-in error:', err);
                                                                        alert('‚ùå Sign-in failed: ' + err.message);
                                                                    }
                                                                } else {
                                                                    alert('‚ùå DriveSync module not loaded');
                                                                }
                                                            }}
                                                            className="px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3e54] font-semibold"
                                                        >
                                                            üîê Sign in with Google
                                                        </button>
                                                    );
                                                }
                                            })()}
                                        </div>
                                        
                                        {/* Save/Load Row */}
                                        <div className="flex gap-4 flex-wrap mt-4" style={{rowGap: '12px'}}>
                                            <button
                                                onClick={async () => {
                                                    if (typeof DriveSync === 'undefined' || !DriveSync.isSignedIn()) {
                                                        alert('‚ö†Ô∏è Please sign in to Google Drive first');
                                                        return;
                                                    }
                                                    if (!recognitionResults || recognitionResults.length === 0) {
                                                        alert('‚ö†Ô∏è No recognition results to save. Run recognition first.');
                                                        return;
                                                    }
                                                    
                                                    // Generate HKI data
                                                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                                                    const inscriptionId = `hakli_${timestamp}`;
                                                    const filename = inscriptionTitle 
                                                        ? `${inscriptionTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${timestamp}.hki.json`
                                                        : `${inscriptionId}.hki.json`;
                                                    
                                                    // Optionally capture GPS location
                                                    let locationData = null;
                                                    if (navigator.geolocation) {
                                                        const captureLocation = confirm('üìç Include GPS location?\n\n‚Ä¢ Helps organize inscriptions by area\n‚Ä¢ Stays private in your Google Drive\n‚Ä¢ Optional - click Cancel to skip');
                                                        
                                                        if (captureLocation) {
                                                            try {
                                                                const position = await new Promise((resolve, reject) => {
                                                                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                                                                        enableHighAccuracy: true,
                                                                        timeout: 10000,
                                                                        maximumAge: 0
                                                                    });
                                                                });
                                                                
                                                                locationData = {
                                                                    latitude: position.coords.latitude,
                                                                    longitude: position.coords.longitude,
                                                                    accuracy: position.coords.accuracy,
                                                                    timestamp: new Date().toISOString(),
                                                                    manual: false
                                                                };
                                                                console.log('üìç Location captured:', locationData);
                                                            } catch (err) {
                                                                console.warn('Failed to get location:', err);
                                                                alert('‚ö†Ô∏è Could not get GPS location. Saving without location data.');
                                                            }
                                                        }
                                                    }
                                                    
                                                    // Capture preprocessed image if available
                                                    let preprocessedImage = null;
                                                    if (preprocessCanvasRef.current && preprocessedMat && !preprocessedMat.isDeleted()) {
                                                        try {
                                                            preprocessedImage = preprocessCanvasRef.current.toDataURL('image/png');
                                                        } catch (err) {
                                                            console.warn('Could not capture preprocessed image:', err);
                                                        }
                                                    }
                                                    
                                                    const hkiData = {
                                                        version: '1.0',
                                                        created: new Date().toISOString(),
                                                        source: 'Hakli Glyph Recognizer v251215',
                                                        inscriptionId: inscriptionId,
                                                        inscriptionTitle: inscriptionTitle || '',
                                                        inscriptionNotes: inscriptionNotes || '',
                                                        location: locationData,
                                                        image: image,
                                                        preprocessedImage: preprocessedImage,
                                                        preprocessing: preprocessing,
                                                        recognitionResults: recognitionResults,
                                                        readingOrder: readingOrder,
                                                        readingDirection: readingDirection,
                                                        wordBoundaries: Array.from(wordBoundaries),
                                                        columnBreaks: Array.from(columnBreaks),
                                                        lineBreaks: Array.from(lineBreaks),
                                                        validations: validations,
                                                        translationEnglish: translationEnglish,
                                                        translationArabic: translationArabic
                                                    };
                                                    
                                                    try {
                                                        const result = await DriveSync.saveToCloud(hkiData, filename);
                                                        console.log('Saved to Drive:', result);
                                                        alert(`‚úÖ Saved to Google Drive!\n\nFilename: ${filename}\nFolder: Hakli_Inscriptions`);
                                                    } catch (err) {
                                                        console.error('Save error:', err);
                                                        alert('‚ùå Save failed: ' + err.message);
                                                    }
                                                }}
                                                className="px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5d7a6d] font-semibold"
                                            >
                                                üíæ Save to Drive
                                            </button>
                                            <button
                                                onClick={async () => {
                                                    if (typeof DriveSync === 'undefined' || !DriveSync.isSignedIn()) {
                                                        alert('‚ö†Ô∏è Please sign in to Google Drive first');
                                                        return;
                                                    }
                                                    
                                                    try {
                                                        const files = await DriveSync.listFiles();
                                                        console.log('Drive files:', files);
                                                        
                                                        if (files.length === 0) {
                                                            alert('üìÇ No HKI files found in your Hakli_Inscriptions folder.');
                                                            return;
                                                        }
                                                        
                                                        // Load all file thumbnails
                                                        setShowCloudSyncModal(false);
                                                        setShowFilePickerModal({ files, isLoading: true });
                                                        
                                                        const filesWithThumbnails = await Promise.all(
                                                            files.map(async (file) => {
                                                                try {
                                                                    const hkiData = await DriveSync.loadFromCloud(file.id);
                                                                    console.log('üì∏ Thumbnail debug for', file.name, ':', {
                                                                        hasImage: !!hkiData.image,
                                                                        imageLength: hkiData.image ? hkiData.image.length : 0,
                                                                        imageStart: hkiData.image ? hkiData.image.substring(0, 50) : null,
                                                                        hasLocation: !!hkiData.location
                                                                    });
                                                                    return {
                                                                        ...file,
                                                                        thumbnail: hkiData.image || null,
                                                                        title: hkiData.inscriptionTitle || file.name,
                                                                        location: hkiData.location || null
                                                                    };
                                                                } catch (err) {
                                                                    console.error(`Failed to load thumbnail for ${file.name}:`, err);
                                                                    return { ...file, thumbnail: null, title: file.name, location: null };
                                                                }
                                                            })
                                                        );
                                                        
                                                        setShowFilePickerModal({ files: filesWithThumbnails, isLoading: false });
                                                    } catch (err) {
                                                        console.error('Load error:', err);
                                                        alert('‚ùå Load failed: ' + err.message);
                                                    }
                                                }}
                                                className="px-4 py-2 bg-stone text-white rounded-lg hover:bg-stone-dark font-semibold"
                                            >
                                                üìÇ Load from Drive
                                            </button>
                                        </div>
                                        
                                        <p className="text-xs text-ancient-purple">
                                            üîí Files saved to "Hakli_Inscriptions" folder in your Drive
                                        </p>
                                    </div>
                                </div>

                                <div className="mt-4 pt-4 border-t border-gray-200">
                                    <button
                                        onClick={() => setShowCloudSyncModal(false)}
                                        className="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                    >
                                        Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Community Corrections Modal */}
                    {showCommunityModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
                             onClick={() => setShowCommunityModal(false)}>
                            <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto shadow-2xl"
                                 onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4 p-6 pb-4 border-b border-gray-200">
                                    <h3 className="text-2xl font-bold text-gray-900">üåê Community Corrections</h3>
                                    <button
                                        onClick={() => setShowCommunityModal(false)}
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                    >
                                        &times;
                                    </button>
                                </div>

                                <div className="space-y-4 px-6">
                                    {/* Download from Master */}
                                    <div className="p-4 bg-[#f5f3f0] border-2 border-stone-light rounded-lg">
                                        <h4 className="font-semibold text-stone-dark mb-2">üì• Download Community Corrections</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Get the latest corrections from the community master collection
                                        </p>
                                        <button
                                            onClick={async () => {
                                                setShowCommunityModal(false);
                                                await downloadCorrectionsFromCloud(MASTER_PASTE_RAW_URL);
                                            }}
                                            className="w-full px-4 py-2 bg-stone text-white rounded-lg hover:bg-stone-dark font-semibold"
                                        >
                                            Download from Master Collection
                                        </button>
                                    </div>

                                    {/* Download from Custom URL */}
                                    <div className="p-4 bg-gray-50 border-2 border-gray-200 rounded-lg">
                                        <h4 className="font-semibold text-gray-900 mb-2">üîó Download from Custom URL</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Import corrections from a specific GitHub raw URL or other source
                                        </p>
                                        <div className="flex gap-2">
                                            <input
                                                type="text"
                                                placeholder="Paste raw JSON URL here..."
                                                value={customGistUrl}
                                                onChange={(e) => setCustomGistUrl(e.target.value)}
                                                className="flex-1 px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-stone focus:outline-none"
                                            />
                                            <button
                                                onClick={async () => {
                                                    if (customGistUrl) {
                                                        setShowCommunityModal(false);
                                                        await downloadCorrectionsFromCloud(customGistUrl);
                                                        setCustomGistUrl('');
                                                    }
                                                }}
                                                disabled={!customGistUrl}
                                                className="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                            >
                                                Download
                                            </button>
                                        </div>
                                    </div>

                                    {/* Upload Your Corrections */}
                                    <div className="p-4 bg-[#f0f5f3] border-2 border-[#b5d4c8] rounded-lg">
                                        <h4 className="font-semibold text-green-900 mb-2">üì§ Share Your Corrections</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Export your corrections and submit them to the community via GitHub Issue
                                        </p>
                                        <button
                                            onClick={async () => {
                                                setShowCommunityModal(false);
                                                await uploadCorrectionsToCloud();
                                            }}
                                            className="w-full px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5d7a6d] font-semibold"
                                        >
                                            üì• Export & Create Issue
                                        </button>
                                        <div className="mt-3 text-xs text-gray-600 bg-white p-2 rounded border border-patina">
                                            <p className="font-semibold mb-1">How it works:</p>
                                            <ol className="list-decimal list-inside space-y-1">
                                                <li>Downloads your corrections as a JSON file</li>
                                                <li>Opens a GitHub Issue template</li>
                                                <li>You attach the file and submit</li>
                                                <li>Corrections are reviewed and added to master</li>
                                            </ol>
                                        </div>
                                    </div>
                                </div>

                                <div className="mt-4 pt-4 border-t border-gray-200 px-6 pb-6">
                                    <button
                                        onClick={() => setShowCommunityModal(false)}
                                        className="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                    >
                                        Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* File Picker Modal with Image Thumbnails */}
                    {showFilePickerModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
                             onClick={() => setShowFilePickerModal(null)}>
                            <div className="bg-white rounded-2xl shadow-2xl max-w-5xl w-full max-h-[90vh] overflow-hidden flex flex-col"
                                 onClick={(e) => e.stopPropagation()}>
                                
                                {/* Header */}
                                <div className="bg-gradient-to-r from-ancient-purple to-stone p-6 text-white">
                                    <div className="flex items-center justify-between mb-3">
                                        <div>
                                            <h3 className="text-2xl font-bold">üìÇ Select Inscription</h3>
                                            <p className="text-sm opacity-90 mt-1">
                                                {showFilePickerModal.files?.length || 0} inscription{(showFilePickerModal.files?.length !== 1) ? 's' : ''} in your collection
                                            </p>
                                        </div>
                                        <button
                                            onClick={() => setShowFilePickerModal(null)}
                                            className="text-white hover:bg-white hover:bg-opacity-20 rounded-full p-2 transition-all"
                                        >
                                            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                            </svg>
                                        </button>
                                    </div>
                                    
                                    {/* Sort Controls */}
                                    {!showFilePickerModal.isLoading && showFilePickerModal.files?.length > 1 && (
                                        <div className="flex items-center gap-2 text-sm">
                                            <span className="opacity-90">Sort by:</span>
                                            <button
                                                onClick={() => {
                                                    const sorted = [...showFilePickerModal.files].sort((a, b) => 
                                                        new Date(b.modifiedTime) - new Date(a.modifiedTime)
                                                    );
                                                    setShowFilePickerModal({ ...showFilePickerModal, files: sorted, groupBy: null });
                                                }}
                                                className="px-3 py-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded transition-all"
                                            >
                                                üìÖ Newest
                                            </button>
                                            <button
                                                onClick={() => {
                                                    const sorted = [...showFilePickerModal.files].sort((a, b) => 
                                                        new Date(a.modifiedTime) - new Date(b.modifiedTime)
                                                    );
                                                    setShowFilePickerModal({ ...showFilePickerModal, files: sorted, groupBy: null });
                                                }}
                                                className="px-3 py-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded transition-all"
                                            >
                                                üìÖ Oldest
                                            </button>
                                            <button
                                                onClick={() => {
                                                    const sorted = [...showFilePickerModal.files].sort((a, b) => 
                                                        (a.title || a.name).localeCompare(b.title || b.name)
                                                    );
                                                    setShowFilePickerModal({ ...showFilePickerModal, files: sorted, groupBy: null });
                                                }}
                                                className="px-3 py-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded transition-all"
                                            >
                                                üî§ A-Z
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setShowFilePickerModal({ ...showFilePickerModal, groupBy: 'location' });
                                                }}
                                                className="px-3 py-1 bg-white bg-opacity-20 hover:bg-opacity-30 rounded transition-all"
                                            >
                                                üìç Location
                                            </button>
                                        </div>
                                    )}
                                </div>

                                {/* File Grid */}
                                <div className="flex-1 overflow-y-auto p-6 bg-gray-50">
                                    {showFilePickerModal.isLoading ? (
                                        <div className="flex flex-col items-center justify-center py-16">
                                            <div className="animate-spin rounded-full h-16 w-16 border-4 border-ancient-purple border-t-transparent mb-4"></div>
                                            <p className="text-gray-600 text-lg">Loading inscription previews...</p>
                                            <p className="text-gray-400 text-sm mt-2">This may take a moment</p>
                                        </div>
                                    ) : (
                                        <>
                                        {(() => {
                                            // Helper function to calculate distance between two points (Haversine formula)
                                            const getDistance = (lat1, lon1, lat2, lon2) => {
                                                const R = 6371; // Earth's radius in km
                                                const dLat = (lat2 - lat1) * Math.PI / 180;
                                                const dLon = (lon2 - lon1) * Math.PI / 180;
                                                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                                                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                                                    Math.sin(dLon/2) * Math.sin(dLon/2);
                                                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                                                return R * c;
                                            };
                                            
                                            // Group files by location if enabled
                                            if (showFilePickerModal.groupBy === 'location') {
                                                const CLUSTER_RADIUS_KM = 5; // Group inscriptions within 5km
                                                const groups = [];
                                                const filesWithLocation = showFilePickerModal.files.filter(f => f.location);
                                                const filesWithoutLocation = showFilePickerModal.files.filter(f => !f.location);
                                                
                                                // Cluster files by proximity
                                                filesWithLocation.forEach(file => {
                                                    let addedToGroup = false;
                                                    
                                                    for (let group of groups) {
                                                        const centerLat = group.files.reduce((sum, f) => sum + f.location.latitude, 0) / group.files.length;
                                                        const centerLon = group.files.reduce((sum, f) => sum + f.location.longitude, 0) / group.files.length;
                                                        const distance = getDistance(centerLat, centerLon, file.location.latitude, file.location.longitude);
                                                        
                                                        if (distance < CLUSTER_RADIUS_KM) {
                                                            group.files.push(file);
                                                            addedToGroup = true;
                                                            break;
                                                        }
                                                    }
                                                    
                                                    if (!addedToGroup) {
                                                        groups.push({
                                                            files: [file],
                                                            centerLat: file.location.latitude,
                                                            centerLon: file.location.longitude
                                                        });
                                                    }
                                                });
                                                
                                                // Add files without location as separate group
                                                if (filesWithoutLocation.length > 0) {
                                                    groups.push({
                                                        files: filesWithoutLocation,
                                                        noLocation: true
                                                    });
                                                }
                                                
                                                // Render grouped files
                                                return groups.map((group, groupIndex) => (
                                                    <div key={groupIndex} className="mb-8">
                                                        <h4 className="text-lg font-bold text-gray-900 mb-4 flex items-center gap-2">
                                                            {group.noLocation ? (
                                                                <>üìç Unknown Location</>
                                                            ) : (
                                                                <>
                                                                    üìç Near {group.centerLat.toFixed(3)}¬∞N, {group.centerLon.toFixed(3)}¬∞E
                                                                    <span className="text-sm font-normal text-gray-500">
                                                                        ({group.files.length} inscription{group.files.length !== 1 ? 's' : ''})
                                                                    </span>
                                                                </>
                                                            )}
                                                        </h4>
                                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                                            {group.files.map((file) => renderFileCard(file))}
                                                        </div>
                                                    </div>
                                                ));
                                            } else {
                                                // Normal grid view (no grouping)
                                                return (
                                                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                                        {showFilePickerModal.files?.map((file) => renderFileCard(file))}
                                                    </div>
                                                );
                                            }
                                            
                                            // Helper function to render a file card
                                            function renderFileCard(file) {
                                                return (
                                                    <div
                                                        key={file.id}
                                                        onClick={async () => {
                                                            try {
                                                                setShowFilePickerModal(null);
                                                                const hkiData = await DriveSync.loadFromCloud(file.id);
                                                            console.log('Loaded from Drive:', hkiData);
                                                            
                                                            // Restore image with OpenCV processing
                                                            if (hkiData.image) {
                                                                setIsImageLoading(true);
                                                                
                                                                // Clear old display states
                                                                setDisplayImage(null);
                                                                setPreprocessedMat(null);
                                                                setImageRotation(0);
                                                                setRotatedImageDimensions(null);
                                                                
                                                                const img = new Image();
                                                                img.onload = () => {
                                                                    setImage(hkiData.image);
                                                                    
                                                                    if (imageRef.current) {
                                                                        imageRef.current.src = hkiData.image;
                                                                    }
                                                                    
                                                                    if (isOpenCvReady) {
                                                                        const canvas = document.createElement('canvas');
                                                                        canvas.width = img.width;
                                                                        canvas.height = img.height;
                                                                        const ctx = canvas.getContext('2d');
                                                                        ctx.drawImage(img, 0, 0);
                                                                        
                                                                        const mat = cv.imread(canvas);
                                                                        setOriginalMat(mat);
                                                                        
                                                                        if (originalCanvasRef.current) {
                                                                            cv.imshow(originalCanvasRef.current, mat);
                                                                        }
                                                                        
                                                                        processImageWithSettings(mat, preprocessing);
                                                                    }
                                                                    
                                                                    setIsImageLoading(false);
                                                                };
                                                                img.onerror = () => {
                                                                    setIsImageLoading(false);
                                                                    alert('‚ùå Failed to load image from HKI file.');
                                                                };
                                                                img.src = hkiData.image;
                                                            }
                                                            
                                                            // Restore all other data
                                                            if (hkiData.recognitionResults) setRecognitionResults(hkiData.recognitionResults);
                                                            if (hkiData.readingOrder) setReadingOrder(hkiData.readingOrder);
                                                            if (hkiData.readingDirection) setReadingDirection(hkiData.readingDirection);
                                                            if (hkiData.wordBoundaries) setWordBoundaries(new Set(hkiData.wordBoundaries));
                                                            if (hkiData.columnBreaks) setColumnBreaks(new Set(hkiData.columnBreaks));
                                                            if (hkiData.lineBreaks) setLineBreaks(new Set(hkiData.lineBreaks));
                                                            if (hkiData.validations) setValidations(hkiData.validations);
                                                            if (hkiData.translationEnglish) setTranslationEnglish(hkiData.translationEnglish);
                                                            if (hkiData.translationArabic) setTranslationArabic(hkiData.translationArabic);
                                                            if (hkiData.inscriptionTitle) setInscriptionTitle(hkiData.inscriptionTitle);
                                                            if (hkiData.inscriptionNotes) setInscriptionNotes(hkiData.inscriptionNotes);
                                                            
                                                            alert(`‚úÖ Loaded: ${file.name}`);
                                                        } catch (err) {
                                                            console.error('Load error:', err);
                                                            alert('‚ùå Load failed: ' + err.message);
                                                        }
                                                    }}
                                                    className="bg-white rounded-xl border-2 border-gray-200 hover:border-ancient-purple hover:shadow-xl transition-all cursor-pointer overflow-hidden group relative"
                                                >
                                                    {/* Delete Button (appears on hover) */}
                                                    <button
                                                        onClick={async (e) => {
                                                            e.stopPropagation(); // Prevent card click
                                                            if (!confirm(`üóëÔ∏è Delete "${file.title || file.name}"?\n\nThis will permanently remove it from Google Drive.`)) {
                                                                return;
                                                            }
                                                            
                                                            try {
                                                                // Delete from Google Drive
                                                                if (typeof DriveSync !== 'undefined' && DriveSync.deleteFile) {
                                                                    await DriveSync.deleteFile(file.id);
                                                                } else {
                                                                    // Fallback: Use gapi directly
                                                                    await window.gapi.client.drive.files.delete({
                                                                        fileId: file.id
                                                                    });
                                                                }
                                                                
                                                                // Remove from list
                                                                const updatedFiles = showFilePickerModal.files.filter(f => f.id !== file.id);
                                                                setShowFilePickerModal({ ...showFilePickerModal, files: updatedFiles });
                                                                
                                                                alert(`‚úÖ Deleted: ${file.name}`);
                                                            } catch (err) {
                                                                console.error('Delete error:', err);
                                                                alert('‚ùå Delete failed: ' + err.message);
                                                            }
                                                        }}
                                                        className="absolute top-2 right-2 z-10 bg-rust text-white rounded-full p-2 opacity-0 group-hover:opacity-100 hover:bg-red-600 transition-all shadow-lg"
                                                        title="Delete inscription"
                                                    >
                                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                                        </svg>
                                                    </button>
                                                    
                                                    {/* Thumbnail */}
                                                    <div className="aspect-video bg-gradient-to-br from-stone-light to-gray-300 relative overflow-hidden">
                                                        {file.thumbnail ? (
                                                            <img 
                                                                src={file.thumbnail} 
                                                                alt={file.title || file.name}
                                                                className="w-full h-full object-contain group-hover:scale-105 transition-transform duration-300"
                                                            />
                                                        ) : (
                                                            <div className="w-full h-full flex items-center justify-center text-gray-400">
                                                                <svg className="w-16 h-16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                                                </svg>
                                                            </div>
                                                        )}
                                                    </div>
                                                    
                                                    {/* File Info */}
                                                    <div className="p-4">
                                                        <h4 className="font-bold text-gray-900 truncate mb-1 group-hover:text-ancient-purple transition-colors">
                                                            {file.title || file.name}
                                                        </h4>
                                                        <div className="flex items-center justify-between text-xs text-gray-500">
                                                            <span className="truncate flex-1 pr-2">{file.name}</span>
                                                        </div>
                                                        <div className="text-xs text-gray-400 mt-1">
                                                            üìÖ {new Date(file.modifiedTime).toLocaleDateString('en-US', { 
                                                                year: 'numeric', 
                                                                month: 'short', 
                                                                day: 'numeric',
                                                                hour: '2-digit',
                                                                minute: '2-digit'
                                                            })}
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                            }
                                        })()}
                                        </>
                                    )}
                                </div>

                                {/* Footer */}
                                <div className="border-t border-gray-200 p-4 bg-white">
                                    <button
                                        onClick={() => setShowFilePickerModal(null)}
                                        className="w-full px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-semibold transition-colors"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<HakliGlyphRecognizer />);
    </script>

    <!-- Service Worker Registration -->
    <script>
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/hakli_glyph_recognizer/sw.js')
                    .then((registration) => {
                        console.log('‚úÖ Service Worker registered:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            console.log('üîÑ New service worker found, installing...');
                            
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('‚ú® New version available! Refresh to update.');
                                    // Could show a toast notification here
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.error('‚ùå Service Worker registration failed:', error);
                    });
            });
        } else {
            console.warn('‚ö†Ô∏è Service Workers not supported in this browser');
        }
    </script>
</body>

</html>
