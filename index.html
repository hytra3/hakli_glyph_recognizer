<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Glyph Recognizer</title>
    <meta name="description" content="Ancient South Arabian script recognition tool">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#5d4e6d">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <!-- React & Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'ancient-purple': '#5d4e6d',
                        'stone': '#8b7d6b',
                        'patina': '#6b8e7f',
                        'ochre': '#b8956a',
                        'rust': '#a0674f',
                    }
                }
            }
        }
    </script>
    
    <!-- OpenCV -->
    <script>
        var isOpenCvReady = false;
        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('‚úÖ OpenCV.js is ready');
            window.dispatchEvent(new Event('opencv-ready'));
        }
    </script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <style>
        .detection-box {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
            border: 3px solid;
            border-radius: 4px;
            cursor: pointer;
        }
        .detection-box.validated-correct { border-color: #6b8e7f; background: rgba(107, 142, 127, 0.25); }
        .detection-box.validated-incorrect { border-color: #a0674f; background: rgba(239, 68, 68, 0.25); }
        .detection-box.unvalidated { border-color: #8b7d6b; background: rgba(59, 130, 246, 0.25); }
        .detection-box.selected { border-color: #b8956a; background: rgba(245, 158, 11, 0.3); border-width: 4px; }
        .detection-box.uncertain { border-style: dashed; }
        .detection-label {
            position: absolute;
            top: -28px;
            left: -2px;
            padding: 4px 10px;
            font-size: 16px;
            font-weight: 600;
            color: white;
            border-radius: 4px;
            white-space: nowrap;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            letter-spacing: 0.5px;
            min-width: 24px;
            min-height: 20px;
            text-align: center;
            line-height: 1.2;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .reading-order-badge {
            position: absolute;
            top: -16px;
            left: -16px;
            width: 22px;
            height: 22px;
            background: #b8956a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            z-index: 20;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <!-- Core modules (must load first) -->
    <script src="src/core/config.js"></script>
    <script src="src/utils/helpers.js"></script>
    
    <!-- Storage modules -->
    <script src="src/storage/hki.js"></script>
    <script src="src/storage/cache.js"></script>
    <script src="src/storage/corrections.js"></script>
    <script src="src/storage/drive-sync.js"></script>
    
    <!-- Recognition modules -->
    <script src="src/recognition/preprocessing.js"></script>
    <script src="src/recognition/isolation.js"></script>
    <script src="src/recognition/matching.js"></script>
    <script src="src/recognition/nms.js"></script>
    <script src="src/recognition/validation.js"></script>
    <script src="src/recognition/template-learning.js"></script>
    
    <!-- Reading modules -->
    <script src="src/reading/reading.js"></script>
    <script src="src/reading/transcription.js"></script>
    
    <!-- UI Components (loaded as Babel) -->
    <script type="text/babel" src="src/components/common/CommonComponents.jsx"></script>
    <script type="text/babel" src="src/components/panels/InscriptionPanel.jsx"></script>
    <script type="text/babel" src="src/components/panels/ExportPanel.jsx"></script>

    <!-- Main Application -->
    <script type="text/babel">
        const APP_VERSION = 'v251224';
        console.log('üöÄ Hakli Glyph Recognizer ' + APP_VERSION);

        function HakliGlyphRecognizer() {
            const { useState, useEffect, useRef, useCallback, useMemo } = React;
            
            // ========== STATE ==========
            const [originalImage, setOriginalImage] = useState(null);
            const [displayImage, setDisplayImage] = useState(null);
            const [isImageLoading, setIsImageLoading] = useState(false);
            
            const [chartData, setChartData] = useState(null);
            const [chartStatus, setChartStatus] = useState('not-loaded');
            const [loadedGlyphImages, setLoadedGlyphImages] = useState({});
            const [glyphThumbnails, setGlyphThumbnails] = useState({});
            const [chartLoadProgress, setChartLoadProgress] = useState({ loaded: 0, total: 0 });
            
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [validations, setValidations] = useState({});
            const [isProcessing, setIsProcessing] = useState(false);
            const [processingStatus, setProcessingStatus] = useState('');
            
            const [viewMode, setViewMode] = useState('detection');
            const [readingDirection, setReadingDirection] = useState('rtl');
            const [readingOrder, setReadingOrder] = useState([]);
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [lineBreaks, setLineBreaks] = useState(new Set());
            
            const [selectedRegions, setSelectedRegions] = useState(new Set());
            const [showArabicLabels, setShowArabicLabels] = useState(false);
            const [isPreprocessingCollapsed, setIsPreprocessingCollapsed] = useState(false);
            
            // Force re-render of detection boxes when layout changes
            const [boxLayoutKey, setBoxLayoutKey] = useState(0);
            const [imageDimensions, setImageDimensions] = useState({ width: 0, height: 0 });
            
            // Enhanced detection card state
            const [expandedCards, setExpandedCards] = useState(new Set()); // Cards showing alternatives
            const [excludedDetections, setExcludedDetections] = useState(new Set()); // Excluded from reading
            const [editingBoxIdx, setEditingBoxIdx] = useState(null); // Index of detection being edited
            
            // Manual box drawing state
            const [manualBoxMode, setManualBoxMode] = useState(false);
            const [drawingBox, setDrawingBox] = useState(null); // {startX, startY, currentX, currentY}
            // Glyph selector: { mode: 'manual', position: {...} } OR { mode: 'change', detectionIndex: n }
            const [showGlyphSelector, setShowGlyphSelector] = useState(null);
            const [glyphSelectorSearch, setGlyphSelectorSearch] = useState('');
            
            // Translation & inscription state
            const [translationEnglish, setTranslationEnglish] = useState('');
            const [translationArabic, setTranslationArabic] = useState('');
            const [showTranslationSection, setShowTranslationSection] = useState(false);
            const [inscriptionNotes, setInscriptionNotes] = useState('');
            const [inscriptionTitle, setInscriptionTitle] = useState('');
            const [inscriptionComplete, setInscriptionComplete] = useState(false);
            const [transcriptionScript, setTranscriptionScript] = useState('english');
            
            // Storage state
            const [showStorageSection, setShowStorageSection] = useState(false);
            const [currentInscriptionId, setCurrentInscriptionId] = useState(null);
            const [columnBreaks, setColumnBreaks] = useState(new Set());
            const [actionHistory, setActionHistory] = useState([]);
            
            // Eraser tool state
            const [eraserMode, setEraserMode] = useState(false);
            const [eraserSize, setEraserSize] = useState(15);
            const eraserCanvasRef = useRef(null);
            const isDrawingRef = useRef(false);
            
            // Region editor state (per-detection eraser)
            const [regionEditorIdx, setRegionEditorIdx] = useState(null);
            const [regionEditorSize, setRegionEditorSize] = useState(10);
            const regionEditorCanvasRef = useRef(null);
            const regionEditorDrawingRef = useRef(false);
            
            // Chart Manager state
            const [showChartManager, setShowChartManager] = useState(false);
            const [showGlyphEditor, setShowGlyphEditor] = useState(false);
            const [editingGlyph, setEditingGlyph] = useState(null);
            const [glyphEditorMode, setGlyphEditorMode] = useState('add');
            
            const [preprocessing, setPreprocessing] = useState({
                rotation: 0,
                useAdaptiveThreshold: false,
                blockSize: 11,
                constantOffset: 2,
                gaussianBlur: 0,
                morphologyOperation: 'none',
                invertColors: false
            });
            
            const [opencvReady, setOpencvReady] = useState(false);
            const originalMatRef = useRef(null);
            const preprocessedMatRef = useRef(null);
            
            // Track dimensions of the image used for recognition (for box alignment)
            const [recognitionSourceDims, setRecognitionSourceDims] = useState(null);
            
            // Debounce timer for real-time preprocessing
            const preprocessDebounceRef = useRef(null);
            
            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);
            const fileInputRef = useRef(null);
            
            // ========== OPENCV SETUP ==========
            useEffect(() => {
                const checkOpenCV = () => {
                    if (typeof cv !== 'undefined' && cv.Mat) {
                        setOpencvReady(true);
                        console.log('‚úÖ OpenCV ready in React');
                    } else {
                        setTimeout(checkOpenCV, 100);
                    }
                };
                checkOpenCV();
                
                return () => {
                    if (originalMatRef.current) try { originalMatRef.current.delete(); } catch(e) {}
                    if (preprocessedMatRef.current) try { preprocessedMatRef.current.delete(); } catch(e) {}
                };
            }, []);
            
            // ========== LOAD CHART ==========
            useEffect(() => {
                const loadChart = async () => {
                    setChartStatus('loading');
                    try {
                        const response = await fetch('Hakli_glyphs.JSON');
                        const data = await response.json();
                        setChartData(data);
                        console.log(`üìú Loaded chart with ${data.glyphs.length} glyphs`);
                        
                        let loaded = 0;
                        const total = data.glyphs.length;
                        const newImages = {};
                        const newThumbnails = {};
                        
                        for (const glyph of data.glyphs) {
                            if (glyph.images?.primary) {
                                try {
                                    const img = new Image();
                                    img.crossOrigin = 'anonymous';
                                    await new Promise((resolve, reject) => {
                                        img.onload = resolve;
                                        img.onerror = reject;
                                        img.src = glyph.images.primary;
                                    });
                                    newImages[glyph.id] = img;
                                    newThumbnails[glyph.id] = img.src;
                                } catch (e) {
                                    console.warn(`Failed to load glyph ${glyph.id}`);
                                }
                            }
                            loaded++;
                            setChartLoadProgress({ loaded, total });
                        }
                        
                        setLoadedGlyphImages(newImages);
                        setGlyphThumbnails(newThumbnails);
                        setChartStatus('loaded');
                        console.log(`‚úÖ Loaded ${Object.keys(newImages).length} glyph images`);
                    } catch (error) {
                        console.error('Failed to load chart:', error);
                        setChartStatus('error');
                    }
                };
                loadChart();
            }, []);
            
            // ========== TRACK IMAGE DIMENSIONS FOR BOX ALIGNMENT ==========
            useEffect(() => {
                const img = imageRef.current;
                const container = imageContainerRef.current;
                if (!img || !container) return;
                
                // Update dimensions when image loads
                const handleImageLoad = () => {
                    setImageDimensions({ 
                        width: img.naturalWidth, 
                        height: img.naturalHeight 
                    });
                    setBoxLayoutKey(k => k + 1);
                };
                
                img.addEventListener('load', handleImageLoad);
                
                // Also observe container resize
                const resizeObserver = new ResizeObserver(() => {
                    setBoxLayoutKey(k => k + 1);
                });
                resizeObserver.observe(container);
                
                // If image is already loaded, trigger immediately
                if (img.complete) {
                    handleImageLoad();
                }
                
                return () => {
                    img.removeEventListener('load', handleImageLoad);
                    resizeObserver.disconnect();
                };
            }, [displayImage]);
            
            // ========== IMAGE HANDLING ==========
            const loadImageToMat = useCallback((imageSource) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = img.naturalWidth;
                            canvas.height = img.naturalHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            const mat = cv.imread(canvas);
                            resolve(mat);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = imageSource;
                });
            }, []);
            
            const matToDataUrl = useCallback((mat) => {
                const canvas = document.createElement('canvas');
                cv.imshow(canvas, mat);
                return canvas.toDataURL('image/png');
            }, []);
            
            const handleImageUpload = useCallback(async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                setIsImageLoading(true);
                
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const dataUrl = e.target.result;
                    setOriginalImage(dataUrl);
                    setDisplayImage(dataUrl);
                    
                    if (opencvReady) {
                        try {
                            if (originalMatRef.current) originalMatRef.current.delete();
                            originalMatRef.current = await loadImageToMat(dataUrl);
                            console.log('‚úÖ Image loaded:', originalMatRef.current.cols, 'x', originalMatRef.current.rows);
                        } catch (error) {
                            console.error('Failed to load image to OpenCV:', error);
                        }
                    }
                    
                    // Clear previous recognition state
                    setRecognitionResults([]);
                    setValidations({});
                    setReadingOrder([]);
                    setWordBoundaries(new Set());
                    setLineBreaks(new Set());
                    setSelectedRegions(new Set());
                    setRecognitionSourceDims(null);
                    setIsImageLoading(false);
                };
                reader.onerror = () => {
                    alert('Failed to read image file');
                    setIsImageLoading(false);
                };
                reader.readAsDataURL(file);
            }, [opencvReady, loadImageToMat]);
            
            // ========== PREPROCESSING ==========
            const applyPreprocessing = useCallback(async () => {
                if (!originalMatRef.current || !opencvReady) {
                    console.warn('No image or OpenCV not ready');
                    return;
                }
                
                try {
                    // Use the Preprocessing module if available
                    if (typeof Preprocessing !== 'undefined' && Preprocessing.processImageWithSettings) {
                        if (preprocessedMatRef.current) preprocessedMatRef.current.delete();
                        preprocessedMatRef.current = Preprocessing.processImageWithSettings(
                            originalMatRef.current, 
                            preprocessing
                        );
                        const dataUrl = matToDataUrl(preprocessedMatRef.current);
                        setDisplayImage(dataUrl);
                        // Track the dimensions of the preprocessed image for box alignment
                        setRecognitionSourceDims({
                            width: preprocessedMatRef.current.cols,
                            height: preprocessedMatRef.current.rows
                        });
                        console.log('‚úÖ Preprocessing applied via Preprocessing module');
                    } else {
                        // Fallback: manual preprocessing
                        if (preprocessedMatRef.current) preprocessedMatRef.current.delete();
                        
                        let result = originalMatRef.current.clone();
                        
                        // Rotation
                        if (preprocessing.rotation !== 0) {
                            const center = new cv.Point(result.cols / 2, result.rows / 2);
                            const rotMatrix = cv.getRotationMatrix2D(center, -preprocessing.rotation, 1.0);
                            const cos = Math.abs(rotMatrix.doubleAt(0, 0));
                            const sin = Math.abs(rotMatrix.doubleAt(0, 1));
                            const newWidth = Math.floor(result.rows * sin + result.cols * cos);
                            const newHeight = Math.floor(result.rows * cos + result.cols * sin);
                            rotMatrix.doublePtr(0, 2)[0] += (newWidth - result.cols) / 2;
                            rotMatrix.doublePtr(1, 2)[0] += (newHeight - result.rows) / 2;
                            const rotated = new cv.Mat();
                            cv.warpAffine(result, rotated, rotMatrix, new cv.Size(newWidth, newHeight), 
                                cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255, 255, 255, 255));
                            result.delete();
                            rotMatrix.delete();
                            result = rotated;
                        }
                        
                        // Grayscale
                        let gray = new cv.Mat();
                        if (result.channels() === 4) cv.cvtColor(result, gray, cv.COLOR_RGBA2GRAY);
                        else if (result.channels() === 3) cv.cvtColor(result, gray, cv.COLOR_RGB2GRAY);
                        else gray = result.clone();
                        
                        // Blur
                        if (preprocessing.gaussianBlur > 0) {
                            const ksize = preprocessing.gaussianBlur % 2 === 0 ? preprocessing.gaussianBlur + 1 : preprocessing.gaussianBlur;
                            cv.GaussianBlur(gray, gray, new cv.Size(ksize, ksize), 0);
                        }
                        
                        // Threshold
                        if (preprocessing.useAdaptiveThreshold) {
                            const blockSize = preprocessing.blockSize % 2 === 0 ? preprocessing.blockSize + 1 : preprocessing.blockSize;
                            cv.adaptiveThreshold(gray, gray, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, blockSize, preprocessing.constantOffset);
                        }
                        
                        // Morphology
                        if (preprocessing.morphologyOperation !== 'none') {
                            const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
                            const morphed = new cv.Mat();
                            switch (preprocessing.morphologyOperation) {
                                case 'erode': cv.erode(gray, morphed, kernel); break;
                                case 'dilate': cv.dilate(gray, morphed, kernel); break;
                                case 'open': cv.morphologyEx(gray, morphed, cv.MORPH_OPEN, kernel); break;
                                case 'close': cv.morphologyEx(gray, morphed, cv.MORPH_CLOSE, kernel); break;
                                default: gray.copyTo(morphed);
                            }
                            gray.delete();
                            kernel.delete();
                            gray = morphed;
                        }
                        
                        // Invert
                        if (preprocessing.invertColors) {
                            cv.bitwise_not(gray, gray);
                        }
                        
                        result.delete();
                        preprocessedMatRef.current = gray;
                        
                        const dataUrl = matToDataUrl(gray);
                        setDisplayImage(dataUrl);
                        // Track the dimensions of the preprocessed image for box alignment
                        setRecognitionSourceDims({
                            width: gray.cols,
                            height: gray.rows
                        });
                        console.log('‚úÖ Preprocessing applied (fallback)');
                    }
                } catch (error) {
                    console.error('Preprocessing error:', error);
                    alert('Preprocessing failed: ' + error.message);
                }
            }, [preprocessing, opencvReady, matToDataUrl]);
            
            const resetPreprocessing = useCallback(() => {
                // If there are active detections, warn user
                if (recognitionResults.length > 0) {
                    const confirmed = confirm(
                        '‚ö†Ô∏è Resetting will misalign detection boxes since they were positioned on the preprocessed image.\n\n' +
                        'Options:\n' +
                        '‚Ä¢ OK - Reset anyway (boxes may not align)\n' +
                        '‚Ä¢ Cancel - Keep current preprocessing\n\n' +
                        'Tip: Clear detections first, or re-run recognition after reset.'
                    );
                    if (!confirmed) return;
                }
                
                setPreprocessing({
                    rotation: 0,
                    useAdaptiveThreshold: false,
                    blockSize: 11,
                    constantOffset: 2,
                    gaussianBlur: 0,
                    morphologyOperation: 'none',
                    invertColors: false
                });
                if (originalImage) setDisplayImage(originalImage);
                if (preprocessedMatRef.current) {
                    preprocessedMatRef.current.delete();
                    preprocessedMatRef.current = null;
                }
                
                // Only reset recognitionSourceDims if no detections
                // Otherwise keep it so boxes at least scale consistently
                if (recognitionResults.length === 0) {
                    setRecognitionSourceDims(null);
                }
            }, [originalImage, recognitionResults.length]);
            
            // ========== REAL-TIME PREPROCESSING ==========
            // Auto-apply preprocessing when settings change (with debounce)
            useEffect(() => {
                // Only auto-apply if we have an image and OpenCV
                if (!originalMatRef.current || !opencvReady) return;
                
                // Clear previous timeout
                if (preprocessDebounceRef.current) {
                    clearTimeout(preprocessDebounceRef.current);
                }
                
                // Debounce: wait 50ms after last change before applying (fluid feel)
                preprocessDebounceRef.current = setTimeout(() => {
                    applyPreprocessing();
                }, 50);
                
                return () => {
                    if (preprocessDebounceRef.current) {
                        clearTimeout(preprocessDebounceRef.current);
                    }
                };
            }, [preprocessing, opencvReady, applyPreprocessing]);
            
            // ========== ERASER TOOL ==========
            const initEraserCanvas = useCallback(() => {
                if (!eraserCanvasRef.current || !imageRef.current) return;
                const canvas = eraserCanvasRef.current;
                const img = imageRef.current;
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                
                // Draw current display image onto canvas
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
            }, []);
            
            const handleEraserStart = useCallback((e) => {
                if (!eraserMode || !eraserCanvasRef.current) return;
                isDrawingRef.current = true;
                handleEraserDraw(e);
            }, [eraserMode]);
            
            const handleEraserDraw = useCallback((e) => {
                if (!isDrawingRef.current || !eraserMode || !eraserCanvasRef.current || !imageRef.current) return;
                
                const canvas = eraserCanvasRef.current;
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                
                // Calculate position relative to canvas (accounting for scaling)
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                // Draw white circle (erase) - scale the brush to match cursor visually
                ctx.beginPath();
                ctx.arc(x, y, eraserSize * scaleX, 0, Math.PI * 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();
            }, [eraserMode, eraserSize]);
            
            const handleEraserEnd = useCallback(() => {
                isDrawingRef.current = false;
            }, []);
            
            const applyEraser = useCallback(async () => {
                if (!eraserCanvasRef.current || !opencvReady) return;
                
                try {
                    // Get erased canvas data
                    const canvas = eraserCanvasRef.current;
                    const dataUrl = canvas.toDataURL('image/png');
                    
                    // Update display image
                    setDisplayImage(dataUrl);
                    
                    // Create mat from erased image
                    const img = new Image();
                    img.src = dataUrl;
                    await new Promise(resolve => { img.onload = resolve; });
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = img.naturalWidth;
                    tempCanvas.height = img.naturalHeight;
                    tempCanvas.getContext('2d').drawImage(img, 0, 0);
                    const newMat = cv.imread(tempCanvas);
                    
                    // Update BOTH originalMatRef AND preprocessedMatRef
                    // This ensures subsequent preprocessing works on the erased image
                    if (originalMatRef.current) originalMatRef.current.delete();
                    originalMatRef.current = newMat.clone();
                    
                    if (preprocessedMatRef.current) preprocessedMatRef.current.delete();
                    preprocessedMatRef.current = newMat;
                    
                    // Also update originalImage so Reset goes back to erased version
                    setOriginalImage(dataUrl);
                    
                    // Track dimensions
                    setRecognitionSourceDims({
                        width: newMat.cols,
                        height: newMat.rows
                    });
                    
                    setEraserMode(false);
                    console.log('‚úÖ Eraser applied (original updated)');
                } catch (error) {
                    console.error('Eraser apply error:', error);
                }
            }, [opencvReady]);
            
            const cancelEraser = useCallback(() => {
                setEraserMode(false);
            }, []);
            
            // Initialize eraser canvas when mode is enabled
            useEffect(() => {
                if (eraserMode) {
                    initEraserCanvas();
                }
            }, [eraserMode, initEraserCanvas]);
            
            // ========== BOX ADJUSTMENT ==========
            const shrinkBox = useCallback((index, amount = 5) => {
                setRecognitionResults(prev => {
                    const updated = [...prev];
                    if (updated[index]) {
                        const pos = updated[index].position;
                        updated[index] = {
                            ...updated[index],
                            position: {
                                x: pos.x + amount,
                                y: pos.y + amount,
                                width: Math.max(10, pos.width - amount * 2),
                                height: Math.max(10, pos.height - amount * 2)
                            }
                        };
                    }
                    return updated;
                });
            }, []);
            
            const expandBox = useCallback((index, amount = 5) => {
                setRecognitionResults(prev => {
                    const updated = [...prev];
                    if (updated[index]) {
                        const pos = updated[index].position;
                        updated[index] = {
                            ...updated[index],
                            position: {
                                x: Math.max(0, pos.x - amount),
                                y: Math.max(0, pos.y - amount),
                                width: pos.width + amount * 2,
                                height: pos.height + amount * 2
                            }
                        };
                    }
                    return updated;
                });
            }, []);
            
            // ========== REGION EDITOR (Per-Detection Eraser) ==========
            const openRegionEditor = useCallback((detectionIdx) => {
                setRegionEditorIdx(detectionIdx);
            }, []);
            
            const initRegionEditorCanvas = useCallback(() => {
                if (regionEditorIdx === null || !regionEditorCanvasRef.current || !displayImage) return;
                
                const detection = recognitionResults[regionEditorIdx];
                if (!detection) return;
                
                const canvas = regionEditorCanvasRef.current;
                const pos = detection.position;
                
                // Add padding around the region
                const padding = 20;
                const regionX = Math.max(0, pos.x - padding);
                const regionY = Math.max(0, pos.y - padding);
                const regionW = pos.width + padding * 2;
                const regionH = pos.height + padding * 2;
                
                // Set canvas size to region size (scaled up for easier editing)
                const scale = Math.min(400 / regionW, 400 / regionH, 3);
                canvas.width = regionW * scale;
                canvas.height = regionH * scale;
                
                // Store region info on canvas for later
                canvas.dataset.regionX = regionX;
                canvas.dataset.regionY = regionY;
                canvas.dataset.regionW = regionW;
                canvas.dataset.regionH = regionH;
                canvas.dataset.scale = scale;
                
                // Draw the region from the display image
                const img = new Image();
                img.onload = () => {
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        img,
                        regionX, regionY, regionW, regionH,  // Source
                        0, 0, canvas.width, canvas.height     // Destination
                    );
                };
                img.src = displayImage;
            }, [regionEditorIdx, recognitionResults, displayImage]);
            
            const handleRegionEditorStart = useCallback((e) => {
                if (regionEditorIdx === null || !regionEditorCanvasRef.current) return;
                regionEditorDrawingRef.current = true;
                handleRegionEditorDraw(e);
            }, [regionEditorIdx]);
            
            const handleRegionEditorDraw = useCallback((e) => {
                if (!regionEditorDrawingRef.current || regionEditorIdx === null || !regionEditorCanvasRef.current) return;
                
                const canvas = regionEditorCanvasRef.current;
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                // Scale the brush size to match cursor (cursor is in screen pixels, canvas is in canvas coords)
                const scale = canvas.width / rect.width;
                const scaledSize = regionEditorSize * scale;
                
                // Draw white circle (erase) - scaled to match cursor appearance
                ctx.beginPath();
                ctx.arc(x, y, scaledSize, 0, Math.PI * 2);
                ctx.fillStyle = '#FFFFFF';
                ctx.fill();
            }, [regionEditorIdx, regionEditorSize]);
            
            const handleRegionEditorEnd = useCallback(() => {
                regionEditorDrawingRef.current = false;
            }, []);
            
            const applyRegionEdit = useCallback(async () => {
                if (regionEditorIdx === null || !regionEditorCanvasRef.current) return;
                
                try {
                    const canvas = regionEditorCanvasRef.current;
                    
                    // ONLY update the thumbnail for this detection card
                    // Do NOT modify the main display image - keep it intact for viewing all boxes
                    const detection = recognitionResults[regionEditorIdx];
                    if (detection) {
                        // Create thumbnail directly from the edited canvas
                        // Scale it down to detection size
                        const pos = detection.position;
                        const padding = 20;
                        
                        // The canvas contains the region with padding, extract just the detection area
                        const thumbCanvas = document.createElement('canvas');
                        thumbCanvas.width = pos.width;
                        thumbCanvas.height = pos.height;
                        const thumbCtx = thumbCanvas.getContext('2d');
                        
                        // Calculate where the actual detection is within the padded canvas
                        const scale = parseFloat(canvas.dataset.scale || 1);
                        const paddingScaled = padding * scale;
                        
                        thumbCtx.drawImage(
                            canvas,
                            paddingScaled, paddingScaled,  // Source x,y (skip padding)
                            pos.width * scale, pos.height * scale,  // Source w,h
                            0, 0, pos.width, pos.height  // Dest
                        );
                        
                        const newThumbnail = thumbCanvas.toDataURL();
                        
                        // Update recognition results with new thumbnail ONLY
                        setRecognitionResults(prev => {
                            const updated = [...prev];
                            if (updated[regionEditorIdx]) {
                                updated[regionEditorIdx] = {
                                    ...updated[regionEditorIdx],
                                    thumbnail: newThumbnail,
                                    thumbnailEdited: true  // Flag that this was manually edited
                                };
                            }
                            return updated;
                        });
                    }
                    
                    const closedIdx = regionEditorIdx;
                    setRegionEditorIdx(null);
                    console.log(`‚úÖ Thumbnail updated for detection #${closedIdx + 1} (main image unchanged)`);
                } catch (error) {
                    console.error('Region edit error:', error);
                    alert('Failed to apply region edit');
                }
            }, [regionEditorIdx, recognitionResults]);
            
            const cancelRegionEdit = useCallback(() => {
                setRegionEditorIdx(null);
            }, []);
            
            // ========== MANUAL BOX DRAWING ==========
            const handleManualBoxStart = useCallback((e) => {
                if (!manualBoxMode || !imageRef.current || !imageContainerRef.current) return;
                
                const container = imageContainerRef.current;
                const img = imageRef.current;
                const containerRect = container.getBoundingClientRect();
                const imgRect = img.getBoundingClientRect();
                
                // Calculate click position relative to image
                const offsetX = (containerRect.width - imgRect.width) / 2;
                const offsetY = (containerRect.height - imgRect.height) / 2;
                const x = e.clientX - containerRect.left - offsetX;
                const y = e.clientY - containerRect.top - offsetY;
                
                // Only start if click is within image bounds
                if (x >= 0 && x <= imgRect.width && y >= 0 && y <= imgRect.height) {
                    setDrawingBox({ startX: x, startY: y, currentX: x, currentY: y });
                }
            }, [manualBoxMode]);
            
            const handleManualBoxMove = useCallback((e) => {
                if (!drawingBox || !imageContainerRef.current) return;
                
                const container = imageContainerRef.current;
                const img = imageRef.current;
                const containerRect = container.getBoundingClientRect();
                const imgRect = img.getBoundingClientRect();
                
                const offsetX = (containerRect.width - imgRect.width) / 2;
                const offsetY = (containerRect.height - imgRect.height) / 2;
                const x = e.clientX - containerRect.left - offsetX;
                const y = e.clientY - containerRect.top - offsetY;
                
                setDrawingBox(prev => prev ? { ...prev, currentX: x, currentY: y } : null);
            }, [drawingBox]);
            
            const handleManualBoxEnd = useCallback((e) => {
                if (!drawingBox || !imageRef.current) return;
                
                const img = imageRef.current;
                const imgRect = img.getBoundingClientRect();
                const sourceWidth = recognitionSourceDims?.width || img.naturalWidth;
                const sourceHeight = recognitionSourceDims?.height || img.naturalHeight;
                
                // Convert screen coords to image coords
                const scaleX = sourceWidth / imgRect.width;
                const scaleY = sourceHeight / imgRect.height;
                
                const x = Math.min(drawingBox.startX, drawingBox.currentX) * scaleX;
                const y = Math.min(drawingBox.startY, drawingBox.currentY) * scaleY;
                const width = Math.abs(drawingBox.currentX - drawingBox.startX) * scaleX;
                const height = Math.abs(drawingBox.currentY - drawingBox.startY) * scaleY;
                
                // Only create box if it has reasonable size
                if (width > 5 && height > 5) {
                    setShowGlyphSelector({ mode: 'manual', position: { x, y, width, height } });
                    setGlyphSelectorSearch('');
                }
                
                setDrawingBox(null);
            }, [drawingBox, recognitionSourceDims]);
            
            // Open glyph selector to change an existing detection's glyph
            const openChartSelector = useCallback((detectionIndex) => {
                setShowGlyphSelector({ mode: 'change', detectionIndex });
                setGlyphSelectorSearch('');
            }, []);
            
            const addManualDetection = useCallback((glyph, position) => {
                if (!glyph || !position) return;
                
                // Create thumbnail from image
                let thumbnail = null;
                if (imageRef.current) {
                    try {
                        const img = imageRef.current;
                        const canvas = document.createElement('canvas');
                        canvas.width = position.width;
                        canvas.height = position.height;
                        const ctx = canvas.getContext('2d');
                        
                        // Draw from the source image
                        const tempImg = new Image();
                        tempImg.crossOrigin = 'anonymous';
                        tempImg.src = displayImage;
                        ctx.drawImage(tempImg, 
                            position.x, position.y, position.width, position.height,
                            0, 0, position.width, position.height
                        );
                        thumbnail = canvas.toDataURL('image/png');
                    } catch (e) {
                        console.warn('Could not create thumbnail:', e);
                    }
                }
                
                const newIndex = recognitionResults.length;
                const newDetection = {
                    glyph: glyph,
                    confidence: 1.0, // Manual = high confidence
                    position: position,
                    thumbnail: thumbnail,
                    matchType: 'manual',
                    isManual: true,
                    regionIndex: newIndex
                };
                
                setRecognitionResults(prev => [...prev, newDetection]);
                
                // Add to reading order at the end
                setReadingOrder(prev => [...prev, newIndex]);
                
                setShowGlyphSelector(null);
                setManualBoxMode(false);
                
                console.log('‚úÖ Added manual detection:', glyph.name, 'at index', newIndex);
            }, [displayImage, recognitionResults.length]);
            
            // Initialize region editor canvas when opened
            useEffect(() => {
                if (regionEditorIdx !== null) {
                    // Small delay to ensure canvas is mounted
                    setTimeout(initRegionEditorCanvas, 50);
                }
            }, [regionEditorIdx, initRegionEditorCanvas]);
            
            // ========== RECOGNITION ==========
            const recognizeGlyphs = useCallback(async () => {
                if (!displayImage || !chartData || Object.keys(loadedGlyphImages).length === 0) {
                    alert('‚ùå Please load an image and wait for the glyph chart to load');
                    return;
                }
                
                if (!opencvReady) {
                    alert('‚ùå OpenCV not ready yet');
                    return;
                }
                
                setIsProcessing(true);
                setRecognitionResults([]);
                setValidations({});
                setProcessingStatus('Isolating glyphs...');
                
                try {
                    console.log('üîç Starting glyph recognition...');
                    
                    // Get the mat to use (preprocessed or original)
                    let inputMat = preprocessedMatRef.current || originalMatRef.current;
                    if (!inputMat) {
                        inputMat = await loadImageToMat(displayImage);
                    }
                    
                    // Store the dimensions of the image we're running recognition on
                    // This is critical for aligning detection boxes later
                    setRecognitionSourceDims({
                        width: inputMat.cols,
                        height: inputMat.rows
                    });
                    
                    // Clone for isolation (Isolation module may modify it)
                    const matForIsolation = inputMat.clone();
                    
                    // Step 1: Isolate potential glyph regions
                    let regions = [];
                    if (typeof Isolation !== 'undefined' && Isolation.isolateGlyphs) {
                        try {
                            regions = Isolation.isolateGlyphs(matForIsolation);
                            console.log(`üì¶ Isolated ${regions.length} regions via Isolation module`);
                        } catch (e) {
                            console.error('Isolation module error:', e);
                            // Fallback
                            regions = await fallbackIsolation(inputMat);
                        }
                    } else {
                        regions = await fallbackIsolation(inputMat);
                    }
                    
                    matForIsolation.delete();
                    
                    if (regions.length === 0) {
                        alert('‚ö†Ô∏è No glyph regions detected. Try adjusting preprocessing settings.');
                        setIsProcessing(false);
                        return;
                    }
                    
                    // Filter overlapping regions
                    if (typeof Isolation !== 'undefined' && Isolation.filterOverlappingRegions) {
                        regions = Isolation.filterOverlappingRegions(regions, 0.3);
                    }
                    
                    setProcessingStatus(`Matching ${regions.length} regions...`);
                    
                    // Step 2: Match each region against templates
                    const allDetections = [];
                    
                    for (let i = 0; i < regions.length; i++) {
                        const region = regions[i];
                        setProcessingStatus(`Matching region ${i + 1}/${regions.length}...`);
                        
                        // Get position from region
                        const position = region.bounds || region;
                        
                        // Match against all glyphs
                        const regionDetections = [];
                        
                        for (const glyph of chartData.glyphs) {
                            const templateImg = loadedGlyphImages[glyph.id];
                            if (!templateImg) continue;
                            
                            // Simple shape-based matching (aspect ratio comparison)
                            const regionAspect = position.width / position.height;
                            const templateAspect = templateImg.naturalWidth / templateImg.naturalHeight;
                            const aspectDiff = Math.abs(regionAspect - templateAspect);
                            let confidence = Math.max(0, 1 - aspectDiff * 0.5);
                            
                            // Add solidity bonus if available
                            if (region.solidity && glyph.expected_solidity) {
                                const solidityDiff = Math.abs(region.solidity - glyph.expected_solidity);
                                confidence += Math.max(0, 1 - solidityDiff) * 0.2;
                            }
                            
                            if (confidence > 0.35) {
                                regionDetections.push({
                                    glyph: glyph,
                                    confidence: Math.min(confidence, 0.99),
                                    position: position,
                                    thumbnail: region.thumbnail || null
                                });
                            }
                        }
                        
                        // Keep best match
                        if (regionDetections.length > 0) {
                            regionDetections.sort((a, b) => b.confidence - a.confidence);
                            const best = regionDetections[0];
                            best.topMatches = regionDetections.slice(0, 5);
                            allDetections.push(best);
                        }
                    }
                    
                    setProcessingStatus('Applying NMS...');
                    
                    // Step 3: Apply NMS
                    let finalDetections = allDetections;
                    if (typeof NMS !== 'undefined' && NMS.applyNMS) {
                        finalDetections = NMS.applyNMS(allDetections, CONFIG.RECOGNITION.IOU_THRESHOLD);
                    } else {
                        // Simple NMS fallback
                        finalDetections = simpleNMS(allDetections, 0.3);
                    }
                    
                    console.log(`‚ú® Final detections: ${finalDetections.length}`);
                    setRecognitionResults(finalDetections);
                    
                    // Step 4: Auto-detect reading order
                    if (finalDetections.length > 0) {
                        if (typeof ReadingOrder !== 'undefined' && ReadingOrder.generateOrder) {
                            const order = ReadingOrder.generateOrder(finalDetections, readingDirection);
                            setReadingOrder(order);
                        } else {
                            // Simple fallback
                            const order = finalDetections
                                .map((d, i) => ({ i, x: d.position.x, y: d.position.y }))
                                .sort((a, b) => {
                                    const rowDiff = Math.floor(a.y / 50) - Math.floor(b.y / 50);
                                    if (rowDiff !== 0) return rowDiff;
                                    return readingDirection === 'rtl' ? b.x - a.x : a.x - b.x;
                                })
                                .map(d => d.i);
                            setReadingOrder(order);
                        }
                    }
                    
                    alert(`‚úÖ Recognition complete! Found ${finalDetections.length} glyphs`);
                    
                } catch (error) {
                    console.error('Recognition error:', error);
                    alert('‚ùå Recognition failed: ' + error.message);
                } finally {
                    setIsProcessing(false);
                    setProcessingStatus('');
                }
            }, [displayImage, chartData, loadedGlyphImages, opencvReady, loadImageToMat, readingDirection]);
            
            // Fallback isolation
            const fallbackIsolation = async (mat) => {
                const regions = [];
                try {
                    let gray = new cv.Mat();
                    if (mat.channels() > 1) cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
                    else gray = mat.clone();
                    
                    let binary = new cv.Mat();
                    cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
                    
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                    
                    const imageArea = mat.rows * mat.cols;
                    const minArea = imageArea * 0.0005;
                    const maxArea = imageArea * 0.15;
                    
                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const area = cv.contourArea(contour);
                        
                        if (area < minArea || area > maxArea) continue;
                        
                        const rect = cv.boundingRect(contour);
                        const aspectRatio = rect.width / rect.height;
                        
                        if (aspectRatio < 0.2 || aspectRatio > 5.0) continue;
                        
                        // Extract thumbnail
                        const roi = mat.roi(new cv.Rect(rect.x, rect.y, rect.width, rect.height));
                        const canvas = document.createElement('canvas');
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                        cv.imshow(canvas, roi);
                        roi.delete();
                        
                        regions.push({
                            bounds: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },
                            area: area,
                            aspectRatio: aspectRatio,
                            solidity: area / (rect.width * rect.height),
                            thumbnail: canvas.toDataURL()
                        });
                    }
                    
                    gray.delete();
                    binary.delete();
                    contours.delete();
                    hierarchy.delete();
                } catch (e) {
                    console.error('Fallback isolation error:', e);
                }
                return regions;
            };
            
            // Simple NMS
            const simpleNMS = (detections, threshold) => {
                const sorted = [...detections].sort((a, b) => b.confidence - a.confidence);
                const kept = [];
                for (const det of sorted) {
                    let dominated = false;
                    for (const kept_det of kept) {
                        const iou = Utils.calculateIoU(det.position, kept_det.position);
                        if (iou > threshold) { dominated = true; break; }
                    }
                    if (!dominated) kept.push(det);
                }
                return kept;
            };
            
            // ========== VALIDATION ==========
            const validateDetection = useCallback((index, isCorrect) => {
                setValidations(prev => ({
                    ...prev,
                    [index]: { isCorrect, timestamp: new Date().toISOString() }
                }));
            }, []);
            
            const deleteDetection = useCallback((index) => {
                setRecognitionResults(prev => prev.filter((_, i) => i !== index));
                setValidations(prev => {
                    const updated = {};
                    Object.entries(prev).forEach(([k, v]) => {
                        const oldIdx = parseInt(k);
                        if (oldIdx < index) updated[oldIdx] = v;
                        else if (oldIdx > index) updated[oldIdx - 1] = v;
                    });
                    return updated;
                });
                setReadingOrder(prev => prev.filter(i => i !== index).map(i => i > index ? i - 1 : i));
                setExcludedDetections(prev => {
                    const updated = new Set();
                    prev.forEach(i => {
                        if (i < index) updated.add(i);
                        else if (i > index) updated.add(i - 1);
                    });
                    return updated;
                });
                setExpandedCards(prev => {
                    const updated = new Set();
                    prev.forEach(i => {
                        if (i < index) updated.add(i);
                        else if (i > index) updated.add(i - 1);
                    });
                    return updated;
                });
            }, []);
            
            // Change glyph assignment to an alternative match
            const changeGlyphAssignment = useCallback((detectionIdx, newGlyph) => {
                setRecognitionResults(prev => {
                    const updated = [...prev];
                    if (updated[detectionIdx]) {
                        updated[detectionIdx] = {
                            ...updated[detectionIdx],
                            glyph: newGlyph,
                            // Find confidence from topMatches
                            confidence: updated[detectionIdx].topMatches?.find(m => m.glyph.id === newGlyph.id)?.confidence || updated[detectionIdx].confidence
                        };
                    }
                    return updated;
                });
                // Clear validation when glyph changes
                setValidations(prev => {
                    const updated = { ...prev };
                    delete updated[detectionIdx];
                    return updated;
                });
            }, []);
            
            // Toggle exclusion of a detection from reading order
            const toggleExcludeDetection = useCallback((index) => {
                setExcludedDetections(prev => {
                    const updated = new Set(prev);
                    if (updated.has(index)) {
                        updated.delete(index);
                    } else {
                        updated.add(index);
                    }
                    return updated;
                });
            }, []);
            
            // Merge two selected detections
            const mergeSelectedDetections = useCallback(() => {
                if (selectedRegions.size !== 2) {
                    alert('Select exactly 2 detections to merge');
                    return;
                }
                
                const indices = Array.from(selectedRegions).sort((a, b) => a - b);
                const [idx1, idx2] = indices;
                const det1 = recognitionResults[idx1];
                const det2 = recognitionResults[idx2];
                
                if (!det1 || !det2) return;
                
                // Create merged detection - use higher confidence one as base
                const baseDet = det1.confidence >= det2.confidence ? det1 : det2;
                const mergedPosition = {
                    x: Math.min(det1.position.x, det2.position.x),
                    y: Math.min(det1.position.y, det2.position.y),
                    width: Math.max(det1.position.x + det1.position.width, det2.position.x + det2.position.width) - Math.min(det1.position.x, det2.position.x),
                    height: Math.max(det1.position.y + det1.position.height, det2.position.y + det2.position.height) - Math.min(det1.position.y, det2.position.y)
                };
                
                const merged = {
                    ...baseDet,
                    position: mergedPosition,
                    isMerged: true,
                    mergedFrom: [idx1, idx2]
                };
                
                // Remove both, add merged at first position
                setRecognitionResults(prev => {
                    const updated = prev.filter((_, i) => i !== idx1 && i !== idx2);
                    updated.splice(idx1, 0, merged);
                    return updated;
                });
                
                setSelectedRegions(new Set());
                setReadingOrder(prev => {
                    // Remove old indices, adjust remaining
                    return prev
                        .filter(i => i !== idx1 && i !== idx2)
                        .map(i => i > idx2 ? i - 2 : i > idx1 ? i - 1 : i)
                        .concat([idx1]); // Add merged at end
                });
                
                alert('‚úÖ Detections merged');
            }, [selectedRegions, recognitionResults]);
            
            // Toggle card expansion (show alternatives)
            const toggleCardExpansion = useCallback((index) => {
                setExpandedCards(prev => {
                    const updated = new Set(prev);
                    if (updated.has(index)) {
                        updated.delete(index);
                    } else {
                        updated.add(index);
                    }
                    return updated;
                });
            }, []);

            // ============================================
            // RENDER
            // ============================================
            return (
                <div className="min-h-screen bg-gray-100 flex flex-col">
                    {/* Header */}
                    <header className="bg-ancient-purple text-white shadow-lg flex-shrink-0">
                        <div className="max-w-7xl mx-auto px-4 py-2">
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                    <img src="hh-logo.png" alt="Hoopoe Holdings" className="w-10 h-10 rounded-full object-cover" />
                                    <div>
                                        <h1 className="text-base font-bold leading-tight">Hakli Glyph Recognizer</h1>
                                        <p className="text-xs text-purple-200 leading-tight">
                                            Based on Ahmad Al-Jallad (2025), <em>The Decipherment of the Dhofari Script</em>
                                        </p>
                                        <p className="text-xs text-purple-300 leading-tight">
                                            beta {APP_VERSION} ¬© hoopoe holdings
                                        </p>
                                    </div>
                                </div>
                                
                                <div className="flex items-center gap-2">
                                    {/* Manage Chart Button */}
                                    <button
                                        onClick={() => setShowChartManager(true)}
                                        disabled={chartStatus !== 'loaded'}
                                        className="px-3 py-1 bg-white/20 hover:bg-white/30 rounded-lg text-xs font-medium disabled:opacity-50"
                                    >
                                        üìä Manage Chart
                                    </button>
                                    <div className={`px-2 py-1 rounded-full text-xs ${chartStatus === 'loaded' ? 'bg-patina' : 'bg-ochre'}`}>
                                        {chartStatus === 'loaded' ? `‚úÖ ${chartData?.glyphs?.length || 0} glyphs` : `‚è≥ Loading...`}
                                    </div>
                                    <div className={`px-2 py-1 rounded-full text-xs ${opencvReady ? 'bg-patina' : 'bg-ochre'}`}>
                                        {opencvReady ? '‚úÖ CV' : '‚è≥ CV'}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </header>
                    
                    {/* Main Content */}
                    <main className="flex-1 max-w-7xl w-full mx-auto px-4 py-4">
                        <div className="grid grid-cols-12 gap-4">
                            {/* Left Sidebar */}
                            <aside className="col-span-3 space-y-3">
                                {/* Image Upload */}
                                <div className="bg-white rounded-lg shadow p-3">
                                    <h3 className="font-bold text-gray-700 mb-2 text-sm">üì∑ Image</h3>
                                    <input ref={fileInputRef} type="file" accept="image/*" onChange={handleImageUpload} className="hidden" />
                                    <button onClick={() => fileInputRef.current?.click()} disabled={isImageLoading}
                                        className="w-full px-3 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3d5a] text-sm font-medium disabled:bg-gray-300">
                                        {isImageLoading ? '‚è≥ Loading...' : (originalImage ? 'üîÑ Change Image' : 'üì§ Upload Image')}
                                    </button>
                                </div>
                                
                                {/* Preprocessing */}
                                {originalImage && (
                                    <div className="bg-white rounded-lg shadow overflow-hidden">
                                        <div className="px-3 py-2 bg-gray-50 flex items-center justify-between cursor-pointer hover:bg-gray-100"
                                            onClick={() => setIsPreprocessingCollapsed(!isPreprocessingCollapsed)}>
                                            <div className="flex items-center gap-2">
                                                <span className="text-sm">üîß</span>
                                                <span className="font-semibold text-gray-700 text-sm">Preprocessing</span>
                                                {preprocessing.useAdaptiveThreshold && <span className="px-1.5 py-0.5 bg-ancient-purple text-white text-xs rounded">Active</span>}
                                            </div>
                                            <svg className={`w-4 h-4 transition-transform ${isPreprocessingCollapsed ? '' : 'rotate-180'}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                            </svg>
                                        </div>
                                        
                                        {!isPreprocessingCollapsed && (
                                            <div className="p-3 space-y-3 text-sm">
                                                {/* Rotation */}
                                                <div>
                                                    <div className="flex justify-between text-gray-600 mb-1"><span>üîÑ Rotation</span><span>{preprocessing.rotation}¬∞</span></div>
                                                    <input type="range" min="-180" max="180" value={preprocessing.rotation}
                                                        onChange={(e) => setPreprocessing(p => ({ ...p, rotation: parseInt(e.target.value) }))} className="w-full" />
                                                </div>
                                                
                                                {/* Blur */}
                                                <div>
                                                    <div className="flex justify-between text-gray-600 mb-1"><span>üå´Ô∏è Blur</span><span>{preprocessing.gaussianBlur}</span></div>
                                                    <input type="range" min="0" max="15" step="2" value={preprocessing.gaussianBlur}
                                                        onChange={(e) => setPreprocessing(p => ({ ...p, gaussianBlur: parseInt(e.target.value) }))} className="w-full" />
                                                </div>
                                                
                                                {/* Adaptive Threshold */}
                                                <div className="p-2 bg-gray-50 rounded space-y-2">
                                                    <div className="flex items-center justify-between">
                                                        <span className="text-gray-700">üìä Adaptive Threshold</span>
                                                        <button onClick={() => setPreprocessing(p => ({ ...p, useAdaptiveThreshold: !p.useAdaptiveThreshold }))}
                                                            className={`w-10 h-5 rounded-full ${preprocessing.useAdaptiveThreshold ? 'bg-ancient-purple' : 'bg-gray-300'}`}>
                                                            <div className={`w-4 h-4 bg-white rounded-full shadow transform ${preprocessing.useAdaptiveThreshold ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                        </button>
                                                    </div>
                                                    {preprocessing.useAdaptiveThreshold && (
                                                        <>
                                                            <div>
                                                                <div className="flex justify-between text-xs text-gray-500 mb-1"><span>Block Size</span><span>{preprocessing.blockSize}</span></div>
                                                                <input type="range" min="3" max="51" step="2" value={preprocessing.blockSize}
                                                                    onChange={(e) => setPreprocessing(p => ({ ...p, blockSize: parseInt(e.target.value) }))} className="w-full" />
                                                            </div>
                                                            <div>
                                                                <div className="flex justify-between text-xs text-gray-500 mb-1"><span>Offset</span><span>{preprocessing.constantOffset}</span></div>
                                                                <input type="range" min="-20" max="20" value={preprocessing.constantOffset}
                                                                    onChange={(e) => setPreprocessing(p => ({ ...p, constantOffset: parseInt(e.target.value) }))} className="w-full" />
                                                            </div>
                                                        </>
                                                    )}
                                                </div>
                                                
                                                {/* Morphology */}
                                                <div>
                                                    <span className="text-gray-600 block mb-1">üî≤ Morphology</span>
                                                    <select value={preprocessing.morphologyOperation}
                                                        onChange={(e) => setPreprocessing(p => ({ ...p, morphologyOperation: e.target.value }))}
                                                        className="w-full px-2 py-1 border border-gray-300 rounded text-sm">
                                                        <option value="none">None</option>
                                                        <option value="erode">Erode</option>
                                                        <option value="dilate">Dilate</option>
                                                        <option value="open">Open</option>
                                                        <option value="close">Close</option>
                                                    </select>
                                                </div>
                                                
                                                {/* Invert */}
                                                <div className="flex items-center justify-between">
                                                    <span className="text-gray-700">üîÑ Invert</span>
                                                    <button onClick={() => setPreprocessing(p => ({ ...p, invertColors: !p.invertColors }))}
                                                        className={`w-10 h-5 rounded-full ${preprocessing.invertColors ? 'bg-ancient-purple' : 'bg-gray-300'}`}>
                                                        <div className={`w-4 h-4 bg-white rounded-full shadow transform ${preprocessing.invertColors ? 'translate-x-5' : 'translate-x-0.5'}`} />
                                                    </button>
                                                </div>
                                                
                                                {/* Buttons */}
                                                <div className="flex gap-2 pt-2">
                                                    <button onClick={resetPreprocessing} 
                                                        className="flex-1 px-2 py-1.5 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded text-sm border border-gray-300">
                                                        ‚Ü©Ô∏è Reset
                                                    </button>
                                                    <button onClick={applyPreprocessing} disabled={!opencvReady}
                                                        className="flex-1 px-2 py-1.5 bg-patina hover:bg-[#5a7d6e] text-white rounded text-sm font-medium disabled:bg-gray-300">
                                                        ‚úÖ Apply
                                                    </button>
                                                </div>
                                                
                                                {/* Eraser Tool */}
                                                <div className="pt-2 border-t border-gray-200">
                                                    <div className="flex items-center justify-between mb-2">
                                                        <span className="text-gray-700">üßπ Eraser Tool</span>
                                                        <button onClick={() => setEraserMode(!eraserMode)}
                                                            className={`px-2 py-1 rounded text-xs ${eraserMode ? 'bg-ochre text-white' : 'bg-gray-200 text-gray-600 hover:bg-gray-300'}`}>
                                                            {eraserMode ? 'Active' : 'Enable'}
                                                        </button>
                                                    </div>
                                                    {eraserMode && (
                                                        <div className="space-y-2">
                                                            <div>
                                                                <div className="flex justify-between text-xs text-gray-500 mb-1">
                                                                    <span>Brush Size</span><span>{eraserSize}px</span>
                                                                </div>
                                                                <input type="range" min="5" max="50" value={eraserSize}
                                                                    onChange={(e) => setEraserSize(parseInt(e.target.value))} className="w-full" />
                                                            </div>
                                                            <div className="flex gap-2">
                                                                <button onClick={cancelEraser}
                                                                    className="flex-1 px-2 py-1 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded text-xs">Cancel</button>
                                                                <button onClick={applyEraser}
                                                                    className="flex-1 px-2 py-1 bg-patina hover:bg-[#5a7d6e] text-white rounded text-xs">Apply Eraser</button>
                                                            </div>
                                                            <p className="text-xs text-gray-400">Draw on image to erase unwanted marks</p>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </aside>
                            
                            {/* Center - Image */}
                            <div className="col-span-6">
                                <div className="bg-white rounded-lg shadow p-3 h-full flex flex-col">
                                    {/* Eraser mode indicator */}
                                    {eraserMode && (
                                        <div className="mb-2 px-2 py-1 bg-ochre/20 border border-ochre rounded text-xs text-center">
                                            üßπ Eraser Mode Active - Draw to erase, then click "Apply Eraser"
                                        </div>
                                    )}
                                    
                                    {displayImage ? (
                                        <div ref={imageContainerRef} 
                                            className="relative flex-1 flex items-center justify-center overflow-hidden"
                                            style={{ cursor: manualBoxMode ? 'crosshair' : 'default' }}
                                            onMouseDown={manualBoxMode ? handleManualBoxStart : undefined}
                                            onMouseMove={manualBoxMode ? handleManualBoxMove : undefined}
                                            onMouseUp={manualBoxMode ? handleManualBoxEnd : undefined}
                                            onMouseLeave={manualBoxMode ? () => setDrawingBox(null) : undefined}
                                        >
                                            {/* Regular image display (hidden when eraser active) */}
                                            <img ref={imageRef} src={displayImage} alt="Inscription" 
                                                className={`max-w-full max-h-full object-contain ${eraserMode ? 'hidden' : ''}`}
                                                style={{ pointerEvents: manualBoxMode ? 'none' : 'auto' }}
                                            />
                                            
                                            {/* Manual Box Drawing Overlay */}
                                            {manualBoxMode && drawingBox && (() => {
                                                const img = imageRef.current;
                                                const container = imageContainerRef.current;
                                                if (!img || !container) return null;
                                                
                                                const containerRect = container.getBoundingClientRect();
                                                const imgRect = img.getBoundingClientRect();
                                                const offsetX = (containerRect.width - imgRect.width) / 2;
                                                const offsetY = (containerRect.height - imgRect.height) / 2;
                                                
                                                const left = offsetX + Math.min(drawingBox.startX, drawingBox.currentX);
                                                const top = offsetY + Math.min(drawingBox.startY, drawingBox.currentY);
                                                const width = Math.abs(drawingBox.currentX - drawingBox.startX);
                                                const height = Math.abs(drawingBox.currentY - drawingBox.startY);
                                                
                                                return (
                                                    <div 
                                                        className="absolute border-2 border-dashed border-ochre bg-ochre/20 pointer-events-none"
                                                        style={{ left, top, width, height }}
                                                    />
                                                );
                                            })()}
                                            
                                            {/* Eraser canvas (shown when eraser active) */}
                                            {eraserMode && (
                                                <canvas ref={eraserCanvasRef}
                                                    className="max-w-full max-h-full object-contain"
                                                    style={{ cursor: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="${eraserSize * 2 + 2}" height="${eraserSize * 2 + 2}" viewBox="0 0 ${eraserSize * 2 + 2} ${eraserSize * 2 + 2}"><circle cx="${eraserSize + 1}" cy="${eraserSize + 1}" r="${eraserSize}" fill="none" stroke="black" stroke-width="1.5"/><circle cx="${eraserSize + 1}" cy="${eraserSize + 1}" r="${eraserSize}" fill="none" stroke="white" stroke-width="0.5"/><line x1="${eraserSize + 1}" y1="${eraserSize - 4}" x2="${eraserSize + 1}" y2="${eraserSize + 7}" stroke="black" stroke-width="1"/><line x1="${eraserSize - 4}" y1="${eraserSize + 1}" x2="${eraserSize + 7}" y2="${eraserSize + 1}" stroke="black" stroke-width="1"/></svg>') ${eraserSize + 1} ${eraserSize + 1}, crosshair` }}
                                                    onMouseDown={handleEraserStart}
                                                    onMouseMove={handleEraserDraw}
                                                    onMouseUp={handleEraserEnd}
                                                    onMouseLeave={handleEraserEnd}
                                                />
                                            )}
                                            
                                            {/* Detection boxes (hidden during eraser mode) */}
                                            {!eraserMode && recognitionResults.map((result, index) => {
                                                const validation = validations[index];
                                                const isSelected = selectedRegions.has(index);
                                                
                                                let boxClass = 'detection-box unvalidated';
                                                let labelBg = 'bg-stone';
                                                
                                                if (isSelected) { boxClass = 'detection-box selected'; labelBg = 'bg-ochre'; }
                                                else if (validation?.isCorrect) { boxClass = 'detection-box validated-correct'; labelBg = 'bg-patina'; }
                                                else if (validation && !validation.isCorrect) { boxClass = 'detection-box validated-incorrect'; labelBg = 'bg-rust'; }
                                                if (result.confidence < 0.5) boxClass += ' uncertain';
                                                
                                                const img = imageRef.current;
                                                const container = imageContainerRef.current;
                                                if (!img || !container) return null;
                                                
                                                // Force recalculation by using boxLayoutKey (referenced but not directly used)
                                                const _ = boxLayoutKey;
                                                
                                                const containerRect = container.getBoundingClientRect();
                                                const imgRect = img.getBoundingClientRect();
                                                
                                                // Use tracked recognition source dimensions if available
                                                // This ensures boxes align correctly even if the display image changed
                                                const sourceWidth = recognitionSourceDims?.width || img.naturalWidth;
                                                const sourceHeight = recognitionSourceDims?.height || img.naturalHeight;
                                                
                                                const scaleX = imgRect.width / sourceWidth;
                                                const scaleY = imgRect.height / sourceHeight;
                                                const offsetX = containerRect && imgRect ? (containerRect.width - imgRect.width) / 2 : 0;
                                                const offsetY = containerRect && imgRect ? (containerRect.height - imgRect.height) / 2 : 0;
                                                
                                                // Skip rendering if dimensions aren't ready
                                                if (!imgRect.width || !imgRect.height) return null;
                                                
                                                return (
                                                    <div key={index} className={boxClass}
                                                        style={{
                                                            left: offsetX + result.position.x * scaleX,
                                                            top: offsetY + result.position.y * scaleY,
                                                            width: result.position.width * scaleX,
                                                            height: result.position.height * scaleY
                                                        }}
                                                        onClick={() => setSelectedRegions(prev => {
                                                            const next = new Set(prev);
                                                            next.has(index) ? next.delete(index) : next.add(index);
                                                            return next;
                                                        })}
                                                        title={`${result.glyph.name} (${Math.round(result.confidence * 100)}%)`}>
                                                        <div className={`detection-label ${labelBg}`}>
                                                            {showArabicLabels ? result.glyph.arabic : result.glyph.transliteration}
                                                        </div>
                                                        {viewMode === 'reading' && <div className="reading-order-badge">{readingOrder.indexOf(index) + 1}</div>}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ) : (
                                        <div className="flex-1 flex flex-col items-center justify-center text-gray-400">
                                            <span className="text-5xl mb-3">üì∑</span>
                                            <p>Upload an inscription image to begin</p>
                                        </div>
                                    )}
                                </div>
                            </div>
                            
                            {/* Right Sidebar */}
                            <aside className="col-span-3 flex flex-col gap-3">
                                {/* Recognition Button */}
                                <div className="bg-white rounded-lg shadow p-3">
                                    <button onClick={recognizeGlyphs} disabled={isProcessing || chartStatus !== 'loaded' || !displayImage}
                                        className="w-full px-3 py-2.5 bg-patina text-white rounded-lg hover:bg-[#5a7d6e] text-sm font-medium disabled:bg-gray-300">
                                        {isProcessing ? `‚è≥ ${processingStatus || 'Processing...'}` : 'üîç Recognize Glyphs'}
                                    </button>
                                    
                                    {/* Manual Box Mode */}
                                    <button 
                                        onClick={() => {
                                            setManualBoxMode(!manualBoxMode);
                                            if (eraserMode) setEraserMode(false);
                                        }}
                                        disabled={!displayImage}
                                        className={`w-full mt-2 px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                                            manualBoxMode 
                                                ? 'bg-ochre text-white' 
                                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                        } disabled:bg-gray-100 disabled:text-gray-400`}
                                    >
                                        {manualBoxMode ? '‚úã Click to Exit Manual Mode' : '‚ûï Add Manual Box'}
                                    </button>
                                    
                                    {manualBoxMode && (
                                        <div className="mt-2 p-2 bg-ochre/10 rounded text-xs text-ochre">
                                            üñ±Ô∏è Click and drag on the image to draw a box around a glyph
                                        </div>
                                    )}
                                </div>
                                
                                {/* Detection List */}
                                <div className="bg-white rounded-lg shadow p-3 flex-1 overflow-hidden flex flex-col">
                                    <div className="flex items-center justify-between mb-2">
                                        <h3 className="font-bold text-gray-700 text-sm">
                                            {recognitionResults.length > 0 ? `üîç ${recognitionResults.length} Detections` : 'üîç No detections yet'}
                                        </h3>
                                        {recognitionResults.length > 0 && (
                                            <button onClick={() => setShowArabicLabels(!showArabicLabels)}
                                                className={`px-2 py-1 rounded text-xs ${showArabicLabels ? 'bg-ancient-purple text-white' : 'bg-gray-200'}`}>
                                                {showArabicLabels ? 'ÿπÿ±ÿ®Ÿä' : 'ABC'}
                                            </button>
                                        )}
                                    </div>
                                    
                                    {recognitionResults.length === 0 ? (
                                        <div className="flex-1 flex flex-col items-center justify-center text-gray-400 text-sm">
                                            <span className="text-3xl mb-2">üîç</span>
                                            <p>Run recognition to detect glyphs</p>
                                        </div>
                                    ) : (
                                        <>
                                            <div className="flex gap-1 mb-2">
                                                <button onClick={() => setViewMode('detection')}
                                                    className={`flex-1 px-2 py-1 rounded text-xs ${viewMode === 'detection' ? 'bg-ancient-purple text-white' : 'bg-gray-100'}`}>üîç Detection</button>
                                                <button onClick={() => setViewMode('reading')}
                                                    className={`flex-1 px-2 py-1 rounded text-xs ${viewMode === 'reading' ? 'bg-ancient-purple text-white' : 'bg-gray-100'}`}>üìñ Reading</button>
                                                <button onClick={() => { if(confirm('Clear all detections?')) { setRecognitionResults([]); setValidations({}); setReadingOrder([]); setExcludedDetections(new Set()); setExpandedCards(new Set()); }}}
                                                    className="px-2 py-1 bg-red-100 text-red-600 rounded text-xs hover:bg-red-200" title="Clear all detections">üóë</button>
                                            </div>
                                            
                                            {/* Merge button when 2 selected */}
                                            {selectedRegions.size === 2 && (
                                                <button onClick={mergeSelectedDetections}
                                                    className="w-full mb-2 px-2 py-1.5 bg-ochre text-white rounded text-xs hover:bg-[#a07f5a]">
                                                    üîó Merge {selectedRegions.size} Selected
                                                </button>
                                            )}
                                            
                                            <div className="flex-1 overflow-y-auto space-y-2">
                                                {(viewMode === 'reading' 
                                                    ? readingOrder.filter(i => !excludedDetections.has(i))
                                                    : recognitionResults.map((_, i) => i)
                                                ).map((idx, displayIdx) => {
                                                    const result = recognitionResults[idx];
                                                    if (!result) return null;
                                                    
                                                    const validation = validations[idx];
                                                    const isSelected = selectedRegions.has(idx);
                                                    const isExpanded = expandedCards.has(idx);
                                                    const isExcluded = excludedDetections.has(idx);
                                                    const conf = Math.round(result.confidence * 100);
                                                    
                                                    let borderColor = 'border-gray-200';
                                                    if (isExcluded) borderColor = 'border-gray-300';
                                                    else if (isSelected) borderColor = 'border-ochre';
                                                    else if (validation?.isCorrect) borderColor = 'border-patina';
                                                    else if (validation && !validation.isCorrect) borderColor = 'border-rust';
                                                    
                                                    return (
                                                        <div key={idx} className={`border-2 ${borderColor} rounded-lg overflow-hidden ${isSelected ? 'bg-yellow-50' : ''} ${isExcluded ? 'opacity-50' : ''}`}>
                                                            {/* Main card header */}
                                                            <div className="p-2 cursor-pointer hover:bg-gray-50"
                                                                onClick={() => setSelectedRegions(prev => { const n = new Set(prev); n.has(idx) ? n.delete(idx) : n.add(idx); return n; })}>
                                                                <div className="flex gap-2">
                                                                    {/* Thumbnails: Detected vs Chart */}
                                                                    <div className="flex gap-1 flex-shrink-0">
                                                                        {/* Detected region thumbnail */}
                                                                        {result.thumbnail && (
                                                                            <div className="relative">
                                                                                <div className={`w-10 h-10 bg-gray-100 rounded overflow-hidden border ${result.thumbnailEdited ? 'border-patina border-2' : 'border-gray-300'}`}>
                                                                                    <img src={result.thumbnail} alt="Detected" className="w-full h-full object-contain" />
                                                                                </div>
                                                                                <span className="absolute -bottom-1 left-0 right-0 text-center text-[8px] text-gray-400">
                                                                                    {result.thumbnailEdited ? '‚úìdet' : 'det'}
                                                                                </span>
                                                                            </div>
                                                                        )}
                                                                        {/* Chart glyph thumbnail */}
                                                                        {glyphThumbnails[result.glyph.id] && (
                                                                            <div className="relative">
                                                                                <div className="w-10 h-10 bg-white rounded overflow-hidden border border-ancient-purple">
                                                                                    <img src={glyphThumbnails[result.glyph.id]} alt="Chart" className="w-full h-full object-contain" />
                                                                                </div>
                                                                                <span className="absolute -bottom-1 left-0 right-0 text-center text-[8px] text-ancient-purple">chart</span>
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                    <div className="flex-1 min-w-0">
                                                                        <div className="flex items-center gap-1">
                                                                            <span className="font-bold text-xs text-gray-500">#{viewMode === 'reading' ? displayIdx + 1 : idx + 1}</span>
                                                                            <span className={`text-xs font-medium ${conf >= 70 ? 'text-patina' : conf >= 50 ? 'text-ochre' : 'text-rust'}`}>{conf}%</span>
                                                                            {isExcluded && <span className="text-xs text-gray-400">(excluded)</span>}
                                                                            {result.isMerged && <span className="text-xs text-blue-500">üîó</span>}
                                                                        </div>
                                                                        <div className="font-medium text-gray-900 text-sm truncate">{result.glyph.name}</div>
                                                                        <div className="text-lg text-ancient-purple leading-tight">{result.glyph.arabic || result.glyph.transliteration}</div>
                                                                    </div>
                                                                    <div className="flex flex-col gap-1">
                                                                        {!validation ? (
                                                                            <>
                                                                                <button onClick={(e) => { e.stopPropagation(); validateDetection(idx, true); }}
                                                                                    className="w-6 h-6 bg-patina text-white rounded text-xs hover:bg-[#5a7d6e]" title="Mark correct">‚úì</button>
                                                                                <button onClick={(e) => { e.stopPropagation(); validateDetection(idx, false); }}
                                                                                    className="w-6 h-6 bg-rust text-white rounded text-xs hover:bg-[#8a574a]" title="Mark incorrect">‚úó</button>
                                                                            </>
                                                                        ) : (
                                                                            <button onClick={(e) => { e.stopPropagation(); setValidations(prev => { const n = {...prev}; delete n[idx]; return n; }); }}
                                                                                className="w-6 h-6 bg-gray-400 text-white rounded text-xs hover:bg-gray-500" title="Clear validation">‚Ü©</button>
                                                                        )}
                                                                        <button onClick={(e) => { e.stopPropagation(); if(confirm('Delete?')) deleteDetection(idx); }}
                                                                            className="w-6 h-6 bg-red-500 text-white rounded text-xs hover:bg-red-600" title="Delete">üóë</button>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            
                                                            {/* Action buttons row */}
                                                            <div className="px-2 pb-2 flex gap-1 flex-wrap">
                                                                <button onClick={(e) => { e.stopPropagation(); toggleCardExpansion(idx); }}
                                                                    className={`px-2 py-0.5 rounded text-xs ${isExpanded ? 'bg-ancient-purple text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                                                                    title="Show alternative matches">
                                                                    {isExpanded ? '‚ñº' : '‚ñ∂'} Alts {result.topMatches?.length > 1 ? `(${result.topMatches.length - 1})` : ''}
                                                                </button>
                                                                <button onClick={(e) => { e.stopPropagation(); openChartSelector(idx); }}
                                                                    className="px-2 py-0.5 rounded text-xs bg-ochre/20 text-ochre hover:bg-ochre/30"
                                                                    title="Select glyph from full chart">
                                                                    üìã Chart
                                                                </button>
                                                                <button onClick={(e) => { e.stopPropagation(); toggleExcludeDetection(idx); }}
                                                                    className={`px-2 py-0.5 rounded text-xs ${isExcluded ? 'bg-gray-500 text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
                                                                    title={isExcluded ? 'Include in reading' : 'Exclude from reading'}>
                                                                    {isExcluded ? 'üëÅ Include' : 'üö´ Exclude'}
                                                                </button>
                                                                <button onClick={(e) => { e.stopPropagation(); shrinkBox(idx, 3); }}
                                                                    className="px-2 py-0.5 rounded text-xs bg-gray-100 text-gray-600 hover:bg-gray-200"
                                                                    title="Shrink detection box">
                                                                    ‚äü Shrink
                                                                </button>
                                                                <button onClick={(e) => { e.stopPropagation(); expandBox(idx, 3); }}
                                                                    className="px-2 py-0.5 rounded text-xs bg-gray-100 text-gray-600 hover:bg-gray-200"
                                                                    title="Expand detection box">
                                                                    ‚äû Expand
                                                                </button>
                                                                <button onClick={(e) => { e.stopPropagation(); openRegionEditor(idx); }}
                                                                    className="px-2 py-0.5 rounded text-xs bg-blue-100 text-blue-600 hover:bg-blue-200"
                                                                    title="Edit region - erase stray marks">
                                                                    ‚úèÔ∏è Edit
                                                                </button>
                                                            </div>
                                                            
                                                            {/* Expanded: Alternative matches */}
                                                            {isExpanded && result.topMatches && result.topMatches.length > 1 && (
                                                                <div className="px-2 pb-2 border-t border-gray-100 bg-gray-50">
                                                                    <div className="text-xs text-gray-500 mb-1 pt-1">Alternative matches:</div>
                                                                    <div className="flex flex-wrap gap-1">
                                                                        {result.topMatches.slice(1, 6).map((alt, altIdx) => (
                                                                            <button key={altIdx}
                                                                                onClick={(e) => { e.stopPropagation(); changeGlyphAssignment(idx, alt.glyph); }}
                                                                                className="flex items-center gap-1 px-2 py-1 bg-white border border-gray-200 rounded hover:border-ancient-purple hover:bg-purple-50 transition-colors"
                                                                                title={`Switch to ${alt.glyph.name} (${Math.round(alt.confidence * 100)}%)`}>
                                                                                {glyphThumbnails[alt.glyph.id] && (
                                                                                    <img src={glyphThumbnails[alt.glyph.id]} alt="" className="w-5 h-5 object-contain" />
                                                                                )}
                                                                                <span className="text-xs font-medium">{alt.glyph.transliteration}</span>
                                                                                <span className="text-xs text-gray-400">{Math.round(alt.confidence * 100)}%</span>
                                                                            </button>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            )}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </>
                                    )}
                                </div>
                            </aside>
                        </div>
                        
                        {/* ===== INSCRIPTION PANEL (Translation & Notes) ===== */}
                        {viewMode === 'reading' && recognitionResults.length > 0 && (
                            <div className="mt-6">
                                <InscriptionPanel
                                    inscriptionTitle={inscriptionTitle}
                                    inscriptionNotes={inscriptionNotes}
                                    inscriptionComplete={inscriptionComplete}
                                    translationEnglish={translationEnglish}
                                    translationArabic={translationArabic}
                                    onTitleChange={setInscriptionTitle}
                                    onNotesChange={setInscriptionNotes}
                                    onCompleteChange={setInscriptionComplete}
                                    onTranslationEnglishChange={setTranslationEnglish}
                                    onTranslationArabicChange={setTranslationArabic}
                                    isCollapsed={!showTranslationSection}
                                    onToggleCollapse={() => setShowTranslationSection(!showTranslationSection)}
                                />
                            </div>
                        )}
                        
                        {/* ===== EXPORT PANEL (Save & Export) ===== */}
                        {recognitionResults.length > 0 && (
                            <div className="mt-6">
                                <ExportPanel
                                    recognitionResults={recognitionResults}
                                    validations={validations}
                                    image={originalImage}
                                    displayImage={displayImage}
                                    preprocessing={preprocessing}
                                    readingDirection={readingDirection}
                                    readingOrder={readingOrder}
                                    wordBoundaries={wordBoundaries}
                                    lineBreaks={lineBreaks}
                                    columnBreaks={columnBreaks}
                                    translationEnglish={translationEnglish}
                                    translationArabic={translationArabic}
                                    currentInscriptionId={currentInscriptionId}
                                    inscriptionTitle={inscriptionTitle}
                                    inscriptionNotes={inscriptionNotes}
                                    inscriptionComplete={inscriptionComplete}
                                    isCollapsed={!showStorageSection}
                                    onToggleCollapse={() => setShowStorageSection(!showStorageSection)}
                                    onSaveHki={() => {
                                        if (typeof HKIStorage !== 'undefined') {
                                            HKIStorage.saveAsHkiFile({
                                                recognitionResults, validations,
                                                image: originalImage, displayImage,
                                                preprocessing, viewMode, readingDirection, readingOrder,
                                                wordBoundaries, columnBreaks, lineBreaks,
                                                translationEnglish, translationArabic,
                                                actionHistory, currentInscriptionId,
                                                inscriptionComplete, inscriptionTitle
                                            });
                                        } else {
                                            const hkiData = {
                                                version: '1.0',
                                                created: new Date().toISOString(),
                                                inscriptionTitle: inscriptionTitle || 'Untitled',
                                                inscriptionNotes,
                                                image: originalImage,
                                                displayImage,
                                                preprocessing,
                                                recognitionResults,
                                                readingOrder: Array.from(readingOrder),
                                                readingDirection,
                                                wordBoundaries: Array.from(wordBoundaries),
                                                lineBreaks: Array.from(lineBreaks),
                                                validations,
                                                translationEnglish,
                                                translationArabic
                                            };
                                            const blob = new Blob([JSON.stringify(hkiData, null, 2)], { type: 'application/json' });
                                            const url = URL.createObjectURL(blob);
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.download = `${inscriptionTitle || 'inscription'}_${new Date().toISOString().slice(0,10)}.hki`;
                                            a.click();
                                            URL.revokeObjectURL(url);
                                            alert('‚úÖ HKI file saved!');
                                        }
                                    }}
                                    onLoadHki={(e) => {
                                        const file = e.target.files[0];
                                        if (!file) return;
                                        const reader = new FileReader();
                                        reader.onload = (ev) => {
                                            try {
                                                const data = JSON.parse(ev.target.result);
                                                if (data.image) setOriginalImage(data.image);
                                                if (data.displayImage) setDisplayImage(data.displayImage);
                                                if (data.images?.original) setOriginalImage(data.images.original);
                                                if (data.images?.preprocessed) setDisplayImage(data.images.preprocessed);
                                                if (data.preprocessing || data.images?.preprocessingSettings) 
                                                    setPreprocessing(data.preprocessing || data.images.preprocessingSettings);
                                                if (data.recognitionResults) setRecognitionResults(data.recognitionResults);
                                                if (data.detections) setRecognitionResults(data.detections.map(d => ({
                                                    glyph: d.glyph, confidence: d.confidence, position: d.position,
                                                    thumbnail: d.thumbnail, matchType: d.matchType
                                                })));
                                                if (data.validations) setValidations(data.validations);
                                                if (data.readingOrder) setReadingOrder(data.readingOrder);
                                                if (data.readingData?.readingOrder) setReadingOrder(data.readingData.readingOrder);
                                                if (data.wordBoundaries) setWordBoundaries(new Set(data.wordBoundaries));
                                                if (data.readingData?.wordBoundaries) setWordBoundaries(new Set(data.readingData.wordBoundaries));
                                                if (data.lineBreaks) setLineBreaks(new Set(data.lineBreaks));
                                                if (data.readingData?.lineBreaks) setLineBreaks(new Set(data.readingData.lineBreaks));
                                                if (data.translationEnglish || data.translations?.english)
                                                    setTranslationEnglish(data.translationEnglish || data.translations?.english || '');
                                                if (data.translationArabic || data.translations?.arabic)
                                                    setTranslationArabic(data.translationArabic || data.translations?.arabic || '');
                                                if (data.inscriptionTitle) setInscriptionTitle(data.inscriptionTitle);
                                                if (data.inscriptionNotes) setInscriptionNotes(data.inscriptionNotes);
                                                if (data.inscriptionComplete || data.complete) setInscriptionComplete(data.inscriptionComplete || data.complete);
                                                if (data.inscriptionId) setCurrentInscriptionId(data.inscriptionId);
                                                alert('‚úÖ Loaded successfully!\n\nüìä ' + (data.recognitionResults?.length || data.detections?.length || 0) + ' detections');
                                            } catch (err) {
                                                alert('‚ùå Failed to load: ' + err.message);
                                            }
                                        };
                                        reader.readAsText(file);
                                    }}
                                    imageRef={imageRef}
                                    className="bg-[#f7f3ed] border-2 border-ochre"
                                />
                            </div>
                        )}
                    </main>
                    
                    {/* ===== GLYPH SELECTOR MODAL (for manual box or changing glyph) ===== */}
                    {showGlyphSelector && chartData && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[80vh] flex flex-col">
                                <div className="flex items-center justify-between p-4 border-b">
                                    <div>
                                        <h3 className="text-xl font-bold text-gray-900">üìã Select Glyph</h3>
                                        <p className="text-sm text-gray-500">
                                            {showGlyphSelector.mode === 'manual' 
                                                ? 'Choose which glyph this box represents' 
                                                : `Change glyph for detection #${showGlyphSelector.detectionIndex + 1}`}
                                        </p>
                                    </div>
                                    <button onClick={() => { setShowGlyphSelector(null); setManualBoxMode(false); setGlyphSelectorSearch(''); }} 
                                        className="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
                                </div>
                                
                                {/* Search */}
                                <div className="p-4 border-b">
                                    <input
                                        type="text"
                                        value={glyphSelectorSearch}
                                        placeholder="Search glyphs by name or transliteration..."
                                        className="w-full px-3 py-2 border rounded-lg"
                                        onChange={(e) => setGlyphSelectorSearch(e.target.value.toLowerCase())}
                                        autoFocus
                                    />
                                </div>
                                
                                {/* Glyph Grid */}
                                <div className="flex-1 overflow-y-auto p-4">
                                    <div className="grid grid-cols-6 gap-2">
                                        {chartData.glyphs
                                            .filter(g => {
                                                if (!glyphSelectorSearch) return true;
                                                return (g.name?.toLowerCase().includes(glyphSelectorSearch) || 
                                                        g.transliteration?.toLowerCase().includes(glyphSelectorSearch) ||
                                                        g.arabic?.includes(glyphSelectorSearch));
                                            })
                                            .map(glyph => (
                                                <button
                                                    key={glyph.id}
                                                    onClick={() => {
                                                        if (showGlyphSelector.mode === 'manual') {
                                                            addManualDetection(glyph, showGlyphSelector.position);
                                                        } else {
                                                            // Change existing detection's glyph
                                                            changeGlyphAssignment(showGlyphSelector.detectionIndex, glyph);
                                                            setShowGlyphSelector(null);
                                                        }
                                                        setGlyphSelectorSearch('');
                                                    }}
                                                    className="p-2 border rounded-lg hover:border-ochre hover:bg-ochre/10 flex flex-col items-center gap-1 transition-colors"
                                                >
                                                    {glyphThumbnails[glyph.id] ? (
                                                        <img src={glyphThumbnails[glyph.id]} alt={glyph.name} 
                                                            className="w-10 h-10 object-contain" />
                                                    ) : (
                                                        <div className="w-10 h-10 bg-gray-100 rounded flex items-center justify-center text-gray-400">?</div>
                                                    )}
                                                    <span className="text-xs font-medium truncate w-full text-center">
                                                        {glyph.transliteration || glyph.name}
                                                    </span>
                                                </button>
                                            ))}
                                    </div>
                                </div>
                                
                                {/* Footer */}
                                <div className="p-4 border-t bg-gray-50 flex justify-between items-center">
                                    <span className="text-sm text-gray-500">
                                        {showGlyphSelector.mode === 'manual' 
                                            ? `Box: ${Math.round(showGlyphSelector.position?.width || 0)}√ó${Math.round(showGlyphSelector.position?.height || 0)}px`
                                            : `Current: ${recognitionResults[showGlyphSelector.detectionIndex]?.glyph?.transliteration || '?'}`}
                                    </span>
                                    <button onClick={() => { setShowGlyphSelector(null); setManualBoxMode(false); setGlyphSelectorSearch(''); }}
                                        className="px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300">
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* ===== CHART MANAGER MODAL ===== */}
                    {showChartManager && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-5xl max-h-[90vh] flex flex-col">
                                {/* Header */}
                                <div className="flex items-center justify-between p-4 border-b">
                                    <div>
                                        <h3 className="text-xl font-bold text-gray-900">üìä Glyph Chart Manager</h3>
                                        <p className="text-sm text-gray-500">{chartData?.glyphs?.length || 0} glyphs in chart</p>
                                    </div>
                                    <button onClick={() => setShowChartManager(false)} className="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
                                </div>
                                
                                {/* Toolbar */}
                                <div className="p-4 border-b flex flex-wrap gap-3 items-center">
                                    <button
                                        onClick={() => {
                                            setGlyphEditorMode('add');
                                            setEditingGlyph(null);
                                            setShowGlyphEditor(true);
                                        }}
                                        className="px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5a7d6e]"
                                    >
                                        ‚ûï Add New Glyph
                                    </button>
                                    <button
                                        onClick={() => {
                                            const blob = new Blob([JSON.stringify(chartData, null, 2)], { type: 'application/json' });
                                            const url = URL.createObjectURL(blob);
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.download = `Hakli_glyphs_${new Date().toISOString().slice(0,10)}.JSON`;
                                            a.click();
                                            URL.revokeObjectURL(url);
                                            alert('‚úÖ Chart exported!');
                                        }}
                                        className="px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3d5a]"
                                    >
                                        üì• Export Chart
                                    </button>
                                </div>
                                
                                {/* Glyph Grid */}
                                <div className="flex-1 overflow-y-auto p-4">
                                    <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-3">
                                        {chartData?.glyphs?.map((glyph) => (
                                            <div
                                                key={glyph.id}
                                                className="border border-gray-200 rounded-lg p-2 hover:border-ancient-purple hover:shadow cursor-pointer transition-all"
                                                onClick={() => {
                                                    setGlyphEditorMode('edit');
                                                    setEditingGlyph(glyph);
                                                    setShowGlyphEditor(true);
                                                }}
                                            >
                                                <div className="aspect-square bg-gray-100 rounded flex items-center justify-center mb-1 overflow-hidden">
                                                    {glyphThumbnails[glyph.id] ? (
                                                        <img src={glyphThumbnails[glyph.id]} alt={glyph.name} className="max-w-full max-h-full object-contain" />
                                                    ) : (
                                                        <span className="text-gray-400 text-xs">?</span>
                                                    )}
                                                </div>
                                                <div className="text-center">
                                                    <div className="text-xs font-medium text-gray-700 truncate">{glyph.name}</div>
                                                    <div className="text-lg text-ancient-purple leading-tight">{glyph.arabic || glyph.transliteration}</div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* ===== GLYPH EDITOR MODAL ===== */}
                    {showGlyphEditor && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[60] p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg max-h-[90vh] flex flex-col">
                                <div className="flex items-center justify-between p-4 border-b">
                                    <h3 className="text-xl font-bold">{glyphEditorMode === 'add' ? '‚ûï Add New Glyph' : '‚úèÔ∏è Edit Glyph'}</h3>
                                    <button onClick={() => setShowGlyphEditor(false)} className="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
                                </div>
                                
                                <div className="flex-1 overflow-y-auto p-4 space-y-4">
                                    {/* Form fields */}
                                    <GlyphEditorForm
                                        mode={glyphEditorMode}
                                        glyph={editingGlyph}
                                        chartData={chartData}
                                        setChartData={setChartData}
                                        loadedGlyphImages={loadedGlyphImages}
                                        setLoadedGlyphImages={setLoadedGlyphImages}
                                        glyphThumbnails={glyphThumbnails}
                                        setGlyphThumbnails={setGlyphThumbnails}
                                        onClose={() => setShowGlyphEditor(false)}
                                    />
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* ===== REGION EDITOR MODAL ===== */}
                    {regionEditorIdx !== null && (
                        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[60] p-4">
                            <div className="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col">
                                <div className="flex items-center justify-between p-4 border-b">
                                    <div>
                                        <h3 className="text-xl font-bold">‚úèÔ∏è Edit Region #{regionEditorIdx + 1}</h3>
                                        <p className="text-sm text-gray-500">Clean up thumbnail only (main image stays intact)</p>
                                    </div>
                                    <button onClick={() => setRegionEditorIdx(null)} className="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
                                </div>
                                
                                <div className="flex-1 overflow-auto p-4">
                                    {/* Brush size control */}
                                    <div className="mb-4">
                                        <div className="flex justify-between text-sm text-gray-600 mb-1">
                                            <span>üñåÔ∏è Eraser Size</span>
                                            <span>{regionEditorSize}px</span>
                                        </div>
                                        <input type="range" min="3" max="30" value={regionEditorSize}
                                            onChange={(e) => setRegionEditorSize(parseInt(e.target.value))}
                                            className="w-full" />
                                    </div>
                                    
                                    {/* Canvas for editing */}
                                    <div className="border-2 border-dashed border-gray-300 rounded-lg p-2 bg-gray-50 flex items-center justify-center">
                                        <canvas 
                                            ref={regionEditorCanvasRef}
                                            className="max-w-full border border-gray-200 bg-white"
                                            style={{ 
                                                imageRendering: 'pixelated',
                                                cursor: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="${regionEditorSize * 2 + 2}" height="${regionEditorSize * 2 + 2}" viewBox="0 0 ${regionEditorSize * 2 + 2} ${regionEditorSize * 2 + 2}"><circle cx="${regionEditorSize + 1}" cy="${regionEditorSize + 1}" r="${regionEditorSize}" fill="none" stroke="black" stroke-width="1.5"/><circle cx="${regionEditorSize + 1}" cy="${regionEditorSize + 1}" r="${regionEditorSize}" fill="none" stroke="white" stroke-width="0.5"/><line x1="${regionEditorSize + 1}" y1="${regionEditorSize - 4}" x2="${regionEditorSize + 1}" y2="${regionEditorSize + 7}" stroke="black" stroke-width="1"/><line x1="${regionEditorSize - 4}" y1="${regionEditorSize + 1}" x2="${regionEditorSize + 7}" y2="${regionEditorSize + 1}" stroke="black" stroke-width="1"/></svg>') ${regionEditorSize + 1} ${regionEditorSize + 1}, crosshair`
                                            }}
                                            onMouseDown={handleRegionEditorStart}
                                            onMouseMove={handleRegionEditorDraw}
                                            onMouseUp={handleRegionEditorEnd}
                                            onMouseLeave={handleRegionEditorEnd}
                                        />
                                    </div>
                                    
                                    <p className="text-xs text-gray-400 mt-2 text-center">
                                        Erase stray marks to clean up the thumbnail. The main image display won't change.
                                    </p>
                                </div>
                                
                                <div className="flex justify-end gap-2 p-4 border-t">
                                    <button onClick={() => setRegionEditorIdx(null)}
                                        className="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg">
                                        Cancel
                                    </button>
                                    <button onClick={() => { initRegionEditorCanvas(); }}
                                        className="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg">
                                        üîÑ Reset
                                    </button>
                                    <button onClick={applyRegionEdit}
                                        className="px-4 py-2 bg-patina text-white rounded-lg hover:bg-[#5a7d6e]">
                                        ‚úÖ Apply Changes
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }
        
        // ===== GLYPH EDITOR FORM COMPONENT =====
        function GlyphEditorForm({ mode, glyph, chartData, setChartData, loadedGlyphImages, setLoadedGlyphImages, glyphThumbnails, setGlyphThumbnails, onClose }) {
            const { useState, useRef } = React;
            
            const [formData, setFormData] = useState({
                name: glyph?.name || '',
                arabic: glyph?.arabic || '',
                transliteration: glyph?.transliteration || '',
                description: glyph?.description || ''
            });
            const [primaryImage, setPrimaryImage] = useState(null);
            const [primaryImagePreview, setPrimaryImagePreview] = useState(glyph?.images?.primary || null);
            const [isSaving, setIsSaving] = useState(false);
            const fileInputRef = useRef(null);
            
            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    setPrimaryImage(event.target.result);
                    setPrimaryImagePreview(event.target.result);
                };
                reader.readAsDataURL(file);
            };
            
            const handleSave = () => {
                if (!formData.name.trim()) {
                    alert('Name is required');
                    return;
                }
                
                setIsSaving(true);
                const updatedChart = { ...chartData };
                
                if (mode === 'add') {
                    const maxId = Math.max(...updatedChart.glyphs.map(g => g.id), 0);
                    const newGlyph = {
                        id: maxId + 1,
                        name: formData.name.trim(),
                        arabic: formData.arabic.trim() || 'x',
                        transliteration: formData.transliteration.trim() || formData.name.trim(),
                        description: formData.description.trim() || '',
                        images: { primary: primaryImage || '', variants: [], examples: [] }
                    };
                    updatedChart.glyphs.push(newGlyph);
                    
                    if (primaryImage) {
                        const img = new Image();
                        img.onload = () => {
                            setLoadedGlyphImages(prev => ({ ...prev, [newGlyph.id]: img }));
                            setGlyphThumbnails(prev => ({ ...prev, [newGlyph.id]: img.src }));
                        };
                        img.src = primaryImage;
                    }
                    alert(`‚úÖ Added glyph "${newGlyph.name}"`);
                } else {
                    const idx = updatedChart.glyphs.findIndex(g => g.id === glyph.id);
                    if (idx !== -1) {
                        updatedChart.glyphs[idx] = {
                            ...updatedChart.glyphs[idx],
                            name: formData.name.trim(),
                            arabic: formData.arabic.trim() || 'x',
                            transliteration: formData.transliteration.trim() || formData.name.trim(),
                            description: formData.description.trim() || ''
                        };
                        if (primaryImage) {
                            updatedChart.glyphs[idx].images.primary = primaryImage;
                            const img = new Image();
                            img.onload = () => {
                                setLoadedGlyphImages(prev => ({ ...prev, [glyph.id]: img }));
                                setGlyphThumbnails(prev => ({ ...prev, [glyph.id]: img.src }));
                            };
                            img.src = primaryImage;
                        }
                        alert(`‚úÖ Updated glyph "${formData.name}"`);
                    }
                }
                
                setChartData(updatedChart);
                setIsSaving(false);
                onClose();
            };
            
            const handleDelete = () => {
                if (!glyph || !confirm(`Delete glyph "${glyph.name}"?`)) return;
                const updatedChart = { ...chartData };
                updatedChart.glyphs = updatedChart.glyphs.filter(g => g.id !== glyph.id);
                setChartData(updatedChart);
                alert(`üóëÔ∏è Deleted glyph "${glyph.name}"`);
                onClose();
            };
            
            return (
                <>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Name *</label>
                        <input type="text" value={formData.name} onChange={(e) => setFormData(p => ({ ...p, name: e.target.value }))}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="e.g., aleph" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Arabic</label>
                        <input type="text" value={formData.arabic} onChange={(e) => setFormData(p => ({ ...p, arabic: e.target.value }))}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg text-2xl text-center" dir="rtl" placeholder="ÿß" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Transliteration</label>
                        <input type="text" value={formData.transliteration} onChange={(e) => setFormData(p => ({ ...p, transliteration: e.target.value }))}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder=" æ" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Description</label>
                        <textarea value={formData.description} onChange={(e) => setFormData(p => ({ ...p, description: e.target.value }))}
                            className="w-full px-3 py-2 border border-gray-300 rounded-lg" rows={2} />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">Template Image {mode === 'add' && '*'}</label>
                        <div className="flex gap-3 items-start">
                            {primaryImagePreview && (
                                <div className="w-20 h-20 border rounded bg-gray-100 flex items-center justify-center overflow-hidden">
                                    <img src={primaryImagePreview} alt="Preview" className="max-w-full max-h-full object-contain" />
                                </div>
                            )}
                            <div>
                                <input ref={fileInputRef} type="file" accept="image/*" onChange={handleImageUpload} className="hidden" />
                                <button onClick={() => fileInputRef.current?.click()} className="px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm">
                                    üì∑ {primaryImagePreview ? 'Change' : 'Upload'}
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div className="flex justify-between pt-4 border-t">
                        {mode === 'edit' && (
                            <button onClick={handleDelete} className="px-4 py-2 bg-rust text-white rounded-lg hover:bg-[#8a574a]">üóëÔ∏è Delete</button>
                        )}
                        {mode === 'add' && <div />}
                        <div className="flex gap-2">
                            <button onClick={onClose} className="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg">Cancel</button>
                            <button onClick={handleSave} disabled={isSaving} className="px-4 py-2 bg-ancient-purple text-white rounded-lg hover:bg-[#4a3d5a] disabled:bg-gray-300">
                                {isSaving ? 'Saving...' : 'Save'}
                            </button>
                        </div>
                    </div>
                </>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<HakliGlyphRecognizer />);
    </script>

    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(() => console.log('‚úÖ SW registered')).catch(console.error);
        }
    </script>
</body>
</html>
