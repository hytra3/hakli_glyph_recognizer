<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Symbol Recognizer</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        var isOpenCvReady = false;
        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('OpenCV.js is ready');
        }
    </script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        .detection-box {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
            border: 3px solid;
            border-radius: 4px;
            cursor: pointer;
        }
        .detection-box.validated-correct { border-color: #10b981; background: rgba(16, 185, 129, 0.25); }
        .detection-box.validated-incorrect { border-color: #ef4444; background: rgba(239, 68, 68, 0.25); }
        .detection-box.unvalidated { border-color: #3b82f6; background: rgba(59, 130, 246, 0.25); }
        .detection-box.selected { border-color: #f59e0b; background: rgba(245, 158, 11, 0.3); border-width: 4px; }
        
        .canvas-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }
        
        .manual-selection-box {
            position: absolute;
            border: 2px dashed #f59e0b;
            background: rgba(245, 158, 11, 0.1);
            pointer-events: none;
            z-index: 5;
        }
        
        .region-boundary {
            position: absolute;
            border: 1px solid rgba(156, 163, 175, 0.5);
            background: rgba(156, 163, 175, 0.05);
            pointer-events: none;
            z-index: 3;
        }
        
        .merge-indicator {
            position: absolute;
            border: 3px solid #8b5cf6;
            background: rgba(139, 92, 246, 0.15);
            border-radius: 8px;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function HakliSymbolRecognizer() {
            const [image, setImage] = useState(null);
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [chartLoadStatus, setChartLoadStatus] = useState('not-loaded');
            const [loadedSymbolImages, setLoadedSymbolImages] = useState({});
            const [manualDetectionMode, setManualDetectionMode] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawStart, setDrawStart] = useState(null);
            const [drawCurrent, setDrawCurrent] = useState(null);
            const [selectedRegions, setSelectedRegions] = useState(new Set());
            const [validations, setValidations] = useState({});
            const [actionHistory, setActionHistory] = useState([]);
            const [isolatedSymbols, setIsolatedSymbols] = useState([]);
            const [showRegionBoundaries, setShowRegionBoundaries] = useState(false);
            const [mergeIndicator, setMergeIndicator] = useState(null);

            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);

            const [viewMode, setViewMode] = useState('detection'); // 'detection' or 'reading'
            const [readingDirection, setReadingDirection] = useState('detection'); // 'detection', 'ltr', 'rtl', 'ttb'
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [readingOrder, setReadingOrder] = useState([]); // Array of indices for manual ordering
            const [draggedItem, setDraggedItem] = useState(null);
            const [correctionMode, setCorrectionMode] = useState(null); // Index of detection being corrected, or null
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [stateHistory, setStateHistory] = useState([]);
            const [confidenceThreshold, setConfidenceThreshold] = useState(0);
            const [useConfidenceFilter, setUseConfidenceFilter] = useState(false);
            const [showCloudSyncModal, setShowCloudSyncModal] = useState(false);
            const [customGistUrl, setCustomGistUrl] = useState('');

            const MASTER_PASTE_URL = ''; // Will update after first upload
            const MASTER_PASTE_RAW_URL = ''; // Will update after first upload

            const convertToGitHubUrl = (githubUrl) => {
                if (!githubUrl) return null;
                if (githubUrl.indexOf('http') === 0) {
                    if (githubUrl.indexOf('github.com') !== -1 && githubUrl.indexOf('/blob/') !== -1) {
                        return githubUrl.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                    }
                    return githubUrl;
                }
                if (typeof githubUrl === 'string' && githubUrl.length > 0) {
                    const baseUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/';
                    const cleanPath = githubUrl.indexOf('/') === 0 ? githubUrl.substring(1) : githubUrl;
                    return baseUrl + cleanPath;
                }
                return null;
            };

            const recordAction = (actionType, actionData) => {
                const action = {
                    type: actionType,
                    data: actionData,
                    timestamp: new Date().toISOString(),
                    id: Date.now()
                };
                setActionHistory(prev => [...prev, action].slice(-50));
                console.log('Action recorded:', action);
                
                // Take snapshot after modifying actions
                const modifyingActions = ['validation', 'delete_detection', 'merge_detections', 
                                        'add_manual_detection', 'correct_symbol', 'reorder_reading', 
                                        'toggle_word_boundary'];
                if (modifyingActions.includes(actionType)) {
                    setTimeout(takeSnapshot, 0);
                }
            };

            const takeSnapshot = () => {
                const snapshot = {
                    recognitionResults: [...recognitionResults],
                    validations: { ...validations },
                    selectedRegions: new Set(selectedRegions),
                    wordBoundaries: new Set(wordBoundaries),
                    readingOrder: [...readingOrder],
                    isolatedSymbols: [...isolatedSymbols]
                };
                
                // Remove any "future" history if we're not at the end
                const newHistory = stateHistory.slice(0, historyIndex + 1);
                newHistory.push(snapshot);
                
                // Keep only last 50 states
                const trimmedHistory = newHistory.slice(-50);
                
                setStateHistory(trimmedHistory);
                setHistoryIndex(trimmedHistory.length - 1);
            };

            const validateDetection = (detectionIndex, isCorrect) => {
                recordAction('validation', {
                    detectionIndex,
                    isCorrect,
                    detectionData: recognitionResults[detectionIndex]
                });
                setValidations(prev => ({
                    ...prev,
                    [detectionIndex]: {
                        isCorrect,
                        timestamp: new Date().toISOString(),
                        detectionData: recognitionResults[detectionIndex]
                    }
                }));
            };

            const deleteDetection = (detectionIndex) => {
                recordAction('delete_detection', {
                    index: detectionIndex,
                    detection: recognitionResults[detectionIndex]
                });

                // Update recognition results
                setRecognitionResults(prev => prev.filter((_, i) => i !== detectionIndex));

                // Update validations with shifted indices
                setValidations(prev => {
                    const newValidations = { ...prev };
                    delete newValidations[detectionIndex];
                    const shifted = {};
                    Object.keys(newValidations).forEach(key => {
                        const numKey = parseInt(key);
                        shifted[numKey > detectionIndex ? numKey - 1 : numKey] = newValidations[key];
                    });
                    return shifted;
                });

                // Update selected regions - remove deleted index and shift others
                setSelectedRegions(prev => {
                    const newSet = new Set();
                    prev.forEach(idx => {
                        if (idx !== detectionIndex) {
                            // Shift down indices that come after the deleted one
                            newSet.add(idx > detectionIndex ? idx - 1 : idx);
                        }
                    });
                    return newSet;
                });

                // Clear merge indicator if it existed
                setMergeIndicator(null);
            };

            const mergeSelectedDetections = () => {
                const selectedIndices = Array.from(selectedRegions).sort((a, b) => a - b);
                if (selectedIndices.length < 2) {
                    alert('Please select at least 2 detections to merge');
                    return;
                }
                const detectionsToMerge = selectedIndices.map(i => recognitionResults[i]);
                const minX = Math.min(...detectionsToMerge.map(d => d.position.x));
                const minY = Math.min(...detectionsToMerge.map(d => d.position.y));
                const maxX = Math.max(...detectionsToMerge.map(d => d.position.x + d.position.width));
                const maxY = Math.max(...detectionsToMerge.map(d => d.position.y + d.position.height));
                const baseDetection = detectionsToMerge.reduce((best, current) => 
                    current.confidence > best.confidence ? current : best
                );
                const mergedDetection = {
                    ...baseDetection,
                    position: { x: minX, y: minY, width: maxX - minX, height: maxY - minY },
                    confidence: detectionsToMerge.reduce((sum, d) => sum + d.confidence, 0) / detectionsToMerge.length,
                    mergedFrom: detectionsToMerge.length,
                    isMerged: true
                };
                recordAction('merge_detections', { indices: selectedIndices, detections: detectionsToMerge, mergedResult: mergedDetection });
                let newResults = recognitionResults.slice();
                for (let i = selectedIndices.length - 1; i >= 0; i--) {
                    newResults.splice(selectedIndices[i], 1);
                }
                newResults.push(mergedDetection);
                setRecognitionResults(newResults);
                setSelectedRegions(new Set());
                setMergeIndicator(null);
            };

            const getImageCoordinates = (event) => {
                if (!imageRef.current) return null;
                const rect = imageRef.current.getBoundingClientRect();
                const scaleX = imageRef.current.naturalWidth / rect.width;
                const scaleY = imageRef.current.naturalHeight / rect.height;
                return {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            };

            const handleImageMouseDown = (event) => {
                if (!manualDetectionMode) return;
                const coords = getImageCoordinates(event);
                if (!coords) return;
                setIsDrawing(true);
                setDrawStart(coords);
                setDrawCurrent(coords);
            };

           const handleImageMouseMove = (event) => {
                if (!manualDetectionMode) return;
                if (!isDrawing) return;
                
                event.preventDefault(); // Prevent default drag behavior
                const coords = getImageCoordinates(event);
                if (coords) {
                    setDrawCurrent(coords);
                }
            };

            const handleImageMouseUp = (event) => {
                if (!manualDetectionMode || !isDrawing || !drawStart) return;
                const coords = getImageCoordinates(event);
                if (!coords) return;

                const bounds = {
                    x: Math.min(drawStart.x, coords.x),
                    y: Math.min(drawStart.y, coords.y),
                    width: Math.abs(coords.x - drawStart.x),
                    height: Math.abs(coords.y - drawStart.y)
                };

                if (bounds.width > 10 && bounds.height > 10) {
                    // Extract thumbnail for the manually selected region
                    const thumbnail = extractRegionThumbnail(imageRef.current, { bounds: bounds });

                    // Create manual detection with thumbnail
                    const manualDetection = {
                        symbol: { id: 'unknown', name: 'Unknown', transliteration: '?' },
                        confidence: 0.5,
                        position: bounds,
                        matchType: 'manual',
                        isManual: true,
                        regionIndex: isolatedSymbols.length, // Assign next index
                        thumbnail: thumbnail // Add thumbnail
                    };

                    // Add to isolated symbols so it can be displayed
                    setIsolatedSymbols(prev => [...prev, {
                        bounds: bounds,
                        thumbnail: thumbnail,
                        area: bounds.width * bounds.height,
                        aspectRatio: bounds.width / bounds.height
                    }]);

                    // Add to recognition results
                    setRecognitionResults(prev => [...prev, manualDetection]);

                    recordAction('add_manual_detection', { bounds, thumbnail: !!thumbnail });
                }

                setIsDrawing(false);
                setDrawStart(null);
                setDrawCurrent(null);
            };

            const toggleRegionSelection = (regionIndex) => {
                setSelectedRegions(prev => {
                    const newSet = new Set(prev);
                    newSet.has(regionIndex) ? newSet.delete(regionIndex) : newSet.add(regionIndex);
                    return newSet;
                });
            };

            const handleDetectionClick = (event, index) => {
                if (event.ctrlKey || event.metaKey) {
                    event.stopPropagation();
                    toggleRegionSelection(index);
                }
            };

            const getReadingOrderedResults = () => {
                if (viewMode === 'detection') return recognitionResults;
                
                // If manual reading order exists, use it
                if (readingOrder.length === recognitionResults.length) {
                    return readingOrder.map(idx => recognitionResults[idx]);
                }
                
                // Otherwise, auto-sort by direction
            const sorted = recognitionResults.map((result, idx) => ({ result, originalIndex: idx }));
                
                if (readingDirection === 'ltr') {
                    sorted.sort((a, b) => 
                        a.result.position.y - b.result.position.y || 
                        a.result.position.x - b.result.position.x
                    );
                } else if (readingDirection === 'rtl') {
                    sorted.sort((a, b) => 
                        a.result.position.y - b.result.position.y || 
                        b.result.position.x - a.result.position.x
                    );
                } else if (readingDirection === 'ttb') {
                    sorted.sort((a, b) => 
                        a.result.position.x - b.result.position.x || 
                        a.result.position.y - b.result.position.y
                    );
                }
                
                return sorted.map(item => item.result);
            };

        const getFilteredResults = () => {
                if (!useConfidenceFilter) {
                    return recognitionResults;
                }
            return recognitionResults.filter(result => result.confidence >= confidenceThreshold / 100);
         };   

        const getReadingOrderIndex = (detectionIndex) => {
            const orderedResults = getReadingOrderedResults();
                return orderedResults.findIndex(result => 
                recognitionResults.indexOf(result) === detectionIndex
            ) + 1;
        };

        const applyReadingDirection = (direction) => {
            setReadingDirection(direction);
                
            // Auto-generate reading order based on direction
            const sorted = recognitionResults.map((result, idx) => ({ result, idx }));
                
            if (direction === 'ltr') {
                sorted.sort((a, b) => 
                    a.result.position.y - b.result.position.y || 
                    a.result.position.x - b.result.position.x
                );
            } else if (direction === 'rtl') {
                sorted.sort((a, b) => 
                    a.result.position.y - b.result.position.y || 
                    b.result.position.x - a.result.position.x
                );
            } else if (direction === 'ttb') {
                sorted.sort((a, b) => 
                    a.result.position.x - b.result.position.x || 
                    a.result.position.y - b.result.position.y
                );
            } else {
                // Detection order - just use original indices
                setReadingOrder(recognitionResults.map((_, idx) => idx));
                return;
            }
            
                setReadingOrder(sorted.map(item => item.idx));
            };

            const toggleWordBoundary = (readingOrderIndex) => {
                setWordBoundaries(prev => {
                    const newSet = new Set(prev);
                    newSet.has(readingOrderIndex) ? newSet.delete(readingOrderIndex) : newSet.add(readingOrderIndex);
                    return newSet;
                });
                recordAction('toggle_word_boundary', { readingOrderIndex });
            };

            const handleDragStart = (e, index) => {
                // Prevent dragging in detection order mode
                if (readingDirection === 'detection') {
                    e.preventDefault();
                    alert('⚠️ Cannot reorder in Detection Order mode.\n\nPlease select a reading direction (LTR, RTL, or TTB) to manually reorder symbols.');
                    return;
                }
                setDraggedItem(index);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, index) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = (e, dropIndex) => {
                e.preventDefault();
                if (draggedItem === null || draggedItem === dropIndex) return;
                
                const newOrder = [...readingOrder];
                const draggedValue = newOrder[draggedItem];
                newOrder.splice(draggedItem, 1);
                newOrder.splice(dropIndex, 0, draggedValue);
                
                setReadingOrder(newOrder);
                setDraggedItem(null);
                
                recordAction('reorder_reading', { from: draggedItem, to: dropIndex });
            };

            useEffect(() => {
                if (selectedRegions.size >= 2) {
                    const selectedDetections = Array.from(selectedRegions).map(i => recognitionResults[i]);
                    if (selectedDetections.length > 0) {
                        const minX = Math.min(...selectedDetections.map(d => d.position.x));
                        const minY = Math.min(...selectedDetections.map(d => d.position.y));
                        const maxX = Math.max(...selectedDetections.map(d => d.position.x + d.position.width));
                        const maxY = Math.max(...selectedDetections.map(d => d.position.y + d.position.height));
                        setMergeIndicator({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });
                    }
                } else {
                    setMergeIndicator(null);
                }
            }, [selectedRegions, recognitionResults]);

            const isolateSymbols = (inputImage) => {
                if (!isOpenCvReady) return [];
                try {
                    const src = cv.imread(inputImage);
                    const gray = new cv.Mat();
                    const binary = new cv.Mat();
                    const denoised = new cv.Mat();
                    const processed = new cv.Mat();

                    // Convert to grayscale
                    if (src.channels() > 1) {
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    } else {
                        src.copyTo(gray);
                    }

                    // Adaptive thresholding
                    cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);

                    // Remove noise with opening (erosion then dilation)
                    const smallKernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(2, 2));
                    cv.morphologyEx(binary, denoised, cv.MORPH_OPEN, smallKernel);

                    // Connect broken strokes with closing (dilation then erosion)
                    const largeKernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                    cv.morphologyEx(denoised, processed, cv.MORPH_CLOSE, largeKernel);

                    // Find contours
                    const contours = new cv.MatVector();
                    const hierarchy = new cv.Mat();
                    cv.findContours(processed, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    const isolatedRegions = [];

                    // Calculate dynamic thresholds based on image size
                    const imageArea = src.rows * src.cols;
                    const minArea = imageArea * 0.0001; // 0.01% of image
                    const maxArea = imageArea * 0.05;   // 5% of image

                    for (let i = 0; i < contours.size(); i++) {
                        const contour = contours.get(i);
                        const boundingRect = cv.boundingRect(contour);
                        const area = boundingRect.width * boundingRect.height;
                        const aspectRatio = boundingRect.width / boundingRect.height;

                        // Calculate solidity (ratio of contour area to bounding box area)
                        const contourArea = cv.contourArea(contour);
                        const solidity = contourArea / area;

                        // Filter criteria
                        const sizeOk = area >= minArea && area <= maxArea;
                        const aspectOk = aspectRatio >= 0.2 && aspectRatio <= 5.0;
                        const solidityOk = solidity >= 0.3; // Reject very sparse/noisy regions

                        if (sizeOk && aspectOk && solidityOk) {
                            const padding = 5;
                            isolatedRegions.push({
                                bounds: {
                                    x: Math.max(0, boundingRect.x - padding),
                                    y: Math.max(0, boundingRect.y - padding),
                                    width: Math.min(src.cols - boundingRect.x + padding, boundingRect.width + 2 * padding),
                                    height: Math.min(src.rows - boundingRect.y + padding, boundingRect.height + 2 * padding)
                                },
                                area,
                                aspectRatio,
                                solidity
                            });
                        }
                    }

                    // Sort by position (left to right, top to bottom)
                    isolatedRegions.sort((a, b) => {
                        const rowDiff = a.bounds.y - b.bounds.y;
                        if (Math.abs(rowDiff) > 20) return rowDiff; // Different rows
                        return a.bounds.x - b.bounds.x; // Same row, sort by x
                    });

                    console.log(`Isolated ${isolatedRegions.length} regions (min area: ${minArea.toFixed(0)}, max area: ${maxArea.toFixed(0)})`);

                    // Cleanup
                    src.delete();
                    gray.delete();
                    binary.delete();
                    denoised.delete();
                    processed.delete();
                    smallKernel.delete();
                    largeKernel.delete();
                    contours.delete();
                    hierarchy.delete();

                    return isolatedRegions;
                } catch (error) {
                    console.error('Symbol isolation error:', error);
                    return [];
                }
            };

            const extractRegionThumbnail = (inputImage, region) => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = region.bounds.width;
                    canvas.height = region.bounds.height;

                    ctx.drawImage(
                        inputImage,
                        region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height,
                        0, 0, region.bounds.width, region.bounds.height
                    );

                    return canvas.toDataURL();
                } catch (error) {
                    console.error('Thumbnail extraction error:', error);
                    return null;
                }
            };
            
            const performTemplateMatchingOnRegion = (inputImage, templateImage, region, symbolId) => {
                if (!isOpenCvReady) return [];
                try {
                    const src = cv.imread(inputImage);
                    const regionMat = src.roi(new cv.Rect(region.bounds.x, region.bounds.y, region.bounds.width, region.bounds.height));
                    const templ = cv.imread(templateImage);
                    const matches = [];

                    // Enhanced preprocessing - normalize both images
                    const preprocessForShape = (img) => {
                        let gray = new cv.Mat();
                        const binary = new cv.Mat();
                        const normalized = new cv.Mat();

                        // Convert to grayscale
                        if (img.channels() > 1) {
                            cv.cvtColor(img, gray, cv.COLOR_RGBA2GRAY);
                        } else {
                            img.copyTo(gray);
                        }

                        // Adaptive threshold
                        cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 3);

                        // Heavy morphological processing to normalize stroke width
                        const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                        cv.morphologyEx(binary, normalized, cv.MORPH_CLOSE, kernel);
                        cv.morphologyEx(normalized, normalized, cv.MORPH_OPEN, kernel);

                        // Normalize to similar stroke width
                        const thinKernel = cv.getStructuringElement(cv.MORPH_CROSS, new cv.Size(2, 2));
                        cv.erode(normalized, normalized, thinKernel, new cv.Point(-1, -1), 1);

                        kernel.delete();
                        thinKernel.delete();
                        gray.delete();
                        binary.delete();

                        return normalized;
                    };

                    const processedRegion = preprocessForShape(regionMat);
                    const processedTemplate = preprocessForShape(templ);

                    // Method 1: Contour Shape Matching (PRIMARY)
                    let shapeScore = 0;
                    let shapeMethod = 'none';
                    try {
                        const contoursRegion = new cv.MatVector();
                        const contoursTemplate = new cv.MatVector();
                        const hierarchy = new cv.Mat();

                        cv.findContours(processedRegion, contoursRegion, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                        cv.findContours(processedTemplate, contoursTemplate, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                        if (contoursRegion.size() > 0 && contoursTemplate.size() > 0) {
                            // Find largest contour in each
                            let maxAreaRegion = 0;
                            let maxContourRegionIdx = 0;
                            for (let i = 0; i < contoursRegion.size(); i++) {
                                const area = cv.contourArea(contoursRegion.get(i));
                                if (area > maxAreaRegion) {
                                    maxAreaRegion = area;
                                    maxContourRegionIdx = i;
                                }
                            }

                            let maxAreaTemplate = 0;
                            let maxContourTemplateIdx = 0;
                            for (let i = 0; i < contoursTemplate.size(); i++) {
                                const area = cv.contourArea(contoursTemplate.get(i));
                                if (area > maxAreaTemplate) {
                                    maxAreaTemplate = area;
                                    maxContourTemplateIdx = i;
                                }
                            }

                            // Try all 3 shape matching methods
                            const methods = [
                                { method: cv.CONTOURS_MATCH_I1, name: 'I1' },
                                { method: cv.CONTOURS_MATCH_I2, name: 'I2' },
                                { method: cv.CONTOURS_MATCH_I3, name: 'I3' }
                            ];

                            let bestShapeScore = 0;
                            for (const m of methods) {
                                try {
                                    const shapeDiff = cv.matchShapes(
                                        contoursRegion.get(maxContourRegionIdx),
                                        contoursTemplate.get(maxContourTemplateIdx),
                                        m.method,
                                        0
                                    );

                                    // Convert distance to similarity (lower distance = higher score)
                                    // Different methods have different scales
                                    let score = 0;
                                    if (m.method === cv.CONTOURS_MATCH_I1) {
                                        score = Math.max(0, 1 - (shapeDiff / 3)); // I1 tends to give values 0-3
                                    } else if (m.method === cv.CONTOURS_MATCH_I2) {
                                        score = Math.max(0, 1 - (shapeDiff / 5)); // I2 tends to give values 0-5
                                    } else {
                                        score = Math.max(0, 1 - (shapeDiff / 10)); // I3 can give larger values
                                    }

                                    if (score > bestShapeScore) {
                                        bestShapeScore = score;
                                        shapeMethod = m.name;
                                    }
                                } catch (e) {
                                    // Method failed, skip
                                }
                            }

                            shapeScore = bestShapeScore;
                        }

                        contoursRegion.delete();
                        contoursTemplate.delete();
                        hierarchy.delete();
                    } catch (shapeError) {
                        console.log(`Shape matching failed for ${symbolId}:`, shapeError);
                        shapeScore = 0;
                    }

                    // Method 2: Aspect Ratio Similarity
                    let aspectScore = 0;
                    const regionAspect = processedRegion.cols / processedRegion.rows;
                    const templateAspect = processedTemplate.cols / processedTemplate.rows;
                    const aspectDiff = Math.abs(regionAspect - templateAspect);
                    aspectScore = Math.max(0, 1 - aspectDiff);

                    // Method 3: Template Matching (SECONDARY - only best scale)
                    let templateScore = 0;
                    let bestScale = 1.0;
                    try {
                        // Try fewer scales, focus on likely matches
                        const scales = [1.0, 0.85, 0.7, 0.55];

                        for (const scale of scales) {
                            const scaledTempl = new cv.Mat();
                            const newSize = new cv.Size(
                                Math.floor(processedTemplate.cols * scale),
                                Math.floor(processedTemplate.rows * scale)
                            );

                            if (newSize.width < 10 || newSize.height < 10 ||
                                newSize.width > processedRegion.cols || newSize.height > processedRegion.rows) {
                                continue;
                            }

                            cv.resize(processedTemplate, scaledTempl, newSize, 0, 0, cv.INTER_AREA);

                            const dst = new cv.Mat();
                            cv.matchTemplate(processedRegion, scaledTempl, dst, cv.TM_CCOEFF_NORMED);
                            const result = cv.minMaxLoc(dst);

                            if (result.maxVal > templateScore) {
                                templateScore = result.maxVal;
                                bestScale = scale;
                            }

                            dst.delete();
                            scaledTempl.delete();
                        }
                    } catch (e) {
                        templateScore = 0;
                    }

                    // Weighted combination - SHAPE is primary
                    const weights = {
                        shape: 0.70,      // Shape matching is most important
                        aspect: 0.15,     // Aspect ratio helps
                        template: 0.15    // Template is just a tiebreaker
                    };

                    const combinedScore = (shapeScore * weights.shape) +
                        (aspectScore * weights.aspect) +
                        (templateScore * weights.template);

                    console.log(`Symbol ${symbolId}: Shape=${(shapeScore * 100).toFixed(1)}%[${shapeMethod}] Aspect=${(aspectScore * 100).toFixed(1)}% Template=${(templateScore * 100).toFixed(1)}% → Combined=${(combinedScore * 100).toFixed(1)}%`);

                    // Lower threshold since we're focusing on shape
                    if (combinedScore >= 0.30) {
                        matches.push({
                            confidence: combinedScore,
                            position: region.bounds,
                            scale: bestScale,
                            debug: {
                                shapeScore: shapeScore,
                                aspectScore: aspectScore,
                                templateScore: templateScore,
                                shapeMethod: shapeMethod
                            }
                        });
                    }

                    processedRegion.delete();
                    processedTemplate.delete();
                    src.delete();
                    regionMat.delete();
                    templ.delete();

                    return matches;
                } catch (error) {
                    console.error('Shape matching error:', error);
                    return [];
                }
            };

            const applyNonMaximumSuppression = (detections, iouThreshold = 0.3) => {
                if (detections.length === 0) return detections;

                // Sort by confidence (highest first)
                const sorted = [...detections].sort((a, b) => b.confidence - a.confidence);
                const keep = [];

                while (sorted.length > 0) {
                    const current = sorted.shift();
                    keep.push(current);

                    // Remove detections that overlap too much with current
                    for (let i = sorted.length - 1; i >= 0; i--) {
                        const iou = calculateIoU(current.position, sorted[i].position);
                        if (iou > iouThreshold) {
                            sorted.splice(i, 1);
                        }
                    }
                }

                return keep;
            };

            const calculateIoU = (box1, box2) => {
                const x1 = Math.max(box1.x, box2.x);
                const y1 = Math.max(box1.y, box2.y);
                const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
                const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

                const intersectionArea = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
                const box1Area = box1.width * box1.height;
                const box2Area = box2.width * box2.height;
                const unionArea = box1Area + box2Area - intersectionArea;

                return unionArea > 0 ? intersectionArea / unionArea : 0;
            };

            const exportDetectionData = () => {
                const data = {
                    timestamp: new Date().toISOString(),
                    imageFile: image ? 'uploaded_image' : null,
                    viewMode: viewMode,
                    readingDirection: readingDirection,
                    detections: recognitionResults.map((result, index) => ({
                        index: index,
                        symbol: result.symbol.name,
                        transliteration: result.symbol.transliteration,
                        confidence: result.confidence,
                        position: result.position,
                        matchType: result.matchType,
                        isManual: result.isManual || false,
                        isMerged: result.isMerged || false,
                        validated: validations[index] ? validations[index].isCorrect : null
                    })),
                    readingOrder: viewMode === 'reading' ? readingOrder : null,
                    wordBoundaries: Array.from(wordBoundaries),
                    actionHistory: actionHistory
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_detection_data_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                recordAction('export_detection_data', { detectionCount: recognitionResults.length });
            };

            const exportAnnotatedImage = () => {
                if (!imageRef.current) return;
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = imageRef.current;
                
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                
                // Draw original image
                ctx.drawImage(img, 0, 0);
                
                // Draw detection boxes and labels
                recognitionResults.forEach((detection, index) => {
                    const pos = detection.position;
                    
                    // Determine box color based on validation
                    let boxColor = '#3b82f6'; // blue - unvalidated
                    if (validations[index]) {
                        boxColor = validations[index].isCorrect ? '#10b981' : '#ef4444'; // green or red
                    }
                    
                    // Draw box
                    ctx.strokeStyle = boxColor;
                    ctx.lineWidth = 4;
                    ctx.strokeRect(pos.x, pos.y, pos.width, pos.height);
                    
                    // Draw semi-transparent background for label
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    const labelText = detection.symbol.name;
                    ctx.font = '16px Arial';
                    const textWidth = ctx.measureText(labelText).width;
                    ctx.fillRect(pos.x, pos.y - 25, textWidth + 10, 25);
                    
                    // Draw label text
                    ctx.fillStyle = 'white';
                    ctx.fillText(labelText, pos.x + 5, pos.y - 7);
                    
                    // Draw reading order number if in reading view
                    if (viewMode === 'reading') {
                        const orderNum = getReadingOrderIndex(index);
                        ctx.fillStyle = '#facc15';
                        ctx.beginPath();
                        ctx.arc(pos.x - 15, pos.y - 15, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.strokeStyle = '#ca8a04';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(orderNum.toString(), pos.x - 15, pos.y - 15);
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'alphabetic';
                    }
                });
                
                // Convert to blob and download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hakli_annotated_${new Date().toISOString().slice(0,10)}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    recordAction('export_annotated_image', {});
                });
            };

            const copyTranscriptionToClipboard = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';
                
                orderedResults.forEach((result, index) => {
                    transcription += result.symbol.transliteration || result.symbol.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });
                
                navigator.clipboard.writeText(transcription).then(() => {
                    alert('Transcription copied to clipboard!');
                    recordAction('copy_transcription', {});
                }).catch(err => {
                    console.error('Failed to copy:', err);
                });
            };

            const startCorrection = (detectionIndex) => {
                setCorrectionMode(detectionIndex);
            };

            const applyCorrection = (detectionIndex, newSymbol) => {
                const oldSymbol = recognitionResults[detectionIndex].symbol;
                const confidence = recognitionResults[detectionIndex].confidence;

                recordAction('correct_symbol', {
                    detectionIndex: detectionIndex,
                    oldSymbol: oldSymbol,
                    newSymbol: newSymbol
                });

                // Save to correction memory
                saveCorrectionToMemory(oldSymbol, newSymbol, confidence);

                setRecognitionResults(prev => prev.map((result, index) => {
                    if (index === detectionIndex) {
                        return {
                            ...result,
                            symbol: newSymbol,
                            corrected: true,
                            originalSymbol: result.symbol
                        };
                    }
                    return result;
                }));

                setCorrectionMode(null);
            };

            const cancelCorrection = () => {
                setCorrectionMode(null);
            };

            // Correction Memory Functions
            const saveCorrectionToMemory = (originalSymbol, correctedSymbol, confidence) => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    const key = originalSymbol.id;

                    if (!corrections[key]) {
                        corrections[key] = {
                            originalSymbol: originalSymbol,
                            corrections: []
                        };
                    }

                    // Find if this correction already exists
                    const existingIndex = corrections[key].corrections.findIndex(c => c.to.id === correctedSymbol.id);

                    if (existingIndex >= 0) {
                        corrections[key].corrections[existingIndex].count++;
                        corrections[key].corrections[existingIndex].lastUsed = new Date().toISOString();
                    } else {
                        corrections[key].corrections.push({
                            to: correctedSymbol,
                            count: 1,
                            firstUsed: new Date().toISOString(),
                            lastUsed: new Date().toISOString(),
                            avgConfidence: confidence
                        });
                    }

                    localStorage.setItem('hakliCorrections', JSON.stringify(corrections));
                    console.log('Correction saved to memory:', originalSymbol.name, '→', correctedSymbol.name);
                } catch (error) {
                    console.error('Failed to save correction:', error);
                }
            };

            const getCorrectionSuggestion = (symbolId) => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    if (corrections[symbolId] && corrections[symbolId].corrections.length > 0) {
                        // Return most frequently used correction
                        const sorted = [...corrections[symbolId].corrections].sort((a, b) => b.count - a.count);
                        return sorted[0];
                    }
                    return null;
                } catch (error) {
                    console.error('Failed to get correction suggestion:', error);
                    return null;
                }
            };

            const exportCorrectionMemory = () => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    const exportData = {
                        version: '1.0',
                        exportDate: new Date().toISOString(),
                        corrections: corrections,
                        stats: {
                            totalSymbols: Object.keys(corrections).length,
                            totalCorrections: Object.values(corrections).reduce((sum, c) => sum + c.corrections.reduce((s, cor) => s + cor.count, 0), 0)
                        }
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hakli_corrections_${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    alert(`Exported ${exportData.stats.totalCorrections} corrections for ${exportData.stats.totalSymbols} symbols!`);
                } catch (error) {
                    console.error('Export failed:', error);
                    alert('Failed to export corrections');
                }
            };

            const importCorrectionMemory = (jsonData) => {
                try {
                    const imported = JSON.parse(jsonData);
                    const existing = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');

                    // Merge imported with existing
                    Object.keys(imported.corrections).forEach(key => {
                        if (existing[key]) {
                            // Merge correction counts
                            imported.corrections[key].corrections.forEach(importedCorr => {
                                const existingCorr = existing[key].corrections.find(c => c.to.id === importedCorr.to.id);
                                if (existingCorr) {
                                    existingCorr.count += importedCorr.count;
                                } else {
                                    existing[key].corrections.push(importedCorr);
                                }
                            });
                        } else {
                            existing[key] = imported.corrections[key];
                        }
                    });

                    localStorage.setItem('hakliCorrections', JSON.stringify(existing));
                    alert(`Imported corrections successfully! Total symbols in memory: ${Object.keys(existing).length}`);
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Failed to import corrections - invalid file format');
                }
            };
            
            const undo = () => {
                if (historyIndex <= 0) return;
                
                const previousState = stateHistory[historyIndex - 1];
                setRecognitionResults(previousState.recognitionResults);
                setValidations(previousState.validations);
                setSelectedRegions(previousState.selectedRegions);
                setWordBoundaries(previousState.wordBoundaries);
                setReadingOrder(previousState.readingOrder);
                setIsolatedSymbols(previousState.isolatedSymbols);
                setHistoryIndex(historyIndex - 1);
                
                console.log('Undo to state', historyIndex - 1);
            };

            const redo = () => {
                if (historyIndex >= stateHistory.length - 1) return;
                
                const nextState = stateHistory[historyIndex + 1];
                setRecognitionResults(nextState.recognitionResults);
                setValidations(nextState.validations);
                setSelectedRegions(nextState.selectedRegions);
                setWordBoundaries(nextState.wordBoundaries);
                setReadingOrder(nextState.readingOrder);
                setIsolatedSymbols(nextState.isolatedSymbols);
                setHistoryIndex(historyIndex + 1);
                
                console.log('Redo to state', historyIndex + 1);
            }; 

            const exportTranscription = () => {
                const orderedResults = viewMode === 'reading' ? getReadingOrderedResults() : recognitionResults;
                let transcription = '';

                orderedResults.forEach((result, index) => {
                    transcription += result.symbol.transliteration || result.symbol.name;
                    if (viewMode === 'reading' && wordBoundaries.has(index)) {
                        transcription += ' | ';
                    } else if (index < orderedResults.length - 1) {
                        transcription += ' ';
                    }
                });

                const blob = new Blob([transcription], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `hakli_transcription_${new Date().toISOString().slice(0, 10)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                recordAction('export_transcription', { transcription });
            };



            const recognizeSymbols = () => {
                if (!image || !equivalenceChart || !isOpenCvReady) return;
                setIsProcessing(true);
                setRecognitionResults([]);
                console.log('Starting recognition with', equivalenceChart.symbols.length, 'symbols and', Object.keys(loadedSymbolImages).length, 'loaded images');
                try {
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        const isolated = isolateSymbols(tempImg);
                        const isolatedWithThumbnails = isolated.map(region => ({
                            ...region,
                            thumbnail: extractRegionThumbnail(tempImg, region)
                        }));
                        setIsolatedSymbols(isolatedWithThumbnails);
                        console.log('Isolated', isolated.length, 'regions');
                        if (isolated.length === 0) {
                            console.log('No regions found - check image contrast and size');
                            setIsProcessing(false);
                            return;
                        }
                        const results = [];
                        let totalMatches = 0;
                        for (const region of isolated) {
                            let bestMatch = null;
                            
                            for (const symbol of equivalenceChart.symbols) {
                                // Check primary image
                                if (loadedSymbolImages[symbol.id]) {
                                    const matches = performTemplateMatchingOnRegion(tempImg, loadedSymbolImages[symbol.id], region);
                                    totalMatches += matches.length;
                                    for (const match of matches) {
                                        if (!bestMatch || match.confidence > bestMatch.confidence) {
                                            bestMatch = {
                                                symbol,
                                                confidence: match.confidence,
                                                position: region.bounds,
                                                matchType: 'primary'
                                            };
                                        }
                                    }
                                }
                                
                                // Check variant images
                                if (symbol.images && symbol.images.variants) {
                                    for (let i = 0; i < symbol.images.variants.length; i++) {
                                        const variantKey = `${symbol.id}_variant_${i}`;
                                        if (loadedSymbolImages[variantKey]) {
                                            const matches = performTemplateMatchingOnRegion(tempImg, loadedSymbolImages[variantKey], region);
                                            for (const match of matches) {
                                                const weightedConfidence = match.confidence * 0.9;
                                                if (!bestMatch || weightedConfidence > bestMatch.confidence) {
                                                    bestMatch = {
                                                        symbol,
                                                        confidence: weightedConfidence,
                                                        position: region.bounds,
                                                        matchType: 'variant',
                                                        variantIndex: i
                                                    };
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                // Check example images
                                if (symbol.images && symbol.images.examples) {
                                    for (let i = 0; i < symbol.images.examples.length; i++) {
                                        const exampleKey = `${symbol.id}_example_${i}`;
                                        if (loadedSymbolImages[exampleKey]) {
                                            const matches = performTemplateMatchingOnRegion(tempImg, loadedSymbolImages[exampleKey], region);
                                            for (const match of matches) {
                                                const weightedConfidence = match.confidence * 0.8;
                                                if (!bestMatch || weightedConfidence > bestMatch.confidence) {
                                                    bestMatch = {
                                                        symbol,
                                                        confidence: weightedConfidence,
                                                        position: region.bounds,
                                                        matchType: 'example',
                                                        exampleIndex: i
                                                    };
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            if (bestMatch && bestMatch.confidence > 0.4) {
                                results.push({
                                    ...bestMatch,
                                    regionIndex: isolated.indexOf(region)
                                });
                                console.log(`Region ${isolated.indexOf(region)}: Matched ${bestMatch.symbol.name} with ${(bestMatch.confidence * 100).toFixed(1)}% confidence`);
                            }
                        }
                                                    console.log(`Recognition complete: ${results.length} symbols detected from ${isolated.length} regions (${totalMatches} total template matches tested)`);
                        
                        // Apply non-maximum suppression to remove overlapping detections
                        const filteredResults = applyNonMaximumSuppression(results, 0.3);
                        console.log(`After NMS: ${filteredResults.length} detections (removed ${results.length - filteredResults.length} overlapping)`);
                        
                        setRecognitionResults(filteredResults);
                        setIsProcessing(false);
                    };
                    tempImg.src = image;
                } catch (error) {
                    console.error('Recognition error:', error);
                    setIsProcessing(false);
                }
            };

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file && file.type.indexOf('image/') === 0) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setImage(e.target.result);
                        setRecognitionResults([]);
                        setValidations({});
                        setActionHistory([]);
                        setIsolatedSymbols([]);
                        setSelectedRegions(new Set());
                        setMergeIndicator(null);
                    };
                    reader.readAsDataURL(file);
                }
            };

            // Cloud Sync Functions - GitHub Repository Method
            const uploadCorrectionsToCloud = async () => {
                try {
                    const corrections = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    const exportData = {
                        version: '1.0',
                        uploadDate: new Date().toISOString(),
                        corrections: corrections,
                        stats: {
                            totalSymbols: Object.keys(corrections).length,
                            totalCorrections: Object.values(corrections).reduce((sum, c) =>
                                sum + c.corrections.reduce((s, cor) => s + cor.count, 0), 0)
                        },
                        source: 'hakli-recognizer-community-contribution'
                    };

                    // Create downloadable JSON file
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hakli_corrections_contribution_${new Date().toISOString().slice(0, 10)}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    // Show instructions
                    const issueUrl = 'https://github.com/hytra3/hakli_glyph_recognizer/issues/new?title=Community%20Corrections%20Contribution&body=Please%20find%20my%20correction%20memory%20attached.%20Thank%20you!';

                    const message = `✅ Corrections file downloaded!\n\n` +
                        `📤 To share with the community:\n\n` +
                        `1. The file has been downloaded to your computer\n` +
                        `2. Click OK to open a new GitHub Issue\n` +
                        `3. Attach the downloaded JSON file to the issue\n` +
                        `4. Submit the issue\n\n` +
                        `Your corrections will be reviewed and added to the master collection!\n\n` +
                        `Stats: ${exportData.stats.totalCorrections} corrections for ${exportData.stats.totalSymbols} symbols`;

                    if (confirm(message)) {
                        window.open(issueUrl, '_blank');
                    }

                    recordAction('export_for_contribution', { stats: exportData.stats });

                    return { success: true };
                } catch (error) {
                    console.error('Export failed:', error);
                    alert('❌ Failed to export corrections. Check console for details.');
                    return null;
                }
            };

            const downloadCorrectionsFromCloud = async (url = null) => {
                try {
                    // Default to master collection
                    const masterUrl = url || 'https://raw.githubusercontent.com/hytra3/hakli_glyph_recognizer/main/community-corrections/master.json';

                    // Fetch the corrections data
                    const response = await fetch(masterUrl);
                    if (!response.ok) {
                        if (response.status === 404) {
                            alert('ℹ️ No master corrections available yet.\n\nBe the first to contribute!');
                            return null;
                        }
                        throw new Error('Failed to download corrections');
                    }

                    const cloudData = await response.json();

                    // Check if there are any corrections
                    if (!cloudData.corrections || Object.keys(cloudData.corrections).length === 0) {
                        alert('ℹ️ The master collection is empty.\n\nContribute your corrections to help the community!');
                        return null;
                    }

                    // Merge with existing corrections
                    const existing = JSON.parse(localStorage.getItem('hakliCorrections') || '{}');
                    let newCorrections = 0;
                    let updatedCorrections = 0;

                    Object.keys(cloudData.corrections).forEach(key => {
                        if (!existing[key]) {
                            existing[key] = cloudData.corrections[key];
                            newCorrections++;
                        } else {
                            // Merge correction counts
                            cloudData.corrections[key].corrections.forEach(cloudCorr => {
                                const existingCorr = existing[key].corrections.find(c => c.to.id === cloudCorr.to.id);
                                if (existingCorr) {
                                    existingCorr.count += cloudCorr.count;
                                    updatedCorrections++;
                                } else {
                                    existing[key].corrections.push(cloudCorr);
                                    newCorrections++;
                                }
                            });
                        }
                    });

                    localStorage.setItem('hakliCorrections', JSON.stringify(existing));

                    const contributorInfo = cloudData.stats?.contributors?.length > 0
                        ? `\n\nThanks to ${cloudData.stats.contributors.length} contributor(s)!`
                        : '';

                    alert(`✅ Community corrections downloaded!\n\n` +
                        `${newCorrections} new corrections added\n` +
                        `${updatedCorrections} existing corrections updated\n\n` +
                        `Total symbols in your memory: ${Object.keys(existing).length}` +
                        contributorInfo);

                    recordAction('download_from_cloud', {
                        source: masterUrl,
                        newCorrections,
                        updatedCorrections
                    });

                    return { newCorrections, updatedCorrections };
                } catch (error) {
                    console.error('Download from cloud failed:', error);
                    alert('❌ Failed to download corrections from cloud.\n\nThe master collection may not exist yet, or there may be a network issue.');
                    return null;
                }
            };

            const getDetectionBoxStyle = (index) => {
                const detection = recognitionResults[index];
                if (!detection || !imageRef.current) return {};
                const imageRect = imageRef.current.getBoundingClientRect();
                const scaleX = imageRect.width / imageRef.current.naturalWidth;
                const scaleY = imageRect.height / imageRef.current.naturalHeight;
                return {
                    left: detection.position.x * scaleX + 'px',
                    top: detection.position.y * scaleY + 'px',
                    width: detection.position.width * scaleX + 'px',
                    height: detection.position.height * scaleY + 'px'
                };
            };

            const getDetectionBoxClass = (index) => {
                let classes = ['detection-box'];
                if (validations[index]) {
                    classes.push(validations[index].isCorrect ? 'validated-correct' : 'validated-incorrect');
                } else {
                    classes.push('unvalidated');
                }
                if (selectedRegions.has(index)) classes.push('selected');
                return classes.join(' ');
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Escape: Close correction modal
                    if (e.key === 'Escape' && correctionMode !== null) {
                        e.preventDefault();
                        cancelCorrection();
                        return;
                    }
                    
                    // Undo: Ctrl+Z (or Cmd+Z on Mac)
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        undo();
                    }
                    // Redo: Ctrl+Shift+Z or Ctrl+Y (or Cmd equivalents on Mac)
                    if ((e.ctrlKey || e.metaKey) && (e.shiftKey && e.key === 'z' || e.key === 'y')) {
                        e.preventDefault();
                        redo();
                    }
                };
                    
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [historyIndex, stateHistory, correctionMode]);

                        useEffect(() => {
                if (chartLoadStatus === 'not-loaded') {
                    setChartLoadStatus('loading');
                    const githubJsonUrl = 'https://raw.githubusercontent.com/hytra3/hakli-recognizer/main/Hakli_symbols.JSON';
                    fetch(githubJsonUrl)
                        .then(response => response.json())
                        .then(chartData => {
                            setEquivalenceChart(chartData);
                            const imageCache = {};
                            const loadPromises = [];
                            
                            for (const symbol of chartData.symbols) {
                                // Load primary image
                                if (symbol.images && symbol.images.primary) {
                                    const fullUrl = convertToGitHubUrl(symbol.images.primary);
                                    if (fullUrl) {
                                        const promise = new Promise((resolve) => {
                                            const img = new Image();
                                            img.crossOrigin = 'anonymous';
                                            img.onload = () => {
                                                imageCache[symbol.id] = img;
                                                resolve();
                                            };
                                            img.onerror = () => resolve();
                                            img.src = fullUrl;
                                        });
                                        loadPromises.push(promise);
                                    }
                                }
                                
                                // Load variant images
                                if (symbol.images && symbol.images.variants) {
                                    for (let i = 0; i < symbol.images.variants.length; i++) {
                                        const fullUrl = convertToGitHubUrl(symbol.images.variants[i]);
                                        if (fullUrl) {
                                            const variantKey = `${symbol.id}_variant_${i}`;
                                            const promise = new Promise((resolve) => {
                                                const img = new Image();
                                                img.crossOrigin = 'anonymous';
                                                img.onload = () => {
                                                    imageCache[variantKey] = img;
                                                    resolve();
                                                };
                                                img.onerror = () => resolve();
                                                img.src = fullUrl;
                                            });
                                            loadPromises.push(promise);
                                        }
                                    }
                                }
                                
                                // Load example images
                                if (symbol.images && symbol.images.examples) {
                                    for (let i = 0; i < symbol.images.examples.length; i++) {
                                        const fullUrl = convertToGitHubUrl(symbol.images.examples[i]);
                                        if (fullUrl) {
                                            const exampleKey = `${symbol.id}_example_${i}`;
                                            const promise = new Promise((resolve) => {
                                                const img = new Image();
                                                img.crossOrigin = 'anonymous';
                                                img.onload = () => {
                                                    imageCache[exampleKey] = img;
                                                    resolve();
                                                };
                                                img.onerror = () => resolve();
                                                img.src = fullUrl;
                                            });
                                            loadPromises.push(promise);
                                        }
                                    }
                                }
                            }
                            
                            Promise.all(loadPromises).then(() => {
                                console.log(`Loaded ${Object.keys(imageCache).length} total images`);
                                setLoadedSymbolImages(imageCache);
                                setChartLoadStatus('loaded');
                            });
                        })
                        .catch(() => setChartLoadStatus('error'));
                }
            }, [chartLoadStatus]);

            return (
                <div className="max-w-6xl mx-auto p-6 bg-white">
                    <div className="mb-8">
                        <h1 className="text-3xl font-bold text-gray-900 mb-2">Hakli Symbol Recognizer</h1>
                        <p className="text-gray-600">beta v251021 ©marty heaton</p>
                    </div>

                    <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                        <div className="flex items-center justify-between">
                            <div>
                                <h3 className="font-semibold text-gray-900">Equivalence Chart Status</h3>
                                <div className="flex items-center gap-2 mt-1">
                                    {chartLoadStatus === 'loading' && <span className="text-blue-600">Loading...</span>}
                                    {chartLoadStatus === 'loaded' && <span className="text-green-600">Loaded ({equivalenceChart?.symbols?.length || 0} symbols, {Object.keys(loadedSymbolImages).length} images)</span>}
                                    {chartLoadStatus === 'error' && <span className="text-red-600">Error loading chart</span>}
                                </div>
                            </div>
                            <button onClick={() => setChartLoadStatus('not-loaded')} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600" disabled={chartLoadStatus === 'loading'}>
                                Reload Chart
                            </button>
                        </div>
                    </div>

                    <div className="mb-6">
                        <input type="file" accept="image/*" onChange={handleFileUpload} className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" />
                    </div>

                    {recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                            <div className="flex items-center justify-between mb-4">
                                <h3 className="font-semibold text-gray-900">View Mode</h3>
                                <div className="flex gap-2">
                                    <button 
                                        onClick={() => setViewMode('detection')}
                                        className={`px-4 py-2 rounded font-medium ${viewMode === 'detection' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        📷 Detection View
                                    </button>
                                    <button 
                                        onClick={() => {
                                            setViewMode('reading');
                                            if (readingOrder.length === 0) {
                                                setReadingOrder(recognitionResults.map((_, idx) => idx));
                                            }
                                        }}
                                        className={`px-4 py-2 rounded font-medium ${viewMode === 'reading' ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        📖 Reading Order View
                                    </button>
                                </div>
                            </div>
                            
                            {viewMode === 'reading' && (
                                <div className="pt-4 border-t border-gray-300">
                                    <div className="flex items-center justify-between">
                                        <span className="text-sm font-medium text-gray-700">Reading Direction:</span>
                                        <div className="flex gap-2">
                                            <button 
                                                onClick={() => applyReadingDirection('detection')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'detection' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Original detection order"
                                            >
                                                🔢 Detection Order
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('ltr')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'ltr' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Left to Right"
                                            >
                                                → LTR
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('rtl')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'rtl' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Right to Left"
                                            >
                                                ← RTL
                                            </button>
                                            <button 
                                                onClick={() => applyReadingDirection('ttb')}
                                                className={`px-3 py-1 text-sm rounded ${readingDirection === 'ttb' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Top to Bottom"
                                            >
                                                ↓ TTB
                                            </button>
                                        </div>
                                    </div>
                                    <div className="mt-3 p-3 bg-blue-50 border border-blue-200 rounded text-sm text-blue-800">
                                        💡 Tip: In Reading Order View, you can drag detection cards below to manually reorder them.
                                    </div>
                                </div>
                            )}
                            
                            {viewMode === 'detection' && (
                                <div className="pt-4 border-t border-gray-300">
                                    <div className="p-3 bg-gray-100 border border-gray-300 rounded text-sm text-gray-700">
                                        📷 Detection View shows symbols in the order they were detected (left-to-right on the image). Use this mode for validation and editing.
                                    </div>
                                </div>
                            )}
                        </div>
                    )}


                    {image && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <div className="flex flex-wrap gap-3 items-center mb-4">
                                <button onClick={recognizeSymbols} disabled={isProcessing || !equivalenceChart} className="px-6 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50">
                                    {isProcessing ? 'Processing...' : 'Recognize Symbols'}
                                </button>

                                <button onClick={() => setManualDetectionMode(!manualDetectionMode)} className={`px-4 py-2 rounded ${manualDetectionMode ? 'bg-orange-500 text-white hover:bg-orange-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>
                                    {manualDetectionMode ? 'Exit Manual Mode' : 'Manual Detection'}
                                </button>
                                <button onClick={() => setShowRegionBoundaries(!showRegionBoundaries)} className={`px-4 py-2 rounded ${showRegionBoundaries ? 'bg-purple-500 text-white hover:bg-purple-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>
                                    Region Boundaries
                                </button>
                                {isolatedSymbols.length > 0 && (
                                    <button
                                        onClick={() => setShowRegionBoundaries(!showRegionBoundaries)}
                                        className="px-4 py-2 bg-teal-500 text-white rounded hover:bg-teal-600"
                                    >
                                        {showRegionBoundaries ? 'Hide' : 'Show'} Isolated Regions ({isolatedSymbols.length})
                                    </button>
                                )}
                                <span className="text-sm text-gray-600">{recognitionResults.length} detections</span>
                            </div>

                            {recognitionResults.length > 0 && (
                                <div className="mt-4 p-4 bg-white border-2 border-gray-300 rounded-lg">
                                    <div className="flex items-center justify-between mb-3">
                                        <div className="flex items-center gap-3">
                                            <h4 className="font-semibold text-gray-900">Confidence Filter</h4>
                                            <label className="flex items-center gap-2 cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={useConfidenceFilter}
                                                    onChange={(e) => setUseConfidenceFilter(e.target.checked)}
                                                    className="w-4 h-4"
                                                />
                                                <span className="text-sm text-gray-700">Enable</span>
                                            </label>
                                        </div>
                                        <div className="text-sm">
                                            {useConfidenceFilter ? (
                                                <span className="text-blue-600 font-semibold">
                                                    Showing {getFilteredResults().length} of {recognitionResults.length} detections
                                                    {recognitionResults.length - getFilteredResults().length > 0 && (
                                                        <span className="text-gray-500 ml-2">
                                                            ({recognitionResults.length - getFilteredResults().length} hidden)
                                                        </span>
                                                    )}
                                                </span>
                                            ) : (
                                                <span className="text-gray-600">Showing all {recognitionResults.length} detections</span>
                                            )}
                                        </div>
                                    </div>
                                    
                                    <div className="flex items-center gap-4">
                                        <label className="text-sm font-medium text-gray-700 whitespace-nowrap">
                                            Min Confidence: {confidenceThreshold}%
                                        </label>
                                        <input
                                            type="range"
                                            min="0"
                                            max="100"
                                            value={confidenceThreshold}
                                            onChange={(e) => setConfidenceThreshold(parseInt(e.target.value))}
                                            disabled={!useConfidenceFilter}
                                            className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed"
                                            style={{
                                                background: useConfidenceFilter 
                                                    ? `linear-gradient(to right, #ef4444 0%, #f59e0b ${confidenceThreshold / 2}%, #10b981 ${confidenceThreshold}%, #e5e7eb ${confidenceThreshold}%, #e5e7eb 100%)`
                                                    : '#e5e7eb'
                                            }}
                                        />
                                        <span className="text-xs text-gray-500 whitespace-nowrap">
                                            {confidenceThreshold < 40 && '🔴 Low'}
                                            {confidenceThreshold >= 40 && confidenceThreshold < 70 && '🟡 Medium'}
                                            {confidenceThreshold >= 70 && '🟢 High'}
                                        </span>
                                    </div>
                                </div>
                            )}
                                <button 
                                    onClick={undo}
                                    disabled={historyIndex <= 0}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed"
                                    title="Undo (Ctrl+Z)"
                                >
                                    ↶ Undo
                                </button>
                                <button 
                                    onClick={redo}
                                    disabled={historyIndex >= stateHistory.length - 1}
                                    className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 disabled:opacity-30 disabled:cursor-not-allowed"
                                    title="Redo (Ctrl+Y)"
                                >
                                    ↷ Redo
                                </button>

                            {selectedRegions.size > 0 && (
                                <div className="flex flex-wrap gap-3 items-center pt-3 border-t border-gray-200">
                                    <span className="text-sm text-gray-600">{selectedRegions.size} selected</span>
                                    {selectedRegions.size >= 2 && (
                                        <button onClick={mergeSelectedDetections} className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600">
                                            Merge Selected
                                        </button>
                                    )}
                                    <button onClick={() => setSelectedRegions(new Set())} className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                                        Clear Selection
                                    </button>
                                </div>
                            )}
                            
                            {manualDetectionMode && (
                                <div className="mt-3 p-3 bg-orange-50 border border-orange-200 rounded text-sm text-orange-800">
                                    Manual Mode: Click and drag to create detections. Ctrl/Cmd+Click to select for merging.
                                </div>
                            )}
                            {recognitionResults.length > 0 && (
                                <div className="mt-3 p-3 bg-blue-50 border border-blue-200 rounded text-sm text-blue-800">
                                    💡 Tip: Ctrl/Cmd+Click any detection box to select it. Delete (✕) and Merge (⚡) buttons will appear.
                                </div>
                            )}
                        </div>
                    )}

                    {image && (
                        <div className="mb-6">
                            <div className="canvas-container relative" ref={imageContainerRef}
                                onMouseMove={handleImageMouseMove}
                                onMouseUp={handleImageMouseUp}
                                onMouseLeave={handleImageMouseUp}
                            >
                                <img
                                    ref={imageRef}
                                    src={image}
                                    alt="Uploaded inscription"
                                    className="max-w-full h-auto border border-gray-300 rounded"
                                    onMouseDown={handleImageMouseDown}
                                    style={{ 
                                        cursor: manualDetectionMode ? 'crosshair' : 'default',
                                        userSelect: 'none',
                                        pointerEvents: 'auto'
                                    }}
                                    draggable={false}
                                />
                                
                                {showRegionBoundaries && isolatedSymbols.map((region, index) => {
                                    if (!imageRef.current) return null;
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div key={`region-${index}`} className="region-boundary" style={{
                                            left: region.bounds.x * scaleX + 'px',
                                            top: region.bounds.y * scaleY + 'px',
                                            width: region.bounds.width * scaleX + 'px',
                                            height: region.bounds.height * scaleY + 'px'
                                        }} />
                                    );
                                })}
                                
                                {getFilteredResults().map((detection) => {
                                    const index = recognitionResults.indexOf(detection);
                                    return (
                                    <div key={`detection-${index}`} className={getDetectionBoxClass(index)} style={getDetectionBoxStyle(index)} onClick={(e) => handleDetectionClick(e, index)}>               
                                        {viewMode === 'reading' && (
                                            <div className="absolute -top-3 -left-3 w-6 h-6 rounded-full bg-yellow-400 border-2 border-yellow-600 text-xs font-bold flex items-center justify-center shadow-lg" style={{ pointerEvents: 'none' }}>
                                                {getReadingOrderIndex(index)}
                                            </div>
                                        )}

                                        <div className="absolute top-1 left-1 bg-black bg-opacity-75 text-white text-xs px-1 py-0.5 rounded flex items-center gap-1" style={{ pointerEvents: 'none' }}>
                                             {detection.corrected && <span title="Corrected symbol">✏️</span>}
                                                <span>{detection.symbol.name}</span>
                                        </div>

                                        {selectedRegions.has(index) && (
                                        <>
                                            <div className="absolute bottom-1 right-1 bg-black bg-opacity-75 text-white text-xs px-1 py-0.5 rounded" style={{ pointerEvents: 'none' }}>
                                                {Math.round(detection.confidence * 100)}%
                                            </div>
                                            <div className="absolute top-1 right-1 flex gap-1" style={{ pointerEvents: 'auto' }}>
                                                <button 
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        startCorrection(index);
                                                    }}
                                                    className="px-2 py-1 bg-orange-500 text-white text-xs rounded hover:bg-orange-600"
                                                    title="Change symbol"
                                                >
                                                    ✏️
                                                </button>
                                                <button 
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        deleteDetection(index);
                                                    }}
                                                    className="px-2 py-1 bg-red-500 text-white text-xs rounded hover:bg-red-600"
                                                    title="Delete this detection"
                                                >
                                                    ✕
                                                </button>
                                                {selectedRegions.size >= 2 && (
                                                    <button 
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            mergeSelectedDetections();
                                                        }}
                                                        className="px-2 py-1 bg-purple-500 text-white text-xs rounded hover:bg-purple-600"
                                                        title="Merge selected detections"
                                                    >
                                                        ⚡
                                                    </button>
                                                )}
                                            </div>
                                        </>
                                    )}
                                    </div>
                                );
                                })}
                                
                                {isDrawing && drawStart && drawCurrent && imageRef.current && (() => {
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div className="manual-selection-box" style={{
                                            left: Math.min(drawStart.x, drawCurrent.x) * scaleX + 'px',
                                            top: Math.min(drawStart.y, drawCurrent.y) * scaleY + 'px',
                                            width: Math.abs(drawCurrent.x - drawStart.x) * scaleX + 'px',
                                            height: Math.abs(drawCurrent.y - drawStart.y) * scaleY + 'px'
                                        }} />
                                    );
                                })()}
                                
                                {mergeIndicator && imageRef.current && (() => {
                                    const imageRect = imageRef.current.getBoundingClientRect();
                                    const scaleX = imageRect.width / imageRef.current.naturalWidth;
                                    const scaleY = imageRect.height / imageRef.current.naturalHeight;
                                    return (
                                        <div className="merge-indicator" style={{
                                            left: mergeIndicator.x * scaleX + 'px',
                                            top: mergeIndicator.y * scaleY + 'px',
                                            width: mergeIndicator.width * scaleX + 'px',
                                            height: mergeIndicator.height * scaleY + 'px'
                                        }} />
                                    );
                                })()}
                            </div>
                        </div>
                    )}
                        {isolatedSymbols.length > 0 && showRegionBoundaries && (
                            <div className="mt-4 p-4 bg-gray-50 border-2 border-teal-300 rounded-lg">
                                <h4 className="font-semibold text-gray-900 mb-3">Isolated Symbol Regions ({isolatedSymbols.length})</h4>
                                <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-2">
                                    {isolatedSymbols.map((region, index) => (
                                        <div key={`thumb-${index}`} className="flex flex-col items-center p-2 bg-white border border-gray-300 rounded">
                                            {region.thumbnail && (
                                                <img src={region.thumbnail} alt={`Region ${index}`} className="w-full h-auto border border-gray-200" />
                                            )}
                                            <div className="text-xs text-gray-600 mt-1">#{index + 1}</div>
                                            <div className="text-xs text-gray-500">{region.bounds.width}×{region.bounds.height}</div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                    {correctionMode !== null && equivalenceChart && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={cancelCorrection}>
                            <div className="bg-white rounded-lg p-6 max-w-5xl w-full max-h-[85vh] overflow-y-auto shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900">Select Correct Symbol</h3>
                                    <button 
                                        onClick={cancelCorrection} 
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none w-8 h-8 flex items-center justify-center"
                                        title="Close (Esc)"
                                    >
                                        &times;
                                    </button>
                                </div>
                                
                                <div className="mb-4 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-blue-200 rounded-lg">
                                    <div className="flex items-center justify-between gap-4">
                                        <div className="flex-1">
                                            <span className="text-sm text-gray-600">Currently detected as:</span>
                                            <div className="text-xl font-bold text-gray-900 mt-1">
                                                {recognitionResults[correctionMode].symbol.name}
                                                <span className="ml-3 text-base font-normal text-gray-600">
                                                    ({recognitionResults[correctionMode].symbol.transliteration || recognitionResults[correctionMode].symbol.name})
                                                </span>
                                            </div>
                                            <div className="text-sm text-gray-500 mt-1">
                                                {Math.round(recognitionResults[correctionMode].confidence * 100)}% confidence
                                            </div>
                                        </div>
                                        {recognitionResults[correctionMode].regionIndex !== undefined &&
                                            isolatedSymbols[recognitionResults[correctionMode].regionIndex]?.thumbnail && (
                                                <div className="flex-shrink-0">
                                                    <div className="text-xs text-gray-600 mb-1 text-center">Detected Region:</div>
                                                    <img
                                                        src={isolatedSymbols[recognitionResults[correctionMode].regionIndex].thumbnail}
                                                        alt="Isolated region"
                                                        className="w-32 h-auto border-2 border-blue-300 rounded"
                                                    />
                                                </div>
                                            )}
                                    </div>
                                </div>                          
                                <div className="mb-4">
                                    <input
                                        type="text"
                                        placeholder="Search symbols by name or transliteration..."
                                        className="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none"
                                        onChange={(e) => {
                                            const searchTerm = e.target.value.toLowerCase();
                                            const symbolGrid = e.target.parentElement.nextElementSibling;
                                            const buttons = symbolGrid.querySelectorAll('button');
                                            buttons.forEach(btn => {
                                                const text = btn.textContent.toLowerCase();
                                                btn.style.display = text.includes(searchTerm) ? '' : 'none';
                                            });
                                        }}
                                    />
                                </div>
                                
                                {(() => {
                                    const suggestion = getCorrectionSuggestion(recognitionResults[correctionMode].symbol.id);
                                    if (suggestion) {
                                        return (
                                            <div className="mb-4 p-3 bg-green-50 border-2 border-green-300 rounded-lg">
                                                <div className="flex items-center justify-between">
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-green-700 font-semibold">💡 Suggestion:</span>
                                                        <span className="text-gray-700">
                                                            You've corrected this to <strong>{suggestion.to.name}</strong> {suggestion.count} time{suggestion.count > 1 ? 's' : ''} before
                                                        </span>
                                                    </div>
                                                    <button
                                                        onClick={() => applyCorrection(correctionMode, suggestion.to)}
                                                        className="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 font-semibold"
                                                    >
                                                        Apply Suggestion
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    }
                                    return null;
                                })()}

                                <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2">
                                    {equivalenceChart.symbols.map((symbol, index) => {
                                        const isCurrentSymbol = symbol.id === recognitionResults[correctionMode].symbol.id;
                                        return (
                                            <button
                                                key={`symbol-${symbol.id}-${index}`}
                                                onClick={() => applyCorrection(correctionMode, symbol)}
                                                className={`p-3 border-2 rounded-lg flex flex-col items-center gap-1 transition-all hover:scale-105 ${
                                                    isCurrentSymbol 
                                                        ? 'border-blue-500 bg-blue-50 ring-2 ring-blue-300' 
                                                        : 'border-gray-200 hover:border-blue-400 hover:bg-blue-50'
                                                }`}
                                                title={`${symbol.name} (${symbol.transliteration || symbol.name})`}
                                            >
                                                <div className="font-bold text-xl">{symbol.name}</div>
                                                <div className="text-xs text-gray-600 text-center leading-tight">
                                                    {symbol.transliteration || symbol.name}
                                                </div>
                                                {isCurrentSymbol && (
                                                    <div className="text-xs text-blue-600 font-semibold mt-1">Current</div>
                                                )}
                                            </button>
                                        );
                                    })}
                                </div>
                                
                                <div className="mt-6 pt-4 border-t border-gray-200 flex items-center justify-between">
                                    <div className="text-sm text-gray-500">
                                        💡 Tip: You can also search symbols above to find them quickly
                                    </div>
                                    <button 
                                        onClick={cancelCorrection}
                                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                            <h3 className="font-semibold text-gray-900 mb-3">
                                {viewMode === 'detection' ? 'Detection Results' : 'Reading Order Results'}
                                {viewMode === 'reading' && <span className="ml-2 text-sm text-gray-600">(drag cards to reorder)</span>}
                            </h3>
                            
                            {/* Validation Statistics */}
                            <div className="mb-4 flex flex-wrap gap-4 text-sm">
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-600">Total:</span>
                                    <span className="font-semibold text-gray-900">{recognitionResults.length}</span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-green-600">✓ Validated Correct:</span>
                                    <span className="font-semibold text-green-700">
                                        {Object.values(validations).filter(v => v.isCorrect).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-red-600">✗ Validated Incorrect:</span>
                                    <span className="font-semibold text-red-700">
                                        {Object.values(validations).filter(v => !v.isCorrect).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-orange-600">✏️ Corrected:</span>
                                    <span className="font-semibold text-orange-700">
                                        {recognitionResults.filter(r => r.corrected).length}
                                    </span>
                                </div>
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-600">Unvalidated:</span>
                                    <span className="font-semibold text-gray-700">
                                        {recognitionResults.length - Object.keys(validations).length}
                                    </span>
                                </div>
                            </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                        {(viewMode === 'detection' ? getFilteredResults() : getReadingOrderedResults().filter(r => getFilteredResults().includes(r))).map((result, displayIndex) => {
                            const originalIndex = viewMode === 'detection' ? displayIndex : recognitionResults.indexOf(result);
                            const readingOrderNum = viewMode === 'reading' ? displayIndex + 1 : null;
                            
                            return (
                                <div 
                                    key={`result-${originalIndex}`} 
                                    className={`p-3 bg-white rounded border ${selectedRegions.has(originalIndex) ? 'ring-2 ring-amber-400' : ''} ${validations[originalIndex] ? (validations[originalIndex].isCorrect ? 'border-green-300' : 'border-red-300') : 'border-gray-200'} ${viewMode === 'reading' ? 'cursor-move' : ''}`}
                                    draggable={viewMode === 'reading'}
                                    onDragStart={(e) => viewMode === 'reading' && handleDragStart(e, displayIndex)}
                                    onDragOver={(e) => viewMode === 'reading' && handleDragOver(e, displayIndex)}
                                    onDrop={(e) => viewMode === 'reading' && handleDrop(e, displayIndex)}
                                >
                                    <div className="flex items-start justify-between mb-2">
                                        <div className="flex-1">
                                            <div className="flex items-center gap-2">
                                                {viewMode === 'reading' && (
                                                    <div className="flex-shrink-0 w-6 h-6 rounded-full bg-yellow-400 border-2 border-yellow-600 text-xs font-bold flex items-center justify-center">
                                                        {readingOrderNum}
                                                    </div>
                                                )}
                                                <div className="flex-1">
                                                    <div className="font-medium text-gray-900 flex items-center gap-2">
                                                        {result.symbol.name}
                                                        {result.corrected && (
                                                            <span className="text-xs bg-orange-100 text-orange-700 px-2 py-0.5 rounded border border-orange-300">
                                                                ✏️ Corrected
                                                            </span>
                                                        )}
                                                        {result.isMerged && <span className="text-xs text-gray-500">(merged)</span>}
                                                        {result.isManual && <span className="text-xs text-gray-500">(manual)</span>}
                                                    </div>
                                                    {result.corrected && result.originalSymbol && (
                                                        <div className="text-xs text-gray-500 mt-0.5">
                                                            Originally: <span className="line-through">{result.originalSymbol.name}</span>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                            <div className="text-sm text-gray-600 mt-1">{result.symbol.transliteration || result.symbol.name}</div>
                                            <div className="text-xs text-gray-500">Confidence: {Math.round(result.confidence * 100)}%</div>
                                            {result.regionIndex !== undefined && isolatedSymbols[result.regionIndex]?.thumbnail && (
                                                <div className="mt-2 flex items-center gap-2">
                                                    <span className="text-xs text-gray-500">Region:</span>
                                                    <img
                                                        src={isolatedSymbols[result.regionIndex].thumbnail}
                                                        alt="Isolated region"
                                                        className="w-16 h-auto border border-gray-300 rounded"
                                                    />
                                                </div>
                                            )}
                                        </div>
                                        <div className="flex gap-1">
                                            <button 
                                                onClick={() => startCorrection(originalIndex)} 
                                                className="text-orange-500 hover:text-orange-700 text-sm"
                                                title="Change symbol"
                                            >
                                                ✏️
                                            </button>
                                            <button 
                                                onClick={() => deleteDetection(originalIndex)} 
                                                className="text-red-500 hover:text-red-700 text-sm"
                                                title="Delete detection"
                                            >
                                                ✕
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex gap-2 flex-wrap">
                                        <button 
                                            onClick={() => validateDetection(originalIndex, true)} 
                                            className={`px-3 py-1 text-xs rounded ${validations[originalIndex]?.isCorrect ? 'bg-green-500 text-white' : 'bg-green-100 text-green-700 hover:bg-green-200'}`}
                                        >
                                            ✓ Correct
                                        </button>
                                        <button 
                                            onClick={() => validateDetection(originalIndex, false)} 
                                            className={`px-3 py-1 text-xs rounded ${validations[originalIndex] && !validations[originalIndex].isCorrect ? 'bg-red-500 text-white' : 'bg-red-100 text-red-700 hover:bg-red-200'}`}
                                        >
                                            ✗ Incorrect
                                        </button>
                                        {viewMode === 'reading' && (
                                            <button 
                                                onClick={() => toggleWordBoundary(displayIndex)} 
                                                className={`px-3 py-1 text-xs rounded ${wordBoundaries.has(displayIndex) ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                                title="Mark word boundary after this symbol"
                                            >
                                                | Word Break
                                            </button>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                    </div>
                    )}


                    {viewMode === 'reading' && recognitionResults.length > 0 && (
                        <div className="mb-6 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border-2 border-blue-200">
                            <div className="flex items-center justify-between mb-3">
                                <h3 className="font-semibold text-gray-900">Transcription</h3>
                                <div className="flex gap-2">
                                    <button 
                                        onClick={copyTranscriptionToClipboard}
                                        className="px-3 py-1 bg-blue-500 text-white text-sm rounded hover:bg-blue-600 flex items-center gap-1"
                                        title="Copy transcription to clipboard"
                                    >
                                        📋 Copy
                                    </button>
                                    <button 
                                        onClick={exportTranscription}
                                        className="px-3 py-1 bg-green-500 text-white text-sm rounded hover:bg-green-600 flex items-center gap-1"
                                        title="Download transcription as text file"
                                    >
                                        💾 Export TXT
                                    </button>
                                </div>
                            </div>
                            <div className="p-4 bg-white rounded border-2 border-blue-300 shadow-inner">
                                <div className="font-mono text-lg leading-relaxed">
                                    {getReadingOrderedResults().map((result, index) => (
                                        <span key={index}>
                                            <span className="text-gray-900">{result.symbol.transliteration || result.symbol.name}</span>
                                            {wordBoundaries.has(index) && <span className="text-blue-600 font-bold mx-1">|</span>}
                                            {!wordBoundaries.has(index) && index < getReadingOrderedResults().length - 1 && <span className="text-gray-400">·</span>}
                                        </span>
                                    ))}
                                </div>
                            </div>

                            <div className="mt-3 text-xs text-gray-600">
                                <span className="text-blue-600 font-bold">|</span> = word boundary &middot; 
                                <span className="text-gray-400">&middot;</span> = symbol separator
                            </div>
                        </div>
                    )}

                    <div className="mt-8 p-4 bg-gray-50 rounded-lg">
                        <div className="text-sm text-gray-600">
                            <div className="flex items-center gap-2">
                                <span className={`w-2 h-2 rounded-full ${isOpenCvReady ? 'bg-green-500' : 'bg-red-500'}`} />
                                OpenCV Status: {isOpenCvReady ? 'Ready' : 'Loading...'}
                                {actionHistory.length > 0 && <span className="ml-4 text-xs text-gray-500">{actionHistory.length} actions recorded</span>}
                            </div>
                        </div>
                    </div>

                    {recognitionResults.length > 0 && (
                        <div className="mt-6 p-4 bg-yellow-50 rounded-lg border-2 border-yellow-300">
                            <h3 className="font-semibold text-gray-900 mb-3">🧠 Correction Memory</h3>
                            <div className="flex flex-wrap gap-3 items-center mb-3">
                                <input
                                    type="file"
                                    accept=".json"
                                    onChange={(e) => {
                                        const file = e.target.files[0];
                                        if (file) {
                                                const reader = new FileReader();
                                                reader.onload = (event) => importCorrectionMemory(event.target.result);
                                                reader.readAsText(file);
                                            }
                                        }}
                                        id="import-corrections"
                                         className="block text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-yellow-100 file:text-yellow-700 hover:file:bg-yellow-200"
                                 />
                                    <button
                                        onClick={exportCorrectionMemory}
                                        className="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600"
                                    >
                                        📥 Export Memory
                                    </button>
                                    <button
                                        onClick={() => setShowCloudSyncModal(true)}
                                        className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                                        >
                                        ☁️ Cloud Sync
                                    </button>
                                    <button
                                        onClick={() => {
                                            if (confirm('Clear all correction memory? This cannot be undone.')) {
                                                localStorage.removeItem('hakliCorrections');
                                                alert('Correction memory cleared!');
                                            }
                                        }}
                                        className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                                    >
                                        🗑️ Clear Memory
                                    </button>
                                </div>
                                <div className="text-xs text-gray-600">
                                    💡 Import previously exported corrections to continue learning from your past work. Your corrections are automatically saved and will suggest symbols you've corrected before.
                                </div>
                            </div>
                    )}
                    {recognitionResults.length > 0 && (       
                        <div className="mt-6 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                            <h3 className="font-semibold text-gray-900 mb-3">Export Options</h3>
                            <div className="flex flex-wrap gap-3">
                                <button 
                                    onClick={exportDetectionData}
                                    className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 flex items-center gap-2"
                                >
                                    📊 Export Detection Data (JSON)
                                </button>
                                <button 
                                    onClick={exportAnnotatedImage}
                                    className="px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 flex items-center gap-2"
                                >
                                    🖼️ Export Annotated Image
                                </button>
                                {viewMode === 'reading' && (
                                    <button 
                                        onClick={exportTranscription}
                                        className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 flex items-center gap-2"
                                    >
                                        📝 Export Transcription (TXT)
                                    </button>
                                )}
                                <button
                                    onClick={exportCorrectionMemory}
                                    className="px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600 flex items-center gap-2"
                                >
                                    🧠 Export Correction Memory
                                </button>
                            </div>
                            <div className="mt-3 text-xs text-gray-600">
                                Export your work in different formats: JSON for data analysis, annotated images for presentations, or plain text transcriptions.
                            </div>
                        </div>
                    )}
                    
                    {showCloudSyncModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setShowCloudSyncModal(false)}>
                            <div className="bg-white rounded-lg p-6 max-w-2xl w-full shadow-2xl" onClick={(e) => e.stopPropagation()}>
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-2xl font-bold text-gray-900">☁️ Cloud Sync</h3>
                                    <button
                                        onClick={() => setShowCloudSyncModal(false)}
                                        className="text-gray-400 hover:text-gray-600 text-3xl leading-none"
                                    >
                                        &times;
                                    </button>
                                </div>

                                <div className="space-y-4">
                                    {/* Download from Master */}
                                    <div className="p-4 bg-blue-50 border-2 border-blue-200 rounded-lg">
                                        <h4 className="font-semibold text-blue-900 mb-2">📥 Download Community Corrections</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Get the latest corrections from the community master collection
                                        </p>
                                        <button
                                            onClick={async () => {
                                                setShowCloudSyncModal(false);
                                                await downloadCorrectionsFromCloud(MASTER_PASTE_RAW_URL);
                                            }}
                                            className="w-full px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 font-semibold"
                                        >
                                            Download from Master Collection
                                        </button>
                                    </div>

                                    {/* Download from Custom URL */}
                                    <div className="p-4 bg-gray-50 border-2 border-gray-200 rounded-lg">
                                        <h4 className="font-semibold text-gray-900 mb-2">🔗 Download from Custom URL</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Import corrections from a specific GitHub raw URL or other source
                                        </p>
                                        <div className="flex gap-2">
                                            <input
                                                type="text"
                                                placeholder="Paste raw JSON URL here..."
                                                value={customGistUrl}
                                                onChange={(e) => setCustomGistUrl(e.target.value)}
                                                className="flex-1 px-3 py-2 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none"
                                            />
                                            <button
                                                onClick={async () => {
                                                    if (customGistUrl) {
                                                        setShowCloudSyncModal(false);
                                                        await downloadCorrectionsFromCloud(customGistUrl);
                                                        setCustomGistUrl('');
                                                    }
                                                }}
                                                disabled={!customGistUrl}
                                                className="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed"
                                            >
                                                Download
                                            </button>
                                        </div>
                                    </div>

                                    {/* Upload Your Corrections */}
                                    <div className="p-4 bg-green-50 border-2 border-green-200 rounded-lg">
                                        <h4 className="font-semibold text-green-900 mb-2">📤 Share Your Corrections</h4>
                                        <p className="text-sm text-gray-700 mb-3">
                                            Export your corrections and submit them to the community via GitHub Issue
                                        </p>
                                        <button
                                            onClick={async () => {
                                                setShowCloudSyncModal(false);
                                                await uploadCorrectionsToCloud();
                                            }}
                                            className="w-full px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 font-semibold"
                                        >
                                            📥 Export & Create Issue
                                        </button>
                                        <div className="mt-3 text-xs text-gray-600 bg-white p-2 rounded border border-green-300">
                                            <p className="font-semibold mb-1">How it works:</p>
                                            <ol className="list-decimal list-inside space-y-1">
                                                <li>Downloads your corrections as a JSON file</li>
                                                <li>Opens a GitHub Issue template</li>
                                                <li>You attach the file and submit</li>
                                                <li>Corrections are reviewed and added to master</li>
                                            </ol>
                                        </div>
                                    </div>
                                </div>

                                <div className="mt-4 pt-4 border-t border-gray-200">
                                    <button
                                        onClick={() => setShowCloudSyncModal(false)}
                                        className="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                    >
                                        Close
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<HakliSymbolRecognizer />);
    </script>
</body>
</html>