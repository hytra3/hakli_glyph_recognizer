<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hakli Glyph Recognizer - Slim</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    
    <!-- React & Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- OpenCV -->
    <script>
        var isOpenCvReady = false;
        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('‚úÖ OpenCV.js is ready');
        }
    </script>
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <style>
        .detection-box {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
            border: 3px solid;
            transition: all 0.15s ease;
        }
        .detection-box:hover {
            z-index: 20;
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .detection-box.selected {
            z-index: 25;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        .corner-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border: 3px solid #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            z-index: 30;
            transform: translate(-50%, -50%);
        }
        .corner-handle:hover {
            background: #3b82f6;
            transform: translate(-50%, -50%) scale(1.2);
        }
        .corner-handle.tl { top: 0; left: 0; cursor: nw-resize; }
        .corner-handle.tr { top: 0; right: 0; transform: translate(50%, -50%); cursor: ne-resize; }
        .corner-handle.bl { bottom: 0; left: 0; transform: translate(-50%, 50%); cursor: sw-resize; }
        .corner-handle.br { bottom: 0; right: 0; transform: translate(50%, 50%); cursor: se-resize; }
        .reading-number {
            position: absolute;
            top: -12px;
            left: -12px;
            width: 24px;
            height: 24px;
            background: #facc15;
            border: 2px solid #ca8a04;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 11px;
            color: black;
            z-index: 15;
        }
    </style>

    <!-- ========================================== -->
    <!-- MODULAR BACKEND - Required modules        -->
    <!-- ========================================== -->
    
    <!-- Core -->
    <script src="src/core/config.js"></script>
    <script src="src/utils/helpers.js"></script>
    
    <!-- Storage -->
    <script src="src/storage/hki.js"></script>
    <script src="src/storage/cache.js"></script>
    <script src="src/storage/corrections.js"></script>
    <script src="src/storage/export.js"></script>
    <script src="src/storage/drive-sync.js"></script>
    
    <!-- Recognition -->
    <script src="src/recognition/preprocessing.js"></script>
    <script src="src/recognition/isolation.js"></script>
    <script src="src/recognition/matching.js"></script>
    <script src="src/recognition/nms.js"></script>
    <script src="src/recognition/validation.js"></script>
    <script src="src/recognition/template-learning.js"></script>
    
    <!-- Reading & Transcription -->
    <script src="src/reading/reading.js"></script>
    <script src="src/reading/transcription.js"></script>
    
    <script>
        // Verify all required modules loaded
        console.log('üöÄ Hakli Glyph Recognizer - Slim v2.1');
        
        const requiredModules = {
            CONFIG: typeof CONFIG !== 'undefined',
            Utils: typeof Utils !== 'undefined',
            HKIStorage: typeof HKIStorage !== 'undefined',
            CacheStorage: typeof CacheStorage !== 'undefined',
            CorrectionMemory: typeof CorrectionMemory !== 'undefined',
            ExportUtils: typeof ExportUtils !== 'undefined',
            DriveSync: typeof DriveSync !== 'undefined',
            Isolation: typeof Isolation !== 'undefined',
            Matching: typeof Matching !== 'undefined',
            Preprocessing: typeof Preprocessing !== 'undefined',
            NMS: typeof NMS !== 'undefined',
            Validation: typeof Validation !== 'undefined',
            PolygonRegion: typeof PolygonRegion !== 'undefined',
            TemplateLearning: typeof TemplateLearning !== 'undefined',
            ReadingOrder: typeof ReadingOrder !== 'undefined',
            Transcription: typeof Transcription !== 'undefined'
        };
        
        console.log('üì¶ Modules:', requiredModules);
        
        const missingModules = Object.entries(requiredModules)
            .filter(([k, v]) => !v)
            .map(([k]) => k);
            
        if (missingModules.length > 0) {
            console.error('‚ùå CRITICAL: Missing required modules:', missingModules.join(', '));
            console.error('The slim version requires ALL modules. Please ensure all .js files are present.');
        } else {
            console.log('‚úÖ All 16 modules loaded - slim mode active');
        }
    </script>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="root"></div>

    <!-- ========================================== -->
    <!-- SLIM REACT APP - Uses modules for logic   -->
    <!-- ========================================== -->

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function HakliGlyphRecognizer() {
            // ============================================
            // STATE DECLARATIONS
            // ============================================
            const [image, setImage] = useState(null);
            const [displayImage, setDisplayImage] = useState(null);
            const [recognitionResults, setRecognitionResults] = useState([]);
            const [isProcessing, setIsProcessing] = useState(false);
            const [equivalenceChart, setEquivalenceChart] = useState(null);
            const [chartLoadStatus, setChartLoadStatus] = useState('not-loaded');
            const [loadedGlyphImages, setLoadedGlyphImages] = useState({});
            const [manualDetectionMode, setManualDetectionMode] = useState(false);
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawStart, setDrawStart] = useState(null);
            const [drawCurrent, setDrawCurrent] = useState(null);
            const [selectedRegions, setSelectedRegions] = useState(new Set());
            const [validations, setValidations] = useState({});
            const [actionHistory, setActionHistory] = useState([]);
            const [isolatedGlyphs, setIsolatedGlyphs] = useState([]);
            const [showRegionBoundaries, setShowRegionBoundaries] = useState(false);
            const [mergeIndicator, setMergeIndicator] = useState(null);
            const [showChartViewer, setShowChartViewer] = useState(false);
            const [showCorrectionAnalysis, setShowCorrectionAnalysis] = useState(false);
            const [showArabicLabels, setShowArabicLabels] = useState(false);
            
            // Collapse states
            const [isChartStatusCollapsed, setIsChartStatusCollapsed] = useState(false);
            const [isRotationCollapsed, setIsRotationCollapsed] = useState(true);
            const [isControlsCollapsed, setIsControlsCollapsed] = useState(true);
            const [isViewModeCollapsed, setIsViewModeCollapsed] = useState(false);
            const [isCorrectionMemoryCollapsed, setIsCorrectionMemoryCollapsed] = useState(true);
            const [isExportOptionsCollapsed, setIsExportOptionsCollapsed] = useState(true);
            const [isPreprocessingCollapsed, setIsPreprocessingCollapsed] = useState(false);
            
            const [processingProgress, setProcessingProgress] = useState({ current: 0, total: 0 });
            const [imageLoadingProgress, setImageLoadingProgress] = useState({ loaded: 0, total: 0 });

            const imageRef = useRef(null);
            const imageContainerRef = useRef(null);

            // Reading/transcription state
            const [viewMode, setViewMode] = useState('detection');
            const [readingDirection, setReadingDirection] = useState('detection');
            const [wordBoundaries, setWordBoundaries] = useState(new Set());
            const [columnBreaks, setColumnBreaks] = useState(new Set());
            const [lineBreaks, setLineBreaks] = useState(new Set());
            const [readingOrder, setReadingOrder] = useState([]);
            const [draggedItem, setDraggedItem] = useState(null);
            const [correctionMode, setCorrectionMode] = useState(null);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [stateHistory, setStateHistory] = useState([]);
            const [confidenceThreshold, setConfidenceThreshold] = useState(0);
            const [useConfidenceFilter, setUseConfidenceFilter] = useState(false);
            const [showConfidenceFilter, setShowConfidenceFilter] = useState(false);
            const [imageRotation, setImageRotation] = useState(0);
            const [rotatedImageDimensions, setRotatedImageDimensions] = useState(null);
            const [showCloudSyncModal, setShowCloudSyncModal] = useState(false);
            const [customGistUrl, setCustomGistUrl] = useState('');
            const [trimMode, setTrimMode] = useState(null);
            const [excludeMode, setExcludeMode] = useState(null);
            const [excludeRegions, setExcludeRegions] = useState([]);
            const [selectedIsolatedRegion, setSelectedIsolatedRegion] = useState(null);
            const [templateTrainingMode, setTemplateTrainingMode] = useState(false);
            const [selectedForTemplate, setSelectedForTemplate] = useState(null);
            const [adjustMode, setAdjustMode] = useState(null);
            const [draggingCorner, setDraggingCorner] = useState(null);
            const [dragStartPos, setDragStartPos] = useState(null);
            const [transcriptionPosition, setTranscriptionPosition] = useState({ x: 0, y: 0 });
            const [isDraggingTranscription, setIsDraggingTranscription] = useState(false);
            const [transcriptionDragStart, setTranscriptionDragStart] = useState({ x: 0, y: 0 });
            const [showTranscription, setShowTranscription] = useState(true);
            const [showEnhancedTranscription, setShowEnhancedTranscription] = useState(false);
            const [transcriptionScript, setTranscriptionScript] = useState('english');
            const [showReadingOrderTip, setShowReadingOrderTip] = useState(true);
            
            // Preprocessing state
            const [showPreprocessPreview, setShowPreprocessPreview] = useState(true);
            const [preprocessing, setPreprocessing] = useState({
                rotation: 0,
                useAdaptiveThreshold: false,
                blockSize: 11,
                constantOffset: 2,
                gaussianBlur: 0,
                morphologyOperation: 'none',
                invertColors: false
            });
            const [originalMat, setOriginalMat] = useState(null);
            const [preprocessedMat, setPreprocessedMat] = useState(null);
            const [adjustmentsApplied, setAdjustmentsApplied] = useState(false);
            const [isImageLoading, setIsImageLoading] = useState(false);
            const [eraserMode, setEraserMode] = useState(false);
            const [brushSize, setBrushSize] = useState(15);
            const [isErasing, setIsErasing] = useState(false);
            const [eraserHistory, setEraserHistory] = useState([]);
            const eraserCanvasRef = useRef(null);
            const preprocessCanvasRef = useRef(null);
            const originalCanvasRef = useRef(null);
            
            // Dismissable tips
            const [dismissedTips, setDismissedTips] = useState(() => {
                try {
                    const saved = localStorage.getItem('hakli_dismissed_tips');
                    return saved ? JSON.parse(saved) : {};
                } catch { return {}; }
            });
            
            const dismissTip = (tipId) => {
                const updated = { ...dismissedTips, [tipId]: true };
                setDismissedTips(updated);
                localStorage.setItem('hakli_dismissed_tips', JSON.stringify(updated));
            };

            // ============================================
            // MODULE WRAPPERS - Delegate to external modules
            // ============================================
            
            // Utility wrapper - uses Utils module
            const convertToGitHubUrl = (url) => {
                if (typeof Utils !== 'undefined') {
                    return Utils.convertGitHubUrl(url);
                }
                // Minimal fallback
                if (!url) return null;
                if (url.includes('github.com') && url.includes('/blob/')) {
                    return url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                }
                return url;
            };
            
            // IoU calculation - uses Utils module
            const calculateIoU = (box1, box2) => {
                if (typeof Utils !== 'undefined') {
                    return Utils.calculateIoU(box1, box2);
                }
                // Fallback
                const x1 = Math.max(box1.x, box2.x);
                const y1 = Math.max(box1.y, box2.y);
                const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
                const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);
                const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
                const union = box1.width * box1.height + box2.width * box2.height - intersection;
                return union > 0 ? intersection / union : 0;
            };
            
            // Isolation - uses Isolation module
            const isolateGlyphs = (inputImage) => {
                if (typeof Isolation !== 'undefined') {
                    return Isolation.isolateGlyphs(inputImage);
                }
                console.error('Isolation module not loaded');
                return [];
            };
            
            // NMS - uses NMS module
            const applyNMS = (detections, threshold = 0.3) => {
                if (typeof NMS !== 'undefined') {
                    return NMS.apply(detections, threshold);
                }
                console.error('NMS module not loaded');
                return detections;
            };
            
            // Correction memory - uses CorrectionMemory module
            const saveCorrectionToMemory = (original, corrected, confidence) => {
                if (typeof CorrectionMemory !== 'undefined') {
                    return CorrectionMemory.save(original, corrected, confidence);
                }
            };
            
            const getSuggestionsFromMemory = (glyph, confidence) => {
                if (typeof CorrectionMemory !== 'undefined') {
                    return CorrectionMemory.getSuggestions(glyph, confidence);
                }
                return [];
            };
            
            // Reading order - uses ReadingOrder module
            const autoDetectReadingOrder = () => {
                if (typeof ReadingOrder !== 'undefined' && recognitionResults.length > 0) {
                    const detected = ReadingOrder.detectDirection(recognitionResults);
                    setReadingDirection(detected);
                    const order = ReadingOrder.generateOrder(recognitionResults, detected);
                    setReadingOrder(order);
                    console.log(`üìñ Auto-detected: ${detected}`);
                    return detected;
                }
                return null;
            };
            
            // Transcription - uses Transcription module
            const generateTranscription = () => {
                if (typeof Transcription !== 'undefined') {
                    return Transcription.generate(recognitionResults, {
                        order: readingOrder,
                        wordBoundaries: Array.from(wordBoundaries),
                        lineBreaks: Array.from(lineBreaks),
                        columnBreaks: Array.from(columnBreaks)
                    });
                }
                // Fallback
                return recognitionResults.map(r => r.glyph?.name || '?').join(' ');
            };
            
            // Template learning - uses TemplateLearning module
            const recordCorrection = (original, corrected, thumbnail, inscriptionId) => {
                if (typeof TemplateLearning !== 'undefined') {
                    return TemplateLearning.recordCorrection(original, corrected, thumbnail, inscriptionId);
                }
            };
            
            // ============================================
            // UI-SPECIFIC FUNCTIONS (must stay inline)
            // ============================================
            
            const getImageCoordinates = (event) => {
                if (!imageRef.current) return null;
                const rect = imageRef.current.getBoundingClientRect();
                const scaleX = imageRef.current.naturalWidth / rect.width;
                const scaleY = imageRef.current.naturalHeight / rect.height;
                return {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            };
            
            const extractRegionThumbnail = (inputImage, region) => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = region.bounds.width;
                    canvas.height = region.bounds.height;
                    ctx.drawImage(
                        inputImage,
                        region.bounds.x, region.bounds.y, 
                        region.bounds.width, region.bounds.height,
                        0, 0, region.bounds.width, region.bounds.height
                    );
                    return canvas.toDataURL();
                } catch (error) {
                    console.error('Thumbnail extraction error:', error);
                    return null;
                }
            };
            
            const recordAction = (type, data) => {
                setActionHistory(prev => [...prev, {
                    type,
                    data,
                    timestamp: new Date().toISOString()
                }]);
            };
            
            const getReadingOrderIndex = (detectionIndex) => {
                if (readingOrder.length === 0) return detectionIndex + 1;
                const orderIndex = readingOrder.indexOf(detectionIndex);
                return orderIndex !== -1 ? orderIndex + 1 : detectionIndex + 1;
            };
            
            const getFilteredResults = () => {
                if (!useConfidenceFilter) return recognitionResults;
                return recognitionResults.filter(r => r.confidence >= (confidenceThreshold / 100));
            };
            
            const getReadingOrderedResults = () => {
                if (readingOrder.length === 0) return recognitionResults;
                return readingOrder.map(i => recognitionResults[i]).filter(r => r);
            };
            
            // DismissableTip component
            const DismissableTip = ({ id, children, className = '' }) => {
                if (dismissedTips[id]) return null;
                return (
                    <div className={`relative p-3 bg-yellow-50 border-2 border-yellow-200 rounded-lg ${className}`}>
                        <button
                            onClick={() => dismissTip(id)}
                            className="absolute top-1 right-1 w-6 h-6 flex items-center justify-center text-yellow-600 hover:text-yellow-800 hover:bg-yellow-100 rounded-full"
                            title="Dismiss"
                        >‚úï</button>
                        <div className="pr-6 text-sm text-yellow-800">{children}</div>
                    </div>
                );
            };

            // ============================================
            // PLACEHOLDER - Full UI to be added
            // ============================================
            
            return (
                <div className="container mx-auto p-4 max-w-6xl">
                    <h1 className="text-2xl font-bold mb-4">
                        Hakli Glyph Recognizer 
                        <span className="text-sm font-normal text-gray-500 ml-2">Slim v2.1</span>
                    </h1>
                    
                    <DismissableTip id="slim-notice" className="mb-4">
                        <strong>üöß Slim Version:</strong> This is a work-in-progress slim build that delegates 
                        to external modules. The full UI is being migrated. For now, please use the standard 
                        index.html for full functionality.
                    </DismissableTip>
                    
                    <div className="bg-white rounded-lg shadow p-6">
                        <h2 className="text-lg font-semibold mb-4">Module Status</h2>
                        <div className="grid grid-cols-4 gap-2 text-sm">
                            {[
                                ['CONFIG', typeof CONFIG !== 'undefined'],
                                ['Utils', typeof Utils !== 'undefined'],
                                ['Isolation', typeof Isolation !== 'undefined'],
                                ['Matching', typeof Matching !== 'undefined'],
                                ['NMS', typeof NMS !== 'undefined'],
                                ['Preprocessing', typeof Preprocessing !== 'undefined'],
                                ['Validation', typeof Validation !== 'undefined'],
                                ['PolygonRegion', typeof PolygonRegion !== 'undefined'],
                                ['TemplateLearning', typeof TemplateLearning !== 'undefined'],
                                ['ReadingOrder', typeof ReadingOrder !== 'undefined'],
                                ['Transcription', typeof Transcription !== 'undefined'],
                                ['CorrectionMemory', typeof CorrectionMemory !== 'undefined'],
                                ['HKIStorage', typeof HKIStorage !== 'undefined'],
                                ['CacheStorage', typeof CacheStorage !== 'undefined'],
                                ['ExportUtils', typeof ExportUtils !== 'undefined'],
                                ['DriveSync', typeof DriveSync !== 'undefined'],
                            ].map(([name, loaded]) => (
                                <div key={name} className={`p-2 rounded ${loaded ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                                    {loaded ? '‚úì' : '‚úó'} {name}
                                </div>
                            ))}
                        </div>
                        
                        <div className="mt-6 p-4 bg-gray-50 rounded">
                            <p className="text-gray-600">
                                The slim version reduces index.html from ~6,450 lines to ~400 lines by 
                                delegating all logic to external JavaScript modules. This makes the code 
                                more maintainable and allows independent updates to each module.
                            </p>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<HakliGlyphRecognizer />);
    </script>
</body>
</html>
